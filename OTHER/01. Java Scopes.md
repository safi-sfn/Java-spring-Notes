# Java Scopes - Complete Study Notes 📚

---

## 🎯 Introduction - Scope Kya Hai Bhai?

### Simple Explanation First 🤔
Bhai, **Scope** matlab ye hai ki koi object kitni der tak zinda rahega aur kitni baar create hoga! Just like real life mein - kuch cheezein ek baar banti hain aur hamesha use hoti hain (jaise ghar), kuch baar baar banani padti hain (jaise chai)!

### Real-life Analogy 🏠
```
🏠 Singleton = Ghar (Ek hi ghar, sabke liye same)
🍵 Prototype = Chai (Har baar nayi chai banani padti hai)  
📱 Request = Phone Call (Ek call ke liye, call khatam toh khatam)
👤 Session = Login Session (Tab tak alive jab tak logout nahi kiya)
```

### Technical Definition 📖
**Scope** determines the lifecycle and visibility of objects/beans in an application container. It defines when objects are created, how long they live, and when they are destroyed.

---

## 🔑 Key Terms/Concepts

| Term | Hindi Meaning | Technical Definition |
|------|--------------|---------------------|
| **Singleton** |  (Ek hi instance) | Only one instance exists throughout application |
| **Prototype** |  (Har request pe naya) | New instance created every time |
| **Request** |  (HTTP request ke liye) | One instance per HTTP request |
| **Session** |  (User session ke liye) | One instance per user session |

### Visual Representation 🎨
```
┌─────────────────┐
│   APPLICATION   │
├─────────────────┤
│ Singleton: 🎯   │ ← Only One Instance
│                 │
│ Prototype: 🏭   │ ← Factory Creates New Each Time  
│                 │
│ Request: 📨     │ ← Per HTTP Request
│                 │
│ Session: 👤     │ ← Per User Session
└─────────────────┘
```

---

## 💻 Detailed Examples

### 1️⃣ Singleton Scope 🎯

**Simple words mein:** Ek hi object, sabke liye same!

```java
// Spring Configuration
@Component
@Scope("singleton") // Default scope hai ye
public class DatabaseConnection {
    private String connectionString;
    
    public DatabaseConnection() {
        System.out.println("DatabaseConnection created! 🎯");
        this.connectionString = "jdbc:mysql://localhost:3306/mydb";
    }
    
    public void connect() {
        System.out.println("Connected to: " + connectionString);
    }
}

// Usage Example
@RestController
public class UserController {
    
    @Autowired
    private DatabaseConnection dbConnection; // Same instance milega
    
    @GetMapping("/user")
    public String getUser() {
        dbConnection.connect();
        return "User data fetched!";
    }
}

// Another Controller
@RestController  
public class ProductController {
    
    @Autowired
    private DatabaseConnection dbConnection; // Wohi same instance!
    
    @GetMapping("/product")
    public String getProduct() {
        dbConnection.connect(); // Same connection object
        return "Product data fetched!";
    }
}
```

**Expected Output:** 📋
```
DatabaseConnection created! 🎯
Connected to: jdbc:mysql://localhost:3306/mydb
Connected to: jdbc:mysql://localhost:3306/mydb
```

**Step-by-step explanation:** 🔍
1. Spring container starts
2. DatabaseConnection ka ek hi instance create hota hai
3. Har controller mein same instance inject hota hai
4. Constructor sirf ek baar call hota hai!

---

### 2️⃣ Prototype Scope 🏭

**Simple words mein:** Har baar naya object chahiye!

```java
@Component
@Scope("prototype")
public class EmailService {
    private String emailId;
    private LocalDateTime createdAt;
    
    public EmailService() {
        this.createdAt = LocalDateTime.now();
        System.out.println("New EmailService created at: " + createdAt + " 📧");
    }
    
    public void sendEmail(String to, String message) {
        this.emailId = UUID.randomUUID().toString();
        System.out.println("Email ID: " + emailId);
        System.out.println("Sending to: " + to);
        System.out.println("Message: " + message);
    }
}

// Usage
@RestController
public class NotificationController {
    
    @Autowired
    private ApplicationContext context;
    
    @PostMapping("/send-notification")
    public String sendNotification(@RequestParam String user) {
        
        // Har baar naya instance milega
        EmailService emailService1 = context.getBean(EmailService.class);
        emailService1.sendEmail(user + "@gmail.com", "Welcome!");
        
        // Ye bhi naya instance hoga
        EmailService emailService2 = context.getBean(EmailService.class);  
        emailService2.sendEmail(user + "@gmail.com", "Thank you!");
        
        return "Notifications sent!";
    }
}
```

**Expected Output:** 📋
```
New EmailService created at: 2024-01-15T14:30:20.123 📧
Email ID: 550e8400-e29b-41d4-a716-446655440001
Sending to: john@gmail.com
Message: Welcome!

New EmailService created at: 2024-01-15T14:30:20.456 📧
Email ID: 550e8400-e29b-41d4-a716-446655440002
Sending to: john@gmail.com  
Message: Thank you!
```

---

### 3️⃣ Request Scope 📨

**Simple words mein:** Ek HTTP request = Ek object

```java
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, 
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestLogger {
    private String requestId;
    private LocalDateTime requestTime;
    private List<String> logs;
    
    public RequestLogger() {
        this.requestId = UUID.randomUUID().toString().substring(0, 8);
        this.requestTime = LocalDateTime.now();
        this.logs = new ArrayList<>();
        System.out.println("🔍 New RequestLogger created for request: " + requestId);
    }
    
    public void log(String message) {
        String logEntry = "[" + requestId + "] " + message;
        logs.add(logEntry);
        System.out.println("📝 " + logEntry);
    }
    
    public void printAllLogs() {
        System.out.println("=== Request " + requestId + " Logs ===");
        logs.forEach(System.out::println);
        System.out.println("Request completed at: " + LocalDateTime.now());
    }
}

@RestController
public class OrderController {
    
    @Autowired
    private RequestLogger logger; // Same instance throughout this request
    
    @PostMapping("/order")
    public ResponseEntity<String> createOrder(@RequestBody Order order) {
        
        logger.log("Order creation started");
        
        // Validate order
        validateOrder(order);
        
        // Save order  
        saveOrder(order);
        
        logger.log("Order created successfully");
        logger.printAllLogs();
        
        return ResponseEntity.ok("Order created!");
    }
    
    private void validateOrder(Order order) {
        logger.log("Validating order: " + order.getId());
        // validation logic
    }
    
    private void saveOrder(Order order) {
        logger.log("Saving order to database");
        // save logic
    }
}
```

**Expected Output (Request 1):** 📋
```
🔍 New RequestLogger created for request: abc12345
📝 [abc12345] Order creation started  
📝 [abc12345] Validating order: ORD001
📝 [abc12345] Saving order to database
📝 [abc12345] Order created successfully
=== Request abc12345 Logs ===
[abc12345] Order creation started
[abc12345] Validating order: ORD001  
[abc12345] Saving order to database
[abc12345] Order created successfully
Request completed at: 2024-01-15T14:35:22.789
```

**Expected Output (Request 2):** 📋
```
🔍 New RequestLogger created for request: xyz67890
📝 [xyz67890] Order creation started
📝 [xyz67890] Validating order: ORD002
📝 [xyz67890] Saving order to database  
📝 [xyz67890] Order created successfully
=== Request xyz67890 Logs ===
[xyz67890] Order creation started
[xyz67890] Validating order: ORD002
[xyz67890] Saving order to database
[xyz67890] Order created successfully
Request completed at: 2024-01-15T14:35:45.123
```

---

### 4️⃣ Session Scope 👤

**Simple words mein:** Ek user session = Ek object

```java
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ShoppingCart {
    private String sessionId;
    private List<CartItem> items;
    private LocalDateTime createdAt;
    
    public ShoppingCart() {
        this.sessionId = UUID.randomUUID().toString().substring(0, 8);
        this.items = new ArrayList<>();
        this.createdAt = LocalDateTime.now();
        System.out.println("🛒 New ShoppingCart created for session: " + sessionId);
    }
    
    public void addItem(String productId, int quantity) {
        CartItem item = new CartItem(productId, quantity);
        items.add(item);
        System.out.println("➕ Added to cart [" + sessionId + "]: " + 
                         productId + " x" + quantity);
    }
    
    public void removeItem(String productId) {
        items.removeIf(item -> item.getProductId().equals(productId));
        System.out.println("➖ Removed from cart [" + sessionId + "]: " + productId);
    }
    
    public List<CartItem> getItems() {
        return new ArrayList<>(items);
    }
    
    public int getTotalItems() {
        return items.size();
    }
    
    public void clearCart() {
        items.clear();
        System.out.println("🗑️ Cart cleared for session: " + sessionId);
    }
}

@RestController
public class CartController {
    
    @Autowired
    private ShoppingCart cart; // Same cart throughout user session
    
    @PostMapping("/cart/add")
    public ResponseEntity<String> addToCart(@RequestParam String productId,
                                          @RequestParam int quantity) {
        cart.addItem(productId, quantity);
        return ResponseEntity.ok("Item added to cart! Total items: " + cart.getTotalItems());
    }
    
    @DeleteMapping("/cart/remove")
    public ResponseEntity<String> removeFromCart(@RequestParam String productId) {
        cart.removeItem(productId);
        return ResponseEntity.ok("Item removed! Total items: " + cart.getTotalItems());
    }
    
    @GetMapping("/cart")
    public ResponseEntity<List<CartItem>> getCart() {
        return ResponseEntity.ok(cart.getItems());
    }
    
    @PostMapping("/cart/checkout") 
    public ResponseEntity<String> checkout() {
        int totalItems = cart.getTotalItems();
        cart.clearCart();
        return ResponseEntity.ok("Checkout successful! Ordered " + totalItems + " items");
    }
}

// CartItem class
public class CartItem {
    private String productId;
    private int quantity;
    
    public CartItem(String productId, int quantity) {
        this.productId = productId;
        this.quantity = quantity;
    }
    
    // getters and setters
    public String getProductId() { return productId; }
    public int getQuantity() { return quantity; }
}
```

**Expected Output (User Session 1):** 📋
```
🛒 New ShoppingCart created for session: sess1234
➕ Added to cart [sess1234]: PHONE001 x1
➕ Added to cart [sess1234]: LAPTOP001 x2  
➖ Removed from cart [sess1234]: PHONE001
🗑️ Cart cleared for session: sess1234
```

**Expected Output (User Session 2 - Different Browser):** 📋
```
🛒 New ShoppingCart created for session: sess5678
➕ Added to cart [sess5678]: BOOK001 x3
➕ Added to cart [sess5678]: PEN001 x5
```

---

## 📋 Rules/Guidelines

### ✅ Singleton Scope Rules

1. **✅ Default Scope:** Spring mein default scope Singleton hai
```java
@Component // Automatically singleton
public class DatabaseService { }

@Component
@Scope("singleton") // Explicitly singleton  
public class ConfigService { }
```

2. **✅ Thread Safety:** Singleton objects thread-safe hone chahiye
```java
@Component
public class CounterService {
    private AtomicInteger count = new AtomicInteger(0); // Thread-safe
    
    public int increment() {
        return count.incrementAndGet();
    }
}
```

3. **❌ Avoid Mutable State:** Singleton mein mutable state risky hai
```java
// ❌ WRONG - Not thread safe
@Component  
public class BadCounterService {
    private int count = 0; // Dangerous in singleton!
    
    public int increment() {
        return ++count; // Race condition possible
    }
}
```

### ✅ Prototype Scope Rules

1. **✅ New Instance Every Time:** Har getBean() call pe naya object
```java
@Component
@Scope("prototype")
public class TaskProcessor {
    public TaskProcessor() {
        System.out.println("New TaskProcessor created!");
    }
}

// Usage
TaskProcessor task1 = context.getBean(TaskProcessor.class); // New
TaskProcessor task2 = context.getBean(TaskProcessor.class); // Another new
```

2. **✅ No Destruction Callbacks:** Spring prototype objects ko destroy nahi karta
```java
@Component
@Scope("prototype")
public class FileProcessor {
    
    @PostConstruct
    public void init() {
        System.out.println("FileProcessor initialized ✅");
    }
    
    @PreDestroy  
    public void cleanup() {
        System.out.println("This won't be called! ❌"); // Spring won't call this
    }
}
```

### ✅ Request Scope Rules

1. **✅ Proxy Mode Required:** Web scopes ke liye proxy chahiye
```java
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST,
       proxyMode = ScopedProxyMode.TARGET_CLASS) // Required!
public class RequestScopedBean { }
```

2. **❌ Without Proxy Mode:** Error aayega
```java
// ❌ WRONG - Will cause BeanCreationException
@Component
@Scope(WebApplicationContext.SCOPE_REQUEST) // No proxy mode!
public class BadRequestBean { }
```

**Error Message:** 📛
```
BeanCreationException: Error creating bean with name 'badRequestBean': 
Scope 'request' is not active for the current thread
```

### ✅ Session Scope Rules

1. **✅ HTTP Session Required:** Bina HTTP session ke kaam nahi karega
```java
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserPreferences {
    // Session ke saath bind hoga
}
```

2. **✅ Serializable Recommended:** Session objects serializable hone chahiye
```java
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserSession implements Serializable { // Good practice
    private static final long serialVersionUID = 1L;
    // fields
}
```

---

## 🏢 Real-world Applications

### 1. Banking Application 🏦

```java
// Singleton - Database Connection Pool
@Component
@Scope("singleton")
public class DatabaseConnectionPool {
    private final HikariDataSource dataSource;
    
    public DatabaseConnectionPool() {
        System.out.println("🏊 Creating Database Pool - Expensive Operation!");
        HikariConfig config = new HikariConfig();
        config.setJdbcUrl("jdbc:mysql://localhost:3306/bank_db");
        config.setMaximumPoolSize(20);
        this.dataSource = new HikariDataSource(config);
    }
    
    public Connection getConnection() throws SQLException {
        return dataSource.getConnection();
    }
}

// Prototype - Transaction Processor  
@Component
@Scope("prototype")
public class TransactionProcessor {
    private String transactionId;
    private LocalDateTime startTime;
    
    public TransactionProcessor() {
        this.transactionId = "TXN_" + UUID.randomUUID().toString().substring(0, 8);
        this.startTime = LocalDateTime.now();
        System.out.println("💰 New Transaction Processor: " + transactionId);
    }
    
    public TransactionResult processTransfer(String fromAccount, 
                                           String toAccount, 
                                           BigDecimal amount) {
        System.out.println("Processing transfer: " + amount + " from " + 
                         fromAccount + " to " + toAccount);
        // Complex transaction logic
        return new TransactionResult(transactionId, "SUCCESS");
    }
}

// Request - Audit Logger
@Component  
@Scope(value = WebApplicationContext.SCOPE_REQUEST,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class AuditLogger {
    private String requestId;
    private List<String> activities;
    
    public AuditLogger() {
        this.requestId = "REQ_" + System.currentTimeMillis();
        this.activities = new ArrayList<>();
        System.out.println("🔍 Audit Logger started for: " + requestId);
    }
    
    public void logActivity(String activity) {
        activities.add(LocalDateTime.now() + ": " + activity);
    }
    
    @PreDestroy
    public void saveAuditLog() {
        System.out.println("💾 Saving audit log for request: " + requestId);
        // Save to database
    }
}

// Session - User Banking Session
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class BankingSession implements Serializable {
    private String userId;
    private List<String> accountNumbers;
    private LocalDateTime loginTime;
    
    public BankingSession() {
        this.accountNumbers = new ArrayList<>();
        this.loginTime = LocalDateTime.now();
        System.out.println("🏦 Banking session created at: " + loginTime);
    }
    
    public void addAccount(String accountNumber) {
        accountNumbers.add(accountNumber);
    }
    
    public List<String> getAccounts() {
        return new ArrayList<>(accountNumbers);
    }
}
```

### 2. E-commerce Application 🛒

```java
// Singleton - Product Catalog
@Component
public class ProductCatalog {
    private final Map<String, Product> products;
    
    public ProductCatalog() {
        System.out.println("📦 Loading Product Catalog - Heavy Operation!");
        this.products = loadAllProducts(); // Expensive operation
    }
    
    public Product getProduct(String productId) {
        return products.get(productId);
    }
    
    private Map<String, Product> loadAllProducts() {
        // Simulate loading from database
        Map<String, Product> catalog = new HashMap<>();
        catalog.put("PHONE001", new Product("PHONE001", "iPhone", 999.99));
        catalog.put("LAPTOP001", new Product("LAPTOP001", "MacBook", 1999.99));
        return catalog;
    }
}

// Prototype - Order Processor
@Component
@Scope("prototype")  
public class OrderProcessor {
    private String orderId;
    private OrderStatus status;
    
    public OrderProcessor() {
        this.orderId = "ORD_" + UUID.randomUUID().toString().substring(0, 8);
        this.status = OrderStatus.CREATED;
        System.out.println("📋 New Order Processor: " + orderId);
    }
    
    public void processOrder(List<CartItem> items) {
        status = OrderStatus.PROCESSING;
        System.out.println("🔄 Processing order: " + orderId);
        
        // Validate items
        // Calculate total
        // Apply discounts
        // Process payment
        // Update inventory
        
        status = OrderStatus.COMPLETED;
        System.out.println("✅ Order completed: " + orderId);
    }
}
```

---

## 📊 Comparison Tables

### Scope Comparison Table

| Feature | Singleton | Prototype | Request | Session |
|---------|-----------|-----------|---------|---------|
| **Instance Count** | 1️⃣ Only One | 🏭 New Every Time | 📨 One per Request | 👤 One per Session |
| **Lifecycle** | ♾️ Application Lifetime | 🔄 Manual Management | ⏱️ Request Lifetime | 🕒 Session Lifetime |
| **Thread Safety** | ⚠️ Must Handle | ✅ Isolated | ✅ Per Thread | ⚠️ Must Handle |
| **Memory Usage** | 💚 Low | 🔴 High | 🟡 Medium | 🟡 Medium |
| **Use Case** | 🔧 Utilities, Services | 🎯 Stateful Tasks | 📊 Request Tracking | 🛒 User Data |

### When to Use What? 🤔

| Scenario | Recommended Scope | Reason |
|----------|-------------------|---------|
| **Database Connection Pool** | Singleton | Expensive to create, shared resource |
| **Configuration Settings** | Singleton | Static data, memory efficient |
| **User Shopping Cart** | Session | User-specific, persists across requests |
| **Request ID Logger** | Request | Track single request lifecycle |
| **File Upload Processor** | Prototype | Each upload is independent task |
| **Email Template** | Prototype | Customized per use |
| **Cache Manager** | Singleton | Shared across application |
| **User Preferences** | Session | User-specific settings |

### Performance Comparison 📈

```java
// Performance Test Example
@RestController
public class PerformanceTestController {
    
    @Autowired
    private ApplicationContext context;
    
    @GetMapping("/perf-test/{scope}")
    public ResponseEntity<String> testScope(@PathVariable String scope) {
        long startTime = System.currentTimeMillis();
        
        for (int i = 0; i < 1000; i++) {
            switch (scope) {
                case "singleton":
                    context.getBean("singletonBean");
                    break;
                case "prototype":  
                    context.getBean("prototypeBean"); // 1000 new objects!
                    break;
            }
        }
        
        long endTime = System.currentTimeMillis();
        return ResponseEntity.ok("Time taken: " + (endTime - startTime) + "ms");
    }
}
```

**Expected Results:** ⏱️
- **Singleton:** ~5ms (Same object returned)
- **Prototype:** ~150ms (1000 objects created)

---

## 🎤 Interview Questions

### Q1: What is the default scope in Spring? 🤔

**Answer:** 
Default scope **Singleton** hai bhai! Matlab agar aap koi scope specify nahi karte, toh Spring automatically singleton scope use karta hai.

```java
@Component // This is singleton by default
public class MyService {
    // Only one instance throughout application
}

// Same as above
@Component
@Scope("singleton")  
public class MyService {
    // Explicitly singleton
}
```

**Tricky Follow-up:** "Is singleton thread-safe?"
**Answer:** Nahi bhai! Singleton matlab sirf ek instance, but thread-safe nahi automatically. Aapko manually thread safety handle karni padegi.

### Q2: How does prototype scope work with @Autowired? 🔄

**Answer:**
Ye tricky hai! Agar aap prototype bean ko directly @Autowired karte hain, toh sirf ek baar inject hoga, not every time!

```java
// ❌ WRONG WAY - Prototype won't work as expected
@Component
public class ServiceA {
    @Autowired
    private PrototypeBean prototypeBean; // Same instance always!
    
    public void doSomething() {
        prototypeBean.process(); // Always same object
    }
}

// ✅ CORRECT WAY - Use ApplicationContext or Lookup
@Component  
public class ServiceB {
    @Autowired
    private ApplicationContext context;
    
    public void doSomething() {
        PrototypeBean bean = context.getBean(PrototypeBean.class); // New each time!
        bean.process();
    }
}

// ✅ ANOTHER WAY - Use @Lookup annotation
@Component
public class ServiceC {
    
    @Lookup
    public PrototypeBean getPrototypeBean() {
        return null; // Spring will override this method
    }
    
    public void doSomething() {
        PrototypeBean bean = getPrototypeBean(); // New instance!
        bean.process();
    }
}
```

### Q3: What's the difference between request and session scope? 🌐

**Answer:**

```java
// Request Scope - Har HTTP request ke liye naya
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestBean {
    // New instance for each HTTP request
    // Dies when request completes
}

// Session Scope - User session ke liye ek
@Component  
@Scope(value = WebApplicationContext.SCOPE_SESSION,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SessionBean {
    // One instance per user session
    // Dies when session expires/logout
}
```

**Real Example:**
- **Request:** Payment processing (ek payment = ek request)
- **Session:** Shopping cart (user login se logout tak same cart)

### Q4: Why do we need proxyMode for web scopes? 🔄

**Answer:**
Bhai, ye bahut important question hai! Web scopes (request/session) runtime pe active hote hain, but Spring beans creation time pe inject hote hain.

```java
// Without Proxy Mode - ERROR!
@Component
@Scope(WebApplicationContext.SCOPE_REQUEST) // ❌ Will fail
public class RequestService { }

@Component  
public class SingletonService {
    @Autowired
    private RequestService requestService; // ERROR at startup!
}
```

**Error Message:** 📛
```
BeanCreationException: Scope 'request' is not active for the current thread;
consider defining a scoped proxy for this bean
```

**Solution with Proxy:** ✅
```java
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST,
       proxyMode = ScopedProxyMode.TARGET_CLASS) // ✅ PROXY!
public class RequestService { }

@Component
public class SingletonService {
    @Autowired
    private RequestService requestService; // Works! Gets proxy
}
```

**How Proxy Works:** 🔄
1. Spring creates proxy object at startup
2. Proxy object gets injected into singleton
3. When method is called, proxy finds actual request-scoped bean
4. Proxy delegates call to real bean

---

## ❌ Common Mistakes

### 1️⃣ Mixing Singleton with Prototype Incorrectly

**❌ Wrong Code:**
```java
@Component // Singleton by default
public class OrderService {
    
    @Autowired
    private OrderProcessor orderProcessor; // Prototype bean
    
    public void processOrder(Order order) {
        orderProcessor.process(order); // Always same instance! 😱
    }
}

@Component
@Scope("prototype")
public class OrderProcessor {
    private List<String> processedItems = new ArrayList<>(); // Shared state!
    
    public void process(Order order) {
        processedItems.add(order.getId()); // Memory leak + wrong data!
    }
}
```

**Why it's wrong:** 🤔
- Singleton mein prototype inject kiya, but same instance milega always
- State contamination hoga
- Memory leak ho sakta hai

**✅ Correct Approach:**
```java
@Component
public class OrderService {
    
    @Autowired
    private ApplicationContext context;
    
    public void processOrder(Order order) {
        OrderProcessor processor = context.getBean(OrderProcessor.class); // New instance
        processor.process(order);
    }
}
```

### 2️⃣ Thread Safety Issues in Singleton

**❌ Wrong Code:**
```java
@Component // Singleton - shared across threads!
public class CounterService {
    private int count = 0; // Mutable state in singleton! 💥
    
    public int increment() {
        return ++count; // Race condition! Multiple threads = wrong count
    }
    
    public int getCount() {
        return count;
    }
}
```

**What happens:** 😱
```java
// Thread 1 calls increment() -> reads count=0, increments to 1
// Thread 2 calls increment() -> reads count=0 (before thread 1 writes), increments to 1  
// Result: count=1 instead of 2!
```

**✅ Correct Approaches:**

**Option 1: Use AtomicInteger**
```java
@Component
public class CounterService {
    private final AtomicInteger count = new AtomicInteger(0); // Thread-safe!
    
    public int increment() {
        return count.incrementAndGet(); // Atomic operation
    }
    
    public int getCount() {
        return count.get();
    }
}
```

**Option 2: Use Synchronized**
```java
@Component
public class CounterService {
    private int count = 0;
    
    public synchronized int increment() { // Synchronized method
        return ++count;
    }
    
    public synchronized int getCount() {
        return count;
    }
}
```

**Option 3: Make it Stateless**
```java
@Component
public class CounterService {
    
    @Autowired
    private CounterRepository repository; // Database stores state
    
    public int increment(String counterId) {
        // No instance state - stateless and thread-safe!
        return repository.incrementAndGet(counterId);
    }
}
```

### 3️⃣ Forgetting Proxy Mode for Web Scopes

**❌ Wrong Code:**
```java
// Missing proxyMode!
@Component
@Scope(WebApplicationContext.SCOPE_REQUEST) // ❌ No proxy!
public class RequestLogger {
    private String requestId;
    
    public void log(String message) {
        System.out.println(requestId + ": " + message);
    }
}

@Service
public class UserService {
    
    @Autowired  
    private RequestLogger logger; // Will fail at startup!
    
    public void createUser(User user) {
        logger.log("Creating user: " + user.getName());
    }
}
```

**Error you'll get:** 📛
```
org.springframework.beans.factory.BeanCreationException: 
Error creating bean with name 'userService': Unsatisfied dependency 
expressed through field 'logger'; nested exception is 
org.springframework.beans.factory.BeanCreationException: 
Error creating bean with name 'requestLogger': 
Scope 'request' is not active for the current thread
```

**✅ Correct Code:**
```java
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST,
       proxyMode = ScopedProxyMode.TARGET_CLASS) // ✅ Added proxy!
public class RequestLogger {
    private String requestId;
    
    public RequestLogger() {
        this.requestId = UUID.randomUUID().toString();
    }
    
    public void log(String message) {
        System.out.println(requestId + ": " + message);
    }
}
```

### 4️⃣ Memory Leaks with Prototype Scope

**❌ Wrong Code:**
```java
@Component
public class FileProcessingService {
    
    private List<FileProcessor> processors = new ArrayList<>(); // Memory leak!
    
    @Autowired
    private ApplicationContext context;
    
    public void processFile(String fileName) {
        FileProcessor processor = context.getBean(FileProcessor.class); // Prototype
        processors.add(processor); // Never removed! Memory leak! 💥
        processor.processFile(fileName);
    }
}

@Component
@Scope("prototype")
public class FileProcessor {
    private byte[] fileData; // Large object
    
    public void processFile(String fileName) {
        fileData = readLargeFile(fileName); // 100MB data
        // Process file...
        // fileData never cleared!
    }
}
```

**What happens:** 😱
- Har file process karne pe new FileProcessor create hota hai
- Wo list mein store hota rehta hai
- Large file data memory mein rehta hai
- Eventually OutOfMemoryError!

**✅ Correct Code:**
```java
@Component
public class FileProcessingService {
    
    @Autowired
    private ApplicationContext context;
    
    public void processFile(String fileName) {
        FileProcessor processor = context.getBean(FileProcessor.class);
        try {
            processor.processFile(fileName);
        } finally {
            processor.cleanup(); // Clean up resources
            // Don't store reference, let GC handle it
        }
    }
}

@Component
@Scope("prototype")
public class FileProcessor {
    private byte[] fileData;
    
    public void processFile(String fileName) {
        fileData = readLargeFile(fileName);
        // Process file...
    }
    
    public void cleanup() {
        fileData = null; // Help GC
        System.gc(); // Suggest garbage collection
    }
}
```

---

## ⭐ Best Practices

### 1️⃣ Singleton Best Practices 🎯

**✅ Make them Stateless:**
```java
@Component
public class EmailService {
    
    @Autowired
    private EmailTemplate emailTemplate; // Dependency injection
    
    @Value("${smtp.host}")
    private String smtpHost; // Configuration injection
    
    // No instance state - thread safe!
    public void sendEmail(String to, String subject, String body) {
        Email email = emailTemplate.create(to, subject, body);
        // Send email logic
        System.out.println("Email sent via: " + smtpHost);
    }
}
```

**✅ Use Final Fields for Dependencies:**
```java
@Component
public class OrderService {
    
    private final PaymentService paymentService;
    private final InventoryService inventoryService;
    
    // Constructor injection - fields are final!
    public OrderService(PaymentService paymentService, 
                       InventoryService inventoryService) {
        this.paymentService = paymentService;
        this.inventoryService = inventoryService;
    }
    
    public OrderResult processOrder(Order order) {
        // Thread-safe operations using injected services
        paymentService.processPayment(order.getPayment());
        inventoryService.updateInventory(order.getItems());
        return new OrderResult("SUCCESS");
    }
}
```

**✅ Use Concurrent Collections when State is Needed:**
```java
@Component
public class CacheService {
    
    // Thread-safe collections
    private final ConcurrentHashMap<String, Object> cache = new ConcurrentHashMap<>();
    private final AtomicLong hitCount = new AtomicLong(0);
    
    public void put(String key, Object value) {
        cache.put(key, value);
    }
    
    public Object get(String key) {
        Object value = cache.get(key);
        if (value != null) {
            hitCount.incrementAndGet();
        }
        return value;
    }
    
    public long getHitCount() {
        return hitCount.get();
    }
}
```

### 2️⃣ Prototype Best Practices 🏭

**✅ Use for Stateful Operations:**
```java
@Component
@Scope("prototype")
public class ReportGenerator {
    
    private String reportId;
    private List<String> errors;
    private ReportData data;
    
    public ReportGenerator() {
        this.reportId = "RPT_" + UUID.randomUUID().toString();
        this.errors = new ArrayList<>();
        System.out.println("🔄 New ReportGenerator: " + reportId);
    }
    
    public ReportResult generateReport(ReportRequest request) {
        try {
            validateRequest(request);
            data = fetchData(request);
            return createReport();
        } catch (Exception e) {
            errors.add("Report generation failed: " + e.getMessage());
            throw e;
        }
    }
    
    private void validateRequest(ReportRequest request) {
        if (request.getStartDate() == null) {
            errors.add("Start date is required");
        }
        // More validation...
    }
    
    public List<String> getErrors() {
        return new ArrayList<>(errors);
    }
}

// Usage
@Service
public class ReportService {
    
    @Autowired
    private ApplicationContext context;
    
    public ReportResult createUserReport(String userId) {
        ReportGenerator generator = context.getBean(ReportGenerator.class);
        ReportRequest request = new ReportRequest(userId);
        return generator.generateReport(request);
    }
}
```

**✅ Proper Resource Management:**
```java
@Component
@Scope("prototype")
public class DatabaseTransactionProcessor {
    
    private Connection connection;
    private String transactionId;
    
    public DatabaseTransactionProcessor() {
        this.transactionId = "TXN_" + System.currentTimeMillis();
    }
    
    public void initializeTransaction(DataSource dataSource) throws SQLException {
        this.connection = dataSource.getConnection();
        this.connection.setAutoCommit(false);
        System.out.println("Transaction started: " + transactionId);
    }
    
    public void executeOperation(String sql, Object... params) throws SQLException {
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            // Set parameters and execute
            stmt.executeUpdate();
        }
    }
    
    public void commit() throws SQLException {
        if (connection != null) {
            connection.commit();
            System.out.println("Transaction committed: " + transactionId);
        }
    }
    
    public void rollback() {
        try {
            if (connection != null) {
                connection.rollback();
                System.out.println("Transaction rolled back: " + transactionId);
            }
        } catch (SQLException e) {
            System.err.println("Rollback failed: " + e.getMessage());
        }
    }
    
    // Manual cleanup since Spring doesn't call @PreDestroy for prototypes
    public void cleanup() {
        try {
            if (connection != null && !connection.isClosed()) {
                connection.close();
                System.out.println("Connection closed for: " + transactionId);
            }
        } catch (SQLException e) {
            System.err.println("Connection close failed: " + e.getMessage());
        }
    }
}
```

### 3️⃣ Request/Session Scope Best Practices 🌐

**✅ Always Use Proxy Mode:**
```java
// Request Scope
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST,
       proxyMode = ScopedProxyMode.TARGET_CLASS) // MUST HAVE!
public class RequestAuditLog {
    
    private final String requestId;
    private final LocalDateTime startTime;
    private final List<AuditEntry> entries;
    
    public RequestAuditLog() {
        this.requestId = generateRequestId();
        this.startTime = LocalDateTime.now();
        this.entries = new ArrayList<>();
        System.out.println("📝 Audit log started: " + requestId);
    }
    
    public void addEntry(String action, String details) {
        entries.add(new AuditEntry(action, details, LocalDateTime.now()));
    }
    
    @PreDestroy
    public void finalizeAuditLog() {
        System.out.println("💾 Finalizing audit log: " + requestId);
        // Save to database or external system
        saveAuditEntries(requestId, entries);
    }
    
    private String generateRequestId() {
        return "REQ_" + System.currentTimeMillis() + "_" + 
               Thread.currentThread().getId();
    }
}

// Session Scope  
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserSession implements Serializable { // Serializable for session replication
    
    private static final long serialVersionUID = 1L;
    
    private String sessionId;
    private String userId;
    private LocalDateTime loginTime;
    private Map<String, Object> attributes;
    
    public UserSession() {
        this.sessionId = "SESS_" + UUID.randomUUID().toString();
        this.loginTime = LocalDateTime.now();
        this.attributes = new ConcurrentHashMap<>(); // Thread-safe
        System.out.println("👤 User session created: " + sessionId);
    }
    
    public void setAttribute(String key, Object value) {
        attributes.put(key, value);
    }
    
    public Object getAttribute(String key) {
        return attributes.get(key);
    }
    
    @PreDestroy
    public void cleanup() {
        System.out.println("🗑️ User session destroyed: " + sessionId);
        // Cleanup resources, save session data etc.
    }
}
```

**✅ Handle Session Serialization Properly:**
```java
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION,
       proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ShoppingCart implements Serializable {
    
    private static final long serialVersionUID = 2L; // Version for compatibility
    
    private List<CartItem> items;
    private transient DiscountCalculator calculator; // transient = not serialized
    
    public ShoppingCart() {
        this.items = new ArrayList<>();
        this.calculator = new DiscountCalculator(); // Will be null after deserialization
    }
    
    // Called after deserialization
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        this.calculator = new DiscountCalculator(); // Reinitialize transient fields
    }
    
    public void addItem(CartItem item) {
        items.add(item);
    }
    
    public BigDecimal calculateTotal() {
        if (calculator == null) {
            calculator = new DiscountCalculator(); // Lazy initialization
        }
        return calculator.calculateTotal(items);
    }
}
```

### 4️⃣ Configuration Best Practices ⚙️

**✅ Use Configuration Classes:**
```java
@Configuration
public class ScopeConfiguration {
    
    // Singleton scope configuration
    @Bean
    @Scope("singleton")
    public CacheManager cacheManager() {
        return CacheManager.create(); // Expensive operation, do once
    }
    
    // Prototype scope for stateful beans
    @Bean
    @Scope("prototype")
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(2);
        executor.setMaxPoolSize(5);
        executor.setThreadNamePrefix("task-");
        executor.initialize();
        return executor;
    }
    
    // Request scope with proper proxy
    @Bean
    @Scope(value = WebApplicationContext.SCOPE_REQUEST,
           proxyMode = ScopedProxyMode.INTERFACES)
    public RequestProcessor requestProcessor() {
        return new DefaultRequestProcessor();
    }
    
    // Session scope configuration
    @Bean
    @Scope(value = WebApplicationContext.SCOPE_SESSION,
           proxyMode = ScopedProxyMode.TARGET_CLASS)
    public UserPreferences userPreferences() {
        return new UserPreferences();
    }
}
```

**✅ Use Profiles for Different Environments:**
```java
@Configuration
@Profile("production")
public class ProductionScopeConfig {
    
    @Bean
    @Scope("singleton")
    public DataSource productionDataSource() {
        // Connection pooling, multiple databases etc.
        HikariConfig config = new HikariConfig();
        config.setMaximumPoolSize(50); // High pool size for production
        return new HikariDataSource(config);
    }
}

@Configuration
@Profile("development")  
public class DevelopmentScopeConfig {
    
    @Bean
    @Scope("singleton")
    public DataSource developmentDataSource() {
        // Simple datasource for dev
        HikariConfig config = new HikariConfig();
        config.setMaximumPoolSize(5); // Small pool for dev
        return new HikariDataSource(config);
    }
}
```

---

## 📚 Summary/Quick Recap

### 🧠 Memory Tricks (Yaad Rakhne Ka Mantra)

**🎯 Singleton = Single + Ton**
- **Single** instance
- **Ton** of requests use same object
- Think: **One boss for entire company**

**🏭 Prototype = Proto + Type**  
- **Proto** = first/new
- **Type** = template/pattern
- Think: **Cookie cutter - har baar new cookie!**

**📨 Request = Re + Quest**
- **Re** = again (new request)
- **Quest** = journey/task
- Think: **New delivery boy for each package**

**👤 Session = Sess + Ion**
- **Sess** = sitting (user baithe rahe)
- **Ion** = charged particle (active user)
- Think: **Same waiter throughout your restaurant visit**

### ⚡ Quick Decision Guide

```
🤔 Choosing Scope - Decision Tree:

Is it expensive to create? 
├─ YES → Singleton (Database pools, configs)
└─ NO ↓

Does it have user-specific data?
├─ YES ↓
│   └─ Data needed across requests? 
│       ├─ YES → Session (Shopping cart, preferences)  
│       └─ NO → Request (Form data, request tracking)
└─ NO ↓

Does it have state/data that changes?
├─ YES → Prototype (File processors, calculators)
└─ NO → Singleton (Utilities, services)
```

### 🔥 Key Takeaways

1. **Default hai Singleton** - Spring mein by default singleton scope hai ✅

2. **Thread Safety Sambhalo** - Singleton objects mein mutable state se bacho ⚠️

3. **Prototype ke liye ApplicationContext use karo** - @Autowired se nahi milega new instance 🔄

4. **Web scopes mein Proxy Mode mandatory** - Nahi toh startup pe error aayega 🚨

5. **Session objects Serializable banao** - Clustering ke liye important hai 📦

6. **Memory leaks se bacho** - Prototype objects ko properly cleanup karo 🧹

### 🎯 When to Use What - One Liner

- **Singleton:** "Ek baar banao, hamesha use karo" 🎯
- **Prototype:** "Har baar naya, har task unique" 🏭  
- **Request:** "Ek request, ek object" 📨
- **Session:** "Ek user, ek session object" 👤

### 🚀 Pro Tips

1. **Performance ke liye:** Singleton > Request > Session > Prototype

2. **Memory usage ke liye:** Singleton < Request < Session < Prototype

3. **Thread safety ke liye:** Prototype > Request > Session/Singleton (with care)

4. **Development ease ke liye:** Singleton > Prototype > Request > Session

### 🎭 Final Mantra

```
🎯 Singleton - "Sab ka ek, ek ka sab"
🏭 Prototype - "Nayi shururat, har baar"  
📨 Request - "Ek request, ek kahani"
👤 Session - "User ke saath, session ke saath"
```

---

## 📖 Additional Resources

### 🔗 Documentation Links
- Spring Framework Documentation: https://spring.io/projects/spring-framework
- Bean Scopes: https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes

### 📝 Practice Exercises
1. Create a banking application with all 4 scopes
2. Implement a file processing system using prototype scope
3. Build a web application with request/session scoped beans
4. Performance test different scopes

### 🎯 Next Topics to Study
- Spring Bean Lifecycle
- Dependency Injection Patterns  
- AOP (Aspect Oriented Programming)
- Spring Boot Auto Configuration

---

**Happy Coding! 🚀**

*"Code karo, scope samjho, Spring master bano!" - Java Guru* 😄
