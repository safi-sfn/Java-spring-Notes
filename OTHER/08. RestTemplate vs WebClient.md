# RestTemplate vs WebClient - Complete Java Study Notes 🚀

---

## 1. Introduction with Confusion Clearing 🤔

### Simple Explanation First 📝
**Bhai, ye concept samjho** - RestTemplate aur WebClient dono Java mein HTTP calls karne ke liye use hote hain. Matlab jab tumhe kisi external API se data mangna ho ya bhejna ho, tab ye dono tools use karte hain! 

### Real-life Analogy 🏪
**Imagine karo** - Tum ek shop owner ho:
- **RestTemplate** = Traditional counter system 🏪
  - Customer aata hai, order deta hai
  - Tum wait karte ho jab tak order ready nahi hota
  - Phir next customer ko serve karte ho
  
- **WebClient** = Modern food court system 🍕
  - Multiple orders simultaneously le sakte ho
  - Jaise hi koi order ready hota hai, customer ko token se pata chal jata hai
  - Non-blocking, efficient!

### Technical Definition 📚
- **RestTemplate**: Spring Framework ka synchronous HTTP client
- **WebClient**: Spring WebFlux ka reactive, non-blocking HTTP client

---

## 2. Key Terms/Concepts 🔑

| Term | Meaning | Example |
|------|---------|---------|
| **Synchronous** | Blocking call - wait karna padta hai | `restTemplate.getForObject()` |
| **Asynchronous** | Non-blocking - parallel execution | `webClient.get().retrieve()` |
| **Reactive** | Data streams handle karna | `Mono<String>`, `Flux<User>` |
| **HTTP Methods** | GET, POST, PUT, DELETE operations | Various API calls |
| **Mono** | Single value return type | `Mono<User>` |
| **Flux** | Multiple values stream | `Flux<List<User>>` |

### Visual Representation 📊
```
RestTemplate Flow:
Request → [WAIT] → Response → Next Request

WebClient Flow:
Request1 → [Process]
Request2 → [Process] → Response1, Response2, Response3...
Request3 → [Process]
```

---

## 3. Detailed Examples 💻

### RestTemplate Example - Complete Code 🔧

```java
// RestTemplate Configuration
@Configuration
public class RestTemplateConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        RestTemplate template = new RestTemplate();
        
        // Timeout configuration
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory();
        factory.setConnectTimeout(5000);  // 5 seconds
        factory.setReadTimeout(5000);     // 5 seconds
        
        template.setRequestFactory(factory);
        return template;
    }
}

// Service Class using RestTemplate
@Service
public class UserService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    private final String BASE_URL = "https://jsonplaceholder.typicode.com";
    
    // GET request example
    public User getUserById(Long id) {
        String url = BASE_URL + "/users/" + id;
        try {
            User user = restTemplate.getForObject(url, User.class);
            System.out.println("User fetched: " + user.getName());
            return user;
        } catch (Exception e) {
            System.err.println("Error fetching user: " + e.getMessage());
            return null;
        }
    }
    
    // POST request example
    public User createUser(User newUser) {
        String url = BASE_URL + "/users";
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<User> request = new HttpEntity<>(newUser, headers);
        
        User createdUser = restTemplate.postForObject(url, request, User.class);
        System.out.println("User created with ID: " + createdUser.getId());
        return createdUser;
    }
    
    // PUT request example
    public void updateUser(Long id, User user) {
        String url = BASE_URL + "/users/" + id;
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<User> request = new HttpEntity<>(user, headers);
        
        restTemplate.put(url, request);
        System.out.println("User updated successfully!");
    }
    
    // DELETE request example
    public void deleteUser(Long id) {
        String url = BASE_URL + "/users/" + id;
        restTemplate.delete(url);
        System.out.println("User deleted with ID: " + id);
    }
}

// User Model Class
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Long id;
    private String name;
    private String username;
    private String email;
    private String phone;
    private String website;
}
```

**Expected Output:**
```
User fetched: Leanne Graham
User created with ID: 11
User updated successfully!
User deleted with ID: 1
```

### WebClient Example - Complete Code ⚡

```java
// WebClient Configuration
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient webClient() {
        return WebClient.builder()
                .baseUrl("https://jsonplaceholder.typicode.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .defaultHeader(HttpHeaders.USER_AGENT, "MyApp/1.0")
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(2 * 1024 * 1024)) // 2MB
                .build();
    }
}

// Service Class using WebClient
@Service
public class UserServiceReactive {
    
    @Autowired
    private WebClient webClient;
    
    // GET request - Single user (Mono)
    public Mono<User> getUserById(Long id) {
        return webClient.get()
                .uri("/users/{id}", id)
                .retrieve()
                .onStatus(HttpStatus::is4xxClientError, response -> {
                    System.err.println("Client Error: " + response.statusCode());
                    return Mono.error(new RuntimeException("User not found"));
                })
                .onStatus(HttpStatus::is5xxServerError, response -> {
                    System.err.println("Server Error: " + response.statusCode());
                    return Mono.error(new RuntimeException("Server error"));
                })
                .bodyToMono(User.class)
                .doOnSuccess(user -> System.out.println("✅ User fetched: " + user.getName()))
                .doOnError(error -> System.err.println("❌ Error: " + error.getMessage()));
    }
    
    // GET request - Multiple users (Flux)
    public Flux<User> getAllUsers() {
        return webClient.get()
                .uri("/users")
                .retrieve()
                .bodyToFlux(User.class)
                .doOnNext(user -> System.out.println("📋 Processing user: " + user.getName()))
                .doOnComplete(() -> System.out.println("✅ All users processed!"))
                .doOnError(error -> System.err.println("❌ Error fetching users: " + error.getMessage()));
    }
    
    // POST request
    public Mono<User> createUser(User newUser) {
        return webClient.post()
                .uri("/users")
                .body(Mono.just(newUser), User.class)
                .retrieve()
                .bodyToMono(User.class)
                .doOnSuccess(user -> System.out.println("✅ User created: " + user.getId()))
                .doOnError(error -> System.err.println("❌ Error creating user: " + error.getMessage()));
    }
    
    // PUT request
    public Mono<User> updateUser(Long id, User user) {
        return webClient.put()
                .uri("/users/{id}", id)
                .body(Mono.just(user), User.class)
                .retrieve()
                .bodyToMono(User.class)
                .doOnSuccess(updatedUser -> System.out.println("✅ User updated: " + updatedUser.getId()))
                .doOnError(error -> System.err.println("❌ Error updating user: " + error.getMessage()));
    }
    
    // DELETE request
    public Mono<Void> deleteUser(Long id) {
        return webClient.delete()
                .uri("/users/{id}", id)
                .retrieve()
                .bodyToMono(Void.class)
                .doOnSuccess(response -> System.out.println("✅ User deleted: " + id))
                .doOnError(error -> System.err.println("❌ Error deleting user: " + error.getMessage()));
    }
    
    // Advanced: Parallel processing
    public Mono<String> processMultipleUsers() {
        List<Long> userIds = Arrays.asList(1L, 2L, 3L, 4L, 5L);
        
        return Flux.fromIterable(userIds)
                .flatMap(this::getUserById, 3) // Concurrent requests limit = 3
                .collectList()
                .map(users -> {
                    System.out.println("🚀 Processed " + users.size() + " users concurrently!");
                    return "Processing completed for " + users.size() + " users";
                });
    }
}
```

**Expected Output:**
```
✅ User fetched: Leanne Graham
📋 Processing user: Leanne Graham
📋 Processing user: Ervin Howell
📋 Processing user: Clementine Bauch
✅ All users processed!
✅ User created: 11
✅ User updated: 1
✅ User deleted: 1
🚀 Processed 5 users concurrently!
```

### Controller Example 🎮

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService; // RestTemplate
    
    @Autowired
    private UserServiceReactive userServiceReactive; // WebClient
    
    // RestTemplate endpoints
    @GetMapping("/sync/{id}")
    public ResponseEntity<User> getUserSync(@PathVariable Long id) {
        User user = userService.getUserById(id);
        return user != null ? ResponseEntity.ok(user) : ResponseEntity.notFound().build();
    }
    
    @PostMapping("/sync")
    public ResponseEntity<User> createUserSync(@RequestBody User user) {
        User createdUser = userService.createUser(user);
        return ResponseEntity.ok(createdUser);
    }
    
    // WebClient endpoints (Reactive)
    @GetMapping("/async/{id}")
    public Mono<ResponseEntity<User>> getUserAsync(@PathVariable Long id) {
        return userServiceReactive.getUserById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
    
    @GetMapping("/async/all")
    public Flux<User> getAllUsersAsync() {
        return userServiceReactive.getAllUsers();
    }
    
    @PostMapping("/async")
    public Mono<ResponseEntity<User>> createUserAsync(@RequestBody User user) {
        return userServiceReactive.createUser(user)
                .map(ResponseEntity::ok);
    }
    
    // Performance comparison endpoint
    @GetMapping("/performance-test")
    public Mono<String> performanceTest() {
        long startTime = System.currentTimeMillis();
        
        return userServiceReactive.processMultipleUsers()
                .map(result -> {
                    long endTime = System.currentTimeMillis();
                    return result + " in " + (endTime - startTime) + "ms";
                });
    }
}
```

---

## 4. Rules/Guidelines 📋

### ✅ RestTemplate Best Practices

1. **Always configure timeouts** ⏰
```java
// ✅ Correct way
@Bean
public RestTemplate restTemplate() {
    RestTemplate template = new RestTemplate();
    HttpComponentsClientHttpRequestFactory factory = 
        new HttpComponentsClientHttpRequestFactory();
    factory.setConnectTimeout(5000);
    factory.setReadTimeout(10000);
    template.setRequestFactory(factory);
    return template;
}

// ❌ Wrong way - No timeout configuration
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate(); // Default timeout might be too long
}
```

2. **Handle exceptions properly** 🛡️
```java
// ✅ Correct way
public User getUser(Long id) {
    try {
        return restTemplate.getForObject("/users/" + id, User.class);
    } catch (HttpClientErrorException.NotFound e) {
        System.err.println("User not found: " + id);
        return null;
    } catch (ResourceAccessException e) {
        System.err.println("Timeout occurred: " + e.getMessage());
        throw new ServiceUnavailableException("Service timeout");
    }
}

// ❌ Wrong way - No exception handling
public User getUser(Long id) {
    return restTemplate.getForObject("/users/" + id, User.class); // Can throw runtime exceptions
}
```

3. **Use proper HTTP headers** 📄
```java
// ✅ Correct way
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
headers.set("Authorization", "Bearer " + token);
HttpEntity<User> entity = new HttpEntity<>(user, headers);

// ❌ Wrong way - Missing headers
HttpEntity<User> entity = new HttpEntity<>(user); // No content type specified
```

### ✅ WebClient Best Practices

4. **Configure WebClient properly** ⚙️
```java
// ✅ Correct way
@Bean
public WebClient webClient() {
    return WebClient.builder()
            .baseUrl("https://api.example.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(1024 * 1024))
            .clientConnector(new ReactorClientHttpConnector(
                HttpClient.create().responseTimeout(Duration.ofSeconds(10))
            ))
            .build();
}

// ❌ Wrong way - Basic configuration
@Bean
public WebClient webClient() {
    return WebClient.create(); // No timeout, no base URL
}
```

5. **Handle errors reactively** 🔄
```java
// ✅ Correct way
public Mono<User> getUser(Long id) {
    return webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            .onStatus(HttpStatus::is4xxClientError, response -> 
                Mono.error(new UserNotFoundException("User not found: " + id)))
            .onStatus(HttpStatus::is5xxServerError, response -> 
                Mono.error(new ServiceException("Server error")))
            .bodyToMono(User.class);
}

// ❌ Wrong way - No error handling
public Mono<User> getUser(Long id) {
    return webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            .bodyToMono(User.class); // Will throw WebClientException
}
```

6. **Use appropriate return types** 📦
```java
// ✅ Correct way
public Mono<User> getSingleUser(Long id) {     // Single value
    return webClient.get().uri("/users/{id}", id).retrieve().bodyToMono(User.class);
}

public Flux<User> getMultipleUsers() {         // Multiple values
    return webClient.get().uri("/users").retrieve().bodyToFlux(User.class);
}

// ❌ Wrong way - Wrong return types
public Flux<User> getSingleUser(Long id) {    // Should be Mono, not Flux
    return webClient.get().uri("/users/{id}", id).retrieve().bodyToFlux(User.class);
}
```

---

## 5. Real-world Applications 🌍

### Banking Application Example 🏦

```java
@Service
public class BankingService {
    
    @Autowired
    private WebClient webClient;
    
    // Account balance check
    public Mono<AccountBalance> getAccountBalance(String accountNumber) {
        return webClient.get()
                .uri("/accounts/{accountNumber}/balance", accountNumber)
                .headers(headers -> headers.setBearerAuth(getAuthToken()))
                .retrieve()
                .onStatus(HttpStatus::is4xxClientError, response -> {
                    if (response.statusCode() == HttpStatus.NOT_FOUND) {
                        return Mono.error(new AccountNotFoundException("Account not found"));
                    }
                    return Mono.error(new InvalidRequestException("Invalid request"));
                })
                .bodyToMono(AccountBalance.class)
                .timeout(Duration.ofSeconds(5))
                .retry(2);
    }
    
    // Money transfer
    public Mono<TransferResponse> transferMoney(TransferRequest request) {
        return webClient.post()
                .uri("/transfers")
                .headers(headers -> {
                    headers.setBearerAuth(getAuthToken());
                    headers.set("Idempotency-Key", UUID.randomUUID().toString());
                })
                .body(Mono.just(request), TransferRequest.class)
                .retrieve()
                .bodyToMono(TransferResponse.class)
                .doOnSuccess(response -> 
                    System.out.println("✅ Transfer completed: " + response.getTransactionId()))
                .doOnError(error -> 
                    System.err.println("❌ Transfer failed: " + error.getMessage()));
    }
    
    // Get transaction history with pagination
    public Flux<Transaction> getTransactionHistory(String accountNumber, int page, int size) {
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/accounts/{accountNumber}/transactions")
                        .queryParam("page", page)
                        .queryParam("size", size)
                        .queryParam("sort", "timestamp,desc")
                        .build(accountNumber))
                .retrieve()
                .bodyToFlux(Transaction.class)
                .take(size); // Limit results
    }
}
```

### E-commerce Integration 🛒

```java
@Service
public class ProductService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private WebClient webClient;
    
    // Sync approach - RestTemplate
    public List<Product> getProductsCatalogSync(String category) {
        String url = "/products?category=" + category;
        
        try {
            ResponseEntity<Product[]> response = restTemplate.getForEntity(url, Product[].class);
            return Arrays.asList(response.getBody());
        } catch (Exception e) {
            System.err.println("Error fetching products: " + e.getMessage());
            return Collections.emptyList();
        }
    }
    
    // Async approach - WebClient
    public Flux<Product> getProductsCatalogAsync(String category) {
        return webClient.get()
                .uri("/products")
                .header("X-Category", category)
                .retrieve()
                .bodyToFlux(Product.class)
                .filter(product -> product.isAvailable())
                .map(this::enrichProductData)
                .doOnNext(product -> cacheProduct(product));
    }
    
    // Parallel processing for inventory check
    public Mono<InventoryReport> checkInventoryStatus(List<String> productIds) {
        return Flux.fromIterable(productIds)
                .flatMap(productId -> 
                    webClient.get()
                        .uri("/inventory/{productId}", productId)
                        .retrieve()
                        .bodyToMono(InventoryItem.class), 
                    5) // Process 5 products concurrently
                .collectList()
                .map(this::generateInventoryReport);
    }
}
```

---

## 6. Comparison Tables 📊

### Feature Comparison

| Feature | RestTemplate 🔄 | WebClient ⚡ | Winner |
|---------|----------------|--------------|---------|
| **Performance** | Blocking, slower | Non-blocking, faster | WebClient 🏆 |
| **Memory Usage** | Higher (thread per request) | Lower (event loop) | WebClient 🏆 |
| **Learning Curve** | Easy, familiar | Steeper (reactive concepts) | RestTemplate 🏆 |
| **Error Handling** | Try-catch blocks | Reactive error operators | WebClient 🏆 |
| **Testing** | Simple unit tests | Need reactive testing | RestTemplate 🏆 |
| **Spring Boot Integration** | Built-in support | Built-in support | Tie 🤝 |
| **HTTP/2 Support** | Limited | Full support | WebClient 🏆 |
| **Streaming** | Not suitable | Excellent | WebClient 🏆 |
| **Legacy Code Integration** | Perfect fit | Needs adaptation | RestTemplate 🏆 |
| **Future Support** | Deprecated in Spring 6 | Active development | WebClient 🏆 |

### Performance Metrics 📈

| Metric | RestTemplate | WebClient | Improvement |
|--------|--------------|-----------|-------------|
| **Concurrent Requests (1000)** | 45 seconds | 12 seconds | **73% faster** |
| **Memory Usage** | 512 MB | 128 MB | **75% less** |
| **Thread Count** | 200 threads | 10 threads | **95% reduction** |
| **Response Time (avg)** | 890ms | 320ms | **64% faster** |

### When to Use What? 🤔

| Scenario | Use RestTemplate | Use WebClient |
|----------|------------------|---------------|
| **Simple CRUD operations** | ✅ Perfect | ⚠️ Overkill |
| **High-traffic applications** | ❌ Not suitable | ✅ Excellent |
| **Legacy system integration** | ✅ Great choice | ❌ Complex |
| **Microservices communication** | ⚠️ Okay | ✅ Recommended |
| **Real-time data streaming** | ❌ Can't handle | ✅ Built for this |
| **Team has reactive experience** | ❌ Not needed | ✅ Go for it |
| **Quick prototyping** | ✅ Fast setup | ❌ Takes time |
| **Production-ready applications** | ⚠️ Consider alternatives | ✅ Future-proof |

---

## 7. Interview Questions 🎤

### Basic Level Questions

**Q1: RestTemplate aur WebClient mein main difference kya hai?**
```java
// Answer with example
public class HttpClientExample {
    
    // RestTemplate - Synchronous
    public User getUserRestTemplate(Long id) {
        RestTemplate restTemplate = new RestTemplate();
        // Thread block ho jata hai yahan
        User user = restTemplate.getForObject("/users/" + id, User.class);
        System.out.println("Got user: " + user.getName());
        return user; // Response milne ke baad hi next line execute hoti hai
    }
    
    // WebClient - Asynchronous  
    public Mono<User> getUserWebClient(Long id) {
        WebClient webClient = WebClient.create();
        // Thread block nahi hota, immediately Mono return karta hai
        return webClient.get()
                .uri("/users/{id}", id)
                .retrieve()
                .bodyToMono(User.class)
                .doOnSuccess(user -> System.out.println("Got user: " + user.getName()));
    }
}
```

**Q2: Reactive programming kya hai aur kyon use karte hain?**
```java
// Traditional approach - Blocking
public List<String> processUsersBlocking() {
    List<User> users = fetchAllUsers();        // Wait for response
    List<String> names = new ArrayList<>();
    for (User user : users) {                  // Process one by one
        String processedName = processUser(user); // Each call blocks
        names.add(processedName);
    }
    return names; // Return after all processing done
}

// Reactive approach - Non-blocking
public Flux<String> processUsersReactive() {
    return fetchAllUsersReactive()              // Returns immediately
            .flatMap(this::processUserReactive)  // Parallel processing
            .collectList()                       // Collect results when ready
            .flatMapMany(Flux::fromIterable);   // Convert to Flux
}
```

### Intermediate Level Questions

**Q3: WebClient mein error handling kaise karte hain?**
```java
public Mono<User> getUserWithErrorHandling(Long id) {
    return webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            
            // Specific error handling
            .onStatus(HttpStatus::is4xxClientError, response -> {
                if (response.statusCode() == HttpStatus.NOT_FOUND) {
                    return Mono.error(new UserNotFoundException("User not found: " + id));
                }
                return Mono.error(new BadRequestException("Invalid request"));
            })
            
            .onStatus(HttpStatus::is5xxServerError, response -> 
                Mono.error(new ServiceUnavailableException("Server error")))
                
            .bodyToMono(User.class)
            
            // Additional error handling
            .doOnError(WebClientException.class, ex -> 
                log.error("WebClient error: {}", ex.getMessage()))
                
            .onErrorReturn(new User()); // Fallback value
}
```

**Q4: Timeout kaise configure karte hain dono mein?**
```java
// RestTemplate timeout
@Bean
public RestTemplate restTemplate() {
    RestTemplate template = new RestTemplate();
    
    HttpComponentsClientHttpRequestFactory factory = 
        new HttpComponentsClientHttpRequestFactory();
    
    factory.setConnectTimeout(5000);    // Connection timeout
    factory.setReadTimeout(10000);      // Read timeout
    
    template.setRequestFactory(factory);
    return template;
}

// WebClient timeout
@Bean  
public WebClient webClient() {
    HttpClient httpClient = HttpClient.create()
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)     // Connection timeout
            .responseTimeout(Duration.ofSeconds(10));               // Response timeout
            
    return WebClient.builder()
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .build();
}

// Per-request timeout in WebClient
public Mono<User> getUserWithTimeout(Long id) {
    return webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            .bodyToMono(User.class)
            .timeout(Duration.ofSeconds(5));  // This request ka timeout
}
```

### Advanced Level Questions

**Q5: BackPressure handling kaise karte hain WebClient mein?**
```java
public class BackPressureExample {
    
    // Problem: Fast producer, slow consumer
    public Flux<ProcessedData> handleBackPressure() {
        return webClient.get()
                .uri("/large-dataset")
                .retrieve()
                .bodyToFlux(RawData.class)
                
                // BackPressure strategies
                .onBackpressureBuffer(1000)        // Buffer up to 1000 items
                .onBackpressureDrop()               // Drop excess items
                .onBackpressureLatest()             // Keep only latest
                
                // Controlled processing
                .limitRate(10)                      // Process max 10 items at a time
                .delayElements(Duration.ofMillis(100)) // Add delay
                
                .map(this::processData)             // Transform data
                .doOnNext(data -> log.info("Processed: {}", data.getId()));
    }
    
    // Custom backpressure handling
    public Flux<String> customBackPressureHandling() {
        return Flux.create(sink -> {
            // Custom emission logic
            AtomicLong requested = new AtomicLong();
            
            sink.onRequest(n -> {
                long currentRequested = requested.addAndGet(n);
                // Emit only requested amount
                for (int i = 0; i < currentRequested && !sink.isCancelled(); i++) {
                    sink.next("Data-" + i);
                }
            });
            
        }, FluxSink.OverflowStrategy.BUFFER);
    }
}
```

**Q6: Parallel processing kaise implement karte hain?**
```java
public class ParallelProcessingExample {
    
    // Sequential processing (slow)
    public Mono<List<UserDetails>> processUsersSequential(List<Long> userIds) {
        return Flux.fromIterable(userIds)
                .concatMap(this::fetchUserDetails)  // One after another
                .collectList();
    }
    
    // Parallel processing (fast)
    public Mono<List<UserDetails>> processUsersParallel(List<Long> userIds) {
        return Flux.fromIterable(userIds)
                .flatMap(this::fetchUserDetails, 5)  // Max 5 concurrent calls
                .collectList();
    }
    
    // Advanced parallel with custom scheduler
    public Mono<List<UserDetails>> processUsersAdvancedParallel(List<Long> userIds) {
        return Flux.fromIterable(userIds)
                .parallel(4)                        // Create 4 rails
                .runOn(Schedulers.parallel())       // Run on parallel scheduler
                .flatMap(this::fetchUserDetails)    // Process on each rail
                .sequential()                       // Merge back to single Flux
                .collectList();
    }
    
    private Mono<UserDetails> fetchUserDetails(Long userId) {
        return webClient.get()
                .uri("/users/{id}/details", userId)
                .retrieve()
                .bodyToMono(UserDetails.class)
                .doOnSuccess(details -> 
                    log.info("Processed user {} on thread: {}", 
                            userId, Thread.currentThread().getName()));
    }
}
```

---

## 8. Common Mistakes 🚫

### Mistake #1: RestTemplate mein timeout nahi lagana
```java
// ❌ Wrong - No timeout configuration
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate(); 
    // Default timeout bahut zyada hai, application hang ho sakti hai
}

// ✅ Correct - Proper timeout
@Bean  
public RestTemplate restTemplate() {
    RestTemplate template = new RestTemplate();
    HttpComponentsClientHttpRequestFactory factory = 
        new HttpComponentsClientHttpRequestFactory();
    factory.setConnectTimeout(5000);
    factory.setReadTimeout(10000);
    template.setRequestFactory(factory);
    return template;
}

// Error Message you might see:
// java.net.SocketTimeoutException: Read timed out
```

### Mistake #2: WebClient ko sync way mein use karna
```java
// ❌ Wrong - Blocking the reactive chain
public User getUserWrong(Long id) {
    Mono<User> userMono = webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            .bodyToMono(User.class);
            
    return userMono.block(); // Don't do this! Blocks the thread
}

// ✅ Correct - Keep it reactive
public Mono<User> getUserCorrect(Long id) {
    return webClient.get()
            .
