# RestTemplate vs WebClient - Complete Java Study Notes ğŸš€

---

## 1. Introduction with Confusion Clearing ğŸ¤”

### Simple Explanation First ğŸ“
**Bhai, ye concept samjho** - RestTemplate aur WebClient dono Java mein HTTP calls karne ke liye use hote hain. Matlab jab tumhe kisi external API se data mangna ho ya bhejna ho, tab ye dono tools use karte hain! 

### Real-life Analogy ğŸª
**Imagine karo** - Tum ek shop owner ho:
- **RestTemplate** = Traditional counter system ğŸª
  - Customer aata hai, order deta hai
  - Tum wait karte ho jab tak order ready nahi hota
  - Phir next customer ko serve karte ho
  
- **WebClient** = Modern food court system ğŸ•
  - Multiple orders simultaneously le sakte ho
  - Jaise hi koi order ready hota hai, customer ko token se pata chal jata hai
  - Non-blocking, efficient!

### Technical Definition ğŸ“š
- **RestTemplate**: Spring Framework ka synchronous HTTP client
- **WebClient**: Spring WebFlux ka reactive, non-blocking HTTP client

---

## 2. Key Terms/Concepts ğŸ”‘

| Term | Meaning | Example |
|------|---------|---------|
| **Synchronous** | Blocking call - wait karna padta hai | `restTemplate.getForObject()` |
| **Asynchronous** | Non-blocking - parallel execution | `webClient.get().retrieve()` |
| **Reactive** | Data streams handle karna | `Mono<String>`, `Flux<User>` |
| **HTTP Methods** | GET, POST, PUT, DELETE operations | Various API calls |
| **Mono** | Single value return type | `Mono<User>` |
| **Flux** | Multiple values stream | `Flux<List<User>>` |

### Visual Representation ğŸ“Š
```
RestTemplate Flow:
Request â†’ [WAIT] â†’ Response â†’ Next Request

WebClient Flow:
Request1 â†’ [Process]
Request2 â†’ [Process] â†’ Response1, Response2, Response3...
Request3 â†’ [Process]
```

---

## 3. Detailed Examples ğŸ’»

### RestTemplate Example - Complete Code ğŸ”§

```java
// RestTemplate Configuration
@Configuration
public class RestTemplateConfig {
    
    @Bean
    public RestTemplate restTemplate() {
        RestTemplate template = new RestTemplate();
        
        // Timeout configuration
        HttpComponentsClientHttpRequestFactory factory = 
            new HttpComponentsClientHttpRequestFactory();
        factory.setConnectTimeout(5000);  // 5 seconds
        factory.setReadTimeout(5000);     // 5 seconds
        
        template.setRequestFactory(factory);
        return template;
    }
}

// Service Class using RestTemplate
@Service
public class UserService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    private final String BASE_URL = "https://jsonplaceholder.typicode.com";
    
    // GET request example
    public User getUserById(Long id) {
        String url = BASE_URL + "/users/" + id;
        try {
            User user = restTemplate.getForObject(url, User.class);
            System.out.println("User fetched: " + user.getName());
            return user;
        } catch (Exception e) {
            System.err.println("Error fetching user: " + e.getMessage());
            return null;
        }
    }
    
    // POST request example
    public User createUser(User newUser) {
        String url = BASE_URL + "/users";
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<User> request = new HttpEntity<>(newUser, headers);
        
        User createdUser = restTemplate.postForObject(url, request, User.class);
        System.out.println("User created with ID: " + createdUser.getId());
        return createdUser;
    }
    
    // PUT request example
    public void updateUser(Long id, User user) {
        String url = BASE_URL + "/users/" + id;
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        
        HttpEntity<User> request = new HttpEntity<>(user, headers);
        
        restTemplate.put(url, request);
        System.out.println("User updated successfully!");
    }
    
    // DELETE request example
    public void deleteUser(Long id) {
        String url = BASE_URL + "/users/" + id;
        restTemplate.delete(url);
        System.out.println("User deleted with ID: " + id);
    }
}

// User Model Class
@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Long id;
    private String name;
    private String username;
    private String email;
    private String phone;
    private String website;
}
```

**Expected Output:**
```
User fetched: Leanne Graham
User created with ID: 11
User updated successfully!
User deleted with ID: 1
```

### WebClient Example - Complete Code âš¡

```java
// WebClient Configuration
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient webClient() {
        return WebClient.builder()
                .baseUrl("https://jsonplaceholder.typicode.com")
                .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                .defaultHeader(HttpHeaders.USER_AGENT, "MyApp/1.0")
                .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(2 * 1024 * 1024)) // 2MB
                .build();
    }
}

// Service Class using WebClient
@Service
public class UserServiceReactive {
    
    @Autowired
    private WebClient webClient;
    
    // GET request - Single user (Mono)
    public Mono<User> getUserById(Long id) {
        return webClient.get()
                .uri("/users/{id}", id)
                .retrieve()
                .onStatus(HttpStatus::is4xxClientError, response -> {
                    System.err.println("Client Error: " + response.statusCode());
                    return Mono.error(new RuntimeException("User not found"));
                })
                .onStatus(HttpStatus::is5xxServerError, response -> {
                    System.err.println("Server Error: " + response.statusCode());
                    return Mono.error(new RuntimeException("Server error"));
                })
                .bodyToMono(User.class)
                .doOnSuccess(user -> System.out.println("âœ… User fetched: " + user.getName()))
                .doOnError(error -> System.err.println("âŒ Error: " + error.getMessage()));
    }
    
    // GET request - Multiple users (Flux)
    public Flux<User> getAllUsers() {
        return webClient.get()
                .uri("/users")
                .retrieve()
                .bodyToFlux(User.class)
                .doOnNext(user -> System.out.println("ğŸ“‹ Processing user: " + user.getName()))
                .doOnComplete(() -> System.out.println("âœ… All users processed!"))
                .doOnError(error -> System.err.println("âŒ Error fetching users: " + error.getMessage()));
    }
    
    // POST request
    public Mono<User> createUser(User newUser) {
        return webClient.post()
                .uri("/users")
                .body(Mono.just(newUser), User.class)
                .retrieve()
                .bodyToMono(User.class)
                .doOnSuccess(user -> System.out.println("âœ… User created: " + user.getId()))
                .doOnError(error -> System.err.println("âŒ Error creating user: " + error.getMessage()));
    }
    
    // PUT request
    public Mono<User> updateUser(Long id, User user) {
        return webClient.put()
                .uri("/users/{id}", id)
                .body(Mono.just(user), User.class)
                .retrieve()
                .bodyToMono(User.class)
                .doOnSuccess(updatedUser -> System.out.println("âœ… User updated: " + updatedUser.getId()))
                .doOnError(error -> System.err.println("âŒ Error updating user: " + error.getMessage()));
    }
    
    // DELETE request
    public Mono<Void> deleteUser(Long id) {
        return webClient.delete()
                .uri("/users/{id}", id)
                .retrieve()
                .bodyToMono(Void.class)
                .doOnSuccess(response -> System.out.println("âœ… User deleted: " + id))
                .doOnError(error -> System.err.println("âŒ Error deleting user: " + error.getMessage()));
    }
    
    // Advanced: Parallel processing
    public Mono<String> processMultipleUsers() {
        List<Long> userIds = Arrays.asList(1L, 2L, 3L, 4L, 5L);
        
        return Flux.fromIterable(userIds)
                .flatMap(this::getUserById, 3) // Concurrent requests limit = 3
                .collectList()
                .map(users -> {
                    System.out.println("ğŸš€ Processed " + users.size() + " users concurrently!");
                    return "Processing completed for " + users.size() + " users";
                });
    }
}
```

**Expected Output:**
```
âœ… User fetched: Leanne Graham
ğŸ“‹ Processing user: Leanne Graham
ğŸ“‹ Processing user: Ervin Howell
ğŸ“‹ Processing user: Clementine Bauch
âœ… All users processed!
âœ… User created: 11
âœ… User updated: 1
âœ… User deleted: 1
ğŸš€ Processed 5 users concurrently!
```

### Controller Example ğŸ®

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService; // RestTemplate
    
    @Autowired
    private UserServiceReactive userServiceReactive; // WebClient
    
    // RestTemplate endpoints
    @GetMapping("/sync/{id}")
    public ResponseEntity<User> getUserSync(@PathVariable Long id) {
        User user = userService.getUserById(id);
        return user != null ? ResponseEntity.ok(user) : ResponseEntity.notFound().build();
    }
    
    @PostMapping("/sync")
    public ResponseEntity<User> createUserSync(@RequestBody User user) {
        User createdUser = userService.createUser(user);
        return ResponseEntity.ok(createdUser);
    }
    
    // WebClient endpoints (Reactive)
    @GetMapping("/async/{id}")
    public Mono<ResponseEntity<User>> getUserAsync(@PathVariable Long id) {
        return userServiceReactive.getUserById(id)
                .map(ResponseEntity::ok)
                .defaultIfEmpty(ResponseEntity.notFound().build());
    }
    
    @GetMapping("/async/all")
    public Flux<User> getAllUsersAsync() {
        return userServiceReactive.getAllUsers();
    }
    
    @PostMapping("/async")
    public Mono<ResponseEntity<User>> createUserAsync(@RequestBody User user) {
        return userServiceReactive.createUser(user)
                .map(ResponseEntity::ok);
    }
    
    // Performance comparison endpoint
    @GetMapping("/performance-test")
    public Mono<String> performanceTest() {
        long startTime = System.currentTimeMillis();
        
        return userServiceReactive.processMultipleUsers()
                .map(result -> {
                    long endTime = System.currentTimeMillis();
                    return result + " in " + (endTime - startTime) + "ms";
                });
    }
}
```

---

## 4. Rules/Guidelines ğŸ“‹

### âœ… RestTemplate Best Practices

1. **Always configure timeouts** â°
```java
// âœ… Correct way
@Bean
public RestTemplate restTemplate() {
    RestTemplate template = new RestTemplate();
    HttpComponentsClientHttpRequestFactory factory = 
        new HttpComponentsClientHttpRequestFactory();
    factory.setConnectTimeout(5000);
    factory.setReadTimeout(10000);
    template.setRequestFactory(factory);
    return template;
}

// âŒ Wrong way - No timeout configuration
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate(); // Default timeout might be too long
}
```

2. **Handle exceptions properly** ğŸ›¡ï¸
```java
// âœ… Correct way
public User getUser(Long id) {
    try {
        return restTemplate.getForObject("/users/" + id, User.class);
    } catch (HttpClientErrorException.NotFound e) {
        System.err.println("User not found: " + id);
        return null;
    } catch (ResourceAccessException e) {
        System.err.println("Timeout occurred: " + e.getMessage());
        throw new ServiceUnavailableException("Service timeout");
    }
}

// âŒ Wrong way - No exception handling
public User getUser(Long id) {
    return restTemplate.getForObject("/users/" + id, User.class); // Can throw runtime exceptions
}
```

3. **Use proper HTTP headers** ğŸ“„
```java
// âœ… Correct way
HttpHeaders headers = new HttpHeaders();
headers.setContentType(MediaType.APPLICATION_JSON);
headers.set("Authorization", "Bearer " + token);
HttpEntity<User> entity = new HttpEntity<>(user, headers);

// âŒ Wrong way - Missing headers
HttpEntity<User> entity = new HttpEntity<>(user); // No content type specified
```

### âœ… WebClient Best Practices

4. **Configure WebClient properly** âš™ï¸
```java
// âœ… Correct way
@Bean
public WebClient webClient() {
    return WebClient.builder()
            .baseUrl("https://api.example.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(1024 * 1024))
            .clientConnector(new ReactorClientHttpConnector(
                HttpClient.create().responseTimeout(Duration.ofSeconds(10))
            ))
            .build();
}

// âŒ Wrong way - Basic configuration
@Bean
public WebClient webClient() {
    return WebClient.create(); // No timeout, no base URL
}
```

5. **Handle errors reactively** ğŸ”„
```java
// âœ… Correct way
public Mono<User> getUser(Long id) {
    return webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            .onStatus(HttpStatus::is4xxClientError, response -> 
                Mono.error(new UserNotFoundException("User not found: " + id)))
            .onStatus(HttpStatus::is5xxServerError, response -> 
                Mono.error(new ServiceException("Server error")))
            .bodyToMono(User.class);
}

// âŒ Wrong way - No error handling
public Mono<User> getUser(Long id) {
    return webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            .bodyToMono(User.class); // Will throw WebClientException
}
```

6. **Use appropriate return types** ğŸ“¦
```java
// âœ… Correct way
public Mono<User> getSingleUser(Long id) {     // Single value
    return webClient.get().uri("/users/{id}", id).retrieve().bodyToMono(User.class);
}

public Flux<User> getMultipleUsers() {         // Multiple values
    return webClient.get().uri("/users").retrieve().bodyToFlux(User.class);
}

// âŒ Wrong way - Wrong return types
public Flux<User> getSingleUser(Long id) {    // Should be Mono, not Flux
    return webClient.get().uri("/users/{id}", id).retrieve().bodyToFlux(User.class);
}
```

---

## 5. Real-world Applications ğŸŒ

### Banking Application Example ğŸ¦

```java
@Service
public class BankingService {
    
    @Autowired
    private WebClient webClient;
    
    // Account balance check
    public Mono<AccountBalance> getAccountBalance(String accountNumber) {
        return webClient.get()
                .uri("/accounts/{accountNumber}/balance", accountNumber)
                .headers(headers -> headers.setBearerAuth(getAuthToken()))
                .retrieve()
                .onStatus(HttpStatus::is4xxClientError, response -> {
                    if (response.statusCode() == HttpStatus.NOT_FOUND) {
                        return Mono.error(new AccountNotFoundException("Account not found"));
                    }
                    return Mono.error(new InvalidRequestException("Invalid request"));
                })
                .bodyToMono(AccountBalance.class)
                .timeout(Duration.ofSeconds(5))
                .retry(2);
    }
    
    // Money transfer
    public Mono<TransferResponse> transferMoney(TransferRequest request) {
        return webClient.post()
                .uri("/transfers")
                .headers(headers -> {
                    headers.setBearerAuth(getAuthToken());
                    headers.set("Idempotency-Key", UUID.randomUUID().toString());
                })
                .body(Mono.just(request), TransferRequest.class)
                .retrieve()
                .bodyToMono(TransferResponse.class)
                .doOnSuccess(response -> 
                    System.out.println("âœ… Transfer completed: " + response.getTransactionId()))
                .doOnError(error -> 
                    System.err.println("âŒ Transfer failed: " + error.getMessage()));
    }
    
    // Get transaction history with pagination
    public Flux<Transaction> getTransactionHistory(String accountNumber, int page, int size) {
        return webClient.get()
                .uri(uriBuilder -> uriBuilder
                        .path("/accounts/{accountNumber}/transactions")
                        .queryParam("page", page)
                        .queryParam("size", size)
                        .queryParam("sort", "timestamp,desc")
                        .build(accountNumber))
                .retrieve()
                .bodyToFlux(Transaction.class)
                .take(size); // Limit results
    }
}
```

### E-commerce Integration ğŸ›’

```java
@Service
public class ProductService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private WebClient webClient;
    
    // Sync approach - RestTemplate
    public List<Product> getProductsCatalogSync(String category) {
        String url = "/products?category=" + category;
        
        try {
            ResponseEntity<Product[]> response = restTemplate.getForEntity(url, Product[].class);
            return Arrays.asList(response.getBody());
        } catch (Exception e) {
            System.err.println("Error fetching products: " + e.getMessage());
            return Collections.emptyList();
        }
    }
    
    // Async approach - WebClient
    public Flux<Product> getProductsCatalogAsync(String category) {
        return webClient.get()
                .uri("/products")
                .header("X-Category", category)
                .retrieve()
                .bodyToFlux(Product.class)
                .filter(product -> product.isAvailable())
                .map(this::enrichProductData)
                .doOnNext(product -> cacheProduct(product));
    }
    
    // Parallel processing for inventory check
    public Mono<InventoryReport> checkInventoryStatus(List<String> productIds) {
        return Flux.fromIterable(productIds)
                .flatMap(productId -> 
                    webClient.get()
                        .uri("/inventory/{productId}", productId)
                        .retrieve()
                        .bodyToMono(InventoryItem.class), 
                    5) // Process 5 products concurrently
                .collectList()
                .map(this::generateInventoryReport);
    }
}
```

---

## 6. Comparison Tables ğŸ“Š

### Feature Comparison

| Feature | RestTemplate ğŸ”„ | WebClient âš¡ | Winner |
|---------|----------------|--------------|---------|
| **Performance** | Blocking, slower | Non-blocking, faster | WebClient ğŸ† |
| **Memory Usage** | Higher (thread per request) | Lower (event loop) | WebClient ğŸ† |
| **Learning Curve** | Easy, familiar | Steeper (reactive concepts) | RestTemplate ğŸ† |
| **Error Handling** | Try-catch blocks | Reactive error operators | WebClient ğŸ† |
| **Testing** | Simple unit tests | Need reactive testing | RestTemplate ğŸ† |
| **Spring Boot Integration** | Built-in support | Built-in support | Tie ğŸ¤ |
| **HTTP/2 Support** | Limited | Full support | WebClient ğŸ† |
| **Streaming** | Not suitable | Excellent | WebClient ğŸ† |
| **Legacy Code Integration** | Perfect fit | Needs adaptation | RestTemplate ğŸ† |
| **Future Support** | Deprecated in Spring 6 | Active development | WebClient ğŸ† |

### Performance Metrics ğŸ“ˆ

| Metric | RestTemplate | WebClient | Improvement |
|--------|--------------|-----------|-------------|
| **Concurrent Requests (1000)** | 45 seconds | 12 seconds | **73% faster** |
| **Memory Usage** | 512 MB | 128 MB | **75% less** |
| **Thread Count** | 200 threads | 10 threads | **95% reduction** |
| **Response Time (avg)** | 890ms | 320ms | **64% faster** |

### When to Use What? ğŸ¤”

| Scenario | Use RestTemplate | Use WebClient |
|----------|------------------|---------------|
| **Simple CRUD operations** | âœ… Perfect | âš ï¸ Overkill |
| **High-traffic applications** | âŒ Not suitable | âœ… Excellent |
| **Legacy system integration** | âœ… Great choice | âŒ Complex |
| **Microservices communication** | âš ï¸ Okay | âœ… Recommended |
| **Real-time data streaming** | âŒ Can't handle | âœ… Built for this |
| **Team has reactive experience** | âŒ Not needed | âœ… Go for it |
| **Quick prototyping** | âœ… Fast setup | âŒ Takes time |
| **Production-ready applications** | âš ï¸ Consider alternatives | âœ… Future-proof |

---

## 7. Interview Questions ğŸ¤

### Basic Level Questions

**Q1: RestTemplate aur WebClient mein main difference kya hai?**
```java
// Answer with example
public class HttpClientExample {
    
    // RestTemplate - Synchronous
    public User getUserRestTemplate(Long id) {
        RestTemplate restTemplate = new RestTemplate();
        // Thread block ho jata hai yahan
        User user = restTemplate.getForObject("/users/" + id, User.class);
        System.out.println("Got user: " + user.getName());
        return user; // Response milne ke baad hi next line execute hoti hai
    }
    
    // WebClient - Asynchronous  
    public Mono<User> getUserWebClient(Long id) {
        WebClient webClient = WebClient.create();
        // Thread block nahi hota, immediately Mono return karta hai
        return webClient.get()
                .uri("/users/{id}", id)
                .retrieve()
                .bodyToMono(User.class)
                .doOnSuccess(user -> System.out.println("Got user: " + user.getName()));
    }
}
```

**Q2: Reactive programming kya hai aur kyon use karte hain?**
```java
// Traditional approach - Blocking
public List<String> processUsersBlocking() {
    List<User> users = fetchAllUsers();        // Wait for response
    List<String> names = new ArrayList<>();
    for (User user : users) {                  // Process one by one
        String processedName = processUser(user); // Each call blocks
        names.add(processedName);
    }
    return names; // Return after all processing done
}

// Reactive approach - Non-blocking
public Flux<String> processUsersReactive() {
    return fetchAllUsersReactive()              // Returns immediately
            .flatMap(this::processUserReactive)  // Parallel processing
            .collectList()                       // Collect results when ready
            .flatMapMany(Flux::fromIterable);   // Convert to Flux
}
```

### Intermediate Level Questions

**Q3: WebClient mein error handling kaise karte hain?**
```java
public Mono<User> getUserWithErrorHandling(Long id) {
    return webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            
            // Specific error handling
            .onStatus(HttpStatus::is4xxClientError, response -> {
                if (response.statusCode() == HttpStatus.NOT_FOUND) {
                    return Mono.error(new UserNotFoundException("User not found: " + id));
                }
                return Mono.error(new BadRequestException("Invalid request"));
            })
            
            .onStatus(HttpStatus::is5xxServerError, response -> 
                Mono.error(new ServiceUnavailableException("Server error")))
                
            .bodyToMono(User.class)
            
            // Additional error handling
            .doOnError(WebClientException.class, ex -> 
                log.error("WebClient error: {}", ex.getMessage()))
                
            .onErrorReturn(new User()); // Fallback value
}
```

**Q4: Timeout kaise configure karte hain dono mein?**
```java
// RestTemplate timeout
@Bean
public RestTemplate restTemplate() {
    RestTemplate template = new RestTemplate();
    
    HttpComponentsClientHttpRequestFactory factory = 
        new HttpComponentsClientHttpRequestFactory();
    
    factory.setConnectTimeout(5000);    // Connection timeout
    factory.setReadTimeout(10000);      // Read timeout
    
    template.setRequestFactory(factory);
    return template;
}

// WebClient timeout
@Bean  
public WebClient webClient() {
    HttpClient httpClient = HttpClient.create()
            .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000)     // Connection timeout
            .responseTimeout(Duration.ofSeconds(10));               // Response timeout
            
    return WebClient.builder()
            .clientConnector(new ReactorClientHttpConnector(httpClient))
            .build();
}

// Per-request timeout in WebClient
public Mono<User> getUserWithTimeout(Long id) {
    return webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            .bodyToMono(User.class)
            .timeout(Duration.ofSeconds(5));  // This request ka timeout
}
```

### Advanced Level Questions

**Q5: BackPressure handling kaise karte hain WebClient mein?**
```java
public class BackPressureExample {
    
    // Problem: Fast producer, slow consumer
    public Flux<ProcessedData> handleBackPressure() {
        return webClient.get()
                .uri("/large-dataset")
                .retrieve()
                .bodyToFlux(RawData.class)
                
                // BackPressure strategies
                .onBackpressureBuffer(1000)        // Buffer up to 1000 items
                .onBackpressureDrop()               // Drop excess items
                .onBackpressureLatest()             // Keep only latest
                
                // Controlled processing
                .limitRate(10)                      // Process max 10 items at a time
                .delayElements(Duration.ofMillis(100)) // Add delay
                
                .map(this::processData)             // Transform data
                .doOnNext(data -> log.info("Processed: {}", data.getId()));
    }
    
    // Custom backpressure handling
    public Flux<String> customBackPressureHandling() {
        return Flux.create(sink -> {
            // Custom emission logic
            AtomicLong requested = new AtomicLong();
            
            sink.onRequest(n -> {
                long currentRequested = requested.addAndGet(n);
                // Emit only requested amount
                for (int i = 0; i < currentRequested && !sink.isCancelled(); i++) {
                    sink.next("Data-" + i);
                }
            });
            
        }, FluxSink.OverflowStrategy.BUFFER);
    }
}
```

**Q6: Parallel processing kaise implement karte hain?**
```java
public class ParallelProcessingExample {
    
    // Sequential processing (slow)
    public Mono<List<UserDetails>> processUsersSequential(List<Long> userIds) {
        return Flux.fromIterable(userIds)
                .concatMap(this::fetchUserDetails)  // One after another
                .collectList();
    }
    
    // Parallel processing (fast)
    public Mono<List<UserDetails>> processUsersParallel(List<Long> userIds) {
        return Flux.fromIterable(userIds)
                .flatMap(this::fetchUserDetails, 5)  // Max 5 concurrent calls
                .collectList();
    }
    
    // Advanced parallel with custom scheduler
    public Mono<List<UserDetails>> processUsersAdvancedParallel(List<Long> userIds) {
        return Flux.fromIterable(userIds)
                .parallel(4)                        // Create 4 rails
                .runOn(Schedulers.parallel())       // Run on parallel scheduler
                .flatMap(this::fetchUserDetails)    // Process on each rail
                .sequential()                       // Merge back to single Flux
                .collectList();
    }
    
    private Mono<UserDetails> fetchUserDetails(Long userId) {
        return webClient.get()
                .uri("/users/{id}/details", userId)
                .retrieve()
                .bodyToMono(UserDetails.class)
                .doOnSuccess(details -> 
                    log.info("Processed user {} on thread: {}", 
                            userId, Thread.currentThread().getName()));
    }
}
```

---

## 8. Common Mistakes ğŸš«

### Mistake #1: RestTemplate mein timeout nahi lagana
```java
// âŒ Wrong - No timeout configuration
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate(); 
    // Default timeout bahut zyada hai, application hang ho sakti hai
}

// âœ… Correct - Proper timeout
@Bean  
public RestTemplate restTemplate() {
    RestTemplate template = new RestTemplate();
    HttpComponentsClientHttpRequestFactory factory = 
        new HttpComponentsClientHttpRequestFactory();
    factory.setConnectTimeout(5000);
    factory.setReadTimeout(10000);
    template.setRequestFactory(factory);
    return template;
}

// Error Message you might see:
// java.net.SocketTimeoutException: Read timed out
```

### Mistake #2: WebClient ko sync way mein use karna
```java
// âŒ Wrong - Blocking the reactive chain
public User getUserWrong(Long id) {
    Mono<User> userMono = webClient.get()
            .uri("/users/{id}", id)
            .retrieve()
            .bodyToMono(User.class);
            
    return userMono.block(); // Don't do this! Blocks the thread
}

// âœ… Correct - Keep it reactive
public Mono<User> getUserCorrect(Long id) {
    return webClient.get()
            .
