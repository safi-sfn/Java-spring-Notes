# üöÄ Spring MVC Annotations - Complete Study Guide 

*Bhai, Spring MVC ke saath web development karne ka proper tarika!* üî•

---

## üìö Introduction - Confusion Clear Karte Hain!

### Simple Explanation First üéØ
Yaar, **Spring MVC Annotations** basically aise special tags hain jo humein apne Java code mein lagane padte hain. Ye tags Spring framework ko batate hain ki - *"Bhai ye method kya kaam karega, kahan se request aayegi, kya response bhejni hai"* etc.

### Real-life Analogy üè†
Samjho ki tum ek restaurant ke manager ho:
- **@Controller** = Main waiter jo orders handle karta hai
- **@RequestMapping** = Menu card jo batata hai ki kya dish available hai
- **@PathVariable** = Customer ka special request ("Table number 5 ke liye")
- **@RequestParam** = Extra requirements ("Extra spicy chahiye")
- **@ResponseBody** = Final dish jo customer ko serve karte hain

### Technical Definition üéì
Spring MVC annotations provide an annotation-based programming model where @Controller and @RestController components use annotations to express request mappings, request input, exception handling, and more.

---

## üîë Key Terms/Concepts

| Term | Purpose |
|------|---------|
| **Annotation**  | Code ko metadata dene ke liye |
| **Handler** | Request handle karne wala method |
| **Mapping** | URL ko method se connect karna |
| **REST** | RESTful web services banane ke liye |
| **Dispatcher** | Requests ko sahi controller tak pahunchane wala |

---

## üéØ Top Spring MVC Annotations - Detailed Examples

### 1. @Controller üëë

**Kya hai ye bhai?**
@Controller annotation designates a Controller class in a Spring Web application, matlab ye batata hai ki ye class web requests handle karegi.

**Complete Working Example:**

```java
package com.example.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

@Controller  // ‚úÖ Ye batata hai ki main ek controller hun
@RequestMapping("/student")  // Base URL for all methods
public class StudentController {
    
    @RequestMapping(value = "/list", method = RequestMethod.GET)
    public String getStudentList(Model model) {
        // Business logic yahan likhoge
        model.addAttribute("message", "Students ki list yahan hai!");
        return "student-list";  // JSP page ka naam
    }
    
    @RequestMapping(value = "/add", method = RequestMethod.POST)  
    public String addStudent(Model model) {
        // Student add karne ka logic
        model.addAttribute("success", "Student successfully add ho gaya!");
        return "success-page";
    }
}
```

**Expected Output:**
- URL: `http://localhost:8080/student/list` ‚Üí student-list.jsp page load hoga
- URL: `http://localhost:8080/student/add` (POST request) ‚Üí success-page.jsp load hoga

---

### 2. @RestController üî•

**Kya fark hai @Controller se?**
@RestController annotation is a specialization of the Controller annotation that combines the behaviour of the @Controller and @ResponseBody annotations

**Complete REST API Example:**

```java
package com.example.api;

import org.springframework.web.bind.annotation.*;
import java.util.*;

@RestController  // ‚úÖ REST API banane ke liye
@RequestMapping("/api/users")
public class UserRestController {
    
    private List<User> users = new ArrayList<>();
    
    // GET request - All users
    @GetMapping
    public List<User> getAllUsers() {
        return users;  // Directly JSON return hoga, JSP nahi!
    }
    
    // GET request with ID
    @GetMapping("/{id}")
    public User getUserById(@PathVariable Long id) {
        return users.stream()
                .filter(user -> user.getId().equals(id))
                .findFirst()
                .orElse(null);
    }
    
    // POST request - Create user
    @PostMapping
    public User createUser(@RequestBody User user) {
        users.add(user);
        return user;  // JSON response
    }
}

// User class
class User {
    private Long id;
    private String name;
    private String email;
    
    // Constructors, getters, setters
    public User() {}
    
    public User(Long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }
    
    // Getters and Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
}
```

**Expected JSON Response:**
```json
// GET /api/users
[
    {
        "id": 1,
        "name": "Rahul",
        "email": "rahul@example.com"
    },
    {
        "id": 2,
        "name": "Priya",
        "email": "priya@example.com"
    }
]
```

---

### 3. @RequestMapping üó∫Ô∏è

**Sab se important annotation hai ye!**
@RequestMapping annotation maps a method in a @Controller class to an appropriate HTTP method and specifies the URL that the method maps to

**Advanced Example with Multiple Mappings:**

```java
@Controller
@RequestMapping("/ecommerce")  // Class level mapping
public class EcommerceController {
    
    // Method level mapping - GET only
    @RequestMapping(
        value = {"/products", "/items"},  // Multiple URLs
        method = RequestMethod.GET,
        produces = "application/json"    // Response type
    )
    @ResponseBody
    public List<Product> getProducts() {
        return Arrays.asList(
            new Product(1L, "Laptop", 50000.0),
            new Product(2L, "Mobile", 25000.0)
        );
    }
    
    // POST mapping with specific content type
    @RequestMapping(
        value = "/orders",
        method = RequestMethod.POST,
        consumes = "application/json",   // Accept JSON only
        produces = "application/json"
    )
    @ResponseBody
    public Order createOrder(@RequestBody Order order) {
        // Order processing logic
        order.setStatus("CONFIRMED");
        return order;
    }
    
    // Multiple HTTP methods support
    @RequestMapping(
        value = "/status",
        method = {RequestMethod.GET, RequestMethod.POST}
    )
    @ResponseBody
    public String getStatus() {
        return "Service is running fine! ‚úÖ";
    }
}
```

---

### 4. Shortcut Mappings üöÄ

**GET/POST/PUT/DELETE ke liye alag alag annotations:**

```java
@RestController
@RequestMapping("/api/books")
public class BookController {
    
    private List<Book> books = new ArrayList<>();
    
    @GetMapping  // Same as @RequestMapping(method = GET)
    public List<Book> getAllBooks() {
        return books;
    }
    
    @GetMapping("/{id}")  // Path variable ke saath
    public Book getBookById(@PathVariable Long id) {
        return books.stream()
                .filter(b -> b.getId().equals(id))
                .findFirst()
                .orElse(null);
    }
    
    @PostMapping  // Create new book
    public Book addBook(@RequestBody Book book) {
        books.add(book);
        return book;
    }
    
    @PutMapping("/{id}")  // Update existing book
    public Book updateBook(@PathVariable Long id, @RequestBody Book book) {
        // Update logic yahan
        book.setId(id);
        return book;
    }
    
    @DeleteMapping("/{id}")  // Delete book
    public String deleteBook(@PathVariable Long id) {
        books.removeIf(b -> b.getId().equals(id));
        return "Book deleted successfully! üóëÔ∏è";
    }
}
```

---

### 5. @PathVariable üõ§Ô∏è

**URL mein se values extract karne ke liye:**

```java
@RestController
@RequestMapping("/api")
public class PathVariableController {
    
    // Single path variable
    @GetMapping("/users/{userId}")
    public String getUserProfile(@PathVariable Long userId) {
        return "User profile for ID: " + userId;
    }
    
    // Multiple path variables
    @GetMapping("/users/{userId}/posts/{postId}")
    public String getUserPost(
        @PathVariable Long userId,
        @PathVariable Long postId
    ) {
        return String.format("User %d ka post %d", userId, postId);
    }
    
    // Path variable with different name
    @GetMapping("/categories/{cat-id}")
    public String getCategory(@PathVariable("cat-id") Long categoryId) {
        return "Category ID: " + categoryId;
    }
    
    // Optional path variable
    @GetMapping({"/search", "/search/{query}"})
    public String search(@PathVariable(required = false) String query) {
        if (query == null) {
            return "Please provide search query!";
        }
        return "Searching for: " + query;
    }
}
```

**URL Examples:**
- `GET /api/users/123` ‚Üí "User profile for ID: 123"
- `GET /api/users/5/posts/10` ‚Üí "User 5 ka post 10"
- `GET /api/search/java` ‚Üí "Searching for: java"

---

### 6. @RequestParam üìù

**Query parameters handle karne ke liye:**

```java
@RestController
@RequestMapping("/api/search")
public class RequestParamController {
    
    // Basic request param
    @GetMapping("/products")
    public List<Product> searchProducts(@RequestParam String keyword) {
        // keyword required hai, nahi toh error aayega
        return productService.search(keyword);
    }
    
    // Optional parameter with default value
    @GetMapping("/books")
    public List<Book> getBooks(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(required = false) String category
    ) {
        // Logic for pagination and filtering
        return bookService.findBooks(page, size, category);
    }
    
    // Multiple parameters
    @GetMapping("/filter")
    public String filterData(
        @RequestParam String name,
        @RequestParam int age,
        @RequestParam(required = false) String city
    ) {
        return String.format("Filtering: name=%s, age=%d, city=%s", 
                           name, age, city != null ? city : "Not specified");
    }
    
    // Map se saare parameters ek saath
    @GetMapping("/dynamic")
    public String dynamicFilter(@RequestParam Map<String, String> allParams) {
        StringBuilder result = new StringBuilder("Parameters received:\n");
        allParams.forEach((key, value) -> 
            result.append(key).append(" = ").append(value).append("\n"));
        return result.toString();
    }
}
```

**URL Examples:**
- `GET /api/search/products?keyword=laptop` ‚úÖ
- `GET /api/search/books?page=1&size=5&category=fiction`
- `GET /api/search/filter?name=Raj&age=25&city=Mumbai`

---

### 7. @RequestBody & @ResponseBody üì¶

**JSON data handle karne ke liye:**

```java
@Controller
@RequestMapping("/api/auth")
public class AuthController {
    
    // @RequestBody - JSON se Java object banata hai
    @PostMapping("/login")
    @ResponseBody  // Response ko JSON mein convert karta hai
    public LoginResponse login(@RequestBody LoginRequest loginRequest) {
        // Validation
        if (loginRequest.getUsername() == null || loginRequest.getPassword() == null) {
            return new LoginResponse(false, "Username aur password required!");
        }
        
        // Authentication logic
        boolean isValid = authService.validate(
            loginRequest.getUsername(), 
            loginRequest.getPassword()
        );
        
        if (isValid) {
            String token = jwtService.generateToken(loginRequest.getUsername());
            return new LoginResponse(true, "Login successful!", token);
        } else {
            return new LoginResponse(false, "Invalid credentials!");
        }
    }
    
    // Registration endpoint
    @PostMapping("/register") 
    @ResponseBody
    public RegisterResponse register(@RequestBody User user) {
        try {
            userService.createUser(user);
            return new RegisterResponse(true, "User registered successfully!");
        } catch (Exception e) {
            return new RegisterResponse(false, "Registration failed: " + e.getMessage());
        }
    }
}

// Request/Response classes
class LoginRequest {
    private String username;
    private String password;
    
    // Constructors, getters, setters
    public LoginRequest() {}
    
    public String getUsername() { return username; }
    public void setUsername(String username) { this.username = username; }
    
    public String getPassword() { return password; }
    public void setPassword(String password) { this.password = password; }
}

class LoginResponse {
    private boolean success;
    private String message;
    private String token;
    
    public LoginResponse(boolean success, String message) {
        this.success = success;
        this.message = message;
    }
    
    public LoginResponse(boolean success, String message, String token) {
        this(success, message);
        this.token = token;
    }
    
    // Getters and setters
    public boolean isSuccess() { return success; }
    public void setSuccess(boolean success) { this.success = success; }
    
    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
    
    public String getToken() { return token; }
    public void setToken(String token) { this.token = token; }
}
```

**Example JSON Request:**
```json
POST /api/auth/login
{
    "username": "rahul123",
    "password": "mypassword"
}
```

**Expected JSON Response:**
```json
{
    "success": true,
    "message": "Login successful!",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

---

## ‚úÖ‚ùå Rules & Guidelines

### Rule 1: @Controller vs @RestController 
‚úÖ **Correct Usage:**
```java
// Web pages ke liye - JSP/Thymeleaf return karta hai
@Controller
public class WebController {
    @GetMapping("/home")
    public String home() {
        return "home";  // home.jsp or home.html
    }
}

// REST API ke liye - JSON/XML return karta hai  
@RestController
public class ApiController {
    @GetMapping("/api/data")
    public Data getData() {
        return new Data();  // Automatically JSON mein convert hoga
    }
}
```

‚ùå **Wrong:**
```java
@Controller  // REST API ke liye galat choice
public class WrongApiController {
    @GetMapping("/api/users")
    public User getUser() {  // Ye JSP dhundega, JSON nahi dega!
        return new User();
    }
}
```

### Rule 2: Path Variables Properly Define Karo
‚úÖ **Correct:**
```java
@GetMapping("/users/{userId}/orders/{orderId}")
public Order getOrder(
    @PathVariable Long userId,      // Type specify karo
    @PathVariable Long orderId
) {
    return orderService.findOrder(userId, orderId);
}
```

‚ùå **Wrong:**
```java
@GetMapping("/users/{id}/orders/{id}")  // Same variable name!
public Order getOrder(@PathVariable Long id) {  // Confusion hoga!
    // Kaunsa ID hai ye??
}
```

### Rule 3: Request Parameters Validation
‚úÖ **Correct:**
```java
@GetMapping("/search")
public List<Product> search(
    @RequestParam(required = false, defaultValue = "") String keyword,
    @RequestParam(required = false, defaultValue = "0") int page,
    @RequestParam(required = false, defaultValue = "10") int size
) {
    // Validation logic
    if (size > 100) size = 100;  // Limit check
    return productService.search(keyword, page, size);
}
```

‚ùå **Wrong:**
```java
@GetMapping("/search")
public List<Product> search(@RequestParam String keyword) {
    // Agar keyword nahi bheja toh error aayega!
    // 400 Bad Request: Required String parameter 'keyword' is not present
}
```

---

## üè¢ Real-world Applications

### 1. E-commerce Backend API üõí

```java
@RestController
@RequestMapping("/api/v1/ecommerce")
@CrossOrigin(origins = "http://localhost:3000")  // React frontend ke liye
public class EcommerceController {
    
    @Autowired
    private ProductService productService;
    
    @Autowired
    private OrderService orderService;
    
    // Product catalog
    @GetMapping("/products")
    public ResponseEntity<PagedResponse<Product>> getProducts(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "12") int size,
        @RequestParam(required = false) String category,
        @RequestParam(required = false) String brand,
        @RequestParam(defaultValue = "price") String sortBy
    ) {
        PagedResponse<Product> products = productService.getProducts(
            page, size, category, brand, sortBy
        );
        return ResponseEntity.ok(products);
    }
    
    // Product details
    @GetMapping("/products/{productId}")
    public ResponseEntity<Product> getProductDetails(@PathVariable Long productId) {
        Product product = productService.findById(productId);
        if (product != null) {
            return ResponseEntity.ok(product);
        }
        return ResponseEntity.notFound().build();
    }
    
    // Add to cart
    @PostMapping("/cart/add")
    public ResponseEntity<CartResponse> addToCart(@RequestBody CartItem item) {
        try {
            CartResponse response = cartService.addItem(item);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new CartResponse(false, e.getMessage()));
        }
    }
    
    // Place order
    @PostMapping("/orders")
    public ResponseEntity<OrderResponse> placeOrder(
        @RequestBody OrderRequest orderRequest,
        @RequestHeader("Authorization") String token
    ) {
        // JWT token validation
        String userId = jwtUtil.extractUserId(token);
        
        OrderResponse response = orderService.placeOrder(userId, orderRequest);
        return ResponseEntity.ok(response);
    }
}
```

### 2. Banking System API üè¶

```java
@RestController
@RequestMapping("/api/banking")
public class BankingController {
    
    @Autowired
    private AccountService accountService;
    
    // Account balance check
    @GetMapping("/accounts/{accountNumber}/balance")
    public ResponseEntity<BalanceResponse> checkBalance(
        @PathVariable String accountNumber,
        @RequestHeader("X-Customer-ID") String customerId
    ) {
        try {
            BigDecimal balance = accountService.getBalance(accountNumber, customerId);
            return ResponseEntity.ok(new BalanceResponse(balance, "SUCCESS"));
        } catch (Exception e) {
            return ResponseEntity.badRequest()
                .body(new BalanceResponse(null, e.getMessage()));
        }
    }
    
    // Money transfer
    @PostMapping("/transfer")
    public ResponseEntity<TransferResponse> transferMoney(
        @RequestBody TransferRequest request,
        @RequestParam(required = false) String remarks
    ) {
        // Validation
        if (request.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            return ResponseEntity.badRequest()
                .body(new TransferResponse("FAILED", "Invalid amount"));
        }
        
        // Transfer logic
        TransferResponse response = accountService.transfer(request, remarks);
        
        if ("SUCCESS".equals(response.getStatus())) {
            return ResponseEntity.ok(response);
        } else {
            return ResponseEntity.badRequest().body(response);
        }
    }
    
    // Transaction history
    @GetMapping("/accounts/{accountNumber}/transactions")
    public ResponseEntity<List<Transaction>> getTransactionHistory(
        @PathVariable String accountNumber,
        @RequestParam(required = false) @DateTimeFormat(pattern = "yyyy-MM-dd") Date fromDate,
        @RequestParam(required = false) @DateTimeFormat(pattern = "yyyy-MM-dd") Date toDate,
        @RequestParam(defaultValue = "10") int limit
    ) {
        List<Transaction> transactions = accountService.getTransactionHistory(
            accountNumber, fromDate, toDate, limit
        );
        return ResponseEntity.ok(transactions);
    }
}
```

---

## üìä Comparison Tables

### @Controller vs @RestController vs @Component

| Aspect | @Controller | @RestController | @Component |
|--------|-------------|-----------------|------------|
| **Purpose** | Web MVC controllers | REST API controllers | General Spring beans |
| **Return Type** | View names (String) | Direct objects (JSON/XML) | N/A |
| **@ResponseBody** | Manual addition required | Automatic | N/A |
| **Use Case** | Traditional web apps | REST APIs | Service/Utility classes |
| **Stereotype** | ‚úÖ Yes | ‚úÖ Yes | ‚úÖ Yes |

### HTTP Mapping Annotations Comparison

| Annotation | HTTP Method | Purpose | Example URL |
|------------|-------------|---------|-------------|
| `@GetMapping` | GET | Data retrieve | `/api/users` |
| `@PostMapping` | POST | Data create | `/api/users` |
| `@PutMapping` | PUT | Data update (full) | `/api/users/123` |
| `@PatchMapping` | PATCH | Data update (partial) | `/api/users/123` |
| `@DeleteMapping` | DELETE | Data delete | `/api/users/123` |

### Parameter Binding Comparison

| Annotation | Source | Example | Use Case |
|------------|--------|---------|----------|
| `@PathVariable` | URL path | `/users/{id}` | Resource identification |
| `@RequestParam` | Query string | `?name=value` | Filtering, pagination |
| `@RequestBody` | Request body | JSON/XML payload | Complex data |
| `@RequestHeader` | HTTP headers | `Authorization: Bearer token` | Authentication |

---

## üé§ Interview Questions & Answers

### Q1: @Controller aur @RestController mein kya difference hai?

**Answer:**
```java
// @Controller - Traditional MVC ke liye
@Controller
public class WebController {
    @GetMapping("/users")
    public String getUsers(Model model) {
        model.addAttribute("users", userService.getAllUsers());
        return "users";  // users.jsp return karega
    }
    
    @GetMapping("/api/users")
    @ResponseBody  // Manually add karna pada
    public List<User> getUsersJson() {
        return userService.getAllUsers();  // JSON return karega
    }
}

// @RestController - REST API ke liye optimized
@RestController
public class ApiController {
    @GetMapping("/api/users")
    public List<User> getUsers() {
        return userService.getAllUsers();  // Automatic JSON conversion
    }
    // @ResponseBody ki zarurat nahi!
}
```

**Key Points:**
- @RestController combines the behaviour of @Controller and @ResponseBody annotations
- @Controller JSP/Thymeleaf pages return karta hai
- @RestController direct JSON/XML response deta hai

### Q2: @PathVariable aur @RequestParam mein difference kya hai?

**Answer:**
```java
@RestController
public class DifferenceController {
    
    // @PathVariable - URL path mein embedded values
    @GetMapping("/users/{userId}/posts/{postId}")
    public Post getPost(
        @PathVariable Long userId,    // /users/123/posts/456
        @PathVariable Long postId
    ) {
        return postService.getPost(userId, postId);
    }
    
    // @RequestParam - Query parameters (?key=value)
    @GetMapping("/search")
    public List<User> searchUsers(
        @RequestParam String name,          // ?name=rahul
        @RequestParam(required = false) Integer age,  // &age=25
        @RequestParam(defaultValue = "0") int page    // &page=1
    ) {
        return userService.search(name, age, page);
    }
    
    // Combined usage
    @GetMapping("/users/{userId}/posts")
    public List<Post> getUserPosts(
        @PathVariable Long userId,                    // Path se user ID
        @RequestParam(defaultValue = "10") int limit, // Query param
        @RequestParam(required = false) String tag    // Optional filter
    ) {
        return postService.getUserPosts(userId, limit, tag);
    }
}
```

**URLs:**
- PathVariable: `GET /users/123/posts/456`
- RequestParam: `GET /search?name=rahul&age=25&page=0`
- Combined: `GET /users/123/posts?limit=5&tag=technology`

### Q3: @RequestMapping ka advanced usage kaise karte hain?

**Answer:**
```java
@Controller
@RequestMapping("/api/v1")  // Base path for all methods
public class AdvancedMappingController {
    
    // Multiple URLs map karna
    @RequestMapping(
        value = {"/products", "/items", "/catalog"},
        method = RequestMethod.GET,
        produces = {"application/json", "application/xml"}
    )
    @ResponseBody
    public List<Product> getProducts() {
        return productService.getAllProducts();
    }
    
    // Headers ke basis pe mapping
    @RequestMapping(
        value = "/data",
        method = RequestMethod.GET,
        headers = "X-API-Version=1"  // Header check
    )
    @ResponseBody
    public String getV1Data() {
        return "Version 1 data";
    }
    
    @RequestMapping(
        value = "/data", 
        method = RequestMethod.GET,
        headers = "X-API-Version=2"
    )
    @ResponseBody
    public String getV2Data() {
        return "Version 2 data";
    }
    
    // Content type ke basis pe
    @RequestMapping(
        value = "/upload",
        method = RequestMethod.POST,
        consumes = "multipart/form-data"  // File upload
    )
    @ResponseBody
    public String uploadFile(@RequestParam("file") MultipartFile file) {
        return "File uploaded: " + file.getOriginalFilename();
    }
    
    // Parameter conditions
    @RequestMapping(
        value = "/users",
        method = RequestMethod.GET,
        params = "type=admin"  // ?type=admin hona chahiye
    )
    @ResponseBody
    public List<User> getAdminUsers() {
        return userService.getAdminUsers();
    }
}
```

### Q4: Exception handling Spring MVC mein kaise karte hain?

**Answer:**
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUser(@PathVariable Long id) {
        try {
            User user = userService.findById(id);
            if (user != null) {
                return ResponseEntity.ok(user);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
}

// Global exception handler
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(UserNotFoundException e) {
        ErrorResponse error = new ErrorResponse("USER_NOT_FOUND", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
    
    @ExceptionHandler(ValidationException.class)
    public ResponseEntity<ErrorResponse> handleValidation(ValidationException e) {
        ErrorResponse error = new ErrorResponse("VALIDATION_ERROR", e.getMessage());
        return ResponseEntity.badRequest().body(error);
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception e) {
        ErrorResponse error = new ErrorResponse("INTERNAL_ERROR", "Something went wrong!");
        return ResponseEntity.internalServerError().body(error);
    }
}
```

---

## ‚ùå Common Mistakes - Inse Bacho!

### Mistake 1: @ResponseBody Bhool Jana

‚ùå **Wrong:**
```java
@Controller  // RestController nahi hai
public class ApiController {
    @GetMapping("/api/data")
    public Data getData() {  // @ResponseBody missing!
        return new Data();  // Ye JSP page dhundega
    }
}
```
**Error:** `java.lang.IllegalStateException: Name for argument of type [java.lang.Long] not specified, and parameter name information not available via reflection. Ensure that the compiler uses the '-parameters' flag.`

‚úÖ **Correct:**
```java
@GetMapping("/users/{userId}")
public User getUser(@PathVariable Long userId) {  // Same name
    return userService.findById(userId);
}

// Or specify the name explicitly:
@GetMapping("/users/{userId}")
public User getUser(@PathVariable("userId") Long id) {
    return userService.findById(id);
}
```

### Mistake 3: Required Parameters Ko Handle Nahi Karna

‚ùå **Wrong:**
```java
@GetMapping("/search")
public List<Product> search(@RequestParam String keyword) {
    // Agar keyword nahi bheja toh crash!
    return productService.search(keyword);
}
```
**Error:** `400 Bad Request: Required request parameter 'keyword' for method parameter type String is not present`

‚úÖ **Correct:**
```java
@GetMapping("/search")
public List<Product> search(
    @RequestParam(required = false, defaultValue = "") String keyword
) {
    if (keyword.trim().isEmpty()) {
        return Collections.emptyList();  // Empty list return karo
    }
    return productService.search(keyword);
}
```

### Mistake 4: JSON Request Body Ko Galat Handle Karna

‚ùå **Wrong:**
```java
@PostMapping("/users")
public User createUser(@RequestParam String name, @RequestParam String email) {
    // JSON request body ke liye ye galat approach hai!
    return userService.createUser(name, email);
}
```

‚úÖ **Correct:**
```java
@PostMapping("/users")
public User createUser(@RequestBody User user) {  // Complete object receive karo
    return userService.createUser(user);
}

// Request JSON:
// {
//     "name": "Rahul",
//     "email": "rahul@example.com"
// }
```

### Mistake 5: HTTP Status Codes Properly Set Nahi Karna

‚ùå **Wrong:**
```java
@PostMapping("/users")
public User createUser(@RequestBody User user) {
    User savedUser = userService.save(user);
    return savedUser;  // Always 200 OK return karega
}
```

‚úÖ **Correct:**
```java
@PostMapping("/users")
public ResponseEntity<User> createUser(@RequestBody User user) {
    try {
        User savedUser = userService.save(user);
        return ResponseEntity.status(HttpStatus.CREATED).body(savedUser);  // 201 Created
    } catch (ValidationException e) {
        return ResponseEntity.badRequest().build();  // 400 Bad Request
    } catch (Exception e) {
        return ResponseEntity.internalServerError().build();  // 500 Internal Error
    }
}
```

---

## üåü Best Practices

### 1. RESTful URL Design üéØ

```java
@RestController
@RequestMapping("/api/v1")
public class RESTfulController {
    
    // ‚úÖ Good RESTful URLs
    @GetMapping("/users")                    // GET all users
    @GetMapping("/users/{id}")              // GET specific user
    @PostMapping("/users")                  // CREATE new user
    @PutMapping("/users/{id}")             // UPDATE user (complete)
    @PatchMapping("/users/{id}")           // UPDATE user (partial)
    @DeleteMapping("/users/{id}")          // DELETE user
    
    // Nested resources
    @GetMapping("/users/{userId}/posts")              // GET user's posts
    @PostMapping("/users/{userId}/posts")             // CREATE post for user
    @GetMapping("/users/{userId}/posts/{postId}")     // GET specific post
    
    // ‚ùå Avoid these patterns:
    // @GetMapping("/getAllUsers")           // Verb in URL
    // @PostMapping("/createUser")           // Verb in URL  
    // @GetMapping("/user-details")          // Inconsistent naming
}
```

### 2. Proper Response Structure üìã

```java
@RestController
@RequestMapping("/api/v1")
public class ResponseStructureController {
    
    // Standard API response wrapper
    @GetMapping("/users")
    public ResponseEntity<ApiResponse<List<User>>> getUsers(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size
    ) {
        try {
            Page<User> userPage = userService.getUsers(page, size);
            
            ApiResponse<List<User>> response = ApiResponse.<List<User>>builder()
                .success(true)
                .message("Users retrieved successfully")
                .data(userPage.getContent())
                .pagination(new PaginationInfo(
                    userPage.getTotalElements(),
                    userPage.getTotalPages(),
                    page,
                    size
                ))
                .timestamp(LocalDateTime.now())
                .build();
                
            return ResponseEntity.ok(response);
            
        } catch (Exception e) {
            ApiResponse<List<User>> response = ApiResponse.<List<User>>builder()
                .success(false)
                .message("Failed to retrieve users: " + e.getMessage())
                .data(null)
                .timestamp(LocalDateTime.now())
                .build();
                
            return ResponseEntity.internalServerError().body(response);
        }
    }
    
    // Error response with proper status codes
    @PostMapping("/users")
    public ResponseEntity<ApiResponse<User>> createUser(@RequestBody @Valid CreateUserRequest request) {
        try {
            User createdUser = userService.createUser(request);
            
            ApiResponse<User> response = ApiResponse.<User>builder()
                .success(true)
                .message("User created successfully")
                .data(createdUser)
                .timestamp(LocalDateTime.now())
                .build();
                
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
            
        } catch (ValidationException e) {
            ApiResponse<User> response = ApiResponse.<User>builder()
                .success(false)
                .message("Validation failed")
                .errors(e.getErrors())
                .timestamp(LocalDateTime.now())
                .build();
                
            return ResponseEntity.badRequest().body(response);
            
        } catch (DuplicateUserException e) {
            ApiResponse<User> response = ApiResponse.<User>builder()
                .success(false)
                .message("User already exists")
                .timestamp(LocalDateTime.now())
                .build();
                
            return ResponseEntity.status(HttpStatus.CONFLICT).body(response);
        }
    }
}

// Standard API Response class
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
    private List<String> errors;
    private PaginationInfo pagination;
    private LocalDateTime timestamp;
}
```

### 3. Input Validation & Security üîí

```java
@RestController
@RequestMapping("/api/v1/secure")
@Validated
public class SecureController {
    
    // Input validation with Bean Validation
    @PostMapping("/users")
    public ResponseEntity<User> createUser(@RequestBody @Valid CreateUserRequest request) {
        // @Valid automatically validates the request object
        User user = userService.createUser(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(user);
    }
    
    // Path variable validation
    @GetMapping("/users/{id}")
    public ResponseEntity<User> getUser(
        @PathVariable @Min(1) Long id  // ID should be positive
    ) {
        User user = userService.findById(id);
        return ResponseEntity.ok(user);
    }
    
    // Request parameter validation
    @GetMapping("/users")
    public ResponseEntity<List<User>> getUsers(
        @RequestParam(defaultValue = "0") @Min(0) int page,
        @RequestParam(defaultValue = "10") @Min(1) @Max(100) int size,
        @RequestParam(required = false) @Email String email
    ) {
        List<User> users = userService.getUsers(page, size, email);
        return ResponseEntity.ok(users);
    }
    
    // JWT Token validation
    @PostMapping("/protected-resource")
    public ResponseEntity<String> protectedEndpoint(
        @RequestHeader("Authorization") String authHeader
    ) {
        // Extract and validate JWT token
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body("Missing or invalid Authorization header");
        }
        
        String token = authHeader.substring(7);
        
        try {
            String userId = jwtUtil.extractUserId(token);
            return ResponseEntity.ok("Access granted for user: " + userId);
        } catch (JwtException e) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                .body("Invalid JWT token");
        }
    }
}

// Request DTO with validation annotations
@Data
@NoArgsConstructor
@AllArgsConstructor
public class CreateUserRequest {
    
    @NotBlank(message = "Name is required")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Please provide a valid email address")
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    @Pattern(
        regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]",
        message = "Password must contain uppercase, lowercase, digit and special character"
    )
    private String password;
    
    @NotNull(message = "Age is required")
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 100, message = "Age must be less than 100")
    private Integer age;
    
    @Pattern(regexp = "^[+]?[0-9]{10,15}$", message = "Please provide a valid phone number")
    private String phone;
}
```

### 4. Proper Exception Handling üö®

```java
// Global Exception Handler
@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    // Validation errors
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Object>> handleValidationErrors(
        MethodArgumentNotValidException ex
    ) {
        List<String> errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(error -> error.getField() + ": " + error.getDefaultMessage())
            .collect(Collectors.toList());
            
        ApiResponse<Object> response = ApiResponse.builder()
            .success(false)
            .message("Validation failed")
            .errors(errors)
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.badRequest().body(response);
    }
    
    // Path variable validation errors
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ApiResponse<Object>> handleConstraintViolation(
        ConstraintViolationException ex
    ) {
        List<String> errors = ex.getConstraintViolations()
            .stream()
            .map(violation -> violation.getPropertyPath() + ": " + violation.getMessage())
            .collect(Collectors.toList());
            
        ApiResponse<Object> response = ApiResponse.builder()
            .success(false)
            .message("Invalid request parameters")
            .errors(errors)
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.badRequest().body(response);
    }
    
    // Resource not found
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiResponse<Object>> handleResourceNotFound(
        ResourceNotFoundException ex
    ) {
        ApiResponse<Object> response = ApiResponse.builder()
            .success(false)
            .message(ex.getMessage())
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }
    
    // Duplicate resource
    @ExceptionHandler(DuplicateResourceException.class)
    public ResponseEntity<ApiResponse<Object>> handleDuplicateResource(
        DuplicateResourceException ex
    ) {
        ApiResponse<Object> response = ApiResponse.builder()
            .success(false)
            .message(ex.getMessage())
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.status(HttpStatus.CONFLICT).body(response);
    }
    
    // Generic exception
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Object>> handleGenericException(Exception ex) {
        log.error("Unexpected error occurred", ex);
        
        ApiResponse<Object> response = ApiResponse.builder()
            .success(false)
            .message("An unexpected error occurred. Please try again later.")
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.internalServerError().body(response);
    }
    
    // HTTP method not allowed
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ApiResponse<Object>> handleMethodNotAllowed(
        HttpRequestMethodNotSupportedException ex
    ) {
        ApiResponse<Object> response = ApiResponse.builder()
            .success(false)
            .message("HTTP method '" + ex.getMethod() + "' is not supported for this endpoint")
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(response);
    }
}
```

### 5. API Documentation with OpenAPI/Swagger üìñ

```java
@RestController
@RequestMapping("/api/v1/products")
@Tag(name = "Product Management", description = "APIs for managing products")
public class ProductController {
    
    @Operation(
        summary = "Get all products",
        description = "Retrieve a paginated list of products with optional filtering"
    )
    @ApiResponses(value = {
        @ApiResponse(
            responseCode = "200", 
            description = "Successfully retrieved products",
            content = @Content(
                mediaType = "application/json",
                schema = @Schema(implementation = ProductListResponse.class)
            )
        ),
        @ApiResponse(responseCode = "400", description = "Invalid request parameters"),
        @ApiResponse(responseCode = "500", description = "Internal server error")
    })
    @GetMapping
    public ResponseEntity<ApiResponse<List<Product>>> getAllProducts(
        @Parameter(description = "Page number (0-based)", example = "0")
        @RequestParam(defaultValue = "0") @Min(0) int page,
        
        @Parameter(description = "Page size (max 100)", example = "10")
        @RequestParam(defaultValue = "10") @Min(1) @Max(100) int size,
        
        @Parameter(description = "Filter by category", example = "electronics")
        @RequestParam(required = false) String category,
        
        @Parameter(description = "Minimum price filter", example = "100.0")
        @RequestParam(required = false) @DecimalMin("0.0") BigDecimal minPrice
    ) {
        // Implementation
        Page<Product> productPage = productService.getProducts(page, size, category, minPrice);
        
        ApiResponse<List<Product>> response = ApiResponse.<List<Product>>builder()
            .success(true)
            .message("Products retrieved successfully")
            .data(productPage.getContent())
            .pagination(PaginationInfo.from(productPage))
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.ok(response);
    }
    
    @Operation(
        summary = "Create a new product",
        description = "Add a new product to the catalog"
    )
    @ApiResponse(
        responseCode = "201",
        description = "Product created successfully",
        content = @Content(
            mediaType = "application/json",
            schema = @Schema(implementation = Product.class)
        )
    )
    @PostMapping
    public ResponseEntity<ApiResponse<Product>> createProduct(
        @Parameter(description = "Product details", required = true)
        @RequestBody @Valid CreateProductRequest request
    ) {
        Product product = productService.createProduct(request);
        
        ApiResponse<Product> response = ApiResponse.<Product>builder()
            .success(true)
            .message("Product created successfully")
            .data(product)
            .timestamp(LocalDateTime.now())
            .build();
            
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
}

@Schema(description = "Product creation request")
@Data
public class CreateProductRequest {
    
    @Schema(description = "Product name", example = "iPhone 15 Pro", required = true)
    @NotBlank(message = "Product name is required")
    @Size(min = 1, max = 255)
    private String name;
    
    @Schema(description = "Product description", example = "Latest iPhone with advanced camera")
    @Size(max = 1000)
    private String description;
    
    @Schema(description = "Product price", example = "999.99", required = true)
    @NotNull(message = "Price is required")
    @DecimalMin(value = "0.0", inclusive = false, message = "Price must be positive")
    private BigDecimal price;
    
    @Schema(description = "Product category", example = "smartphones", required = true)
    @NotBlank(message = "Category is required")
    private String category;
}
```

---

## üìù Summary/Quick Recap

### üéØ Key Takeaways - Yaad Rakhne Ke Points

1. **@Controller vs @RestController** 
   - @Controller ‚Üí JSP/HTML pages return karta hai
   - @RestController ‚Üí Direct JSON/XML response deta hai

2. **URL Mapping Hierarchy**
   ```java
   @RequestMapping("/api")     // Class level - sabke liye common
   @GetMapping("/users")       // Method level - specific endpoint
   // Final URL: /api/users
   ```

3. **Parameter Types** üìä
   - `@PathVariable` ‚Üí URL mein embedded (`/users/{id}`)
   - `@RequestParam` ‚Üí Query parameters (`?name=value`)
   - `@RequestBody` ‚Üí JSON/XML payload
   - `@RequestHeader` ‚Üí HTTP headers

4. **HTTP Methods Ki Mapping** üåê
   - `@GetMapping` ‚Üí Data retrieve
   - `@PostMapping` ‚Üí Data create  
   - `@PutMapping` ‚Üí Complete update
   - `@PatchMapping` ‚Üí Partial update
   - `@DeleteMapping` ‚Üí Data delete

### üß† Memory Tricks

**CRUD Operations Yaad Karne Ka Mantra:**
- **C**reate ‚Üí **P**OST 
- **R**ead ‚Üí **G**ET
- **U**pdate ‚Üí **P**UT/PATCH
- **D**elete ‚Üí **DELETE**

**URL Design Rule:**
- Nouns use karo, verbs nahi! 
- ‚úÖ `/api/users` 
- ‚ùå `/api/getUsers`

**Response Status Codes:**
- 2xx ‚Üí Success family
- 4xx ‚Üí Client error family  
- 5xx ‚Üí Server error family

### ‚ö° When to Use What?

| Scenario | Use This | Why? |
|----------|----------|------|
| Building REST API | `@RestController` | Automatic JSON conversion |
| Traditional web app | `@Controller` | JSP/Thymeleaf pages |
| Resource identification | `@PathVariable` | Clean URLs |
| Optional parameters | `@RequestParam` | Flexibility |
| Complex data | `@RequestBody` | Object mapping |
| Authentication | `@RequestHeader` | Token validation |

### üî• Pro Tips

1. **Always use ResponseEntity** for proper HTTP status codes
2. **Implement global exception handling** with @ControllerAdvice  
3. **Validate input data** with @Valid and Bean Validation
4. **Follow RESTful URL patterns** for consistency
5. **Use proper HTTP status codes** - don't always return 200!
6. **Document your APIs** with OpenAPI/Swagger annotations

### üéØ Interview Ready Points

**Must Know:**
- @Controller vs @RestController difference
- @PathVariable vs @RequestParam usage
- @RequestMapping advanced features (headers, params, consumes, produces)
- Exception handling patterns
- RESTful API design principles
- HTTP status codes significance

**Bonus Points:**
- CORS handling with @CrossOrigin
- Content negotiation (JSON/XML)
- API versioning strategies
- Security best practices
- Performance optimization tips

---

## üöÄ Next Steps

1. **Practice karo yaar!** - Examples ko run karo
2. **Real project banao** - E-commerce ya Banking API
3. **Spring Boot ke saath integrate karo**
4. **Security add karo** - JWT authentication
5. **Testing likhna seekho** - MockMvc use karo
6. **Database integration** - JPA/Hibernate ke saath
7. **Microservices architecture** explore karo

**Happy Coding! üéâ**

*Remember: Practice makes perfect, lekin smart practice makes you Spring MVC expert!* üòé `Could not resolve view with name 'Data'`

‚úÖ **Correct:**
```java
@Controller
public class ApiController {
    @GetMapping("/api/data")
    @ResponseBody  // Ye lagana zaroori hai
    public Data getData() {
        return new Data();  // Ab JSON return karega
    }
}

// Better approach:
@RestController  // Automatic @ResponseBody
public class ApiController {
    @GetMapping("/api/data")
    public Data getData() {
        return new Data();
    }
}
```

### Mistake 2: Path Variable Name Mismatch

‚ùå **Wrong:**
```java
@GetMapping("/users/{userId}")
public User getUser(@PathVariable Long id) {  // Variable name different!
    return userService.findById(id);
}
```
**Error:**
