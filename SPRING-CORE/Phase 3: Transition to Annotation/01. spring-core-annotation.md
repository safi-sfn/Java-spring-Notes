# üå∏ Spring Core Annotations - Complete Study Notes üöÄ

---

## üéØ Introduction - Confusion Clear Karte Hain Pehle! 

### Simple Words Mein... ü§î
Bhai, **Spring Annotations** matlab simple tags hain jo humein XML configuration se bachate hain! Pehle XML files mein sab kuch likhna padta tha, ab bas annotations use kar ke beans create kar sakte hain! 

### Real-Life Analogy üè†
Socho yaar, tumhara ghar hai aur tum chahte ho ki electrician automatically pata kar le ki kahan light lagani hai, kahan fan lagana hai. Annotations exactly yahi kaam karte hain - Spring framework ko batate hain ki kya karna hai, kahan karna hai!

### Technical Definition üìö
Spring Framework started using annotations from release 2.5 and these provide huge capabilities in configuring Spring behaviors. Annotations provide context in their declaration and help us avoid complex XML configurations.

---

## üîë Key Terms/Concepts

| Term | Hindi Meaning | What it Does |
|------|---------------|--------------|
| **@Component** | ‡§ò‡§ü‡§ï | Class ko Spring bean banata hai |
| **@Autowired** | ‡§∏‡•ç‡§µ‡§ö‡§æ‡§≤‡§ø‡§§ | Dependencies inject karta hai |
| **@Configuration** | ‡§ï‡•â‡§®‡•ç‡§´‡§º‡§ø‡§ó‡§∞‡•á‡§∂‡§® | Java-based configuration class |
| **@Bean** | ‡§¨‡•Ä‡§® | Method se bean create karta hai |
| **@Qualifier** | ‡§Ø‡•ã‡§ó‡•ç‡§Ø‡§§‡§æ ‡§®‡§ø‡§∞‡•ç‡§ß‡§æ‡§∞‡§ï | Specific bean choose karne ke liye |
| **@Value** | ‡§Æ‡•Ç‡§≤‡•ç‡§Ø | Properties file se values inject karta hai |

---

## üìù Detailed Examples with Complete Code

### 1. @Component - The Basic Building Block üß±

```java
// ‚úÖ Correct Way - Component Annotation
@Component
public class Employee {
    private String name;
    private int id;
    
    // Constructor
    public Employee() {
        System.out.println("Employee bean created!");
    }
    
    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
}

// Main Application Class
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        Employee emp = context.getBean(Employee.class);
        emp.setName("Rahul Sharma");
        System.out.println("Employee name: " + emp.getName());
    }
}
```

**Expected Output:**
```
Employee bean created!
Employee name: Rahul Sharma
```

### 2. @Autowired - Dependency Injection Master üíâ

```java
// Address Class
@Component
public class Address {
    private String city = "Mumbai";
    private String pincode = "400001";
    
    public String getCity() { return city; }
    public String getPincode() { return pincode; }
    
    @Override
    public String toString() {
        return "Address{city='" + city + "', pincode='" + pincode + "'}";
    }
}

// Employee Class with Field Injection
@Component
public class Employee {
    @Autowired  // Field injection - simple but not recommended
    private Address address;
    
    private String name;
    
    public void displayInfo() {
        System.out.println("Employee: " + name);
        System.out.println("Address: " + address);
    }
    
    // Getters and Setters
    public void setName(String name) { this.name = name; }
}

// Constructor Injection (Recommended approach)
@Component
public class Manager {
    private final Address address;  // final keyword for immutability
    
    @Autowired  // Constructor injection - best practice
    public Manager(Address address) {
        this.address = address;
        System.out.println("Manager created with address injection");
    }
    
    public void showDetails() {
        System.out.println("Manager Address: " + address);
    }
}

// Setter Injection
@Component
public class Developer {
    private Address address;
    
    @Autowired  // Setter injection
    public void setAddress(Address address) {
        this.address = address;
        System.out.println("Address injected via setter");
    }
    
    public Address getAddress() { return address; }
}
```

### 3. @Qualifier - Confusion Hatane Wala üéØ

```java
// Interface
public interface DatabaseService {
    void connect();
}

// MySQL Implementation
@Component("mysqlService")  // Custom bean name
public class MySQLService implements DatabaseService {
    @Override
    public void connect() {
        System.out.println("Connecting to MySQL Database...");
    }
}

// PostgreSQL Implementation
@Component("postgresService")
public class PostgreSQLService implements DatabaseService {
    @Override
    public void connect() {
        System.out.println("Connecting to PostgreSQL Database...");
    }
}

// Service Class using Qualifier
@Component
public class DataProcessor {
    
    @Autowired
    @Qualifier("mysqlService")  // Specific implementation choose kiya
    private DatabaseService primaryDB;
    
    @Autowired
    @Qualifier("postgresService")
    private DatabaseService secondaryDB;
    
    public void processData() {
        System.out.println("Processing with primary DB:");
        primaryDB.connect();
        
        System.out.println("Backup with secondary DB:");
        secondaryDB.connect();
    }
}
```

### 4. @Configuration + @Bean - Java-based Config üèóÔ∏è

```java
// Configuration Class
@Configuration
@ComponentScan(basePackages = "com.example")
public class AppConfig {
    
    @Bean
    public Employee getEmployee() {
        Employee emp = new Employee();
        emp.setName("Java Developer");
        emp.setSalary(75000);
        return emp;
    }
    
    @Bean
    public Address getAddress() {
        Address addr = new Address();
        addr.setCity("Bangalore");
        addr.setPincode("560001");
        return addr;
    }
    
    @Bean
    public Company getCompany() {
        Company company = new Company();
        company.setName("TechCorp");
        company.setEmployee(getEmployee());  // Bean dependency
        company.setAddress(getAddress());
        return company;
    }
}

// Company Class
public class Company {
    private String name;
    private Employee employee;
    private Address address;
    
    // Getters and Setters
    public void setName(String name) { this.name = name; }
    public void setEmployee(Employee employee) { this.employee = employee; }
    public void setAddress(Address address) { this.address = address; }
    
    public void displayCompanyInfo() {
        System.out.println("Company: " + name);
        System.out.println("Employee: " + employee.getName());
        System.out.println("Location: " + address.getCity());
    }
}
```

### 5. @Value - Properties File Integration üìÅ

```java
// application.properties file content:
/*
app.name=Spring Learning App
app.version=1.0
database.url=jdbc:mysql://localhost:3306/mydb
database.username=admin
server.port=8080
*/

@Component
public class ApplicationProperties {
    
    @Value("${app.name}")  // Properties file se value
    private String applicationName;
    
    @Value("${app.version}")
    private String version;
    
    @Value("${database.url}")
    private String databaseUrl;
    
    @Value("${database.username}")
    private String dbUsername;
    
    @Value("${server.port:9090}")  // Default value if not found
    private int serverPort;
    
    @Value("#{10 + 5}")  // SpEL expression
    private int calculatedValue;
    
    public void displayProperties() {
        System.out.println("Application Name: " + applicationName);
        System.out.println("Version: " + version);
        System.out.println("Database URL: " + databaseUrl);
        System.out.println("DB Username: " + dbUsername);
        System.out.println("Server Port: " + serverPort);
        System.out.println("Calculated Value: " + calculatedValue);
    }
}
```

### 6. @Lazy - Lazy Loading Implementation üò¥

```java
@Component
@Lazy  // Lazy initialization
public class HeavyService {
    
    public HeavyService() {
        System.out.println("HeavyService created - This is expensive!");
        // Simulate heavy initialization
        try {
            Thread.sleep(2000);  // 2 seconds delay
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
    
    public void performTask() {
        System.out.println("Heavy task performed!");
    }
}

@Component
public class ServiceConsumer {
    
    @Autowired
    @Lazy  // Lazy injection
    private HeavyService heavyService;
    
    public void useService() {
        System.out.println("About to use heavy service...");
        heavyService.performTask();  // Created only when first used
    }
}
```

---

## üéØ Rules/Guidelines

### ‚úÖ DO's (Sahi Tarika)

1. **‚úÖ Constructor Injection Use Karo**
```java
@Component
public class GoodPractice {
    private final Service service;
    
    @Autowired
    public GoodPractice(Service service) {
        this.service = service;  // Immutable and testable
    }
}
```

2. **‚úÖ @Qualifier Use Karo Multiple Implementations Ke Liye**
```java
@Autowired
@Qualifier("specificImplementation")
private MyService service;
```

3. **‚úÖ Meaningful Bean Names Do**
```java
@Component("userRepository")
public class UserRepositoryImpl { }
```

### ‚ùå DON'Ts (Galat Tarika)

1. **‚ùå Field Injection Avoid Karo**
```java
@Component
public class BadPractice {
    @Autowired
    private Service service;  // Testing mein problem hogi
}
```

2. **‚ùå Circular Dependencies Create Mat Karo**
```java
// This will cause error
@Component
public class ServiceA {
    @Autowired private ServiceB serviceB;
}

@Component  
public class ServiceB {
    @Autowired private ServiceA serviceA;  // Circular dependency!
}
```

**Error Message:**
```
BeanCurrentlyInCreationException: Error creating bean with name 'serviceA': 
Requested bean is currently in creation: Is there an unresolvable circular reference?
```

---

## üåç Real-world Applications

### Banking System Example üè¶

```java
// Account Interface
public interface Account {
    void deposit(double amount);
    void withdraw(double amount);
    double getBalance();
}

// Savings Account Implementation
@Component("savingsAccount")
public class SavingsAccount implements Account {
    private double balance = 0;
    private static final double MIN_BALANCE = 1000;
    
    @Override
    public void deposit(double amount) {
        balance += amount;
        System.out.println("Deposited ‚Çπ" + amount + " to Savings Account");
    }
    
    @Override
    public void withdraw(double amount) {
        if (balance - amount >= MIN_BALANCE) {
            balance -= amount;
            System.out.println("Withdrawn ‚Çπ" + amount + " from Savings Account");
        } else {
            System.out.println("Insufficient balance! Minimum ‚Çπ" + MIN_BALANCE + " required");
        }
    }
    
    @Override
    public double getBalance() { return balance; }
}

// Current Account Implementation
@Component("currentAccount")
public class CurrentAccount implements Account {
    private double balance = 0;
    
    @Override
    public void deposit(double amount) {
        balance += amount;
        System.out.println("Deposited ‚Çπ" + amount + " to Current Account");
    }
    
    @Override
    public void withdraw(double amount) {
        balance -= amount;  // No minimum balance restriction
        System.out.println("Withdrawn ‚Çπ" + amount + " from Current Account");
    }
    
    @Override
    public double getBalance() { return balance; }
}

// Bank Service
@Component
public class BankService {
    
    @Autowired
    @Qualifier("savingsAccount")
    private Account savingsAccount;
    
    @Autowired  
    @Qualifier("currentAccount")
    private Account currentAccount;
    
    @Value("${bank.name}")
    private String bankName;
    
    @Value("${bank.branch}")
    private String branchName;
    
    public void performBankingOperations() {
        System.out.println("=== " + bankName + " - " + branchName + " ===");
        
        // Savings Account Operations
        savingsAccount.deposit(5000);
        savingsAccount.withdraw(2000);
        System.out.println("Savings Balance: ‚Çπ" + savingsAccount.getBalance());
        
        // Current Account Operations  
        currentAccount.deposit(10000);
        currentAccount.withdraw(8000);
        System.out.println("Current Balance: ‚Çπ" + currentAccount.getBalance());
    }
}
```

### E-commerce System Example üõí

```java
@Component
public class ShoppingCart {
    private List<Product> items = new ArrayList<>();
    
    public void addItem(Product product) {
        items.add(product);
        System.out.println("Added: " + product.getName());
    }
    
    public double getTotalPrice() {
        return items.stream().mapToDouble(Product::getPrice).sum();
    }
    
    public List<Product> getItems() { return items; }
}

@Component  
public class PaymentService {
    
    @Value("${payment.gateway}")
    private String paymentGateway;
    
    public boolean processPayment(double amount) {
        System.out.println("Processing payment of ‚Çπ" + amount + " via " + paymentGateway);
        // Simulate payment processing
        return amount > 0;
    }
}

@Component
public class OrderService {
    
    @Autowired
    private ShoppingCart cart;
    
    @Autowired
    private PaymentService paymentService;
    
    public void placeOrder() {
        if (cart.getItems().isEmpty()) {
            System.out.println("Cart is empty!");
            return;
        }
        
        double total = cart.getTotalPrice();
        System.out.println("Order Total: ‚Çπ" + total);
        
        if (paymentService.processPayment(total)) {
            System.out.println("Order placed successfully!");
            System.out.println("Items ordered:");
            cart.getItems().forEach(item -> 
                System.out.println("- " + item.getName() + " (‚Çπ" + item.getPrice() + ")"));
        } else {
            System.out.println("Payment failed!");
        }
    }
}
```

---

## üìä Comparison Tables

### Injection Types Comparison

| Type | Pros ‚úÖ | Cons ‚ùå | Best For |
|------|---------|---------|----------|
| **Constructor** | Immutable, Required deps, Testable | Verbose for many deps | Production code |
| **Setter** | Optional deps, Flexible | Mutable, Complex testing | Configuration changes |
| **Field** | Clean code, Less boilerplate | Hard to test, Reflection-based | Prototypes only |

### Annotation Comparison

| Annotation | Purpose | Scope | Example Use Case |
|------------|---------|-------|------------------|
| `@Component` | Generic component | Class | Service classes |
| `@Service` | Business logic | Class | Business services |
| `@Repository` | Data access | Class | DAO classes |
| `@Controller` | Web controller | Class | REST controllers |
| `@Configuration` | Config class | Class | Bean configurations |
| `@Bean` | Bean factory method | Method | Third-party objects |

---

## üé§ Interview Questions

### Q1: @Component vs @Bean mein kya difference hai?

**Answer:**
```java
// @Component - Class level, automatic scanning
@Component
public class UserService {
    // Spring automatically creates bean
}

// @Bean - Method level, manual creation
@Configuration
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService(); // Manual bean creation
    }
}
```

**Key Points:**
- `@Component`: Class-level, automatic bean creation
- `@Bean`: Method-level, manual bean creation with custom logic
- `@Bean` gives more control over object creation

### Q2: Constructor vs Field Injection - Kya prefer karna chahiye?

**Answer:**
```java
// ‚úÖ Constructor Injection (Recommended)
@Component
public class OrderService {
    private final PaymentService paymentService;
    private final EmailService emailService;
    
    @Autowired
    public OrderService(PaymentService paymentService, EmailService emailService) {
        this.paymentService = paymentService;
        this.emailService = emailService;
    }
}

// ‚ùå Field Injection (Not recommended)
@Component
public class OrderService {
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private EmailService emailService;
}
```

**Why Constructor Injection?**
1. **Immutability**: `final` keyword use kar sakte hain
2. **Required Dependencies**: Constructor parameters ensure required deps
3. **Testing**: Easy to mock dependencies
4. **Circular Dependency Detection**: Compile time mein detect ho jaate hain

### Q3: @Qualifier ka use kab karte hain?

**Answer:**
```java
// Problem: Multiple implementations
public interface NotificationService {
    void sendNotification(String message);
}

@Component
public class EmailNotificationService implements NotificationService {
    public void sendNotification(String message) {
        System.out.println("Email: " + message);
    }
}

@Component  
public class SmsNotificationService implements NotificationService {
    public void sendNotification(String message) {
        System.out.println("SMS: " + message);
    }
}

// Solution: Use @Qualifier
@Component
public class UserRegistrationService {
    
    @Autowired
    @Qualifier("emailNotificationService")  // Specific implementation
    private NotificationService emailService;
    
    @Autowired
    @Qualifier("smsNotificationService")
    private NotificationService smsService;
    
    public void registerUser(String username) {
        emailService.sendNotification("Welcome " + username + "!");
        smsService.sendNotification("OTP: 123456");
    }
}
```

### Q4: @Value annotation mein ${} vs #{} kya difference hai?

**Answer:**
```java
@Component
public class ConfigExample {
    
    // ${} - Property placeholder (Properties file se value)
    @Value("${app.name}")
    private String appName;
    
    @Value("${server.port:8080}")  // Default value
    private int serverPort;
    
    // #{} - SpEL (Spring Expression Language)
    @Value("#{10 + 5}")  // Mathematical expression
    private int calculatedValue;
    
    @Value("#{T(java.lang.Math).PI}")  // Static method call
    private double piValue;
    
    @Value("#{systemProperties['user.home']}")  // System property
    private String userHome;
    
    @Value("#{someBean.someProperty}")  // Other bean property
    private String beanProperty;
}
```

**Key Differences:**
- `${}`: Properties file values, environment variables
- `#{}`: Expressions, calculations, method calls, other bean references

---

## üö´ Common Mistakes

### Mistake 1: Circular Dependencies 

```java
// ‚ùå Wrong - Circular dependency
@Component
public class ServiceA {
    @Autowired
    private ServiceB serviceB;
}

@Component
public class ServiceB {
    @Autowired  
    private ServiceA serviceA;  // This creates circular dependency!
}
```

**Error:**
```
BeanCurrentlyInCreationException: Error creating bean with name 'serviceA'
```

**‚úÖ Solution:**
```java
// Use @Lazy to break the cycle
@Component
public class ServiceA {
    @Autowired
    @Lazy
    private ServiceB serviceB;
}

// Or restructure your design
@Component
public class ServiceA {
    // Remove dependency on ServiceB
}

@Component
public class ServiceB {
    @Autowired
    private ServiceA serviceA;
}
```

### Mistake 2: Wrong Package Scanning

```java
// ‚ùå Wrong - Components not in scanned package
@Configuration
@ComponentScan(basePackages = "com.example.service")  // Only scanning service package
public class AppConfig {
    // But components are in com.example.repository
}
```

**‚úÖ Solution:**
```java
@Configuration
@ComponentScan(basePackages = {"com.example.service", "com.example.repository"})
// Or scan parent package
@ComponentScan(basePackages = "com.example")
public class AppConfig {
}
```

### Mistake 3: Missing @Configuration

```java
// ‚ùå Wrong - @Bean without @Configuration
public class AppConfig {  // Missing @Configuration
    @Bean
    public UserService userService() {
        return new UserService();
    }
}
```

**‚úÖ Solution:**
```java
@Configuration  // This is mandatory for @Bean methods
public class AppConfig {
    @Bean
    public UserService userService() {
        return new UserService();
    }
}
```

### Mistake 4: Field Injection in Testing

```java
// ‚ùå Problem with field injection - hard to test
@Component
public class UserService {
    @Autowired
    private UserRepository repository;  // Can't easily mock this
    
    public User findUser(Long id) {
        return repository.findById(id);
    }
}

// Test becomes difficult
@Test
public void testFindUser() {
    UserService service = new UserService();
    // How to inject mock repository? Reflection needed!
}
```

**‚úÖ Solution:**
```java
@Component
public class UserService {
    private final UserRepository repository;
    
    @Autowired
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
    
    public User findUser(Long id) {
        return repository.findById(id);
    }
}

// Easy testing
@Test
public void testFindUser() {
    UserRepository mockRepo = mock(UserRepository.class);
    UserService service = new UserService(mockRepo);  // Easy injection!
    
    when(mockRepo.findById(1L)).thenReturn(new User("John"));
    User user = service.findUser(1L);
    assertEquals("John", user.getName());
}
```

---

## üèÜ Best Practices

### 1. Prefer Constructor Injection üèóÔ∏è

```java
// ‚úÖ Best Practice
@Component
public class OrderService {
    private final PaymentService paymentService;
    private final InventoryService inventoryService;
    private final EmailService emailService;
    
    // Single constructor - @Autowired is optional in Spring 4.3+
    public OrderService(PaymentService paymentService, 
                       InventoryService inventoryService,
                       EmailService emailService) {
        this.paymentService = paymentService;
        this.inventoryService = inventoryService;  
        this.emailService = emailService;
    }
}
```

### 2. Use Meaningful Bean Names üìù

```java
// ‚úÖ Good naming
@Component("userRegistrationService")
public class UserRegistrationService { }

@Component("mysqlUserRepository") 
public class MySQLUserRepository implements UserRepository { }

@Component("emailNotificationProvider")
public class EmailNotificationProvider implements NotificationProvider { }
```

### 3. Organize Configuration Properly üìÅ

```java
// ‚úÖ Separate configuration classes
@Configuration
@ComponentScan(basePackages = "com.example.service")
public class ServiceConfig {
    // Service-related beans
}

@Configuration  
@ComponentScan(basePackages = "com.example.repository")
public class RepositoryConfig {
    // Repository-related beans
}

@Configuration
@PropertySource("classpath:application.properties")
public class PropertyConfig {
    // Property-related beans
}
```

### 4. Use Profiles for Different Environments üåç

```java
@Configuration
@Profile("development")
public class DevConfig {
    
    @Bean
    @Primary
    public DataSource dataSource() {
        return new H2DataSource("mem:testdb");
    }
}

@Configuration
@Profile("production")  
public class ProdConfig {
    
    @Bean
    @Primary
    public DataSource dataSource() {
        return new MySQLDataSource("prod-database-url");
    }
}
```

### 5. Document Your Beans üìñ

```java
/**
 * Service responsible for handling user registration process.
 * Integrates with email service for welcome emails and 
 * user repository for data persistence.
 */
@Component
public class UserRegistrationService {
    
    /**
     * Registers a new user in the system.
     * @param userRequest User registration details
     * @return Registered user with generated ID
     * @throws UserAlreadyExistsException if email already registered
     */
    public User registerUser(UserRegistrationRequest userRequest) {
        // Implementation
    }
}
```

---

## üìù Summary/Quick Recap

### üéØ Key Takeaways

| Annotation | Yaad Rakhne Ka Mantra | When to Use |
|------------|----------------------|-------------|
| `@Component` | "Component = Spring Bean" | Generic classes |
| `@Autowired` | "Auto-wire = Auto-inject" | Dependency injection |
| `@Qualifier` | "Qualify = Specify exact bean" | Multiple implementations |
| `@Configuration` | "Config = Java-based setup" | Instead of XML |
| `@Bean` | "Bean = Object factory" | Third-party objects |
| `@Value` | "Value = Properties se value" | External configuration |
| `@Lazy` | "Lazy = Jab zaroorat ho tab banao" | Heavy/expensive objects |

### üß† Memory Tricks

1. **CAQC** = **C**omponent, **A**utowired, **Q**ualifier, **C**onfiguration (Core 4)
2. **BVL** = **B**ean, **V**alue, **L**azy (Configuration helpers)
3. **Constructor > Setter > Field** (Injection preference order)

### üé™ When to Use What?

```java
// Startup mein sab banao = @Component (default)
// Jab zaroori ho tab banao = @Component + @Lazy  
// Multiple choices hain = @Autowired + @Qualifier
// External library object = @Configuration + @Bean
// Properties file se value = @Value
// Custom object creation logic = @Bean method
```

### üöÄ Final Mantra

> **"Annotation se Configuration, XML se Liberation!"** 

Bhai, Spring annotations master kar liye toh XML configuration ki tension bye-bye! üéâ

Remember these golden rules:
- Constructor injection use karo
- Meaningful names do
- Testing ko dhyan mein rakho  
- Circular dependencies se bacho
- Properties file use karo hardcoding ke bajaye

**Ab jaao aur Spring mein annotations ka raja bano!** üëë

---

### üìö Practice Points:
1. Banking system with multiple account types banao
2. E-commerce cart with payment integration karo
3. User management system with different notification services
4. File upload service with multiple storage providers

**Happy Coding, Spring Warriors!** üå∏‚òï
