# ğŸŒ¸ Spring Framework - Properties File Injection Complete Guide ğŸ“

*Bhai, configuration ko flexible banane ka asaan tarika!* 

---

## ğŸ¤” Introduction - Confusion Clear Karte Hain!

### Simple Explanation First ğŸ’¡
Yaar, imagine karo tumhare paas ek website hai aur usme database ka URL hardcoded hai code mein. Kal ko agar database change karna pada toh? Code modify karke phir se build karna padega! ğŸ˜µ

**Properties file** ka matlab hai - Important values ko alag file mein rakhna taaki bina code touch kiye change kar sako!

### Real-Life Analogy ğŸ 
```
Tumhare ghar ka address = Properties file
Tumhara phone contact list = Spring application

Agar address change ho jaye toh sirf contact list update kar denge,
pura phone nahi change karenge! ğŸ“±
```

### Technical Definition ğŸ¯
**Properties File Injection** in Spring means storing configuration values (like database URLs, file paths, API keys) in external `.properties` files and injecting them into Spring beans using `@Value` annotation or XML configuration.

---

## ğŸ”‘ Key Terms/Concepts

| Term | Hindi Meaning | Technical Definition |
|------|---------------|---------------------|
| **Properties File** | properties file | External file storing key-value pairs |
| **@Value Annotation** | value annotation | Injects property values into fields |
| **Property Placeholder** | property placeholder | ${key} syntax to reference properties |
| **Environment** | environment | Spring's way to access properties |
| **@PropertySource** | @PropertySource | Specifies property file location |

### Visual Representation ğŸ¨
```
Properties File (config.properties)
        â†“
Spring Container reads
        â†“
Injects values using ${key}
        â†“
Your Bean gets configured! ğŸ‰
```

---

## ğŸ’» Detailed Examples

### Example 1: Basic Properties File Setup

**Step 1: Create Properties File** ğŸ“„
```properties
# application.properties
database.url=jdbc:mysql://localhost:3306/mydb
database.username=root
database.password=admin123
app.name=MySpringApp
app.version=1.0.0
```

**Step 2: Bean Class with @Value** â˜•
```java
package com.example.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class DatabaseConfig {
    
    @Value("${database.url}")
    private String dbUrl;
    
    @Value("${database.username}")
    private String username;
    
    @Value("${database.password}")
    private String password;
    
    @Value("${app.name:DefaultApp}")  // Default value if property missing
    private String appName;
    
    // Getters and toString
    public String getDbUrl() { return dbUrl; }
    public String getUsername() { return username; }
    public String getPassword() { return password; }
    public String getAppName() { return appName; }
    
    @Override
    public String toString() {
        return "DatabaseConfig{" +
                "dbUrl='" + dbUrl + '\'' +
                ", username='" + username + '\'' +
                ", appName='" + appName + '\'' +
                '}';
    }
}
```

**Step 3: Configuration Class** âš™ï¸
```java
package com.example.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.PropertySource;

@Configuration
@ComponentScan("com.example")
@PropertySource("classpath:application.properties")
public class AppConfig {
    // Spring automatically loads properties!
}
```

**Step 4: Main Application** ğŸš€
```java
package com.example;

import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import com.example.config.DatabaseConfig;
import com.example.config.AppConfig;

public class MainApp {
    public static void main(String[] args) {
        System.out.println("ğŸŒ¸ Spring Properties Demo Starting...");
        
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        
        DatabaseConfig dbConfig = context.getBean(DatabaseConfig.class);
        System.out.println("Database Config: " + dbConfig);
        
        ((AnnotationConfigApplicationContext) context).close();
    }
}
```

**Expected Output** ğŸ“¤
```
ğŸŒ¸ Spring Properties Demo Starting...
Database Config: DatabaseConfig{dbUrl='jdbc:mysql://localhost:3306/mydb', username='root', appName='MySpringApp'}
```

---

## ğŸ“‹ Rules/Guidelines

### Rule 1: Properties File Naming âœ…
âœ… **Correct**: `application.properties`, `config.properties`, `database.properties`
```properties
# Good naming
server.port=8080
logging.level=DEBUG
```

âŒ **Wrong**: Using spaces or special characters
```properties
# Wrong - avoid spaces and special chars
my app.port = 8080
server@port=8080
```

### Rule 2: Property Key Naming Convention âœ…
âœ… **Correct**: Use dot notation, lowercase
```properties
database.connection.timeout=5000
mail.smtp.host=smtp.gmail.com
app.security.jwt.secret=mySecretKey
```

âŒ **Wrong**: Mixed case, inconsistent naming
```properties
Database_URL=localhost
MAIL_HOST=gmail.com
app-Security-Token=secret
```

### Rule 3: @Value Usage âœ…
âœ… **Correct**: With default values and proper syntax
```java
@Value("${server.port:8080}")  // Default value 8080
private int serverPort;

@Value("${app.name:MyApp}")
private String applicationName;
```

âŒ **Wrong**: Without handling missing properties
```java
@Value("${server.port}")  // Will fail if property missing
private int serverPort;

@Value("server.port")  // Missing ${} syntax
private int serverPort;
```

**Error Example:**
```
Exception in thread "main" org.springframework.beans.factory.BeanCreationException: 
Error creating bean with name 'databaseConfig': 
Injection of autowired dependencies failed; 
Could not resolve placeholder 'server.port' in value "${server.port}"
```

---

## ğŸŒ Real-world Applications

### Banking Application Example ğŸ¦
```properties
# bank-config.properties
bank.name=State Bank of India
bank.branch.code=SBI001
interest.rate.savings=3.5
interest.rate.fixed=7.2
transaction.limit.daily=50000
notification.email=admin@sbi.com
```

```java
@Component
@PropertySource("classpath:bank-config.properties")
public class BankingService {
    
    @Value("${bank.name}")
    private String bankName;
    
    @Value("${interest.rate.savings}")
    private double savingsRate;
    
    @Value("${transaction.limit.daily}")
    private long dailyLimit;
    
    public String calculateInterest(double amount, String accountType) {
        double rate = accountType.equals("SAVINGS") ? savingsRate : 7.2;
        double interest = (amount * rate) / 100;
        return String.format("Bank: %s, Interest: â‚¹%.2f", bankName, interest);
    }
    
    public boolean isTransactionAllowed(long amount) {
        return amount <= dailyLimit;
    }
}
```

### E-Commerce Configuration ğŸ›’
```properties
# ecommerce.properties
payment.gateway.url=https://api.razorpay.com
payment.gateway.key=rzp_test_123456
shipping.free.threshold=499
tax.rate.gst=18
email.notification.enabled=true
sms.notification.enabled=false
```

---

## ğŸ“Š Comparison Tables

### Properties vs Hardcoding

| Aspect | Properties File âœ… | Hardcoding âŒ |
|--------|-------------------|---------------|
| **Flexibility** | High - No recompilation | Low - Need to rebuild |
| **Environment** | Different files for Dev/Prod | Same values everywhere |
| **Security** | Sensitive data external | Passwords in source code |
| **Maintenance** | Easy to modify | Need developer to change |
| **Deployment** | Change without rebuild | Requires new deployment |

### @Value vs Environment vs @ConfigurationProperties

| Feature | @Value | Environment | @ConfigurationProperties |
|---------|--------|-------------|------------------------|
| **Syntax** | `@Value("${key}")` | `env.getProperty("key")` | Class-based binding |
| **Type Safety** | Manual conversion | String only | Automatic conversion |
| **Validation** | Limited | None | Full JSR-303 support |
| **IDE Support** | Basic | None | Excellent autocomplete |
| **Best For** | Simple values | Programmatic access | Complex configurations |

---

## ğŸ¤ Interview Questions

### Q1: How do you inject values from properties file in Spring?
**Answer:**
```java
// Method 1: Using @Value annotation
@Value("${database.url}")
private String dbUrl;

// Method 2: Using Environment
@Autowired
private Environment env;

public void someMethod() {
    String dbUrl = env.getProperty("database.url");
}

// Method 3: Using @ConfigurationProperties
@ConfigurationProperties(prefix = "database")
public class DatabaseConfig {
    private String url;
    private String username;
    // getters and setters
}
```

### Q2: What happens if a property is not found?
**Answer:**
```java
// Without default - throws exception
@Value("${missing.property}")  // BeanCreationException

// With default value - works fine
@Value("${missing.property:defaultValue}")
private String property;

// Checking if property exists
@Value("${missing.property:#{null}}")
private String property;  // Will be null if not found
```

### Q3: How to load multiple properties files?
**Answer:**
```java
@Configuration
@PropertySource({
    "classpath:application.properties",
    "classpath:database.properties",
    "classpath:mail.properties"
})
public class AppConfig {
    // Configuration
}

// Or using PropertySourcesPlaceholderConfigurer
@Bean
public static PropertySourcesPlaceholderConfigurer propertyConfig() {
    PropertySourcesPlaceholderConfigurer configurer = new PropertySourcesPlaceholderConfigurer();
    configurer.setLocations(
        new ClassPathResource("app.properties"),
        new ClassPathResource("db.properties")
    );
    return configurer;
}
```

### Q4: Tricky Scenario - Profile-based properties
**Answer:**
```java
// application.properties (default)
app.environment=default
database.url=jdbc:h2:mem:testdb

// application-dev.properties
app.environment=development
database.url=jdbc:mysql://localhost:3306/devdb

// application-prod.properties  
app.environment=production
database.url=jdbc:mysql://prod-server:3306/proddb

// Activate profile
@ActiveProfiles("dev")  // In test
// Or JVM argument: -Dspring.profiles.active=prod
```

---

## âš ï¸ Common Mistakes

### Mistake 1: Typo in Property Names ğŸ”¤
```java
// Properties file
database.connection.url=jdbc:mysql://localhost:3306/mydb

// Wrong in Java class - typo!
@Value("${database.conection.url}")  // Missing 'n' in connection
private String dbUrl;  // Will throw exception!
```
**Fix:** Always double-check property names, use IDE autocomplete if available.

### Mistake 2: Missing PropertySource ğŸ“
```java
@Component
// Missing @PropertySource annotation!
public class MyConfig {
    @Value("${app.name}")  // Will fail!
    private String appName;
}

// Correct way:
@Component
@PropertySource("classpath:application.properties")
public class MyConfig {
    @Value("${app.name}")
    private String appName;
}
```

### Mistake 3: Wrong File Location ğŸ“
```java
@PropertySource("application.properties")  // Wrong! Missing classpath:
// Correct:
@PropertySource("classpath:application.properties")

// Or for file system:
@PropertySource("file:./config/app.properties")
```

### Mistake 4: Not Handling Null Values ğŸš«
```java
// Properties me ye key hi nahi hai
@Value("${non.existent.property}")  // Exception!
private String value;

// Safe approach:
@Value("${non.existent.property:default_value}")
private String value;

// Or nullable:
@Value("${non.existent.property:#{null}}")
private String value;  // Can be null
```

---

## âœ¨ Best Practices

### 1. Environment-specific Properties ğŸŒ
```
src/main/resources/
â”œâ”€â”€ application.properties          # Common properties
â”œâ”€â”€ application-dev.properties      # Development
â”œâ”€â”€ application-test.properties     # Testing  
â”œâ”€â”€ application-prod.properties     # Production
â””â”€â”€ application-local.properties    # Local development
```

### 2. Secure Sensitive Data ğŸ”
```properties
# Don't do this in properties file
database.password=admin123  # âŒ Plain text password

# Better approaches:
database.password=${DB_PASSWORD}  # Environment variable
database.password=${random.value}  # Spring generated
# Use encrypted properties with Jasypt
```

### 3. Documentation Comments ğŸ“
```properties
# Database Configuration
# Default connection pool size is 10
database.connection.pool.size=10

# Mail Configuration  
# SMTP server for sending notifications
mail.smtp.host=smtp.gmail.com
mail.smtp.port=587
```

### 4. Type-safe Configuration Classes ğŸ¯
```java
@ConfigurationProperties(prefix = "app.mail")
@Component
@Validated
public class MailProperties {
    
    @NotEmpty
    private String host;
    
    @Min(1) @Max(65535)
    private int port = 587;
    
    @Email
    private String from;
    
    private boolean ssl = true;
    
    // Getters and setters
}

// Usage
@Autowired
private MailProperties mailProperties;
```

### 5. Property Validation ğŸ”
```java
@Value("${server.port}")
@Min(value = 1024, message = "Port should be greater than 1024")
@Max(value = 65535, message = "Port should be less than 65536")
private int serverPort;

// Or in @ConfigurationProperties class
@ConfigurationProperties(prefix = "app")
@Validated
public class AppProperties {
    
    @NotBlank(message = "App name is required")
    private String name;
    
    @DecimalMin(value = "0.0", message = "Version should be positive")
    private Double version;
}
```

---

## ğŸ¯ Summary/Quick Recap

### Key Takeaways ğŸ§ 
1. **Properties files** = External configuration, no hardcoding! 
2. **@Value("${key}")** = Simple property injection
3. **@PropertySource** = Specify property file location
4. **Default values** = Always provide fallbacks
5. **Profile-based** = Different configs for different environments

### Memory Tricks ğŸ§©
- **${}** = **$** for **$**pring **{}** for **{}**ey 
- **@Value** = **V**ery **A**wesome **L**oading **U**tility **E**verywhere
- **Properties** = **P**owerful **R**eusable **O**utside **P**arameters **E**asily **R**eadable **T**ext **I**n **E**xternal **S**torage

### When to Use What ğŸ¤”

| Use Case | Best Approach |
|----------|---------------|
| **Simple values** | `@Value("${key}")` |
| **Complex objects** | `@ConfigurationProperties` |
| **Runtime access** | `Environment.getProperty()` |
| **Optional properties** | `@Value("${key:default}")` |
| **Multiple files** | Multiple `@PropertySource` |

---

## ğŸª Fun Extras

### ASCII Art ğŸ¨
```
    ğŸ“ Properties File
         |
         â†“
    ğŸŒ¸ Spring Magic
         |
         â†“ 
    â˜• Your Java Bean
         |
         â†“
    ğŸ‰ Configured App!
```

### Mnemonics à¤¯à¤¾à¤¦à¤¿à¤² à¤•à¤°à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ ğŸ’­
- **PROP** = **P**owerful **R**eusable **O**utside **P**arameters
- **VALUE** = **V**ery **A**wesome **L**oading **U**tility **E**verywhere  
- **SPRING** = **S**imple **P**roperty **R**eading **I**n **N**eat **G**roups

### Pro Tips from Industry ğŸ’¼
1. **Netflix approach**: Use distributed configuration with Spring Cloud Config
2. **Microservices**: Each service has its own properties file
3. **DevOps**: Properties in CI/CD pipelines for different environments
4. **Security**: Never commit passwords, use environment variables

---

*Bas yaar! Ab tumhe pata chal gaya properties file injection ka complete concept! Practice karo aur interviews mein rock karo! ğŸš€*

**Happy Coding! ğŸŒ¸ Spring ke saath! â˜•**
