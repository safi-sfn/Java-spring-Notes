# Method Overloading - Complete Study Notes  üìö

> **Note**: What is Method Overloading in Java

## Method Overloading Kya Hai Bhai? ü§î

**Simple Definition**: Same class mein **same name ke multiple methods** banane ko Method Overloading kehte hain, bas **parameters different** hone chahiye!

**Easy Analogy**: Socho ek restaurant mein **"order"** method hai - `order(pizza)`, `order(burger, coke)`, `order(pasta, juice, dessert)` - same name, different parameters! üçïüçî

**Technical Terms**: 
- **Compile-time Polymorphism** 
- **Static Polymorphism**
- **Early Binding**

## Method Overloading Ke Rules üìè

### **Overloading Possible Hai When:**

1. **Number of parameters different** hai
2. **Type of parameters different** hai  
3. **Order of parameters different** hai

### **Overloading NOT possible when:**
- Sirf **return type** different hai
- Sirf **access modifiers** different hain
- Sirf **variable names** different hain

## Complete Method Overloading Examples üöÄ

### **1. Different Number of Parameters:**
```java
public class Calculator {
    
    // Method with 1 parameter
    public int add(int a) {
        System.out.println("Single parameter method");
        return a;
    }
    
    // Method with 2 parameters
    public int add(int a, int b) {
        System.out.println("Two parameter method");
        return a + b;
    }
    
    // Method with 3 parameters
    public int add(int a, int b, int c) {
        System.out.println("Three parameter method");
        return a + b + c;
    }
    
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        System.out.println(calc.add(5));        // Single parameter
        System.out.println(calc.add(5, 10));    // Two parameters  
        System.out.println(calc.add(5, 10, 15)); // Three parameters
    }
}

// Output:
// Single parameter method
// 5
// Two parameter method  
// 15
// Three parameter method
// 30
```

### **2. Different Types of Parameters:**
```java
public class DataProcessor {
    
    // Method for int
    public void process(int data) {
        System.out.println("Processing integer: " + data);
    }
    
    // Method for double
    public void process(double data) {
        System.out.println("Processing double: " + data);
    }
    
    // Method for String
    public void process(String data) {
        System.out.println("Processing string: " + data);
    }
    
    // Method for boolean
    public void process(boolean data) {
        System.out.println("Processing boolean: " + data);
    }
    
    public static void main(String[] args) {
        DataProcessor dp = new DataProcessor();
        
        dp.process(42);         // int version
        dp.process(3.14);       // double version
        dp.process("Hello");    // String version
        dp.process(true);       // boolean version
    }
}

// Output:
// Processing integer: 42
// Processing double: 3.14
// Processing string: Hello
// Processing boolean: true
```

### **3. Different Order of Parameters:**
```java
public class OrderProcessor {
    
    // Method with int, String order
    public void createOrder(int orderId, String customerName) {
        System.out.println("Order ID: " + orderId + ", Customer: " + customerName);
    }
    
    // Method with String, int order
    public void createOrder(String productName, int quantity) {
        System.out.println("Product: " + productName + ", Quantity: " + quantity);
    }
    
    // Method with int, double order
    public void createOrder(int orderId, double amount) {
        System.out.println("Order ID: " + orderId + ", Amount: $" + amount);
    }
    
    // Method with double, int order
    public void createOrder(double discount, int orderId) {
        System.out.println("Discount: " + discount + "%, Order ID: " + orderId);
    }
    
    public static void main(String[] args) {
        OrderProcessor op = new OrderProcessor();
        
        op.createOrder(101, "John");        // int, String
        op.createOrder("Laptop", 2);        // String, int
        op.createOrder(102, 999.99);        // int, double
        op.createOrder(10.5, 103);          // double, int
    }
}
```

## Automatic Promotion in Overloading üîÑ

Java automatically **promote** karta hai smaller types ko larger types mein agar exact match nahi mila!

### **Promotion Hierarchy:**
```
byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double
char ‚Üí int ‚Üí long ‚Üí float ‚Üí double
```

### **Automatic Promotion Example:**
```java
public class PromotionExample {
    
    public void test(int i) {
        System.out.println("int method: " + i);
    }
    
    public void test(float f) {
        System.out.println("float method: " + f);
    }
    
    public static void main(String[] args) {
        PromotionExample pe = new PromotionExample();
        
        pe.test(10);        // Direct int match
        pe.test('A');       // char promoted to int
        pe.test(100L);      // long promoted to float (int se skip)
        pe.test((byte)5);   // byte promoted to int
    }
}

// Output:
// int method: 10
// int method: 65     (ASCII of 'A')
// float method: 100.0
// int method: 5
```

## String vs Object Priority Example üéØ

```java
public class PriorityExample {
    
    public void display(String s) {
        System.out.println("String version: " + s);
    }
    
    public void display(Object o) {
        System.out.println("Object version: " + o);
    }
    
    public static void main(String[] args) {
        PriorityExample pe = new PriorityExample();
        
        pe.display("Hello");        // String match (higher priority)
        pe.display(new Object());   // Object match
        pe.display(null);           // String match (String > Object in hierarchy)
    }
}

// Output:
// String version: Hello
// Object version: java.lang.Object@hashcode
// String version: null
```

**Rule**: Child class ko parent class se **higher priority** milti hai!

## Ambiguity Cases - Confusing Situations! üòµ

### **Ambiguous Method Calls:**
```java
public class AmbiguityExample {
    
    public void method(int i, float f) {
        System.out.println("int-float method");
    }
    
    public void method(float f, int i) {
        System.out.println("float-int method");
    }
    
    public static void main(String[] args) {
        AmbiguityExample ae = new AmbiguityExample();
        
        ae.method(10, 10.5f);     // ‚úÖ Works - int, float
        ae.method(10.5f, 10);     // ‚úÖ Works - float, int
        
        // ae.method(10, 10);     // ‚ùå Compile error - Ambiguous!
        // ae.method(10.5f, 10.5f); // ‚ùå Compile error - No exact match!
    }
}
```

## Var-args in Overloading üìã

```java
public class VarArgsExample {
    
    // Exact match method
    public void process(int i) {
        System.out.println("Exact match - int: " + i);
    }
    
    // Var-args method (lower priority)
    public void process(int... args) {
        System.out.println("Var-args method - " + Arrays.toString(args));
    }
    
    public static void main(String[] args) {
        VarArgsExample ve = new VarArgsExample();
        
        ve.process();           // Var-args (no other match)
        ve.process(10);         // Exact match (higher priority)
        ve.process(10, 20, 30); // Var-args (no other match)
    }
}

// Output:
// Var-args method - []
// Exact match - int: 10
// Var-args method - [10, 20, 30]
```

**Rule**: Var-args method ko **lowest priority** milti hai - last option hai!

## Constructor Overloading üèóÔ∏è

```java
public class Student {
    private String name;
    private int age;
    private String email;
    private String course;
    
    // Default constructor
    public Student() {
        this.name = "Unknown";
        this.age = 18;
        System.out.println("Default constructor called");
    }
    
    // Constructor with name only
    public Student(String name) {
        this.name = name;
        this.age = 18;
        System.out.println("Name constructor called");
    }
    
    // Constructor with name and age
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Name-Age constructor called");
    }
    
    // Constructor with all fields
    public Student(String name, int age, String email, String course) {
        this.name = name;
        this.age = age;
        this.email = email;
        this.course = course;
        System.out.println("Full constructor called");
    }
    
    // Copy constructor
    public Student(Student other) {
        this.name = other.name;
        this.age = other.age;
        this.email = other.email;
        this.course = other.course;
        System.out.println("Copy constructor called");
    }
    
    // toString for display
    @Override
    public String toString() {
        return String.format("Student{name='%s', age=%d, email='%s', course='%s'}", 
                           name, age, email, course);
    }
    
    public static void main(String[] args) {
        Student s1 = new Student();
        Student s2 = new Student("John");
        Student s3 = new Student("Alice", 20);
        Student s4 = new Student("Bob", 22, "bob@email.com", "Java");
        Student s5 = new Student(s4); // Copy constructor
        
        System.out.println(s1);
        System.out.println(s2);
        System.out.println(s3);
        System.out.println(s4);
        System.out.println(s5);
    }
}
```

## Real-World Examples üåç

### **1. File Processing Utility:**
```java
import java.io.*;
import java.util.*;

public class FileProcessor {
    
    // Read from file path
    public List<String> readFile(String filePath) throws IOException {
        System.out.println("Reading from file path: " + filePath);
        return Files.readAllLines(Paths.get(filePath));
    }
    
    // Read from File object
    public List<String> readFile(File file) throws IOException {
        System.out.println("Reading from File object: " + file.getName());
        return Files.readAllLines(file.toPath());
    }
    
    // Read from InputStream
    public List<String> readFile(InputStream inputStream) throws IOException {
        System.out.println("Reading from InputStream");
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
            return reader.lines().collect(Collectors.toList());
        }
    }
    
    // Read with encoding
    public List<String> readFile(String filePath, String encoding) throws IOException {
        System.out.println("Reading from file with encoding: " + encoding);
        return Files.readAllLines(Paths.get(filePath), Charset.forName(encoding));
    }
}
```

### **2. Database Connection Utility:**
```java
public class DatabaseConnector {
    
    // Connect with default settings
    public Connection connect() {
        System.out.println("Connecting to default database");
        return connect("localhost", 3306, "mydb", "root", "password");
    }
    
    // Connect with custom host
    public Connection connect(String host) {
        System.out.println("Connecting to database on: " + host);
        return connect(host, 3306, "mydb", "root", "password");
    }
    
    // Connect with host and port
    public Connection connect(String host, int port) {
        System.out.println("Connecting to " + host + ":" + port);
        return connect(host, port, "mydb", "root", "password");
    }
    
    // Connect with full parameters
    public Connection connect(String host, int port, String database, String username, String password) {
        System.out.println("Full connection to: " + host + ":" + port + "/" + database);
        // Actual connection logic here
        return null; // Placeholder
    }
    
    // Connect with Properties object
    public Connection connect(Properties props) {
        System.out.println("Connecting with Properties: " + props);
        String host = props.getProperty("host", "localhost");
        int port = Integer.parseInt(props.getProperty("port", "3306"));
        String database = props.getProperty("database", "mydb");
        String username = props.getProperty("username", "root");
        String password = props.getProperty("password", "password");
        
        return connect(host, port, database, username, password);
    }
}
```

## Common Mistakes - Inse Bacho! ‚ö†Ô∏è

### **1. Return Type Se Overloading Try Karna**
```java
// ‚ùå Galat - Sirf return type different hai
public class WrongOverloading {
    public int getValue() {
        return 10;
    }
    
    // ‚ùå Compile error - Cannot overload based on return type only
    // public String getValue() {
    //     return "Hello";
    // }
}

// ‚úÖ Sahi - Parameters different hain
public class CorrectOverloading {
    public int getValue() {
        return 10;
    }
    
    public String getValue(String prefix) {
        return prefix + "Hello";
    }
}
```

### **2. Access Modifier Se Overloading**
```java
// ‚ùå Galat - Sirf access modifier different
public class WrongModifierOverloading {
    public void method() {
        System.out.println("Public method");
    }
    
    // ‚ùå Compile error - Cannot overload based on access modifier only
    // private void method() {
    //     System.out.println("Private method");
    // }
}
```

### **3. Variable Name Se Overloading**
```java
// ‚ùå Galat - Sirf variable names different
public class WrongVariableOverloading {
    public void process(int number) {
        System.out.println("Number: " + number);
    }
    
    // ‚ùå Compile error - Parameter names don't matter
    // public void process(int value) {
    //     System.out.println("Value: " + value);
    // }
}
```

## Best Practices - Pro Tips! üéØ

### **1. Meaningful Method Names**
```java
// ‚úÖ Good - Clear purpose
public class MathUtility {
    public double calculate(double radius) {
        return Math.PI * radius * radius; // Circle area
    }
    
    public double calculate(double length, double width) {
        return length * width; // Rectangle area
    }
    
    public double calculate(double base, double height, String shape) {
        if ("triangle".equals(shape)) {
            return 0.5 * base * height;
        }
        return 0;
    }
}
```

### **2. Builder Pattern With Overloading**
```java
public class EmailBuilder {
    private String to;
    private String cc;
    private String bcc;
    private String subject;
    private String body;
    
    // Basic email
    public EmailBuilder send(String to, String subject, String body) {
        this.to = to;
        this.subject = subject;
        this.body = body;
        return this;
    }
    
    // With CC
    public EmailBuilder send(String to, String cc, String subject, String body) {
        this.to = to;
        this.cc = cc;
        this.subject = subject;
        this.body = body;
        return this;
    }
    
    // With CC and BCC
    public EmailBuilder send(String to, String cc, String bcc, String subject, String body) {
        this.to = to;
        this.cc = cc;
        this.bcc = bcc;
        this.subject = subject;
        this.body = body;
        return this;
    }
    
    public void build() {
        System.out.println("Sending email...");
        System.out.println("To: " + to);
        if (cc != null) System.out.println("CC: " + cc);
        if (bcc != null) System.out.println("BCC: " + bcc);
        System.out.println("Subject: " + subject);
        System.out.println("Body: " + body);
    }
}
```

### **3. Validation in Overloaded Methods**
```java
public class UserValidator {
    
    // Validate with username only
    public boolean validate(String username) {
        if (username == null || username.trim().isEmpty()) {
            System.out.println("Username cannot be empty");
            return false;
        }
        return username.length() >= 3;
    }
    
    // Validate with username and email
    public boolean validate(String username, String email) {
        if (!validate(username)) return false;
        
        if (email == null || !email.contains("@")) {
            System.out.println("Invalid email format");
            return false;
        }
        return true;
    }
    
    // Validate with username, email and age
    public boolean validate(String username, String email, int age) {
        if (!validate(username, email)) return false;
        
        if (age < 18 || age > 100) {
            System.out.println("Age should be between 18-100");
            return false;
        }
        return true;
    }
}
```

## Interview Questions & Answers üé§

### **Q1: Method Overloading kya hai aur kyu use karte hain?**
**Answer:** Method Overloading means same class mein same name ke multiple methods banana with different parameters. Isse code readability aur flexibility badh jaati hai. Same functionality ko different ways mein provide kar sakte hain.

### **Q2: Method Overloading aur Method Overriding mein difference kya hai?**
**Answer:** 
- **Overloading**: Same class, same method name, different parameters - Compile time
- **Overriding**: Parent-child classes, same method signature - Runtime

### **Q3: Kya sirf return type change karke method overload kar sakte hain?**
**Answer:** Nahi! Sirf return type change karne se overloading nahi hoti. Parameters mein difference hona zaroori hai.

### **Q4: Automatic promotion kya hai method overloading mein?**
**Answer:** Agar exact match nahi mila toh Java automatically smaller data types ko larger types mein promote kar deta hai. Jaise char ‚Üí int ‚Üí long ‚Üí float ‚Üí double.

### **Q5: Var-args method ka priority kya hai overloading mein?**
**Answer:** Var-args method ko sabse lowest priority milti hai. Pehle exact match, phir promotion, last mein var-args method call hota hai.

### **Q6: Constructor overloading possible hai?**
**Answer:** Haan bilkul! Same class mein different parameters ke saath multiple constructors bana sakte hain. Ye object creation mein flexibility provide karta hai.

### **Q7: Static methods overload kar sakte hain?**
**Answer:** Haan, static methods bhi overload kar sakte hain same rules ke saath - different parameters hone chahiye.

### **Q8: Method overloading performance impact karta hai?**
**Answer:** Nahi, compile time pe resolve ho jaata hai, so runtime performance impact nahi hota. Bas code maintainability aur readability improve hoti hai.

### **Q9: Ambiguous method call kab aata hai?**
**Answer:** Jab compiler ko exact method decide nahi kar pata ki kaunsa call karna hai. Jaise `method(int, float)` aur `method(float, int)` dono available hain aur aap `method(10, 10)` call karte hain.

### **Q10: Generic methods overload kar sakte hain?**
**Answer:** Haan, generic methods bhi overload kar sakte hain if parameter types different hain. But type erasure ke wajah se kuch limitations hain.

## Assignment Problems üíª

### **Easy Level (Beginner) üü¢**

#### **Problem 1: Basic Calculator**
```java
/**
 * Create a Calculator class with overloaded add methods:
 * - add(int, int)
 * - add(double, double)
 * - add(int, int, int)
 * - add(String, String) // String concatenation
 */

// Your solution here
public class Calculator {
    // Implement all add methods
}

// Test case:
// Calculator calc = new Calculator();
// System.out.println(calc.add(5, 10));           // 15
// System.out.println(calc.add(5.5, 2.3));        // 7.8
// System.out.println(calc.add(1, 2, 3));         // 6
// System.out.println(calc.add("Hello", "World")); // HelloWorld
```

#### **Problem 2: Shape Area Calculator**
```java
/**
 * Create AreaCalculator class with overloaded calculateArea methods:
 * - Circle: calculateArea(double radius)
 * - Rectangle: calculateArea(double length, double width)
 * - Triangle: calculateArea(double base, double height, String shape)
 */

// Your solution here
```

### **Intermediate Level üü°**

#### **Problem 3: Employee Management System**
```java
/**
 * Create Employee class with overloaded constructors:
 * - Employee() // Default values
 * - Employee(String name)
 * - Employee(String name, double salary)
 * - Employee(String name, double salary, String department)
 * - Employee(Employee other) // Copy constructor
 * 
 * Also create overloaded updateSalary methods:
 * - updateSalary(double newSalary)
 * - updateSalary(double percentage, boolean isPercentage)
 * - updateSalary(double amount, String type) // "increment" or "decrement"
 */

// Your solution here
```

#### **Problem 4: Data Converter**
```java
/**
 * Create DataConverter class with overloaded convert methods:
 * - convert(String data, Class<?> targetType) // String to any type
 * - convert(Object data, String format) // Object to formatted String
 * - convert(int[] array, String delimiter) // Array to String with delimiter
 * - convert(List<String> list, String separator, boolean sorted)
 * 
 * Handle type conversion and error cases properly.
 */

// Your solution here
```

### **Hard Level (Advanced) üî¥**

#### **Problem 5: Generic Repository Pattern**
```java
/**
 * Create a GenericRepository class with overloaded save methods:
 * - save(T entity)
 * - save(T entity, boolean validate)
 * - save(List<T> entities)
 * - save(T entity, Map<String, Object> options)
 * - save(T entity, String... tags)
 * 
 * Also implement overloaded find methods:
 * - find(ID id)
 * - find(Map<String, Object> criteria)
 * - find(String query, Object... params)
 * - find(Predicate<T> condition, int limit)
 */

// Your solution here with proper generic implementation
```

#### **Problem 6: Advanced Logger System**
```java
/**
 * Create Logger class with sophisticated overloaded log methods:
 * - log(String message)
 * - log(LogLevel level, String message)
 * - log(String message, Throwable exception)
 * - log(LogLevel level, String message, Object... params)
 * - log(Class<?> clazz, String message, Throwable exception)
 * - log(String category, LogLevel level, String message, Map<String, Object> context)
 * 
 * Implement proper formatting, filtering, and output handling.
 * Use automatic promotion concepts for LogLevel hierarchy.
 */

enum LogLevel {
    DEBUG, INFO, WARN, ERROR, FATAL
}

// Your solution here
```

## Assignment Solutions (Sample) üìù

### **Easy Problem 1 Solution:**
```java
public class Calculator {
    
    public int add(int a, int b) {
        System.out.println("Adding two integers");
        return a + b;
    }
    
    public double add(double a, double b) {
        System.out.println("Adding two doubles");
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        System.out.println("Adding three integers");
        return a + b + c;
    }
    
    public String add(String a, String b) {
        System.out.println("Concatenating two strings");
        return a + b;
    }
    
    // Bonus: Var-args method
    public int add(int... numbers) {
        System.out.println("Adding variable arguments");
        int sum = 0;
        for (int num : numbers) {
            sum += num;
        }
        return sum;
    }
    
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        
        System.out.println(calc.add(5, 10));           // 15
        System.out.println(calc.add(5.5, 2.3));        // 7.8
        System.out.println(calc.add(1, 2, 3));         // 6
        System.out.println(calc.add("Hello", "World")); // HelloWorld
        System.out.println(calc.add(1, 2, 3, 4, 5));   // 15 (var-args)
    }
}
```

## Summary üìù

**Key Points to Remember:**

### **Method Overloading Rules:**
1. **Same method name** in same class
2. **Different parameters** (number, type, order)
3. **Compile-time resolution** (early binding)
4. **Return type doesn't matter** for overloading

### **Automatic Promotion Chain:**
```
byte ‚Üí short ‚Üí int ‚Üí long ‚Üí float ‚Üí double
char ‚Üí int
```

### **Priority Order:**
1. **Exact match** (highest priority)
2. **Automatic promotion**
3. **Var-args method** (lowest priority)

### **Best Practices:**
- Use meaningful method names
- Provide proper documentation
- Handle edge cases
- Follow consistent parameter ordering
- Use validation in overloaded methods

### **Real-world Usage:**
- Constructor overloading for flexible object creation
- Utility methods with different input options
- API methods with optional parameters
- Builder patterns and factory methods

**Remember**: Method Overloading **compile-time** pe resolve hoti hai, Method Overriding **runtime** pe! 

Practice these problems thoroughly - interview mein bahut puchte hain! All the best! üöÄüí™
