# Method Overriding - Complete Study Notes 📚

## Method Overriding Kya Hai Bhai? 🤔

**Simple Words Mein**: Jab child class ko parent class ka method pasand nahi aata, toh woh apna khud ka version banata hai - yahi Method Overriding hai!

**Real Life Example**: Jaise Papa kehte hain "Arrange marriage karo", lekin tum kehte ho "Love marriage karunga!" - Ye overriding hai! 😄

**Technical Definition**: When a child class provides its own implementation of a method that already exists in the parent class, it's called Method Overriding.

## Key Terms Yaad Rakho 📝

- **Overridden Method**: Parent class ka original method
- **Overriding Method**: Child class ka new implementation
- **Runtime Polymorphism**: JVM runtime pe decide karta hai kaunsa method call karna hai
- **Dynamic Method Dispatch**: Method resolution at runtime

## Classic Example - Marriage Wali Story! 💑

```java
// Parent class
class Parent {
    public void marry() {
        System.out.println("Arrange Marriage with Parent's choice");
        // ↑ Ye hai overridden method
    }
}

// Child class
class Child extends Parent {
    public void marry() {
        System.out.println("Love/Arrange Marriage with His/Her choice");
        // ↑ Ye hai overriding method
    }
}

public class Test {
    public static void main(String args[]) {
        Parent p = new Parent();
        p.marry();  // Parent ka method call hoga
        
        Child c = new Child();
        c.marry();  // Child ka method call hoga
        
        Parent p1 = new Child();  // Parent reference, Child object
        p1.marry(); // Child ka method call hoga (Runtime Polymorphism!)
    }
}
```

**Output:**
```
Arrange Marriage with Parent's choice
Love/Arrange Marriage with His/Her choice
Love/Arrange Marriage with His/Her choice  ← Ye JVM runtime pe decide karta hai!
```

## Method Overriding Ke Rules - Yaad Kar Lena! 📋

### Rule 1: **Method Signature Same Hona Chahiye** ✅

```java
class Parent {
    public void study(String subject) { }  // Method signature
}

class Child extends Parent {
    public void study(String subject) { }  // ✅ Same signature - Valid overriding
    // public void study(int marks) { }    // ❌ Different signature - Overloading, not overriding
}
```

**Important:** Method name + parameters = Method signature

### Rule 2: **Return Type Same Ya Co-variant Hona Chahiye** (Java 1.5+) ✅

```java
class Parent {
    public Object method1() {
        System.out.println("This is the method in the Parent class");
        return new Object();
    }
}

class Child extends Parent {
    public String method1() {  // ✅ String is subclass of Object - Co-variant return type
        System.out.println("This is the method in the Child class");
        return "";
    }
}

public class Test {
    public static void main(String[] args) {
        Parent p = new Parent();
        p.method1();
        Child c = new Child();
        c.method1();
    }
}
```

**Output:**
```
This is the method in the Parent class
This is the method in the Child class
```

### Rule 3: **Private Methods Override Nahi Ho Sakte** ❌

```java
class Parent {
    private void secretMethod() {
        System.out.println("Parent's secret");
    }
}

class Child extends Parent {
    private void secretMethod() {  // ❌ Ye overriding nahi, new method hai
        System.out.println("Child's secret");
    }
}
```

**Reason:** Private methods child classes mein visible nahi hote.

### Rule 4: **Final Methods Override Nahi Ho Sakte** ❌

```java
class Parent {
    public final void method1() {
        System.out.println("This cannot be changed!");
    }
}

class Child extends Parent {
    public void method1() {  // ❌ Compile error!
        System.out.println("Trying to change...");
    }
}

public class MyClass {
    public static void main(String args[]) {
        Parent p = new Child();
        p.method1();
    }
}
```

**Error:**
```
Test.java:6: error: method1() in Child cannot override method1() in Parent
void method1() {}
^
overridden method is final
1 error
```

### Rule 5: **Access Modifier Scope Kam Nahi Kar Sakte** ⚠️

```java
class Parent {
    public void method1() {
        System.out.println("This is the Parent class method");
    }
}

public class Child extends Parent {
    protected void method1() {  // ❌ Error! Kam access de rahe ho
        System.out.println("This is the Child class method");
    }
    
    public static void main(String args[]) {
        Parent p = new Child();
        p.method1();
    }
}
```

**Error:**
```
Compile time error:
/Child.java:8: error: method() in Child cannot override method() in Parent
protected void method(){
^
attempting to assign weaker access privileges; was public
1 error
```

**Access Modifier Hierarchy:**
```
public → public ✅
protected → protected/public ✅
<default> → <default>/protected/public ✅
private → Override nahi ho sakta ❌
```

### Rule 6: **Exception Handling Rules** 🚨

#### **Checked Exceptions:**
```java
class Parent {
    public void method1() { }  // No exception
}

class Child extends Parent {
    public void method1() throws Exception { }  // ❌ Error! Parent doesn't throw
}

public class Test {
    public static void main(String args[]) {
        Parent p = new Child();
        p.method1();
    }
}
```

**Error:**
```
/Test.java:6: error: method1() in Child cannot override method1() in Parent
public void method1() throws Exception {}
^
overridden method does not throw Exception
1 error
```

#### **Unchecked Exceptions:**
```java
class Parent {
    public void method1() { }
}

class Child extends Parent {
    public void method1() throws ArithmeticException { }  // ✅ Unchecked exception - Allowed!
}

public class Test {
    public static void main(String args[]) {
        Parent p = new Child();
        p.method1();
    }
}
```

### Rule 7: **Static Methods Override Nahi Ho Sakte** ❌

```java
class Parent {
    public static void staticMethod() {
        System.out.println("Parent static");
    }
}

class Child extends Parent {
    public static void staticMethod() {  // ❌ Ye overriding nahi, method hiding hai!
        System.out.println("Child static");
    }
}
```

**Note:** Static methods hide hote hain, override nahi hote.

### Rule 8: **Var-args Method Ko Var-args Se Hi Override Karo** ⚠️

```java
class Parent {
    public void method(int... numbers) {
        System.out.println("Var-arg method in Parent");
    }
}

class Child extends Parent {
    public void method(int... numbers) {  // ✅ Correct overriding
        System.out.println("Var-arg method in Child");
    }
    
    // public void method(int[] numbers) { } // ❌ Different signature - Overloading
}
```

## Runtime Polymorphism - JVM Ka Khel! 🎭

**Concept:** Method resolution JVM ke dwara runtime par decide hota hai based on actual object type, not reference type!

```java
class Animal {
    public void sound() {
        System.out.println("Some animal sound");
    }
}

class Dog extends Animal {
    public void sound() {
        System.out.println("Woof! Woof!");
    }
}

class Cat extends Animal {
    public void sound() {
        System.out.println("Meow! Meow!");
    }
}

public class Test {
    public static void main(String[] args) {
        Animal animal;  // Reference variable
        
        animal = new Dog();
        animal.sound();  // "Woof! Woof!" - Dog ka method call hoga
        
        animal = new Cat();
        animal.sound();  // "Meow! Meow!" - Cat ka method call hoga
        
        // JVM runtime pe object type dekhta hai, reference type nahi!
    }
}
```

**Output:**
```
Woof! Woof!
Meow! Meow!
```

## Method Resolution Process 🔍

1. **Compile Time**: Method signature check karta hai compiler
2. **Runtime**: JVM actual object type dekhta hai
3. **Method Search**: Child class se start karke parent class tak jaata hai
4. **Execution**: Appropriate method execute karta hai

```java
Parent p = new Child();  
p.method();

// JVM Process:
// 1. Reference type: Parent ✓
// 2. Object type: Child ✓
// 3. Method search: Child class mein method hai? ✓
// 4. Execute: Child.method() ✓
```

## Real-World Example - Banking System! 🏦

```java
abstract class Account {
    protected double balance;
    
    public Account(double balance) {
        this.balance = balance;
    }
    
    public abstract void withdraw(double amount);
    
    public void displayBalance() {
        System.out.println("Balance: " + balance);
    }
}

class SavingsAccount extends Account {
    public SavingsAccount(double balance) {
        super(balance);
    }
    
    @Override
    public void withdraw(double amount) {
        if (balance >= amount) {
            balance -= amount;
            System.out.println("Withdrawn from Savings: " + amount);
        } else {
            System.out.println("Insufficient balance in Savings!");
        }
    }
}

class CurrentAccount extends Account {
    private double overdraftLimit = 10000;
    
    public CurrentAccount(double balance) {
        super(balance);
    }
    
    @Override
    public void withdraw(double amount) {
        if (balance + overdraftLimit >= amount) {
            balance -= amount;
            System.out.println("Withdrawn from Current: " + amount);
        } else {
            System.out.println("Overdraft limit exceeded!");
        }
    }
}

// Usage:
public class BankTest {
    public static void main(String[] args) {
        Account acc1 = new SavingsAccount(5000);  // Different implementations
        Account acc2 = new CurrentAccount(2000);  // Same interface!
        
        acc1.withdraw(3000);  // Savings account logic
        acc2.withdraw(8000);  // Current account logic (with overdraft)
    }
}
```

## @Override Annotation - Best Practice! 📝

```java
class Parent {
    public void method() {
        System.out.println("Parent method");
    }
}

class Child extends Parent {
    @Override  // ✅ Always use this annotation!
    public void method() {
        System.out.println("Child method");
    }
    
    /*
    @Override
    public void methd() {  // ❌ Compiler error - method name galat hai
        System.out.println("Wrong method name");
    }
    */
}
```

**@Override Ke Fayde:**
- ✅ Spelling mistakes catch karta hai
- ✅ Code readability improve karta hai
- ✅ Accidental overloading se bachata hai
- ✅ Compile-time checking

## Shape Hierarchy Example 🔺🔴

```java
abstract class Shape {
    public abstract void draw();
    public abstract double calculateArea();
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a Circle");
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

class Rectangle extends Shape {
    private double length, width;
    
    public Rectangle(double length, double width) {
        this.length = length;
        this.width = width;
    }
    
    @Override
    public void draw() {
        System.out.println("Drawing a Rectangle");
    }
    
    @Override
    public double calculateArea() {
        return length * width;
    }
}

public class ShapeTest {
    public static void main(String[] args) {
        Shape[] shapes = {
            new Circle(5),
            new Rectangle(4, 6)
        };
        
        for (Shape shape : shapes) {
            shape.draw();  // Runtime polymorphism
            System.out.println("Area: " + shape.calculateArea());
        }
    }
}
```

## Common Mistakes - Inse Bacho! ⚠️

### 1. **Method Signature Galat**
```java
class Parent {
    public void method(String name) { }
}

// ❌ Galat - Different parameters
class Child extends Parent {
    public void method(String name, int age) { }  // Overloading, not overriding
}

// ✅ Sahi - Same parameters
class Child extends Parent {
    @Override
    public void method(String name) { }  // Correct overriding
}
```

### 2. **Access Modifier Scope Kam Kar Dena**
```java
// ❌ Galat
class Parent {
    public void method() { }
}
class Child extends Parent {
    protected void method() { }  // Scope kam kar diya - ERROR!
}

// ✅ Sahi
class Child extends Parent {
    @Override
    public void method() { }  // Same ya zyada scope
}
```

### 3. **Static Methods Ko Override Samajhna**
```java
// ❌ Galat understanding
class Parent {
    public static void method() { 
        System.out.println("Parent static");
    }
}
class Child extends Parent {
    public static void method() {  // Ye overriding nahi, hiding hai!
        System.out.println("Child static");
    }
}
```

### 4. **Final Methods Override Karne Ki Koshish**
```java
// ❌ Galat
class Parent {
    public final void method() { }
}
class Child extends Parent {
    // public void method() { }  // COMPILE ERROR!
}
```

## Overriding vs Overloading - Confusion Clear Karo! 🤯

| **Method Overriding** | **Method Overloading** |
|----------------------|------------------------|
| Different classes (Parent-Child) | Same class |
| Same method signature | Different method signature |
| Runtime polymorphism | Compile-time polymorphism |
| IS-A relationship | Variety in same class |
| @Override annotation | No special annotation |
| Virtual method invocation | Static method selection |

```java
// Overriding Example
class Parent {
    public void method(String name) { 
        System.out.println("Parent: " + name);
    }
}
class Child extends Parent {
    @Override
    public void method(String name) {  // Same signature
        System.out.println("Child: " + name);
    }
}

// Overloading Example  
class MyClass {
    public void method(String name) { 
        System.out.println("Name: " + name);
    }
    
    public void method(int age) {        // Different signature
        System.out.println("Age: " + age);
    }
    
    public void method(String name, int age) {  // Different signature
        System.out.println("Name: " + name + ", Age: " + age);
    }
}
```

## Benefits of Method Overriding 🎯

### 1. **Runtime Polymorphism** 🔄
```java
// Same interface, different behavior
Animal[] animals = {new Dog(), new Cat(), new Cow()};
for (Animal animal : animals) {
    animal.makeSound();  // Different sounds for each animal
}
```

### 2. **Code Flexibility** 💪
```java
// Easy to extend and modify behavior
class SmartPhone extends Phone {
    @Override
    public void makeCall(String number) {
        // Video call implementation
        super.makeCall(number);  // Can still use parent's logic
        startVideoCall(number);
    }
}
```

### 3. **Framework Development** 🏗️
```java
// Template method pattern
abstract class DataProcessor {
    public final void processData() {
        loadData();      // Common for all
        processData();   // Different for each subclass
        saveData();      // Common for all
    }
    
    protected abstract void processData();  // Must be overridden
}
```

### 4. **Maintainability** 🛠️
- Changes specific classes mein kar sakte hain
- Base class ko touch nahi karna padta
- New implementations easily add kar sakte hain

## Interview Questions - Taiyari Kar Lo! 💪

### Q1: **Can we override static methods?**
**Answer**: Nahi! Static methods belong to class, not object. Static methods hide hote hain, override nahi. Method hiding aur method overriding different concepts hain.

### Q2: **Can we override private methods?**
**Answer**: Nahi! Private methods child class mein visible nahi hote, so inheritance hi nahi hoti. Override ka question hi nahi aata.

### Q3: **What is dynamic method dispatch?**
**Answer**: Runtime pe JVM decide karta hai ki kaunsa method call karna hai based on actual object type, not reference type. Isse runtime polymorphism achieve hota hai.

### Q4: **Why use @Override annotation?**
**Answer**: 
- Compile-time checking of method signature
- Code readability improvement
- Accidental overloading se protection
- IDE support for refactoring

### Q5: **Can we override constructor?**
**Answer**: Nahi! Constructor inherit nahi hote, so override bhi nahi ho sakte. Har class ka apna constructor hota hai.

### Q6: **What is co-variant return type?**
**Answer**: Java 1.5+ mein child class ka return type parent class ke return type ka subclass ho sakta hai. Jaise Object → String allowed hai.

### Q7: **Can we override final methods?**
**Answer**: Nahi! Final methods ko modify nahi kar sakte, so override bhi nahi ho sakta.

### Q8: **Difference between method hiding and method overriding?**
**Answer**: 
- **Method Hiding**: Static methods ke liye (compile-time resolution)
- **Method Overriding**: Instance methods ke liye (runtime resolution)

## Advanced Concepts 🚀

### 1. **Method Resolution Order**
```java
class A {
    public void method() { System.out.println("A"); }
}

class B extends A {
    public void method() { System.out.println("B"); }
}

class C extends B {
    public void method() { System.out.println("C"); }
}

// Method resolution: C → B → A (bottom to top)
A obj = new C();
obj.method();  // Output: "C"
```

### 2. **Super Keyword Usage**
```java
class Parent {
    public void greet() {
        System.out.println("Hello from Parent!");
    }
}

class Child extends Parent {
    @Override
    public void greet() {
        super.greet();  // Call parent's method first
        System.out.println("Hello from Child!");
    }
}
```

### 3. **Abstract Methods Overriding**
```java
abstract class Vehicle {
    abstract void start();  // Must be overridden
    
    void stop() {  // Can be overridden (optional)
        System.out.println("Vehicle stopped");
    }
}

class Car extends Vehicle {
    @Override
    void start() {  // Mandatory override
        System.out.println("Car started with key");
    }
}
```

## Summary 📝

**Method Overriding Key Points:**

1. ✅ **Child class apna implementation deta hai parent method ka**
2. ✅ **Runtime polymorphism achieve karne ke liye use hota hai**
3. ✅ **Method signature same hona chahiye**
4. ✅ **Access modifier scope kam nahi kar sakte**
5. ✅ **Private, final, static methods override nahi ho sakte**
6. ✅ **@Override annotation use karo (best practice)**
7. ✅ **Exception rules follow karo (checked exceptions)**
8. ✅ **Co-variant return types allowed (Java 1.5+)**

**Real-World Benefits:**
- 🎯 Code flexibility aur extensibility
- 🔄 Polymorphic behavior
- 🏗️ Framework development mein essential
- 🛠️ Design patterns implementation
- 📈 Better code organization

**Yaad Rakhne Ka Mantra:**
*"Parent ka method pasand nahi? Child apna bana le, but rules follow kar!"* 😄

**Practice Tips:**
- Different inheritance scenarios try karo
- Exception handling rules practice karo  
- Real-world examples implement karo
- Interview questions solve karo

Practice karte raho different examples ke saath. Method overriding master kar lo toh OOP concepts strong ho jaayenge! 🚀💪

---
*Happy Coding! 🎉*
