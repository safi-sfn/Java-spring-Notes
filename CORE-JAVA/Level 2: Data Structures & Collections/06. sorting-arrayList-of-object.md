# Sorting ArrayList of Objects in Java - Complete Study Notes 📚

## Introduction - Sorting Ki Duniya! 🎯

**Real Life Analogy**: Jaise tum apne contacts ko A-Z ya Z-A mein sort karte ho, waise hi Java mein ArrayList ke objects ko sort kar sakte hain! 📱

**Why Sorting Important Hai?**
- Data ko organized rakhne ke liye 📊
- Search operations fast karne ke liye 🔍
- Better user experience provide karne ke liye ✨
- Database operations mein helpful 💾

## ArrayList Sorting Ke 3 Main Tareeke 🎭

1. **Collections.sort()** - Traditional way (Java 1.2+)
2. **ArrayList.sort()** - Modern way (Java 8+)
3. **Stream.sorted()** - Functional way (Java 8+)

## Method 1: Collections.sort() - Old School but Gold! 🏆

### Basic Syntax:
```java
Collections.sort(list);                    // Natural order sorting
Collections.sort(list, comparator);       // Custom order sorting
```

### Example 1: Natural Order Sorting (Ascending) ⬆️

```java
import java.util.ArrayList;
import java.util.Collections;

public class NaturalSorting {
    public static void main(String args[]) {
        // Creating ArrayList
        ArrayList<String> al = new ArrayList<>();
        al.add("A");
        al.add("Q");
        al.add("Z");
        al.add("K");
        
        System.out.println("Before Sorting: " + al);
        
        // Natural order sorting (A-Z)
        Collections.sort(al);
        
        System.out.println("After Sorting: " + al);
    }
}
```

**Output:**
```
Before Sorting: [A, Q, Z, K]
After Sorting: [A, K, Q, Z]
```

### Example 2: Custom Order Sorting (Descending) ⬇️

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class CustomSorting {
    public static void main(String args[]) {
        ArrayList<String> al = new ArrayList<>();
        al.add("A");
        al.add("Q");
        al.add("Z");
        al.add("K");
        
        System.out.println("Before Sorting: " + al);
        
        // Custom order sorting (Z-A)
        Collections.sort(al, new MyComparator());
        
        System.out.println("After Sorting: " + al);
    }
}

class MyComparator implements Comparator<String> {
    public int compare(String s1, String s2) {
        return s2.compareTo(s1); // Reverse comparison for descending order
    }
}
```

**Output:**
```
Before Sorting: [A, Q, Z, K]
After Sorting: [Z, Q, K, A]
```

### Collections.sort() with Numbers 🔢

```java
import java.util.ArrayList;
import java.util.Collections;

public class NumberSorting {
    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<>();
        numbers.add(50);
        numbers.add(10);
        numbers.add(30);
        numbers.add(20);
        numbers.add(40);
        
        System.out.println("Before Sorting: " + numbers);
        
        // Ascending order
        Collections.sort(numbers);
        System.out.println("Ascending: " + numbers);
        
        // Descending order
        Collections.sort(numbers, Collections.reverseOrder());
        System.out.println("Descending: " + numbers);
    }
}
```

**Output:**
```
Before Sorting: [50, 10, 30, 20, 40]
Ascending: [10, 20, 30, 40, 50]
Descending: [50, 40, 30, 20, 10]
```

## Method 2: ArrayList.sort() - Java 8 Ka Naya Andaaz! 🆕

### Basic Syntax:
```java
list.sort(Comparator.naturalOrder());     // Ascending
list.sort(Comparator.reverseOrder());     // Descending
list.sort(null);                          // Natural order (same as naturalOrder)
```

### Example 1: Ascending Order ⬆️

```java
import java.util.ArrayList;
import java.util.Comparator;

public class Java8Sorting {
    public static void main(String args[]) {
        ArrayList<String> al = new ArrayList<>();
        al.add("A");
        al.add("Q");
        al.add("Z");
        al.add("K");
        
        System.out.println("Before Sorting: " + al);
        
        // Java 8 way - Ascending order
        al.sort(Comparator.naturalOrder());
        
        System.out.println("After Sorting: " + al);
    }
}
```

### Example 2: Descending Order ⬇️

```java
import java.util.ArrayList;
import java.util.Comparator;

public class Java8DescendingSorting {
    public static void main(String args[]) {
        ArrayList<String> al = new ArrayList<>();
        al.add("A");
        al.add("Q");
        al.add("Z");
        al.add("K");
        
        System.out.println("Before Sorting: " + al);
        
        // Java 8 way - Descending order
        al.sort(Comparator.reverseOrder());
        
        System.out.println("After Sorting: " + al);
    }
}
```

**Output:**
```
Before Sorting: [A, Q, Z, K]
After Sorting: [Z, Q, K, A]
```

## Method 3: Stream.sorted() - Functional Programming Style! 🌊

### Basic Syntax:
```java
list.stream().sorted().collect(Collectors.toList());                    // Ascending
list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()); // Descending
```

### Example 1: Integer ArrayList Sorting 🔢

```java
import java.util.ArrayList;
import java.util.Comparator;
import java.util.stream.Collectors;

public class StreamSorting {
    public static void main(String[] args) {
        ArrayList<Integer> al = new ArrayList<>();
        al.add(10);
        al.add(60);
        al.add(40);
        al.add(50);
        al.add(70);
        
        System.out.println("Before Sorting: " + al);
        
        // Ascending order using Stream
        ArrayList<Integer> sortedAscending = al.stream()
                .sorted()
                .collect(Collectors.toCollection(ArrayList::new));
        System.out.println("Ascending: " + sortedAscending);
        
        // Descending order using Stream
        ArrayList<Integer> sortedDescending = al.stream()
                .sorted(Comparator.reverseOrder())
                .collect(Collectors.toCollection(ArrayList::new));
        System.out.println("Descending: " + sortedDescending);
    }
}
```

**Output:**
```
Before Sorting: [10, 60, 40, 50, 70]
Ascending: [10, 40, 50, 60, 70]
Descending: [70, 60, 50, 40, 10]
```

## Real-World Example: Student Class Sorting 🎓

### Student Class Definition:

```java
class Student {
    private int id;
    private String name;
    private double marks;
    private int age;
    
    // Constructor
    public Student(int id, String name, double marks, int age) {
        this.id = id;
        this.name = name;
        this.marks = marks;
        this.age = age;
    }
    
    // Getters and Setters
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public double getMarks() { return marks; }
    public void setMarks(double marks) { this.marks = marks; }
    
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
    
    @Override
    public String toString() {
        return "Student{id=" + id + ", name='" + name + "', marks=" + marks + ", age=" + age + "}";
    }
}
```

### Example 1: Sort by Single Field (Marks) 📊

```java
import java.util.ArrayList;
import java.util.Comparator;

public class StudentSortingExample {
    public static void main(String[] args) {
        ArrayList<Student> students = new ArrayList<>();
        students.add(new Student(1, "Rahul", 85.5, 20));
        students.add(new Student(2, "Priya", 92.3, 19));
        students.add(new Student(3, "Amit", 78.9, 21));
        students.add(new Student(4, "Sneha", 88.7, 20));
        
        System.out.println("=== Before Sorting ===");
        students.forEach(System.out::println);
        
        // Sort by marks (ascending)
        students.sort(Comparator.comparing(Student::getMarks));
        
        System.out.println("\n=== After Sorting by Marks (Ascending) ===");
        students.forEach(System.out::println);
        
        // Sort by marks (descending)
        students.sort(Comparator.comparing(Student::getMarks).reversed());
        
        System.out.println("\n=== After Sorting by Marks (Descending) ===");
        students.forEach(System.out::println);
    }
}
```

**Output:**
```
=== Before Sorting ===
Student{id=1, name='Rahul', marks=85.5, age=20}
Student{id=2, name='Priya', marks=92.3, age=19}
Student{id=3, name='Amit', marks=78.9, age=21}
Student{id=4, name='Sneha', marks=88.7, age=20}

=== After Sorting by Marks (Ascending) ===
Student{id=3, name='Amit', marks=78.9, age=21}
Student{id=1, name='Rahul', marks=85.5, age=20}
Student{id=4, name='Sneha', marks=88.7, age=20}
Student{id=2, name='Priya', marks=92.3, age=19}

=== After Sorting by Marks (Descending) ===
Student{id=2, name='Priya', marks=92.3, age=19}
Student{id=4, name='Sneha', marks=88.7, age=20}
Student{id=1, name='Rahul', marks=85.5, age=20}
Student{id=3, name='Amit', marks=78.9, age=21}
```

### Example 2: Sort by Multiple Fields 🎯

```java
import java.util.ArrayList;
import java.util.Comparator;
import java.util.stream.Collectors;

public class MultiFieldSorting {
    public static void main(String[] args) {
        ArrayList<Student> students = new ArrayList<>();
        students.add(new Student(1, "Rahul", 85.5, 20));
        students.add(new Student(2, "Priya", 92.3, 19));
        students.add(new Student(3, "Amit", 85.5, 21));  // Same marks as Rahul
        students.add(new Student(4, "Sneha", 88.7, 20));
        
        System.out.println("=== Before Sorting ===");
        students.forEach(System.out::println);
        
        // Sort by marks first, then by age (using Stream)
        ArrayList<Student> sortedStudents = students.stream()
                .sorted(Comparator.comparing(Student::getMarks)
                        .thenComparing(Student::getAge))
                .collect(Collectors.toCollection(ArrayList::new));
        
        System.out.println("\n=== After Sorting by Marks then Age ===");
        sortedStudents.forEach(System.out::println);
        
        // Sort by name first, then by marks (descending)
        students.sort(Comparator.comparing(Student::getName)
                .thenComparing(Student::getMarks, Comparator.reverseOrder()));
        
        System.out.println("\n=== After Sorting by Name then Marks (Desc) ===");
        students.forEach(System.out::println);
    }
}
```

**Output:**
```
=== Before Sorting ===
Student{id=1, name='Rahul', marks=85.5, age=20}
Student{id=2, name='Priya', marks=92.3, age=19}
Student{id=3, name='Amit', marks=85.5, age=21}
Student{id=4, name='Sneha', marks=88.7, age=20}

=== After Sorting by Marks then Age ===
Student{id=1, name='Rahul', marks=85.5, age=20}
Student{id=3, name='Amit', marks=85.5, age=21}
Student{id=4, name='Sneha', marks=88.7, age=20}
Student{id=2, name='Priya', marks=92.3, age=19}

=== After Sorting by Name then Marks (Desc) ===
Student{id=3, name='Amit', marks=85.5, age=21}
Student{id=2, name='Priya', marks=92.3, age=19}
Student{id=1, name='Rahul', marks=85.5, age=20}
Student{id=4, name='Sneha', marks=88.7, age=20}
```

## Employee Management System Example 👔

### Employee Class:

```java
class Employee {
    private int empId;
    private String name;
    private String department;
    private double salary;
    
    public Employee(int empId, String name, String department, double salary) {
        this.empId = empId;
        this.name = name;
        this.department = department;
        this.salary = salary;
    }
    
    // Getters
    public int getEmpId() { return empId; }
    public String getName() { return name; }
    public String getDepartment() { return department; }
    public double getSalary() { return salary; }
    
    @Override
    public String toString() {
        return String.format("Employee{id=%d, name='%s', dept='%s', salary=%.2f}", 
                           empId, name, department, salary);
    }
}
```

### Comprehensive Sorting Examples:

```java
import java.util.ArrayList;
import java.util.Comparator;
import java.util.stream.Collectors;

public class EmployeeSortingSystem {
    public static void main(String[] args) {
        ArrayList<Employee> employees = new ArrayList<>();
        employees.add(new Employee(101, "John", "IT", 75000));
        employees.add(new Employee(102, "Alice", "HR", 65000));
        employees.add(new Employee(103, "Bob", "IT", 80000));
        employees.add(new Employee(104, "Carol", "Finance", 70000));
        employees.add(new Employee(105, "David", "IT", 75000));
        
        System.out.println("=== Original List ===");
        employees.forEach(System.out::println);
        
        // 1. Sort by Salary (Ascending)
        System.out.println("\n=== Sort by Salary (Ascending) ===");
        employees.stream()
                .sorted(Comparator.comparing(Employee::getSalary))
                .forEach(System.out::println);
        
        // 2. Sort by Department, then by Salary (Descending)
        System.out.println("\n=== Sort by Department, then Salary (Desc) ===");
        employees.stream()
                .sorted(Comparator.comparing(Employee::getDepartment)
                        .thenComparing(Employee::getSalary, Comparator.reverseOrder()))
                .forEach(System.out::println);
        
        // 3. Sort by Name (Alphabetical)
        System.out.println("\n=== Sort by Name (Alphabetical) ===");
        employees.stream()
                .sorted(Comparator.comparing(Employee::getName))
                .forEach(System.out::println);
        
        // 4. Top 3 Highest Paid Employees
        System.out.println("\n=== Top 3 Highest Paid Employees ===");
        employees.stream()
                .sorted(Comparator.comparing(Employee::getSalary).reversed())
                .limit(3)
                .forEach(System.out::println);
        
        // 5. IT Department Employees sorted by Salary
        System.out.println("\n=== IT Department Employees (by Salary) ===");
        employees.stream()
                .filter(emp -> emp.getDepartment().equals("IT"))
                .sorted(Comparator.comparing(Employee::getSalary))
                .forEach(System.out::println);
    }
}
```

## Advanced Sorting Techniques 🚀

### 1. Custom Comparator with Complex Logic

```java
import java.util.ArrayList;
import java.util.Comparator;

class Product {
    private String name;
    private double price;
    private int rating;
    private boolean inStock;
    
    public Product(String name, double price, int rating, boolean inStock) {
        this.name = name;
        this.price = price;
        this.rating = rating;
        this.inStock = inStock;
    }
    
    // Getters
    public String getName() { return name; }
    public double getPrice() { return price; }
    public int getRating() { return rating; }
    public boolean isInStock() { return inStock; }
    
    @Override
    public String toString() {
        return String.format("Product{name='%s', price=%.2f, rating=%d, inStock=%s}", 
                           name, price, rating, inStock);
    }
}

public class ProductSorting {
    public static void main(String[] args) {
        ArrayList<Product> products = new ArrayList<>();
        products.add(new Product("Laptop", 50000, 4, true));
        products.add(new Product("Mouse", 1000, 5, false));
        products.add(new Product("Keyboard", 2500, 4, true));
        products.add(new Product("Monitor", 15000, 5, true));
        products.add(new Product("Headphones", 3000, 3, false));
        
        // Custom sorting: In-stock first, then by rating (desc), then by price (asc)
        Comparator<Product> customComparator = Comparator
                .comparing(Product::isInStock, Comparator.reverseOrder()) // In-stock first
                .thenComparing(Product::getRating, Comparator.reverseOrder()) // Higher rating first
                .thenComparing(Product::getPrice); // Lower price first
        
        System.out.println("=== Custom Sorting: Stock > Rating > Price ===");
        products.stream()
                .sorted(customComparator)
                .forEach(System.out::println);
    }
}
```

### 2. Null-Safe Sorting

```java
import java.util.ArrayList;
import java.util.Comparator;

class Person {
    private String name;
    private Integer age;  // Can be null
    
    public Person(String name, Integer age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public Integer getAge() { return age; }
    
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}

public class NullSafeSorting {
    public static void main(String[] args) {
        ArrayList<Person> people = new ArrayList<>();
        people.add(new Person("Alice", 25));
        people.add(new Person("Bob", null));  // Null age
        people.add(new Person("Charlie", 30));
        people.add(new Person("Diana", null)); // Null age
        people.add(new Person("Eve", 22));
        
        System.out.println("=== Original List ===");
        people.forEach(System.out::println);
        
        // Null-safe sorting: nulls last, then by age
        System.out.println("\n=== Null-Safe Sorting (Nulls Last) ===");
        people.stream()
                .sorted(Comparator.comparing(Person::getAge, 
                        Comparator.nullsLast(Comparator.naturalOrder())))
                .forEach(System.out::println);
        
        // Null-safe sorting: nulls first, then by age
        System.out.println("\n=== Null-Safe Sorting (Nulls First) ===");
        people.stream()
                .sorted(Comparator.comparing(Person::getAge, 
                        Comparator.nullsFirst(Comparator.naturalOrder())))
                .forEach(System.out::println);
    }
}
```

## Performance Comparison 📈

### Speed Test Example:

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Random;
import java.util.stream.Collectors;

public class SortingPerformanceTest {
    public static void main(String[] args) {
        // Create large dataset
        ArrayList<Integer> numbers = new ArrayList<>();
        Random random = new Random();
        
        for (int i = 0; i < 100000; i++) {
            numbers.add(random.nextInt(1000000));
        }
        
        // Test Collections.sort()
        ArrayList<Integer> list1 = new ArrayList<>(numbers);
        long startTime = System.currentTimeMillis();
        Collections.sort(list1);
        long endTime = System.currentTimeMillis();
        System.out.println("Collections.sort() time: " + (endTime - startTime) + "ms");
        
        // Test ArrayList.sort()
        ArrayList<Integer> list2 = new ArrayList<>(numbers);
        startTime = System.currentTimeMillis();
        list2.sort(Comparator.naturalOrder());
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList.sort() time: " + (endTime - startTime) + "ms");
        
        // Test Stream.sorted()
        ArrayList<Integer> list3 = new ArrayList<>(numbers);
        startTime = System.currentTimeMillis();
        ArrayList<Integer> sortedList = list3.stream()
                .sorted()
                .collect(Collectors.toCollection(ArrayList::new));
        endTime = System.currentTimeMillis();
        System.out.println("Stream.sorted() time: " + (endTime - startTime) + "ms");
    }
}
```

**Typical Results:**
```
Collections.sort() time: 15ms
ArrayList.sort() time: 16ms
Stream.sorted() time: 25ms
```

## Common Mistakes & Solutions ❌➡️✅

### Mistake 1: Modifying List During Sorting

```java
// ❌ Wrong - Don't modify original list in stream
list.stream()
    .sorted()
    .forEach(item -> list.add(item + "modified")); // ConcurrentModificationException

// ✅ Correct - Collect to new list
List<String> sortedList = list.stream()
    .sorted()
    .map(item -> item + "modified")
    .collect(Collectors.toList());
```

### Mistake 2: Null Values in Comparator

```java
// ❌ Wrong - Will throw NullPointerException
list.sort(Comparator.comparing(Person::getName));

// ✅ Correct - Handle nulls
list.sort(Comparator.comparing(Person::getName, 
          Comparator.nullsFirst(String::compareTo)));
```

### Mistake 3: Not Using Method References

```java
// ❌ Verbose way
list.sort((p1, p2) -> p1.getName().compareTo(p2.getName()));

// ✅ Clean way
list.sort(Comparator.comparing(Person::getName));
```

## Best Practices 🌟

### 1. Choose Right Method for Right Scenario

```java
// For simple sorting - Collections.sort()
Collections.sort(list);

// For custom object sorting - ArrayList.sort() with Comparator
list.sort(Comparator.comparing(Employee::getSalary));

// For complex processing with sorting - Stream API
List<String> result = list.stream()
    .filter(item -> item.length() > 5)
    .sorted()
    .map(String::toUpperCase)
    .collect(Collectors.toList());
```

### 2. Create Reusable Comparators

```java
public class StudentComparators {
    public static final Comparator<Student> BY_NAME = 
        Comparator.comparing(Student::getName);
    
    public static final Comparator<Student> BY_MARKS_DESC = 
        Comparator.comparing(Student::getMarks).reversed();
    
    public static final Comparator<Student> BY_NAME_THEN_MARKS = 
        BY_NAME.thenComparing(Student::getMarks);
}

// Usage
students.sort(StudentComparators.BY_NAME_THEN_MARKS);
```

### 3. Use Proper Null Handling

```java
// Always handle potential nulls
Comparator<Person> safeComparator = Comparator
    .comparing(Person::getName, Comparator.nullsFirst(String::compareTo))
    .thenComparing(Person::getAge, Comparator.nullsLast(Integer::compareTo));
```

## Interview Questions - Master Karo! 💪

### Q1: **What's the difference between Collections.sort() and ArrayList.sort()?**

**Answer:**
- **Collections.sort()**: Static method, works with any List implementation, available since Java 1.2
- **ArrayList.sort()**: Instance method, specific to ArrayList, available since Java 8

```java
// Both do the same thing internally
Collections.sort(list, comparator);  // Static call
list.sort(comparator);               // Instance call
```

### Q2: **How to sort by multiple fields?**

**Answer:**
```java
// Using thenComparing()
students.sort(Comparator
    .comparing(Student::getDepartment)           // First criteria
    .thenComparing(Student::getMarks).reversed() // Second criteria
    .thenComparing(Student::getName));           // Third criteria
```

### Q3: **What happens if we don't implement Comparable?**

```java
class Person {
    String name;
    // No Comparable implementation
}

// This will throw ClassCastException
List<Person> people = Arrays.asList(new Person("Alice"), new Person("Bob"));
Collections.sort(people); // ❌ Exception!

// ✅ Solution: Use Comparator
Collections.sort(people, Comparator.comparing(p -> p.name));
```

### Q4: **How to handle null values in sorting?**

**Answer:**
```java
// nullsFirst() - nulls come first
list.sort(Comparator.comparing(Person::getName, 
          Comparator.nullsFirst(String::compareTo)));

// nullsLast() - nulls come last  
list.sort(Comparator.comparing(Person::getName, 
          Comparator.nullsLast(String::compareTo)));
```

### Q5: **Performance comparison of different sorting methods?**

**Answer:**
- **Collections.sort()**: Fastest, uses Arrays.sort() internally
- **ArrayList.sort()**: Same performance as Collections.sort()
- **Stream.sorted()**: Slightly slower due to stream overhead, but more readable

## Quick Reference Card 📋

### Common Sorting Patterns:

```java
// 1. Natural order
list.sort(Comparator.naturalOrder());
Collections.sort(list);

// 2. Reverse order
list.sort(Comparator.reverseOrder());
Collections.sort(list, Collections.reverseOrder());

// 3. By single field
list.sort(Comparator.comparing(Employee::getSalary));

// 4. By multiple fields
list.sort(Comparator.comparing(Employee::getDept)
          .thenComparing(Employee::getSalary).reversed());

// 5. With null handling
list.sort(Comparator.comparing(Employee::getName, 
          Comparator.nullsLast(String::compareTo)));

// 6. Stream sorting
List<Employee> sorted = list.stream()
    .sorted(Comparator.comparing(Employee::getSalary))
    .collect(Collectors.toList());
```

## Summary - Quick Recap! 📝

### **When to Use What?**

| **Scenario** | **Best Method** | **Reason** |
|-------------|----------------|------------|
| Simple primitive sorting | `Collections.sort()` | Fastest, simplest |
| Custom object single field | `list.sort(Comparator.comparing())` | Modern, readable |
| Multiple field sorting | `Comparator.comparing().thenComparing()` | Chainable, clear |
| Complex processing + sorting | `Stream.sorted()` | Functional style |
| Null values present | Use `nullsFirst()/nullsLast()` | Safe handling |
| Performance critical | `Collections.sort()` | Fastest |

### **Key Takeaways:**
1. 🎯 **Collections.sort()** - Traditional but fastest
2. 🆕 **ArrayList.sort()** - Modern Java 8 approach
3. 🌊 **Stream.sorted()** - Functional programming style
4. 🔗 **Method chaining** - Use `thenComparing()` for multiple criteria
5. 🛡️ **Null safety** - Always handle potential nulls
6. 📊 **Performance** - Collections.sort() > ArrayList.sort() > Stream.sorted()

### **Memory Tricks:**
- **Collections** = **C**lassic approach 🏛️
- **ArrayList** = **A**dvanced Java 8+ 🚀  
- **Stream** = **S**mart functional way 🧠

Practice these concepts aur tumhara sorting game strong ho jaayega! 💪🚀

---
*Happy Coding! 🎉*
