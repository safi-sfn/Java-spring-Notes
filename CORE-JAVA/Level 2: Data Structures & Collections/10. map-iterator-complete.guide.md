# Map Iteration in Java - Complete Study Notes üó∫Ô∏è

## Map Kya Hai Bhai? ü§î

**Simple Definition**: Map ek key-value pair store karne wala data structure hai!

**Real Life Example**: Jaise phone book mein naam (key) aur number (value) hota hai! üìû

**Technical Definition**: Map ek interface hai java.util package mein jo key-value pairs store karta hai.

## Map Ki Basic Information üìö

```java
import java.util.*;

public class MapBasics {
    public static void main(String[] args) {
        // Creating different types of Maps
        Map<Integer, String> hashMap = new HashMap<>();
        Map<Integer, String> treeMap = new TreeMap<>();
        Map<Integer, String> linkedHashMap = new LinkedHashMap<>();
        
        // Adding data
        hashMap.put(1, "Peter");
        hashMap.put(2, "Robert");
        hashMap.put(3, "William");
        hashMap.put(4, "John");
        
        System.out.println("Map created: " + hashMap);
    }
}
```

**Output:**
```
Map created: {1=Peter, 2=Robert, 3=William, 4=John}
```

## Map Iterate Karne Ke 6 Tarike! üöÄ

### Method 1: **Iterator Use Karo** (Traditional Way) üîÑ

```java
import java.util.*;

public class IteratorMethod {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "Peter");
        map.put(2, "Robert");
        map.put(3, "William");
        map.put(4, "John");
        
        System.out.println("=== Using Iterator ===");
        
        // Method 1a: entrySet() with Iterator
        Iterator<Map.Entry<Integer, String>> itr = map.entrySet().iterator();
        while (itr.hasNext()) {
            Map.Entry<Integer, String> entry = itr.next();
            System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
        }
        
        System.out.println("\n=== Using Iterator - Keys Only ===");
        
        // Method 1b: keySet() with Iterator  
        Iterator<Integer> keyIterator = map.keySet().iterator();
        while (keyIterator.hasNext()) {
            Integer key = keyIterator.next();
            String value = map.get(key);
            System.out.println("Key = " + key + ", Value = " + value);
        }
        
        System.out.println("\n=== Using Iterator - Values Only ===");
        
        // Method 1c: values() with Iterator
        Iterator<String> valueIterator = map.values().iterator();
        while (valueIterator.hasNext()) {
            String value = valueIterator.next();
            System.out.println("Value = " + value);
        }
    }
}
```

**Output:**
```
=== Using Iterator ===
Key = 1, Value = Peter
Key = 2, Value = Robert
Key = 3, Value = William
Key = 4, Value = John

=== Using Iterator - Keys Only ===
Key = 1, Value = Peter
Key = 2, Value = Robert
Key = 3, Value = William
Key = 4, Value = John

=== Using Iterator - Values Only ===
Value = Peter
Value = Robert
Value = William
Value = John
```

**Pros & Cons:**
- ‚úÖ **Pros**: Safe removal during iteration, works with old Java versions
- ‚ùå **Cons**: Verbose code, more lines required

### Method 2: **Enhanced For Loop** (Most Popular) üî•

```java
import java.util.*;

public class EnhancedForLoop {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "Peter");
        map.put(2, "Robert");
        map.put(3, "William");
        map.put(4, "John");
        
        System.out.println("=== Enhanced For Loop - entrySet() ===");
        
        // Method 2a: Using entrySet()
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue());
        }
        
        System.out.println("\n=== Enhanced For Loop - keySet() ===");
        
        // Method 2b: Using keySet()
        for (Integer key : map.keySet()) {
            String value = map.get(key);
            System.out.println("Key = " + key + ", Value = " + value);
        }
        
        System.out.println("\n=== Enhanced For Loop - values() ===");
        
        // Method 2c: Using values()  
        for (String value : map.values()) {
            System.out.println("Value = " + value);
        }
    }
}
```

**Output:**
```
=== Enhanced For Loop - entrySet() ===
Key = 1, Value = Peter
Key = 2, Value = Robert
Key = 3, Value = William
Key = 4, Value = John

=== Enhanced For Loop - keySet() ===
Key = 1, Value = Peter
Key = 2, Value = Robert
Key = 3, Value = William
Key = 4, Value = John

=== Enhanced For Loop - values() ===
Value = Peter
Value = Robert
Value = William
Value = John
```

**Pros & Cons:**
- ‚úÖ **Pros**: Clean readable code, less verbose than Iterator
- ‚ùå **Cons**: Cannot remove elements during iteration

### Method 3: **keySet() aur values() Methods** üîë

```java
import java.util.*;

public class KeySetValuesMethod {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "Peter");
        map.put(2, "Robert");
        map.put(3, "William");
        map.put(4, "John");
        
        System.out.println("=== Using keySet() - All Keys ===");
        for (Integer key : map.keySet()) {
            System.out.println("Key: " + key);
        }
        
        System.out.println("\n=== Using values() - All Values ===");
        for (String value : map.values()) {
            System.out.println("Value: " + value);
        }
        
        System.out.println("\n=== Combined - Keys with corresponding Values ===");
        for (Integer key : map.keySet()) {
            System.out.println("Key: " + key + " -> Value: " + map.get(key));
        }
    }
}
```

**Output:**
```
=== Using keySet() - All Keys ===
Key: 1
Key: 2
Key: 3
Key: 4

=== Using values() - All Values ===
Value: Peter
Value: Robert
Value: William
Value: John

=== Combined - Keys with corresponding Values ===
Key: 1 -> Value: Peter
Key: 2 -> Value: Robert
Key: 3 -> Value: William
Key: 4 -> Value: John
```

**When to Use:**
- üéØ **keySet()**: Jab sirf keys chahiye
- üéØ **values()**: Jab sirf values chahiye
- ‚ö†Ô∏è **Note**: keySet() se iterate karte time har key ke liye map.get(key) call karna padta hai

### Method 4: **forEach() Method** (Java 8+) üÜï

```java
import java.util.*;

public class ForEachMethod {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "Peter");
        map.put(2, "Robert");
        map.put(3, "William");
        map.put(4, "John");
        
        System.out.println("=== Using forEach() - Lambda Expression ===");
        
        // Method 4a: Simple lambda
        map.forEach((key, value) -> {
            System.out.println("Key = " + key + ", Value = " + value);
        });
        
        System.out.println("\n=== Using forEach() - Method Reference ===");
        
        // Method 4b: Method reference
        map.forEach((k, v) -> System.out.println("Key = " + k + ", Value = " + v));
        
        System.out.println("\n=== Using forEach() - Complex Logic ===");
        
        // Method 4c: Complex lambda with multiple statements
        map.forEach((key, value) -> {
            if (value.length() > 5) {
                System.out.println("Long name: " + key + " -> " + value);
            } else {
                System.out.println("Short name: " + key + " -> " + value);
            }
        });
        
        System.out.println("\n=== Using forEach() with entrySet() ===");
        
        // Method 4d: forEach with entrySet
        map.entrySet().forEach(entry -> {
            System.out.println("Entry: " + entry.getKey() + " = " + entry.getValue());
        });
        
        System.out.println("\n=== Using forEach() - Only Keys ===");
        
        // Method 4e: forEach with keySet
        map.keySet().forEach(key -> System.out.println("Key: " + key));
        
        System.out.println("\n=== Using forEach() - Only Values ===");
        
        // Method 4f: forEach with values
        map.values().forEach(value -> System.out.println("Value: " + value));
    }
}
```

**Output:**
```
=== Using forEach() - Lambda Expression ===
Key = 1, Value = Peter
Key = 2, Value = Robert
Key = 3, Value = William
Key = 4, Value = John

=== Using forEach() - Method Reference ===
Key = 1, Value = Peter
Key = 2, Value = Robert
Key = 3, Value = William
Key = 4, Value = John

=== Using forEach() - Complex Logic ===
Short name: 1 -> Peter
Long name: 2 -> Robert
Long name: 3 -> William
Short name: 4 -> John

=== Using forEach() - Only Keys ===
Key: 1
Key: 2
Key: 3
Key: 4

=== Using forEach() - Only Values ===
Value: Peter
Value: Robert
Value: William
Value: John
```

**Pros & Cons:**
- ‚úÖ **Pros**: Modern, concise, functional programming style
- ‚úÖ **Pros**: Easy to read and write
- ‚ùå **Cons**: Requires Java 8+, cannot break/continue

### Method 5: **Streams API** (Java 8+) üåä

```java
import java.util.*;
import java.util.stream.Collectors;

public class StreamsMethod {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "Peter");
        map.put(2, "Robert");
        map.put(3, "William");
        map.put(4, "John");
        map.put(5, "Alexander");
        
        System.out.println("=== Streams - Basic Iteration ===");
        
        // Method 5a: Basic stream iteration
        map.entrySet().stream()
            .forEach(entry -> System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()));
        
        System.out.println("\n=== Streams - Filtering ===");
        
        // Method 5b: Filter and iterate
        map.entrySet().stream()
            .filter(entry -> entry.getValue().length() > 5)
            .forEach(entry -> System.out.println("Long name: " + entry.getKey() + " -> " + entry.getValue()));
        
        System.out.println("\n=== Streams - Mapping ===");
        
        // Method 5c: Transform and collect
        List<String> upperCaseValues = map.values().stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());
        System.out.println("Uppercase values: " + upperCaseValues);
        
        System.out.println("\n=== Streams - Sorting ===");
        
        // Method 5d: Sort by key and iterate
        map.entrySet().stream()
            .sorted(Map.Entry.comparingByKey())
            .forEach(entry -> System.out.println("Sorted by Key: " + entry.getKey() + " -> " + entry.getValue()));
        
        System.out.println("\n=== Streams - Sort by Value ===");
        
        // Method 5e: Sort by value and iterate
        map.entrySet().stream()
            .sorted(Map.Entry.comparingByValue())
            .forEach(entry -> System.out.println("Sorted by Value: " + entry.getKey() + " -> " + entry.getValue()));
        
        System.out.println("\n=== Streams - Count and Statistics ===");
        
        // Method 5f: Count elements
        long count = map.entrySet().stream()
            .filter(entry -> entry.getValue().startsWith("J"))
            .count();
        System.out.println("Names starting with 'J': " + count);
        
        // Method 5g: Find first
        Optional<Map.Entry<Integer, String>> first = map.entrySet().stream()
            .filter(entry -> entry.getValue().contains("e"))
            .findFirst();
        if (first.isPresent()) {
            System.out.println("First name containing 'e': " + first.get().getValue());
        }
    }
}
```

**Output:**
```
=== Streams - Basic Iteration ===
Key = 1, Value = Peter
Key = 2, Value = Robert
Key = 3, Value = William
Key = 4, Value = John
Key = 5, Value = Alexander

=== Streams - Filtering ===
Long name: 2 -> Robert
Long name: 3 -> William
Long name: 5 -> Alexander

=== Streams - Mapping ===
Uppercase values: [PETER, ROBERT, WILLIAM, JOHN, ALEXANDER]

=== Streams - Sorting ===
Sorted by Key: 1 -> Peter
Sorted by Key: 2 -> Robert
Sorted by Key: 3 -> William
Sorted by Key: 4 -> John
Sorted by Key: 5 -> Alexander

=== Streams - Sort by Value ===
Sorted by Value: 5 -> Alexander
Sorted by Value: 4 -> John
Sorted by Value: 1 -> Peter
Sorted by Value: 2 -> Robert
Sorted by Value: 3 -> William

=== Streams - Count and Statistics ===
Names starting with 'J': 1
First name containing 'e': Peter
```

### Method 6: **Traditional For Loop** (Index-based) üìä

```java
import java.util.*;

public class TraditionalForLoop {
    public static void main(String[] args) {
        Map<Integer, String> map = new LinkedHashMap<>(); // LinkedHashMap for consistent order
        map.put(1, "Peter");
        map.put(2, "Robert");
        map.put(3, "William");
        map.put(4, "John");
        
        System.out.println("=== Traditional For Loop - Convert to Arrays ===");
        
        // Convert to arrays for index-based access
        Integer[] keys = map.keySet().toArray(new Integer[0]);
        String[] values = map.values().toArray(new String[0]);
        
        for (int i = 0; i < keys.length; i++) {
            System.out.println("Index " + i + ": Key = " + keys[i] + ", Value = " + values[i]);
        }
        
        System.out.println("\n=== Traditional For Loop - ArrayList Conversion ===");
        
        // Convert to ArrayList for index-based access
        List<Map.Entry<Integer, String>> entryList = new ArrayList<>(map.entrySet());
        
        for (int i = 0; i < entryList.size(); i++) {
            Map.Entry<Integer, String> entry = entryList.get(i);
            System.out.println("Index " + i + ": Key = " + entry.getKey() + ", Value = " + entry.getValue());
        }
    }
}
```

## Performance Comparison üèÉ‚Äç‚ôÇÔ∏è

```java
import java.util.*;

public class PerformanceTest {
    public static void main(String[] args) {
        // Create a large map for testing
        Map<Integer, String> largeMap = new HashMap<>();
        for (int i = 0; i < 100000; i++) {
            largeMap.put(i, "Value" + i);
        }
        
        System.out.println("Map size: " + largeMap.size());
        
        // Test different iteration methods
        testIterator(largeMap);
        testEnhancedForLoop(largeMap);
        testKeySet(largeMap);
        testForEach(largeMap);
        testStreams(largeMap);
    }
    
    public static void testIterator(Map<Integer, String> map) {
        long startTime = System.currentTimeMillis();
        
        Iterator<Map.Entry<Integer, String>> itr = map.entrySet().iterator();
        int count = 0;
        while (itr.hasNext()) {
            Map.Entry<Integer, String> entry = itr.next();
            count++;
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("Iterator method: " + (endTime - startTime) + " ms, Count: " + count);
    }
    
    public static void testEnhancedForLoop(Map<Integer, String> map) {
        long startTime = System.currentTimeMillis();
        
        int count = 0;
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            count++;
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("Enhanced For Loop: " + (endTime - startTime) + " ms, Count: " + count);
    }
    
    public static void testKeySet(Map<Integer, String> map) {
        long startTime = System.currentTimeMillis();
        
        int count = 0;
        for (Integer key : map.keySet()) {
            String value = map.get(key); // Extra lookup cost
            count++;
        }
        
        long endTime = System.currentTimeMillis();
        System.out.println("KeySet method: " + (endTime - startTime) + " ms, Count: " + count);
    }
    
    public static void testForEach(Map<Integer, String> map) {
        long startTime = System.currentTimeMillis();
        
        final int[] count = {0}; // Using array for lambda
        map.forEach((k, v) -> count[0]++);
        
        long endTime = System.currentTimeMillis();
        System.out.println("forEach method: " + (endTime - startTime) + " ms, Count: " + count[0]);
    }
    
    public static void testStreams(Map<Integer, String> map) {
        long startTime = System.currentTimeMillis();
        
        long count = map.entrySet().stream().count();
        
        long endTime = System.currentTimeMillis();
        System.out.println("Streams method: " + (endTime - startTime) + " ms, Count: " + count);
    }
}
```

## Real-World Examples üåç

### Example 1: Student Grade Management üéì

```java
import java.util.*;

public class StudentGradeManager {
    public static void main(String[] args) {
        Map<String, Integer> studentGrades = new HashMap<>();
        studentGrades.put("Rahul", 85);
        studentGrades.put("Priya", 92);
        studentGrades.put("Amit", 78);
        studentGrades.put("Sneha", 95);
        studentGrades.put("Vikash", 88);
        
        System.out.println("=== All Student Grades ===");
        studentGrades.forEach((name, grade) -> 
            System.out.println(name + ": " + grade + " (" + getGradeLetter(grade) + ")"));
        
        System.out.println("\n=== Top Performers (Grade >= 90) ===");
        studentGrades.entrySet().stream()
            .filter(entry -> entry.getValue() >= 90)
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .forEach(entry -> System.out.println(entry.getKey() + ": " + entry.getValue()));
        
        System.out.println("\n=== Average Grade ===");
        double average = studentGrades.values().stream()
            .mapToInt(Integer::intValue)
            .average()
            .orElse(0.0);
        System.out.println("Class Average: " + String.format("%.2f", average));
        
        System.out.println("\n=== Grade Distribution ===");
        Map<String, Long> gradeDistribution = studentGrades.values().stream()
            .collect(HashMap::new,
                (map, grade) -> map.merge(getGradeLetter(grade), 1L, Long::sum),
                (map1, map2) -> { map2.forEach((k, v) -> map1.merge(k, v, Long::sum)); return map1; });
        
        gradeDistribution.forEach((grade, count) -> 
            System.out.println("Grade " + grade + ": " + count + " students"));
    }
    
    public static String getGradeLetter(int grade) {
        if (grade >= 90) return "A";
        else if (grade >= 80) return "B";
        else if (grade >= 70) return "C";
        else if (grade >= 60) return "D";
        else return "F";
    }
}
```

### Example 2: Word Frequency Counter üìä

```java
import java.util.*;
import java.util.stream.Collectors;

public class WordFrequencyCounter {
    public static void main(String[] args) {
        String text = "Java is great. Java is powerful. Java is everywhere. " +
                     "Programming in Java is fun. Java developers love Java.";
        
        // Count word frequency
        Map<String, Integer> wordCount = new HashMap<>();
        String[] words = text.toLowerCase().replaceAll("[^a-zA-Z\\s]", "").split("\\s+");
        
        // Method 1: Using traditional approach
        for (String word : words) {
            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
        }
        
        System.out.println("=== Word Frequency (Traditional) ===");
        wordCount.entrySet().stream()
            .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
            .forEach(entry -> System.out.println(entry.getKey() + ": " + entry.getValue()));
        
        // Method 2: Using Streams
        System.out.println("\n=== Word Frequency (Streams) ===");
        Map<String, Long> streamWordCount = Arrays.stream(words)
            .collect(Collectors.groupingBy(
                word -> word,
                Collectors.counting()
            ));
        
        streamWordCount.entrySet().stream()
            .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
            .forEach(entry -> System.out.println(entry.getKey() + ": " + entry.getValue()));
        
        System.out.println("\n=== Most Common Words (frequency > 2) ===");
        streamWordCount.entrySet().stream()
            .filter(entry -> entry.getValue() > 2)
            .sorted(Map.Entry.<String, Long>comparingByValue().reversed())
            .forEach(entry -> System.out.println("\"" + entry.getKey() + "\" appears " + entry.getValue() + " times"));
    }
}
```

### Example 3: Configuration Manager ‚öôÔ∏è

```java
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

public class ConfigurationManager {
    private final Map<String, String> config;
    
    public ConfigurationManager() {
        config = new ConcurrentHashMap<>(); // Thread-safe
        loadDefaultConfig();
    }
    
    private void loadDefaultConfig() {
        config.put("database.url", "jdbc:mysql://localhost:3306/mydb");
        config.put("database.username", "admin");
        config.put("database.password", "secret123");
        config.put("server.port", "8080");
        config.put("server.host", "localhost");
        config.put("app.name", "MyApplication");
        config.put("app.version", "1.0.0");
        config.put("logging.level", "INFO");
        config.put("cache.enabled", "true");
        config.put("cache.size", "1000");
    }
    
    public void displayAllConfigs() {
        System.out.println("=== All Configuration Settings ===");
        config.entrySet().stream()
            .sorted(Map.Entry.comparingByKey())
            .forEach(entry -> System.out.println(entry.getKey() + " = " + entry.getValue()));
    }
    
    public void displayDatabaseConfig() {
        System.out.println("\n=== Database Configuration ===");
        config.entrySet().stream()
            .filter(entry -> entry.getKey().startsWith("database."))
            .forEach(entry -> System.out.println(entry.getKey() + " = " + 
                (entry.getKey().contains("password") ? "****" : entry.getValue())));
    }
    
    public void displayServerConfig() {
        System.out.println("\n=== Server Configuration ===");
        config.keySet().stream()
            .filter(key -> key.startsWith("server."))
            .sorted()
            .forEach(key -> System.out.println(key + " = " + config.get(key)));
    }
    
    public void updateConfig(String key, String value) {
        String oldValue = config.put(key, value);
        System.out.println("Updated " + key + ": " + oldValue + " -> " + value);
    }
    
    public static void main(String[] args) {
        ConfigurationManager manager = new ConfigurationManager();
        
        manager.displayAllConfigs();
        manager.displayDatabaseConfig();
        manager.displayServerConfig();
        
        // Update configuration
        System.out.println("\n=== Updating Configuration ===");
        manager.updateConfig("server.port", "9090");
        manager.updateConfig("logging.level", "DEBUG");
        
        manager.displayServerConfig();
    }
}
```

## When to Use Which Method? ü§î

| **Method** | **When to Use** | **Pros** | **Cons** |
|------------|-----------------|----------|----------|
| **Iterator** | Legacy code, need safe removal | Thread-safe removal, works in old Java | Verbose, more code |
| **Enhanced For Loop** | General purpose, readable code | Clean syntax, easy to read | Cannot remove elements |
| **keySet()/values()** | Need only keys or values | Simple for specific needs | Extra map.get() calls for keySet |
| **forEach()** | Modern code, functional style | Concise, functional programming | Requires Java 8+, no break/continue |
| **Streams** | Complex operations, filtering, sorting | Powerful operations, chainable | Performance overhead, requires Java 8+ |
| **Traditional For** | Index-based access needed | Full control over iteration | Need conversion to arrays/lists |

## Performance Tips üöÄ

### 1. **Choose Right Method Based on Use Case**
```java
// ‚úÖ Good - When you need both key and value
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    System.out.println(entry.getKey() + " = " + entry.getValue());
}

// ‚ùå Avoid - When you need both key and value
for (Integer key : map.keySet()) {
    System.out.println(key + " = " + map.get(key)); // Extra lookup!
}
```

### 2. **Use entrySet() for Key-Value Pairs**
```java
// ‚úÖ Efficient - One iteration, no extra lookups
map.entrySet().forEach(entry -> {
    process(entry.getKey(), entry.getValue());
});

// ‚ùå Inefficient - Extra map.get() call for each key
map.keySet().forEach(key -> {
    process(key, map.get(key)); // Extra lookup!
});
```

### 3. **Parallel Streams for Large Data**
```java
// For large maps (> 10,000 entries)
largeMap.entrySet().parallelStream()
    .filter(entry -> complexCondition(entry))
    .forEach(entry -> processEntry(entry));
```

## Common Mistakes - Avoid Karo! ‚ùå

### 1. **ConcurrentModificationException**
```java
// ‚ùå Wrong - Will throw ConcurrentModificationException
Map<Integer, String> map = new HashMap<>();
map.put(1, "One");
map.put(2, "Two");

for (Map.Entry<Integer, String> entry : map.entrySet()) {
    if (entry.getKey() == 1) {
        map.remove(1); // ‚ùå ERROR!
    }
}

// ‚úÖ Correct - Use Iterator for safe removal
Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<Integer, String> entry = iterator.next();
    if (entry.getKey() == 1) {
        iterator.remove(); // ‚úÖ Safe removal
    }
}
```

### 2. **Null Pointer Exception**
```java
Map<String, String> map = new HashMap<>();
map.put("key1", null);
map.put(null, "value");

// ‚ùå Wrong - Can cause NullPointerException
for (Map.Entry<String, String> entry : map.entrySet()) {
    System.out.println(entry.getKey().length()); // ‚ùå NPE if key is null
    System.out.println(entry.getValue().length()); // ‚ùå NPE if value is null
}

// ‚úÖ Correct - Null checks
for (Map.Entry<String, String> entry : map.entrySet()) {
    String key = entry.getKey();
    String value = entry.getValue();
    
    System.out.println("Key: " + (key != null ? key : "null"));
    System.out.println("Value: " + (value != null ? value : "null"));
}
```

### 3. **Inefficient keySet() Usage**
```java
// ‚ùå Inefficient - O(n) lookups
for (String key : map.keySet()) {
    String value = map.get(key); // Each get() is a lookup operation
    System.out.println(key + " = " + value);
}

// ‚úÖ Efficient - O(1) access
for (Map.Entry<String, String> entry : map.entrySet()) {
    String key = entry.getKey();
    String value = entry.getValue();
    System.out.println(key + " = " + value);
}
```

## Interview Questions - Master Karo! üí™

### Q1: **What are different ways to iterate a Map in Java?**
**Answer:**
1. **Iterator** - Traditional approach with safe removal
2. **Enhanced For Loop** - Most readable and commonly used
3. **keySet()/values()** - When you need only keys or values
4. **forEach()** - Modern functional approach (Java 8+)
5. **Streams API** - For complex operations and transformations
6. **Traditional For Loop** - When index-based access needed

### Q2: **Which is more efficient: keySet() or entrySet()?**
```java
// Performance comparison
Map<Integer, String> map = new HashMap<>();
// ... populate map

// ‚ùå Less efficient - O(n) extra lookups
for (Integer key : map.keySet()) {
    String value = map.get(key); // Extra HashMap lookup
}

// ‚úÖ More efficient - No extra lookups
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    Integer key = entry.getKey();
    String value = entry.getValue();
}
```
**Answer**: `entrySet()` is more efficient when you need both key and value because it avoids extra `get()` calls.

### Q3: **How to safely remove elements while iterating?**
```java
// ‚úÖ Safe way - Using Iterator
Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<Integer, String> entry = iterator.next();
    if (shouldRemove(entry)) {
        iterator.remove(); // Safe removal
    }
}

// ‚úÖ Alternative - Collect keys to remove, then remove
List<Integer> keysToRemove = new ArrayList<>();
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    if (shouldRemove(entry)) {
        keysToRemove.add(entry.getKey());
    }
}
keysToRemove.forEach(map::remove);
```

### Q4: **Difference between forEach() and Stream?**
```java
// forEach() - Terminal operation, no return
map.forEach((k, v) -> System.out.println(k + "=" + v));

// Stream - Can chain operations, returns Stream
List<String> result = map.entrySet().stream()
    .filter(entry -> entry.getValue().length() > 5)
    .map(entry -> entry.getValue().toUpperCase())
    .collect(Collectors.toList());
```

### Q5: **How to iterate TreeMap vs HashMap?**
```java
// HashMap - No guaranteed order
Map<Integer, String> hashMap = new HashMap<>();

// TreeMap - Sorted by keys
Map<Integer, String> treeMap = new TreeMap<>();

// LinkedHashMap - Insertion order maintained
Map<Integer, String> linkedHashMap = new LinkedHashMap<>();

// Iteration code is same for all, but order differs
```

## Advanced Iteration Techniques üöÄ

### 1. **Parallel Processing with Streams**
```java
import java.util.*;
import java.util.stream.Collectors;

public class ParallelIteration {
    public static void main(String[] args) {
        // Create large map
        Map<Integer, String> largeMap = new HashMap<>();
        for (int i = 0; i < 1000000; i++) {
            largeMap.put(i, "Value" + i);
        }
        
        System.out.println("=== Sequential vs Parallel Processing ===");
        
        // Sequential processing
        long startTime = System.currentTimeMillis();
        List<String> sequentialResult = largeMap.entrySet().stream()
            .filter(entry -> entry.getKey() % 2 == 0)
            .map(entry -> entry.getValue().toUpperCase())
            .collect(Collectors.toList());
        long sequentialTime = System.currentTimeMillis() - startTime;
        
        // Parallel processing
        startTime = System.currentTimeMillis();
        List<String> parallelResult = largeMap.entrySet().parallelStream()
            .filter(entry -> entry.getKey() % 2 == 0)
            .map(entry -> entry.getValue().toUpperCase())
            .collect(Collectors.toList());
        long parallelTime = System.currentTimeMillis() - startTime;
        
        System.out.println("Sequential time: " + sequentialTime + " ms");
        System.out.println("Parallel time: " + parallelTime + " ms");
        System.out.println("Results equal: " + (sequentialResult.size() == parallelResult.size()));
    }
}
```

### 2. **Custom Iteration with Functional Interfaces**
```java
import java.util.*;
import java.util.function.BiConsumer;
import java.util.function.BiPredicate;

public class CustomIteration {
    
    // Custom iteration with condition
    public static <K, V> void iterateIf(Map<K, V> map, BiPredicate<K, V> condition, BiConsumer<K, V> action) {
        map.entrySet().forEach(entry -> {
            if (condition.test(entry.getKey(), entry.getValue())) {
                action.accept(entry.getKey(), entry.getValue());
            }
        });
    }
    
    // Custom iteration with indexing
    public static <K, V> void iterateWithIndex(Map<K, V> map, TriConsumer<Integer, K, V> action) {
        int index = 0;
        for (Map.Entry<K, V> entry : map.entrySet()) {
            action.accept(index++, entry.getKey(), entry.getValue());
        }
    }
    
    @FunctionalInterface
    interface TriConsumer<T, U, V> {
        void accept(T t, U u, V v);
    }
    
    public static void main(String[] args) {
        Map<String, Integer> scores = new HashMap<>();
        scores.put("Alice", 85);
        scores.put("Bob", 92);
        scores.put("Charlie", 78);
        scores.put("Diana", 95);
        
        System.out.println("=== Custom Conditional Iteration ===");
        iterateIf(scores, 
            (name, score) -> score > 80,
            (name, score) -> System.out.println(name + " scored " + score + " (Above 80)")
        );
        
        System.out.println("\n=== Custom Indexed Iteration ===");
        iterateWithIndex(scores,
            (index, name, score) -> System.out.println(index + ": " + name + " = " + score)
        );
    }
}
```

### 3. **Batched Processing**
```java
import java.util.*;
import java.util.stream.Collectors;

public class BatchedIteration {
    
    public static <K, V> void processBatches(Map<K, V> map, int batchSize, 
                                           java.util.function.Consumer<Map<K, V>> processor) {
        Map<K, V> currentBatch = new HashMap<>();
        int count = 0;
        
        for (Map.Entry<K, V> entry : map.entrySet()) {
            currentBatch.put(entry.getKey(), entry.getValue());
            count++;
            
            if (count == batchSize) {
                processor.accept(new HashMap<>(currentBatch));
                currentBatch.clear();
                count = 0;
            }
        }
        
        // Process remaining items
        if (!currentBatch.isEmpty()) {
            processor.accept(currentBatch);
        }
    }
    
    public static void main(String[] args) {
        Map<Integer, String> largeMap = new HashMap<>();
        for (int i = 1; i <= 25; i++) {
            largeMap.put(i, "Item" + i);
        }
        
        System.out.println("=== Batched Processing (Batch Size: 5) ===");
        processBatches(largeMap, 5, batch -> {
            System.out.println("Processing batch with " + batch.size() + " items:");
            batch.forEach((k, v) -> System.out.println("  " + k + " -> " + v));
            System.out.println();
        });
    }
}
```

## Memory and Performance Considerations üìä

### 1. **Memory Usage Comparison**
```java
import java.util.*;

public class MemoryComparison {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        for (int i = 0; i < 10000; i++) {
            map.put(i, "Value" + i);
        }
        
        // Memory usage of different collections created during iteration
        System.out.println("=== Memory Usage Analysis ===");
        
        Runtime runtime = Runtime.getRuntime();
        
        // keySet() - creates a view (lightweight)
        runtime.gc();
        long beforeKeySet = runtime.totalMemory() - runtime.freeMemory();
        Set<Integer> keySet = map.keySet();
        long afterKeySet = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("keySet() memory: " + (afterKeySet - beforeKeySet) + " bytes");
        
        // values() - creates a view (lightweight)  
        runtime.gc();
        long beforeValues = runtime.totalMemory() - runtime.freeMemory();
        Collection<String> values = map.values();
        long afterValues = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("values() memory: " + (afterValues - beforeValues) + " bytes");
        
        // entrySet() - creates a view (lightweight)
        runtime.gc();
        long beforeEntrySet = runtime.totalMemory() - runtime.freeMemory();
        Set<Map.Entry<Integer, String>> entrySet = map.entrySet();
        long afterEntrySet = runtime.totalMemory() - runtime.freeMemory();
        System.out.println("entrySet() memory: " + (afterEntrySet - beforeEntrySet) + " bytes");
    }
}
```

### 2. **Time Complexity Analysis**
```java
public class TimeComplexityDemo {
    public static void main(String[] args) {
        System.out.println("=== Time Complexity of Different Iteration Methods ===");
        System.out.println();
        
        System.out.println("1. entrySet() iteration:");
        System.out.println("   Time Complexity: O(n)");
        System.out.println("   Space Complexity: O(1) - no extra space needed");
        System.out.println("   Best for: When you need both key and value");
        System.out.println();
        
        System.out.println("2. keySet() iteration:");
        System.out.println("   Time Complexity: O(n) + O(n) for get() calls = O(n)");
        System.out.println("   Space Complexity: O(1)");
        System.out.println("   Best for: When you need only keys");
        System.out.println();
        
        System.out.println("3. values() iteration:");
        System.out.println("   Time Complexity: O(n)");
        System.out.println("   Space Complexity: O(1)");
        System.out.println("   Best for: When you need only values");
        System.out.println();
        
        System.out.println("4. forEach() method:");
        System.out.println("   Time Complexity: O(n)");
        System.out.println("   Space Complexity: O(1)");
        System.out.println("   Best for: Functional programming style");
        System.out.println();
        
        System.out.println("5. Streams API:");
        System.out.println("   Time Complexity: O(n) for simple operations");
        System.out.println("   Space Complexity: O(n) for intermediate collections");
        System.out.println("   Best for: Complex transformations and filtering");
    }
}
```

## Best Practices Summary üìã

### ‚úÖ **DO's:**

1. **Use entrySet() when you need both key and value**
```java
// ‚úÖ Efficient
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    process(entry.getKey(), entry.getValue());
}
```

2. **Use forEach() for simple operations**
```java
// ‚úÖ Clean and readable
map.forEach((key, value) -> System.out.println(key + ": " + value));
```

3. **Use Streams for complex operations**
```java
// ‚úÖ Powerful for transformations
List<String> result = map.entrySet().stream()
    .filter(entry -> entry.getValue() > 50)
    .map(entry -> entry.getKey())
    .collect(Collectors.toList());
```

4. **Use Iterator for safe removal**
```java
// ‚úÖ Safe removal during iteration
Iterator<Map.Entry<String, Integer>> it = map.entrySet().iterator();
while (it.hasNext()) {
    if (shouldRemove(it.next())) {
        it.remove();
    }
}
```

### ‚ùå **DON'Ts:**

1. **Don't use keySet() when you need values too**
```java
// ‚ùå Inefficient - extra get() calls
for (String key : map.keySet()) {
    Integer value = map.get(key); // Unnecessary lookup
    process(key, value);
}
```

2. **Don't modify map during enhanced for loop**
```java
// ‚ùå Will throw ConcurrentModificationException
for (Map.Entry<String, Integer> entry : map.entrySet()) {
    map.remove(entry.getKey()); // ERROR!
}
```

3. **Don't ignore null values**
```java
// ‚ùå Can cause NullPointerException
for (Map.Entry<String, String> entry : map.entrySet()) {
    System.out.println(entry.getValue().length()); // NPE if value is null
}
```

## Summary - Quick Reference! üìù

### **Method Comparison Quick Card:**

| **Method** | **Java Version** | **Performance** | **Use Case** |
|------------|-----------------|------------------|--------------|
| **Iterator** | All versions | ‚≠ê‚≠ê‚≠ê‚≠ê | Legacy code, safe removal |
| **Enhanced For** | Java 5+ | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | General purpose, most readable |
| **keySet()** | All versions | ‚≠ê‚≠ê‚≠ê | Only keys needed |
| **values()** | All versions | ‚≠ê‚≠ê‚≠ê‚≠ê | Only values needed |
| **forEach()** | Java 8+ | ‚≠ê‚≠ê‚≠ê‚≠ê | Functional style, simple operations |
| **Streams** | Java 8+ | ‚≠ê‚≠ê‚≠ê | Complex operations, transformations |

### **Performance Ranking (Fastest to Slowest):**
1. ü•á **Enhanced For Loop with entrySet()**
2. ü•à **forEach() method**
3. ü•â **Iterator with entrySet()**
4. üèÉ‚Äç‚ôÇÔ∏è **Enhanced For Loop with keySet()** (slower due to get() calls)
5. üêå **Streams API** (overhead for simple iterations)

### **Memory Trick to Remember:**
- **"Entry is the Best Entry Point"** - Use entrySet() when you need both key-value pairs
- **"Stream for Complex Dreams"** - Use Streams for complex operations
- **"forEach for Each Simple Task"** - Use forEach() for simple operations
- **"Iterator for Safe Removal"** - Use Iterator when you need to remove elements

### **Common Interview Answer Pattern:**
*"Java provides multiple ways to iterate a Map. For simple iterations needing both key and value, I prefer enhanced for loop with entrySet(). For functional programming and Java 8+ projects, forEach() is excellent. When I need complex operations like filtering or transformation, Streams API is the best choice. For thread-safe removal during iteration, Iterator is the only safe option."*

Practice these different methods and you'll become a Map iteration expert! üöÄüí™

---
*Happy Coding with Maps! üó∫Ô∏è‚ú®*
