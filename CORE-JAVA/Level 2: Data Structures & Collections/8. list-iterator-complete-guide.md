# List Iteration in Java - Complete Study Notes üìö

## Introduction - List Ko Kaise Iterate Karein? ü§î

**Real Life Analogy:** Jaise tum library mein books ki list check karte ho ek-ek karke, waise hi programming mein List ke elements ko ek-ek karke access karna **Iteration** kehte hain! üìñ

**Definition:** List iteration matlab List ke har element ko sequential order mein access karna.

**Java mein List iterate karne ke 7+ ways hain:**
1. üî¢ **Traditional For Loop**
2. üîÑ **Enhanced For Loop (For-each)**
3. ‚è∞ **While Loop**
4. üîç **Iterator Interface**
5. ‚ÜîÔ∏è **ListIterator Interface**
6. Œª **Lambda Expression**
7. üåä **Stream API with forEach()**
8. üÜï **Advanced Techniques**

## Method 1: Traditional For Loop üî¢

**Best for:** Index-based access, performance-critical applications

```java
import java.util.List;
import java.util.ArrayList;

public class ForLoopIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> students = new ArrayList<String>();
        
        // Adding elements to the List
        students.add("Rahul");
        students.add("Priya");
        students.add("Amit");
        students.add("Sneha");
        students.add("Vikash");
        
        System.out.println("=== Traditional For Loop ===");
        // Using for loop to iterate the elements
        for (int i = 0; i < students.size(); i++) {
            System.out.println("Index " + i + ": " + students.get(i));
        }
    }
}
```

**Output:**
```
=== Traditional For Loop ===
Index 0: Rahul
Index 1: Priya
Index 2: Amit
Index 3: Sneha
Index 4: Vikash
```

**Pros:**
- ‚úÖ Index access available
- ‚úÖ Can modify list during iteration
- ‚úÖ Best performance for ArrayList

**Cons:**
- ‚ùå More verbose code
- ‚ùå Index management required
- ‚ùå Not suitable for LinkedList (O(n) access time)

## Method 2: Enhanced For Loop (For-each) üîÑ

**Best for:** Simple iteration, clean code, most commonly used

```java
import java.util.List;
import java.util.ArrayList;

public class ForEachIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> fruits = new ArrayList<String>();
        
        // Adding elements to the List
        fruits.add("Apple üçé");
        fruits.add("Banana üçå");
        fruits.add("Orange üçä");
        fruits.add("Grapes üçá");
        fruits.add("Mango ü•≠");
        
        System.out.println("=== Enhanced For Loop (For-each) ===");
        // Using for-each loop to iterate the List
        for (String fruit : fruits) {
            System.out.println("Fruit: " + fruit);
        }
        
        // Can also use with custom objects
        List<Student> studentList = new ArrayList<>();
        studentList.add(new Student("Ram", 85));
        studentList.add(new Student("Sita", 92));
        studentList.add(new Student("Lakshman", 78));
        
        System.out.println("\n=== Custom Objects ===");
        for (Student student : studentList) {
            System.out.println(student.name + " - Marks: " + student.marks);
        }
    }
}

// Helper class
class Student {
    String name;
    int marks;
    
    Student(String name, int marks) {
        this.name = name;
        this.marks = marks;
    }
}
```

**Output:**
```
=== Enhanced For Loop (For-each) ===
Fruit: Apple üçé
Fruit: Banana üçå
Fruit: Orange üçä
Fruit: Grapes üçá
Fruit: Mango ü•≠

=== Custom Objects ===
Ram - Marks: 85
Sita - Marks: 92
Lakshman - Marks: 78
```

**Pros:**
- ‚úÖ Clean and readable code
- ‚úÖ Less error-prone (no index management)
- ‚úÖ Works with all Collection types
- ‚úÖ Compiler optimized

**Cons:**
- ‚ùå No index information
- ‚ùå Cannot modify list during iteration
- ‚ùå Only forward direction

## Method 3: While Loop ‚è∞

**Best for:** Conditional iteration, dynamic size changes

```java
import java.util.List;
import java.util.ArrayList;

public class WhileLoopIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<Integer> numbers = new ArrayList<Integer>();
        
        // Adding elements to the List
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);
        numbers.add(40);
        numbers.add(50);
        
        System.out.println("=== While Loop ===");
        int i = 0;
        // Using while loop to iterate the List
        while (i < numbers.size()) {
            System.out.println("Number at index " + i + ": " + numbers.get(i));
            i++;
        }
        
        System.out.println("\n=== While Loop with Condition ===");
        // Example: Print only even numbers
        int j = 0;
        while (j < numbers.size()) {
            int num = numbers.get(j);
            if (num % 2 == 0) {
                System.out.println("Even number: " + num);
            }
            j++;
        }
    }
}
```

**Output:**
```
=== While Loop ===
Number at index 0: 10
Number at index 1: 20
Number at index 2: 30
Number at index 3: 40
Number at index 4: 50

=== While Loop with Condition ===
Even number: 10
Even number: 20
Even number: 30
Even number: 40
Even number: 50
```

**Pros:**
- ‚úÖ More control over iteration
- ‚úÖ Can handle complex conditions
- ‚úÖ Index access available

**Cons:**
- ‚ùå Manual index management
- ‚ùå More prone to infinite loops
- ‚ùå Verbose code

## Method 4: Iterator Interface üîç

**Best for:** Safe removal during iteration, large datasets

```java
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorExample {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> cities = new ArrayList<String>();
        
        // Adding elements to the List
        cities.add("Mumbai");
        cities.add("Delhi");
        cities.add("Bangalore");
        cities.add("Chennai");
        cities.add("Kolkata");
        
        System.out.println("=== Iterator - Forward Direction ===");
        // Using Iterator to iterate the List
        Iterator<String> iterator = cities.iterator();
        while (iterator.hasNext()) {
            String city = iterator.next();
            System.out.println("City: " + city);
        }
        
        // Safe removal during iteration
        System.out.println("\n=== Remove elements safely ===");
        List<Integer> nums = new ArrayList<>();
        nums.add(1);
        nums.add(2);
        nums.add(3);
        nums.add(4);
        nums.add(5);
        
        System.out.println("Original List: " + nums);
        
        Iterator<Integer> numIterator = nums.iterator();
        while (numIterator.hasNext()) {
            Integer num = numIterator.next();
            if (num % 2 == 0) {
                numIterator.remove();  // Safe removal
                System.out.println("Removed: " + num);
            }
        }
        
        System.out.println("After removal: " + nums);
    }
}
```

**Output:**
```
=== Iterator - Forward Direction ===
City: Mumbai
City: Delhi
City: Bangalore
City: Chennai
City: Kolkata

=== Remove elements safely ===
Original List: [1, 2, 3, 4, 5]
Removed: 2
Removed: 4
After removal: [1, 3, 5]
```

**Iterator Methods:**
- `hasNext()` - Check if more elements exist
- `next()` - Get next element
- `remove()` - Remove current element safely

**Pros:**
- ‚úÖ Safe removal during iteration
- ‚úÖ Memory efficient
- ‚úÖ Works with all Collection types
- ‚úÖ Fail-fast behavior

**Cons:**
- ‚ùå Only forward direction
- ‚ùå No index information
- ‚ùå Slightly more verbose

## Method 5: ListIterator Interface ‚ÜîÔ∏è

**Best for:** Bidirectional iteration, adding/removing elements

```java
import java.util.List;
import java.util.ArrayList;
import java.util.ListIterator;

public class ListIteratorExample {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> subjects = new ArrayList<String>();
        
        // Adding elements to the List
        subjects.add("Math");
        subjects.add("Physics");
        subjects.add("Chemistry");
        subjects.add("Biology");
        
        System.out.println("=== ListIterator - Forward Direction ===");
        // List Iterator - Forward
        ListIterator<String> listIterator = subjects.listIterator();
        while (listIterator.hasNext()) {
            int index = listIterator.nextIndex();
            String subject = listIterator.next();
            System.out.println("Index " + index + ": " + subject);
        }
        
        System.out.println("\n=== ListIterator - Backward Direction ===");
        // List Iterator - Backward
        while (listIterator.hasPrevious()) {
            int index = listIterator.previousIndex();
            String subject = listIterator.previous();
            System.out.println("Index " + index + ": " + subject);
        }
        
        System.out.println("\n=== ListIterator - Modification ===");
        // Modification during iteration
        List<Integer> scores = new ArrayList<>();
        scores.add(85);
        scores.add(90);
        scores.add(78);
        scores.add(92);
        
        System.out.println("Original scores: " + scores);
        
        ListIterator<Integer> scoreIterator = scores.listIterator();
        while (scoreIterator.hasNext()) {
            Integer score = scoreIterator.next();
            if (score < 80) {
                scoreIterator.set(score + 10);  // Bonus marks!
                System.out.println("Boosted score from " + score + " to " + (score + 10));
            }
        }
        
        System.out.println("Updated scores: " + scores);
    }
}
```

**Output:**
```
=== ListIterator - Forward Direction ===
Index 0: Math
Index 1: Physics
Index 2: Chemistry
Index 3: Biology

=== ListIterator - Backward Direction ===
Index 3: Biology
Index 2: Chemistry
Index 1: Physics
Index 0: Math

=== ListIterator - Modification ===
Original scores: [85, 90, 78, 92]
Boosted score from 78 to 88
Updated scores: [85, 90, 88, 92]
```

**ListIterator Methods:**
- `hasNext()`, `next()` - Forward navigation
- `hasPrevious()`, `previous()` - Backward navigation  
- `nextIndex()`, `previousIndex()` - Index information
- `remove()` - Remove element
- `set()` - Replace element
- `add()` - Add element

**Pros:**
- ‚úÖ Bidirectional iteration
- ‚úÖ Index information available
- ‚úÖ Can add/remove/modify during iteration
- ‚úÖ Only works with List (not Set/Map)

**Cons:**
- ‚ùå Only for List interface
- ‚ùå Slightly complex to use

## Method 6: Lambda Expression Œª

**Best for:** Functional programming style, clean code

```java
import java.util.List;
import java.util.ArrayList;

public class LambdaIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> languages = new ArrayList<String>();
        
        // Adding elements to the List
        languages.add("Java ‚òï");
        languages.add("Python üêç");
        languages.add("JavaScript üåê");
        languages.add("C++ üîß");
        languages.add("Go üöÄ");
        
        System.out.println("=== Lambda Expression - Basic ===");
        // Using Lambda Expression to iterate the List
        languages.forEach(language -> System.out.println("Language: " + language));
        
        System.out.println("\n=== Lambda Expression - With Method Reference ===");
        // Method reference (even cleaner!)
        languages.forEach(System.out::println);
        
        System.out.println("\n=== Lambda Expression - With Logic ===");
        // Lambda with conditional logic
        languages.forEach(language -> {
            if (language.contains("Java")) {
                System.out.println("‚≠ê Favorite: " + language);
            } else {
                System.out.println("Language: " + language);
            }
        });
        
        // Example with custom objects
        List<Product> products = new ArrayList<>();
        products.add(new Product("Laptop", 50000));
        products.add(new Product("Phone", 20000));
        products.add(new Product("Tablet", 15000));
        
        System.out.println("\n=== Lambda with Custom Objects ===");
        products.forEach(product -> 
            System.out.println(product.name + " - ‚Çπ" + product.price)
        );
        
        // Filter and display expensive products
        System.out.println("\n=== Expensive Products (>25000) ===");
        products.forEach(product -> {
            if (product.price > 25000) {
                System.out.println("üí∞ " + product.name + " - ‚Çπ" + product.price);
            }
        });
    }
}

// Helper class
class Product {
    String name;
    double price;
    
    Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
}
```

**Output:**
```
=== Lambda Expression - Basic ===
Language: Java ‚òï
Language: Python üêç
Language: JavaScript üåê
Language: C++ üîß
Language: Go üöÄ

=== Lambda Expression - With Method Reference ===
Java ‚òï
Python üêç
JavaScript üåê
C++ üîß
Go üöÄ

=== Lambda Expression - With Logic ===
‚≠ê Favorite: Java ‚òï
Language: Python üêç
Language: JavaScript üåê
Language: C++ üîß
Language: Go üöÄ

=== Lambda with Custom Objects ===
Laptop - ‚Çπ50000.0
Phone - ‚Çπ20000.0
Tablet - ‚Çπ15000.0

=== Expensive Products (>25000) ===
üí∞ Laptop - ‚Çπ50000.0
```

**Pros:**
- ‚úÖ Very clean and concise code
- ‚úÖ Functional programming style
- ‚úÖ Easy to read and maintain
- ‚úÖ Can use method references

**Cons:**
- ‚ùå Java 8+ required
- ‚ùå No index information
- ‚ùå Learning curve for beginners

## Method 7: Stream API with forEach() üåä

**Best for:** Complex operations, filtering, mapping, modern Java

```java
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;

public class StreamIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> names = new ArrayList<String>();
        
        // Adding elements to the List
        names.add("Arjun");
        names.add("Bheem");
        names.add("Chitra");
        names.add("Devika");
        names.add("Ekta");
        
        System.out.println("=== Stream forEach - Basic ===");
        // Using stream.forEach() to iterate the List
        names.stream().forEach(name -> System.out.println("Name: " + name));
        
        System.out.println("\n=== Stream with Method Reference ===");
        names.stream().forEach(System.out::println);
        
        // Advanced Stream Operations
        List<Employee> employees = new ArrayList<>();
        employees.add(new Employee("Raj", 25, 50000));
        employees.add(new Employee("Simran", 30, 75000));
        employees.add(new Employee("Karan", 28, 60000));
        employees.add(new Employee("Preeti", 32, 80000));
        employees.add(new Employee("Vikram", 26, 55000));
        
        System.out.println("\n=== All Employees ===");
        employees.stream()
                .forEach(emp -> System.out.println(emp.name + " (Age: " + emp.age + ", Salary: ‚Çπ" + emp.salary + ")"));
        
        System.out.println("\n=== High Salary Employees (>60000) ===");
        employees.stream()
                .filter(emp -> emp.salary > 60000)
                .forEach(emp -> System.out.println("üí∞ " + emp.name + " - ‚Çπ" + emp.salary));
        
        System.out.println("\n=== Young Employees (<30) with Names in Uppercase ===");
        employees.stream()
                .filter(emp -> emp.age < 30)
                .map(emp -> emp.name.toUpperCase())
                .forEach(name -> System.out.println("üåü " + name));
        
        System.out.println("\n=== Employee Names Starting with 'S' or 'P' ===");
        employees.stream()
                .filter(emp -> emp.name.startsWith("S") || emp.name.startsWith("P"))
                .forEach(emp -> System.out.println("‚ú® " + emp.name));
        
        // Collect results
        System.out.println("\n=== Collect Names to New List ===");
        List<String> employeeNames = employees.stream()
                .map(emp -> emp.name)
                .collect(Collectors.toList());
        System.out.println("Names List: " + employeeNames);
    }
}

// Helper class
class Employee {
    String name;
    int age;
    double salary;
    
    Employee(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }
}
```

**Output:**
```
=== Stream forEach - Basic ===
Name: Arjun
Name: Bheem
Name: Chitra
Name: Devika
Name: Ekta

=== Stream with Method Reference ===
Arjun
Bheem
Chitra
Devika
Ekta

=== All Employees ===
Raj (Age: 25, Salary: ‚Çπ50000.0)
Simran (Age: 30, Salary: ‚Çπ75000.0)
Karan (Age: 28, Salary: ‚Çπ60000.0)
Preeti (Age: 32, Salary: ‚Çπ80000.0)
Vikram (Age: 26, Salary: ‚Çπ55000.0)

=== High Salary Employees (>60000) ===
üí∞ Simran - ‚Çπ75000.0
üí∞ Preeti - ‚Çπ80000.0

=== Young Employees (<30) with Names in Uppercase ===
üåü RAJ
üåü KARAN
üåü VIKRAM

=== Employee Names Starting with 'S' or 'P' ===
‚ú® Simran
‚ú® Preeti

=== Collect Names to New List ===
Names List: [Raj, Simran, Karan, Preeti, Vikram]
```

**Pros:**
- ‚úÖ Powerful filtering and mapping
- ‚úÖ Chain multiple operations
- ‚úÖ Parallel processing support
- ‚úÖ Functional programming style

**Cons:**
- ‚ùå Java 8+ required
- ‚ùå Can be slower for simple operations
- ‚ùå Memory overhead for small lists

## Method 8: Advanced Techniques üÜï

### A) Parallel Stream for Large Data

```java
import java.util.List;
import java.util.ArrayList;
import java.util.stream.IntStream;

public class ParallelStreamExample {
    public static void main(String[] args) {
        // Create large list
        List<Integer> largeList = new ArrayList<>();
        IntStream.range(1, 1000000).forEach(largeList::add);
        
        System.out.println("=== Sequential vs Parallel Processing ===");
        
        // Sequential processing
        long startTime = System.currentTimeMillis();
        largeList.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n * n)
                .sum();
        long sequentialTime = System.currentTimeMillis() - startTime;
        
        // Parallel processing
        startTime = System.currentTimeMillis();
        largeList.parallelStream()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n * n)
                .sum();
        long parallelTime = System.currentTimeMillis() - startTime;
        
        System.out.println("Sequential time: " + sequentialTime + "ms");
        System.out.println("Parallel time: " + parallelTime + "ms");
        System.out.println("Speedup: " + (double)sequentialTime/parallelTime + "x");
    }
}
```

### B) Custom Iterator

```java
import java.util.*;

public class CustomIteratorExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("A", "B", "C", "D", "E");
        
        // Custom iterator that skips every alternate element
        Iterator<String> customIterator = new Iterator<String>() {
            private Iterator<String> iterator = list.iterator();
            private String next;
            private boolean hasNext = true;
            
            {
                advance();
            }
            
            private void advance() {
                hasNext = false;
                while (iterator.hasNext()) {
                    next = iterator.next();
                    hasNext = true;
                    if (iterator.hasNext()) {
                        iterator.next(); // Skip one
                    }
                    break;
                }
            }
            
            @Override
            public boolean hasNext() {
                return hasNext;
            }
            
            @Override
            public String next() {
                String result = next;
                advance();
                return result;
            }
        };
        
        System.out.println("=== Custom Iterator (Every Alternate Element) ===");
        while (customIterator.hasNext()) {
            System.out.println(customIterator.next());
        }
    }
}
```

### C) Indexed forEach

```java
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicInteger;

public class IndexedForEachExample {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("Apple", "Banana", "Cherry", "Date");
        
        System.out.println("=== Indexed forEach with AtomicInteger ===");
        AtomicInteger index = new AtomicInteger(0);
        fruits.forEach(fruit -> 
            System.out.println("Index " + index.getAndIncrement() + ": " + fruit)
        );
        
        System.out.println("\n=== Indexed forEach with IntStream ===");
        IntStream.range(0, fruits.size())
                .forEach(i -> System.out.println("Index " + i + ": " + fruits.get(i)));
    }
}
```

## Performance Comparison üìä

```java
import java.util.*;
import java.util.stream.IntStream;

public class PerformanceComparison {
    public static void main(String[] args) {
        // Create test data
        List<Integer> list = new ArrayList<>();
        IntStream.range(1, 1000000).forEach(list::add);
        
        System.out.println("=== Performance Comparison (1M elements) ===");
        
        // Traditional for loop
        long startTime = System.nanoTime();
        int sum1 = 0;
        for (int i = 0; i < list.size(); i++) {
            sum1 += list.get(i);
        }
        long time1 = System.nanoTime() - startTime;
        
        // Enhanced for loop
        startTime = System.nanoTime();
        int sum2 = 0;
        for (Integer num : list) {
            sum2 += num;
        }
        long time2 = System.nanoTime() - startTime;
        
        // Iterator
        startTime = System.nanoTime();
        int sum3 = 0;
        Iterator<Integer> it = list.iterator();
        while (it.hasNext()) {
            sum3 += it.next();
        }
        long time3 = System.nanoTime() - startTime;
        
        // Stream forEach
        startTime = System.nanoTime();
        final int[] sum4 = {0};
        list.stream().forEach(num -> sum4[0] += num);
        long time4 = System.nanoTime() - startTime;
        
        System.out.println("Traditional For Loop: " + time1/1000000 + "ms");
        System.out.println("Enhanced For Loop: " + time2/1000000 + "ms");
        System.out.println("Iterator: " + time3/1000000 + "ms");
        System.out.println("Stream forEach: " + time4/1000000 + "ms");
        
        System.out.println("\nAll sums equal: " + 
            (sum1 == sum2 && sum2 == sum3 && sum3 == sum4[0]));
    }
}
```

## When to Use Which Method? ü§î

| **Method** | **Best Use Case** | **Performance** | **Readability** |
|------------|------------------|-----------------|-----------------|
| **Traditional For** | Index needed, ArrayList | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Enhanced For** | Simple iteration, any List | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **While Loop** | Complex conditions | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **Iterator** | Safe removal needed | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê |
| **ListIterator** | Bidirectional access | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê |
| **Lambda** | Modern, clean code | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |
| **Stream** | Complex operations | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê |

## Common Mistakes - Avoid Karo! ‚ùå

### 1. **ConcurrentModificationException**
```java
// ‚ùå Wrong way
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
for (String item : list) {
    if (item.equals("B")) {
        list.remove(item); // ConcurrentModificationException!
    }
}

// ‚úÖ Correct way
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    if (item.equals("B")) {
        iterator.remove(); // Safe removal
    }
}
```

### 2. **Index Out of Bounds**
```java
List<String> list = new ArrayList<>();
// ‚ùå Wrong - empty list
for (int i = 0; i <= list.size(); i++) { // <= is wrong!
    System.out.println(list.get(i));
}

// ‚úÖ Correct
for (int i = 0; i < list.size(); i++) { // < is correct
    System.out.println(list.get(i));
}
```

### 3. **Null Pointer Exception**
```java
List<String> list = null;
// ‚ùå Wrong - no null check
for (String item : list) { // NPE!
    System.out.println(item);
}

// ‚úÖ Correct
if (list != null && !list.isEmpty()) {
    for (String item : list) {
        System.out.println(item);
    }
}
```

## Interview Questions - Master Karo! üí™

### Q1: **Which iteration method is fastest?**
```java
// Answer demonstration
public class FastestIteration {
    public static void main(String[] args) {
        List<Integer> arrayList = new ArrayList<>();
        List<Integer> linkedList = new LinkedList<>();
        
        // Fill lists
        for (int i = 0; i < 100000; i++) {
            arrayList.add(i);
            linkedList.add(i);
        }
        
        // ArrayList: Traditional for loop is fastest
        // LinkedList: Enhanced for loop or Iterator is fastest
        
        System.out.println("ArrayList - Traditional for loop: Fastest");
        System.out.println("LinkedList - Enhanced for loop/Iterator: Fastest");
    }
}
```

### Q2: **How to iterate and modify list safely?**
```java
// Safe modification techniques
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// Method 1: Iterator
Iterator<Integer> it = numbers.iterator();
while (it.hasNext()) {
    if (it.next() % 2 == 0) {
        it.remove();
    }
}

// Method 2: Traditional for loop (backwards)
for (int i = numbers.size() - 1; i >= 0; i--) {
    if (numbers.get(i) % 2 == 0) {
        numbers.remove(i);
    }
}

// Method 3: removeIf (Java 8+)
numbers.removeIf(n -> n % 2 == 0);
```

### Q3: **Difference between Iterator and ListIterator?**

| **Iterator** | **ListIterator** |
|--------------|------------------|
| Forward only | Bidirectional |
| All Collections | Only List |
| hasNext(), next(), remove() | hasNext(), next(), hasPrevious(), previous(), add(), set(), remove() |
| Cannot add elements | Can add elements during iteration |
| No index information | Provides index information |

```java
public class IteratorVsListIterator {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
        
        // Iterator - Forward only
        System.out.println("=== Iterator ===");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        
        // ListIterator - Bidirectional
        System.out.println("\n=== ListIterator - Forward ===");
        ListIterator<String> listIterator = list.listIterator();
        while (listIterator.hasNext()) {
            System.out.println("Index " + listIterator.nextIndex() + ": " + listIterator.next());
        }
        
        System.out.println("\n=== ListIterator - Backward ===");
        while (listIterator.hasPrevious()) {
            System.out.println("Index " + listIterator.previousIndex() + ": " + listIterator.previous());
        }
    }
}
```

### Q4: **Can we use parallel streams for iteration?**
```java
public class ParallelStreamIteration {
    public static void main(String[] args) {
        List<Integer> largeList = IntStream.range(1, 1000000)
                                         .boxed()
                                         .collect(Collectors.toList());
        
        // Sequential stream
        long start = System.currentTimeMillis();
        long sequentialSum = largeList.stream()
                                    .mapToLong(Integer::longValue)
                                    .sum();
        long sequentialTime = System.currentTimeMillis() - start;
        
        // Parallel stream
        start = System.currentTimeMillis();
        long parallelSum = largeList.parallelStream()
                                  .mapToLong(Integer::longValue)
                                  .sum();
        long parallelTime = System.currentTimeMillis() - start;
        
        System.out.println("Sequential: " + sequentialTime + "ms");
        System.out.println("Parallel: " + parallelTime + "ms");
        System.out.println("Results equal: " + (sequentialSum == parallelSum));
    }
}
```

### Q5: **How to iterate with index using streams?**
```java
public class IndexedStreamIteration {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("Apple", "Banana", "Cherry");
        
        // Method 1: Using IntStream.range
        IntStream.range(0, fruits.size())
                .forEach(i -> System.out.println(i + ": " + fruits.get(i)));
        
        // Method 2: Custom collector with AtomicInteger
        AtomicInteger counter = new AtomicInteger(0);
        fruits.stream()
              .forEach(fruit -> System.out.println(counter.getAndIncrement() + ": " + fruit));
        
        // Method 3: Using custom utility method
        fruits.stream()
              .collect(ArrayList::new, (list, item) -> list.add(new IndexedItem<>(list.size(), item)), ArrayList::addAll)
              .forEach(indexedItem -> System.out.println(indexedItem.index + ": " + indexedItem.item));
    }
    
    static class IndexedItem<T> {
        final int index;
        final T item;
        
        IndexedItem(int index, T item) {
            this.index = index;
            this.item = item;
        }
    }
}
```

## Best Practices üåü

### 1. **Choose Right Method for Right Situation**
```java
public class BestPracticesExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("Java", "Python", "C++", "JavaScript");
        
        // ‚úÖ Simple reading - Enhanced for loop
        System.out.println("=== Simple Reading ===");
        for (String language : list) {
            System.out.println(language);
        }
        
        // ‚úÖ Need index - Traditional for loop
        System.out.println("\n=== With Index ===");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(i + ": " + list.get(i));
        }
        
        // ‚úÖ Safe removal - Iterator
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        System.out.println("\n=== Safe Removal ===");
        Iterator<Integer> it = numbers.iterator();
        while (it.hasNext()) {
            Integer num = it.next();
            if (num % 2 == 0) {
                it.remove();
                System.out.println("Removed: " + num);
            }
        }
        System.out.println("Remaining: " + numbers);
        
        // ‚úÖ Complex operations - Stream
        System.out.println("\n=== Complex Operations ===");
        List<String> result = list.stream()
                                 .filter(lang -> lang.length() > 4)
                                 .map(String::toUpperCase)
                                 .collect(Collectors.toList());
        System.out.println("Filtered and transformed: " + result);
    }
}
```

### 2. **Null Safety**
```java
public class NullSafeIteration {
    public static void main(String[] args) {
        List<String> list = null;
        
        // ‚úÖ Always check for null
        if (list != null && !list.isEmpty()) {
            for (String item : list) {
                System.out.println(item);
            }
        } else {
            System.out.println("List is null or empty");
        }
        
        // ‚úÖ Using Optional (Java 8+)
        Optional.ofNullable(list)
                .filter(l -> !l.isEmpty())
                .ifPresent(l -> l.forEach(System.out::println));
        
        // ‚úÖ Using utility method
        safeIterate(list);
    }
    
    public static void safeIterate(List<String> list) {
        if (list == null) {
            System.out.println("Cannot iterate null list");
            return;
        }
        
        if (list.isEmpty()) {
            System.out.println("List is empty");
            return;
        }
        
        for (String item : list) {
            System.out.println(item);
        }
    }
}
```

### 3. **Handle Different List Types Efficiently**
```java
public class EfficientListIteration {
    public static void main(String[] args) {
        // ArrayList - Random access is fast
        List<Integer> arrayList = new ArrayList<>();
        IntStream.range(1, 10000).forEach(arrayList::add);
        
        // LinkedList - Sequential access is better
        List<Integer> linkedList = new LinkedList<>();
        IntStream.range(1, 10000).forEach(linkedList::add);
        
        System.out.println("=== ArrayList - Use traditional for loop ===");
        long start = System.nanoTime();
        for (int i = 0; i < arrayList.size(); i++) {
            int value = arrayList.get(i); // O(1) access
        }
        long arrayListTime = System.nanoTime() - start;
        
        System.out.println("=== LinkedList - Use enhanced for loop ===");
        start = System.nanoTime();
        for (Integer value : linkedList) { // Iterator-based, O(1) per element
            // Process value
        }
        long linkedListTime = System.nanoTime() - start;
        
        System.out.println("ArrayList traditional for: " + arrayListTime/1000000 + "ms");
        System.out.println("LinkedList enhanced for: " + linkedListTime/1000000 + "ms");
    }
}
```

### 4. **Stream vs Loop Performance**
```java
public class StreamVsLoopPerformance {
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.range(1, 1000000)
                                       .boxed()
                                       .collect(Collectors.toList());
        
        // Simple operations - Loop is faster
        System.out.println("=== Simple Sum Operation ===");
        
        // Traditional loop
        long start = System.nanoTime();
        long sum1 = 0;
        for (Integer num : numbers) {
            sum1 += num;
        }
        long loopTime = System.nanoTime() - start;
        
        // Stream
        start = System.nanoTime();
        long sum2 = numbers.stream()
                          .mapToLong(Integer::longValue)
                          .sum();
        long streamTime = System.nanoTime() - start;
        
        System.out.println("Loop time: " + loopTime/1000000 + "ms");
        System.out.println("Stream time: " + streamTime/1000000 + "ms");
        System.out.println("Results equal: " + (sum1 == sum2));
        
        // Complex operations - Stream is more readable
        System.out.println("\n=== Complex Filter-Map-Collect ===");
        
        // Stream (more readable for complex operations)
        start = System.nanoTime();
        List<String> result = numbers.stream()
                                   .filter(n -> n % 2 == 0)
                                   .filter(n -> n > 100)
                                   .map(n -> "Number: " + n)
                                   .limit(1000)
                                   .collect(Collectors.toList());
        streamTime = System.nanoTime() - start;
        
        System.out.println("Complex stream operation: " + streamTime/1000000 + "ms");
        System.out.println("Result size: " + result.size());
    }
}
```

## Real-World Examples üåç

### Example 1: Student Management System
```java
import java.util.*;
import java.util.stream.Collectors;

public class StudentManagementSystem {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Rahul", 85, "Computer Science"),
            new Student("Priya", 92, "Mathematics"),
            new Student("Amit", 78, "Physics"),
            new Student("Sneha", 96, "Computer Science"),
            new Student("Vikash", 82, "Mathematics"),
            new Student("Anita", 88, "Physics")
        );
        
        System.out.println("=== All Students ===");
        students.forEach(student -> 
            System.out.println(student.name + " - " + student.marks + " (" + student.subject + ")")
        );
        
        System.out.println("\n=== Top Performers (>90) ===");
        students.stream()
                .filter(student -> student.marks > 90)
                .forEach(student -> System.out.println("üåü " + student.name + " - " + student.marks));
        
        System.out.println("\n=== Subject-wise Grouping ===");
        Map<String, List<Student>> subjectGroups = students.stream()
                .collect(Collectors.groupingBy(student -> student.subject));
        
        subjectGroups.forEach((subject, studentList) -> {
            System.out.println(subject + ":");
            studentList.forEach(student -> System.out.println("  - " + student.name + " (" + student.marks + ")"));
        });
        
        System.out.println("\n=== Average Marks by Subject ===");
        Map<String, Double> averageMarks = students.stream()
                .collect(Collectors.groupingBy(
                    student -> student.subject,
                    Collectors.averagingDouble(student -> student.marks)
                ));
        
        averageMarks.forEach((subject, avg) -> 
            System.out.println(subject + ": " + String.format("%.2f", avg))
        );
    }
    
    static class Student {
        String name;
        int marks;
        String subject;
        
        Student(String name, int marks, String subject) {
            this.name = name;
            this.marks = marks;
            this.subject = subject;
        }
    }
}
```

### Example 2: E-commerce Order Processing
```java
import java.util.*;
import java.util.stream.Collectors;

public class EcommerceOrderProcessing {
    public static void main(String[] args) {
        List<Order> orders = Arrays.asList(
            new Order("ORD001", "Electronics", 25000, "PENDING"),
            new Order("ORD002", "Clothing", 1200, "SHIPPED"),
            new Order("ORD003", "Books", 800, "DELIVERED"),
            new Order("ORD004", "Electronics", 45000, "PENDING"),
            new Order("ORD005", "Home", 3500, "SHIPPED"),
            new Order("ORD006", "Clothing", 2200, "PENDING")
        );
        
        System.out.println("=== Order Processing Dashboard ===");
        
        // Count orders by status
        System.out.println("\n--- Order Status Summary ---");
        Map<String, Long> statusCount = orders.stream()
                .collect(Collectors.groupingBy(
                    order -> order.status,
                    Collectors.counting()
                ));
        
        statusCount.forEach((status, count) -> 
            System.out.println(status + ": " + count + " orders")
        );
        
        // High-value pending orders (need attention)
        System.out.println("\n--- High-Value Pending Orders (>10000) ---");
        orders.stream()
              .filter(order -> order.status.equals("PENDING"))
              .filter(order -> order.amount > 10000)
              .sorted((o1, o2) -> Double.compare(o2.amount, o1.amount))
              .forEach(order -> System.out.println("üö® " + order.id + " - " + order.category + " - ‚Çπ" + order.amount));
        
        // Revenue by category
        System.out.println("\n--- Revenue by Category ---");
        Map<String, Double> revenueByCategory = orders.stream()
                .collect(Collectors.groupingBy(
                    order -> order.category,
                    Collectors.summingDouble(order -> order.amount)
                ));
        
        revenueByCategory.entrySet().stream()
                        .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
                        .forEach(entry -> System.out.println(entry.getKey() + ": ‚Çπ" + entry.getValue()));
        
        // Process pending orders (simulation)
        System.out.println("\n--- Processing Pending Orders ---");
        ListIterator<Order> iterator = orders.listIterator();
        while (iterator.hasNext()) {
            Order order = iterator.next();
            if (order.status.equals("PENDING")) {
                // Simulate processing
                order.status = "PROCESSED";
                System.out.println("‚úÖ Processed order: " + order.id);
            }
        }
        
        // Final status check
        System.out.println("\n--- Final Status Check ---");
        orders.forEach(order -> 
            System.out.println(order.id + " - " + order.status)
        );
    }
    
    static class Order {
        String id;
        String category;
        double amount;
        String status;
        
        Order(String id, String category, double amount, String status) {
            this.id = id;
            this.category = category;
            this.amount = amount;
            this.status = status;
        }
    }
}
```

## Summary - Quick Reference Card üìã

### **üî• Most Common Methods (80% use cases):**

```java
// 1. Enhanced For Loop (Most Popular)
for (String item : list) {
    System.out.println(item);
}

// 2. Stream forEach (Modern Java)
list.forEach(System.out::println);

// 3. Traditional For (When index needed)
for (int i = 0; i < list.size(); i++) {
    System.out.println(i + ": " + list.get(i));
}

// 4. Iterator (When removal needed)
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String item = it.next();
    if (shouldRemove(item)) {
        it.remove();
    }
}
```

### **‚ö° Performance Quick Guide:**

| **List Type** | **Best Method** | **Reason** |
|---------------|-----------------|------------|
| **ArrayList** | Traditional For | Random access O(1) |
| **LinkedList** | Enhanced For / Iterator | Sequential access O(1) |
| **Large Dataset** | Parallel Stream | Multi-core utilization |
| **Simple Operation** | Enhanced For | Clean + Fast |
| **Complex Operation** | Stream | Readability + Power |

### **üéØ Decision Tree:**

```
Need to iterate a List?
‚îú‚îÄ‚îÄ Need index information?
‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí Traditional For Loop
‚îú‚îÄ‚îÄ Need to remove elements safely?
‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí Iterator
‚îú‚îÄ‚îÄ Need bidirectional access?
‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí ListIterator  
‚îú‚îÄ‚îÄ Complex filtering/mapping needed?
‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí Stream API
‚îú‚îÄ‚îÄ Simple read-only iteration?
‚îÇ   ‚îî‚îÄ‚îÄ YES ‚Üí Enhanced For Loop
‚îî‚îÄ‚îÄ Modern functional style?
    ‚îî‚îÄ‚îÄ YES ‚Üí Lambda forEach
```

### **üö® Remember These Rules:**

1. **Enhanced For Loop** - 80% of cases, cleanest code
2. **Traditional For** - When you need index access
3. **Iterator** - When removing elements during iteration
4. **Stream** - When complex operations needed
5. **Never modify list during enhanced for loop** - Use Iterator!
6. **ArrayList + index access = Traditional For**
7. **LinkedList + sequential = Enhanced For**
8. **Large data + complex ops = Parallel Stream**

### **üí° Pro Tips:**

- **Method Reference**: `list.forEach(System.out::println)` instead of `list.forEach(item -> System.out.println(item))`
- **Null Safety**: Always check `if (list != null && !list.isEmpty())`
- **Performance**: For simple operations, traditional loops are faster than streams
- **Readability**: For complex operations, streams are more readable than loops
- **Memory**: Streams can use more memory due to intermediate collections

---

## Conclusion üéâ

List iteration ‡§è‡§ï fundamental skill ‡§π‡•à Java programming ‡§Æ‡•á‡§Ç! ‡§Ø‡§π‡§æ‡§Å ‡§∏‡§≠‡•Ä methods ‡§ï‡•á ‡§∏‡§æ‡§• real examples ‡§î‡§∞ best practices cover ‡§ï‡§ø‡§è ‡§ó‡§è ‡§π‡•à‡§Ç‡•§

**Key Takeaways:**
1. üéØ **Enhanced For Loop** - Most common and clean
2. üîç **Iterator** - Safe removal during iteration  
3. üåä **Stream API** - Modern functional programming style
4. ‚ö° **Performance matters** - Choose right method for right scenario
5. üõ°Ô∏è **Safety first** - Always handle null cases
6. üìö **Practice** - Try all methods with different scenarios

Practice these examples ‡§î‡§∞ ‡§§‡•Å‡§Æ List iteration ‡§ï‡•á master ‡§¨‡§® ‡§ú‡§æ‡§ì‡§ó‡•á! üöÄüí™

---
*Happy Coding! üéâ*
|
