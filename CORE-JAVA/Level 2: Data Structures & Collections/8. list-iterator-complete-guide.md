# List Iteration in Java - Complete Study Notes 📚

## Introduction - List Ko Kaise Iterate Karein? 🤔

**Real Life Analogy:** Jaise tum library mein books ki list check karte ho ek-ek karke, waise hi programming mein List ke elements ko ek-ek karke access karna **Iteration** kehte hain! 📖

**Definition:** List iteration matlab List ke har element ko sequential order mein access karna.

**Java mein List iterate karne ke 7+ ways hain:**
1. 🔢 **Traditional For Loop**
2. 🔄 **Enhanced For Loop (For-each)**
3. ⏰ **While Loop**
4. 🔍 **Iterator Interface**
5. ↔️ **ListIterator Interface**
6. λ **Lambda Expression**
7. 🌊 **Stream API with forEach()**
8. 🆕 **Advanced Techniques**

## Method 1: Traditional For Loop 🔢

**Best for:** Index-based access, performance-critical applications

```java
import java.util.List;
import java.util.ArrayList;

public class ForLoopIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> students = new ArrayList<String>();
        
        // Adding elements to the List
        students.add("Rahul");
        students.add("Priya");
        students.add("Amit");
        students.add("Sneha");
        students.add("Vikash");
        
        System.out.println("=== Traditional For Loop ===");
        // Using for loop to iterate the elements
        for (int i = 0; i < students.size(); i++) {
            System.out.println("Index " + i + ": " + students.get(i));
        }
    }
}
```

**Output:**
```
=== Traditional For Loop ===
Index 0: Rahul
Index 1: Priya
Index 2: Amit
Index 3: Sneha
Index 4: Vikash
```

**Pros:**
- ✅ Index access available
- ✅ Can modify list during iteration
- ✅ Best performance for ArrayList

**Cons:**
- ❌ More verbose code
- ❌ Index management required
- ❌ Not suitable for LinkedList (O(n) access time)

## Method 2: Enhanced For Loop (For-each) 🔄

**Best for:** Simple iteration, clean code, most commonly used

```java
import java.util.List;
import java.util.ArrayList;

public class ForEachIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> fruits = new ArrayList<String>();
        
        // Adding elements to the List
        fruits.add("Apple 🍎");
        fruits.add("Banana 🍌");
        fruits.add("Orange 🍊");
        fruits.add("Grapes 🍇");
        fruits.add("Mango 🥭");
        
        System.out.println("=== Enhanced For Loop (For-each) ===");
        // Using for-each loop to iterate the List
        for (String fruit : fruits) {
            System.out.println("Fruit: " + fruit);
        }
        
        // Can also use with custom objects
        List<Student> studentList = new ArrayList<>();
        studentList.add(new Student("Ram", 85));
        studentList.add(new Student("Sita", 92));
        studentList.add(new Student("Lakshman", 78));
        
        System.out.println("\n=== Custom Objects ===");
        for (Student student : studentList) {
            System.out.println(student.name + " - Marks: " + student.marks);
        }
    }
}

// Helper class
class Student {
    String name;
    int marks;
    
    Student(String name, int marks) {
        this.name = name;
        this.marks = marks;
    }
}
```

**Output:**
```
=== Enhanced For Loop (For-each) ===
Fruit: Apple 🍎
Fruit: Banana 🍌
Fruit: Orange 🍊
Fruit: Grapes 🍇
Fruit: Mango 🥭

=== Custom Objects ===
Ram - Marks: 85
Sita - Marks: 92
Lakshman - Marks: 78
```

**Pros:**
- ✅ Clean and readable code
- ✅ Less error-prone (no index management)
- ✅ Works with all Collection types
- ✅ Compiler optimized

**Cons:**
- ❌ No index information
- ❌ Cannot modify list during iteration
- ❌ Only forward direction

## Method 3: While Loop ⏰

**Best for:** Conditional iteration, dynamic size changes

```java
import java.util.List;
import java.util.ArrayList;

public class WhileLoopIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<Integer> numbers = new ArrayList<Integer>();
        
        // Adding elements to the List
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);
        numbers.add(40);
        numbers.add(50);
        
        System.out.println("=== While Loop ===");
        int i = 0;
        // Using while loop to iterate the List
        while (i < numbers.size()) {
            System.out.println("Number at index " + i + ": " + numbers.get(i));
            i++;
        }
        
        System.out.println("\n=== While Loop with Condition ===");
        // Example: Print only even numbers
        int j = 0;
        while (j < numbers.size()) {
            int num = numbers.get(j);
            if (num % 2 == 0) {
                System.out.println("Even number: " + num);
            }
            j++;
        }
    }
}
```

**Output:**
```
=== While Loop ===
Number at index 0: 10
Number at index 1: 20
Number at index 2: 30
Number at index 3: 40
Number at index 4: 50

=== While Loop with Condition ===
Even number: 10
Even number: 20
Even number: 30
Even number: 40
Even number: 50
```

**Pros:**
- ✅ More control over iteration
- ✅ Can handle complex conditions
- ✅ Index access available

**Cons:**
- ❌ Manual index management
- ❌ More prone to infinite loops
- ❌ Verbose code

## Method 4: Iterator Interface 🔍

**Best for:** Safe removal during iteration, large datasets

```java
import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

public class IteratorExample {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> cities = new ArrayList<String>();
        
        // Adding elements to the List
        cities.add("Mumbai");
        cities.add("Delhi");
        cities.add("Bangalore");
        cities.add("Chennai");
        cities.add("Kolkata");
        
        System.out.println("=== Iterator - Forward Direction ===");
        // Using Iterator to iterate the List
        Iterator<String> iterator = cities.iterator();
        while (iterator.hasNext()) {
            String city = iterator.next();
            System.out.println("City: " + city);
        }
        
        // Safe removal during iteration
        System.out.println("\n=== Remove elements safely ===");
        List<Integer> nums = new ArrayList<>();
        nums.add(1);
        nums.add(2);
        nums.add(3);
        nums.add(4);
        nums.add(5);
        
        System.out.println("Original List: " + nums);
        
        Iterator<Integer> numIterator = nums.iterator();
        while (numIterator.hasNext()) {
            Integer num = numIterator.next();
            if (num % 2 == 0) {
                numIterator.remove();  // Safe removal
                System.out.println("Removed: " + num);
            }
        }
        
        System.out.println("After removal: " + nums);
    }
}
```

**Output:**
```
=== Iterator - Forward Direction ===
City: Mumbai
City: Delhi
City: Bangalore
City: Chennai
City: Kolkata

=== Remove elements safely ===
Original List: [1, 2, 3, 4, 5]
Removed: 2
Removed: 4
After removal: [1, 3, 5]
```

**Iterator Methods:**
- `hasNext()` - Check if more elements exist
- `next()` - Get next element
- `remove()` - Remove current element safely

**Pros:**
- ✅ Safe removal during iteration
- ✅ Memory efficient
- ✅ Works with all Collection types
- ✅ Fail-fast behavior

**Cons:**
- ❌ Only forward direction
- ❌ No index information
- ❌ Slightly more verbose

## Method 5: ListIterator Interface ↔️

**Best for:** Bidirectional iteration, adding/removing elements

```java
import java.util.List;
import java.util.ArrayList;
import java.util.ListIterator;

public class ListIteratorExample {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> subjects = new ArrayList<String>();
        
        // Adding elements to the List
        subjects.add("Math");
        subjects.add("Physics");
        subjects.add("Chemistry");
        subjects.add("Biology");
        
        System.out.println("=== ListIterator - Forward Direction ===");
        // List Iterator - Forward
        ListIterator<String> listIterator = subjects.listIterator();
        while (listIterator.hasNext()) {
            int index = listIterator.nextIndex();
            String subject = listIterator.next();
            System.out.println("Index " + index + ": " + subject);
        }
        
        System.out.println("\n=== ListIterator - Backward Direction ===");
        // List Iterator - Backward
        while (listIterator.hasPrevious()) {
            int index = listIterator.previousIndex();
            String subject = listIterator.previous();
            System.out.println("Index " + index + ": " + subject);
        }
        
        System.out.println("\n=== ListIterator - Modification ===");
        // Modification during iteration
        List<Integer> scores = new ArrayList<>();
        scores.add(85);
        scores.add(90);
        scores.add(78);
        scores.add(92);
        
        System.out.println("Original scores: " + scores);
        
        ListIterator<Integer> scoreIterator = scores.listIterator();
        while (scoreIterator.hasNext()) {
            Integer score = scoreIterator.next();
            if (score < 80) {
                scoreIterator.set(score + 10);  // Bonus marks!
                System.out.println("Boosted score from " + score + " to " + (score + 10));
            }
        }
        
        System.out.println("Updated scores: " + scores);
    }
}
```

**Output:**
```
=== ListIterator - Forward Direction ===
Index 0: Math
Index 1: Physics
Index 2: Chemistry
Index 3: Biology

=== ListIterator - Backward Direction ===
Index 3: Biology
Index 2: Chemistry
Index 1: Physics
Index 0: Math

=== ListIterator - Modification ===
Original scores: [85, 90, 78, 92]
Boosted score from 78 to 88
Updated scores: [85, 90, 88, 92]
```

**ListIterator Methods:**
- `hasNext()`, `next()` - Forward navigation
- `hasPrevious()`, `previous()` - Backward navigation  
- `nextIndex()`, `previousIndex()` - Index information
- `remove()` - Remove element
- `set()` - Replace element
- `add()` - Add element

**Pros:**
- ✅ Bidirectional iteration
- ✅ Index information available
- ✅ Can add/remove/modify during iteration
- ✅ Only works with List (not Set/Map)

**Cons:**
- ❌ Only for List interface
- ❌ Slightly complex to use

## Method 6: Lambda Expression λ

**Best for:** Functional programming style, clean code

```java
import java.util.List;
import java.util.ArrayList;

public class LambdaIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> languages = new ArrayList<String>();
        
        // Adding elements to the List
        languages.add("Java ☕");
        languages.add("Python 🐍");
        languages.add("JavaScript 🌐");
        languages.add("C++ 🔧");
        languages.add("Go 🚀");
        
        System.out.println("=== Lambda Expression - Basic ===");
        // Using Lambda Expression to iterate the List
        languages.forEach(language -> System.out.println("Language: " + language));
        
        System.out.println("\n=== Lambda Expression - With Method Reference ===");
        // Method reference (even cleaner!)
        languages.forEach(System.out::println);
        
        System.out.println("\n=== Lambda Expression - With Logic ===");
        // Lambda with conditional logic
        languages.forEach(language -> {
            if (language.contains("Java")) {
                System.out.println("⭐ Favorite: " + language);
            } else {
                System.out.println("Language: " + language);
            }
        });
        
        // Example with custom objects
        List<Product> products = new ArrayList<>();
        products.add(new Product("Laptop", 50000));
        products.add(new Product("Phone", 20000));
        products.add(new Product("Tablet", 15000));
        
        System.out.println("\n=== Lambda with Custom Objects ===");
        products.forEach(product -> 
            System.out.println(product.name + " - ₹" + product.price)
        );
        
        // Filter and display expensive products
        System.out.println("\n=== Expensive Products (>25000) ===");
        products.forEach(product -> {
            if (product.price > 25000) {
                System.out.println("💰 " + product.name + " - ₹" + product.price);
            }
        });
    }
}

// Helper class
class Product {
    String name;
    double price;
    
    Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
}
```

**Output:**
```
=== Lambda Expression - Basic ===
Language: Java ☕
Language: Python 🐍
Language: JavaScript 🌐
Language: C++ 🔧
Language: Go 🚀

=== Lambda Expression - With Method Reference ===
Java ☕
Python 🐍
JavaScript 🌐
C++ 🔧
Go 🚀

=== Lambda Expression - With Logic ===
⭐ Favorite: Java ☕
Language: Python 🐍
Language: JavaScript 🌐
Language: C++ 🔧
Language: Go 🚀

=== Lambda with Custom Objects ===
Laptop - ₹50000.0
Phone - ₹20000.0
Tablet - ₹15000.0

=== Expensive Products (>25000) ===
💰 Laptop - ₹50000.0
```

**Pros:**
- ✅ Very clean and concise code
- ✅ Functional programming style
- ✅ Easy to read and maintain
- ✅ Can use method references

**Cons:**
- ❌ Java 8+ required
- ❌ No index information
- ❌ Learning curve for beginners

## Method 7: Stream API with forEach() 🌊

**Best for:** Complex operations, filtering, mapping, modern Java

```java
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;

public class StreamIteration {
    public static void main(String args[]) {
        // Creating an ArrayList
        List<String> names = new ArrayList<String>();
        
        // Adding elements to the List
        names.add("Arjun");
        names.add("Bheem");
        names.add("Chitra");
        names.add("Devika");
        names.add("Ekta");
        
        System.out.println("=== Stream forEach - Basic ===");
        // Using stream.forEach() to iterate the List
        names.stream().forEach(name -> System.out.println("Name: " + name));
        
        System.out.println("\n=== Stream with Method Reference ===");
        names.stream().forEach(System.out::println);
        
        // Advanced Stream Operations
        List<Employee> employees = new ArrayList<>();
        employees.add(new Employee("Raj", 25, 50000));
        employees.add(new Employee("Simran", 30, 75000));
        employees.add(new Employee("Karan", 28, 60000));
        employees.add(new Employee("Preeti", 32, 80000));
        employees.add(new Employee("Vikram", 26, 55000));
        
        System.out.println("\n=== All Employees ===");
        employees.stream()
                .forEach(emp -> System.out.println(emp.name + " (Age: " + emp.age + ", Salary: ₹" + emp.salary + ")"));
        
        System.out.println("\n=== High Salary Employees (>60000) ===");
        employees.stream()
                .filter(emp -> emp.salary > 60000)
                .forEach(emp -> System.out.println("💰 " + emp.name + " - ₹" + emp.salary));
        
        System.out.println("\n=== Young Employees (<30) with Names in Uppercase ===");
        employees.stream()
                .filter(emp -> emp.age < 30)
                .map(emp -> emp.name.toUpperCase())
                .forEach(name -> System.out.println("🌟 " + name));
        
        System.out.println("\n=== Employee Names Starting with 'S' or 'P' ===");
        employees.stream()
                .filter(emp -> emp.name.startsWith("S") || emp.name.startsWith("P"))
                .forEach(emp -> System.out.println("✨ " + emp.name));
        
        // Collect results
        System.out.println("\n=== Collect Names to New List ===");
        List<String> employeeNames = employees.stream()
                .map(emp -> emp.name)
                .collect(Collectors.toList());
        System.out.println("Names List: " + employeeNames);
    }
}

// Helper class
class Employee {
    String name;
    int age;
    double salary;
    
    Employee(String name, int age, double salary) {
        this.name = name;
        this.age = age;
        this.salary = salary;
    }
}
```

**Output:**
```
=== Stream forEach - Basic ===
Name: Arjun
Name: Bheem
Name: Chitra
Name: Devika
Name: Ekta

=== Stream with Method Reference ===
Arjun
Bheem
Chitra
Devika
Ekta

=== All Employees ===
Raj (Age: 25, Salary: ₹50000.0)
Simran (Age: 30, Salary: ₹75000.0)
Karan (Age: 28, Salary: ₹60000.0)
Preeti (Age: 32, Salary: ₹80000.0)
Vikram (Age: 26, Salary: ₹55000.0)

=== High Salary Employees (>60000) ===
💰 Simran - ₹75000.0
💰 Preeti - ₹80000.0

=== Young Employees (<30) with Names in Uppercase ===
🌟 RAJ
🌟 KARAN
🌟 VIKRAM

=== Employee Names Starting with 'S' or 'P' ===
✨ Simran
✨ Preeti

=== Collect Names to New List ===
Names List: [Raj, Simran, Karan, Preeti, Vikram]
```

**Pros:**
- ✅ Powerful filtering and mapping
- ✅ Chain multiple operations
- ✅ Parallel processing support
- ✅ Functional programming style

**Cons:**
- ❌ Java 8+ required
- ❌ Can be slower for simple operations
- ❌ Memory overhead for small lists

## Method 8: Advanced Techniques 🆕

### A) Parallel Stream for Large Data

```java
import java.util.List;
import java.util.ArrayList;
import java.util.stream.IntStream;

public class ParallelStreamExample {
    public static void main(String[] args) {
        // Create large list
        List<Integer> largeList = new ArrayList<>();
        IntStream.range(1, 1000000).forEach(largeList::add);
        
        System.out.println("=== Sequential vs Parallel Processing ===");
        
        // Sequential processing
        long startTime = System.currentTimeMillis();
        largeList.stream()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n * n)
                .sum();
        long sequentialTime = System.currentTimeMillis() - startTime;
        
        // Parallel processing
        startTime = System.currentTimeMillis();
        largeList.parallelStream()
                .filter(n -> n % 2 == 0)
                .mapToInt(n -> n * n)
                .sum();
        long parallelTime = System.currentTimeMillis() - startTime;
        
        System.out.println("Sequential time: " + sequentialTime + "ms");
        System.out.println("Parallel time: " + parallelTime + "ms");
        System.out.println("Speedup: " + (double)sequentialTime/parallelTime + "x");
    }
}
```

### B) Custom Iterator

```java
import java.util.*;

public class CustomIteratorExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("A", "B", "C", "D", "E");
        
        // Custom iterator that skips every alternate element
        Iterator<String> customIterator = new Iterator<String>() {
            private Iterator<String> iterator = list.iterator();
            private String next;
            private boolean hasNext = true;
            
            {
                advance();
            }
            
            private void advance() {
                hasNext = false;
                while (iterator.hasNext()) {
                    next = iterator.next();
                    hasNext = true;
                    if (iterator.hasNext()) {
                        iterator.next(); // Skip one
                    }
                    break;
                }
            }
            
            @Override
            public boolean hasNext() {
                return hasNext;
            }
            
            @Override
            public String next() {
                String result = next;
                advance();
                return result;
            }
        };
        
        System.out.println("=== Custom Iterator (Every Alternate Element) ===");
        while (customIterator.hasNext()) {
            System.out.println(customIterator.next());
        }
    }
}
```

### C) Indexed forEach

```java
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicInteger;

public class IndexedForEachExample {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("Apple", "Banana", "Cherry", "Date");
        
        System.out.println("=== Indexed forEach with AtomicInteger ===");
        AtomicInteger index = new AtomicInteger(0);
        fruits.forEach(fruit -> 
            System.out.println("Index " + index.getAndIncrement() + ": " + fruit)
        );
        
        System.out.println("\n=== Indexed forEach with IntStream ===");
        IntStream.range(0, fruits.size())
                .forEach(i -> System.out.println("Index " + i + ": " + fruits.get(i)));
    }
}
```

## Performance Comparison 📊

```java
import java.util.*;
import java.util.stream.IntStream;

public class PerformanceComparison {
    public static void main(String[] args) {
        // Create test data
        List<Integer> list = new ArrayList<>();
        IntStream.range(1, 1000000).forEach(list::add);
        
        System.out.println("=== Performance Comparison (1M elements) ===");
        
        // Traditional for loop
        long startTime = System.nanoTime();
        int sum1 = 0;
        for (int i = 0; i < list.size(); i++) {
            sum1 += list.get(i);
        }
        long time1 = System.nanoTime() - startTime;
        
        // Enhanced for loop
        startTime = System.nanoTime();
        int sum2 = 0;
        for (Integer num : list) {
            sum2 += num;
        }
        long time2 = System.nanoTime() - startTime;
        
        // Iterator
        startTime = System.nanoTime();
        int sum3 = 0;
        Iterator<Integer> it = list.iterator();
        while (it.hasNext()) {
            sum3 += it.next();
        }
        long time3 = System.nanoTime() - startTime;
        
        // Stream forEach
        startTime = System.nanoTime();
        final int[] sum4 = {0};
        list.stream().forEach(num -> sum4[0] += num);
        long time4 = System.nanoTime() - startTime;
        
        System.out.println("Traditional For Loop: " + time1/1000000 + "ms");
        System.out.println("Enhanced For Loop: " + time2/1000000 + "ms");
        System.out.println("Iterator: " + time3/1000000 + "ms");
        System.out.println("Stream forEach: " + time4/1000000 + "ms");
        
        System.out.println("\nAll sums equal: " + 
            (sum1 == sum2 && sum2 == sum3 && sum3 == sum4[0]));
    }
}
```

## When to Use Which Method? 🤔

| **Method** | **Best Use Case** | **Performance** | **Readability** |
|------------|------------------|-----------------|-----------------|
| **Traditional For** | Index needed, ArrayList | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **Enhanced For** | Simple iteration, any List | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **While Loop** | Complex conditions | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **Iterator** | Safe removal needed | ⭐⭐⭐⭐ | ⭐⭐⭐ |
| **ListIterator** | Bidirectional access | ⭐⭐⭐ | ⭐⭐ |
| **Lambda** | Modern, clean code | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Stream** | Complex operations | ⭐⭐ | ⭐⭐⭐⭐⭐ |

## Common Mistakes - Avoid Karo! ❌

### 1. **ConcurrentModificationException**
```java
// ❌ Wrong way
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
for (String item : list) {
    if (item.equals("B")) {
        list.remove(item); // ConcurrentModificationException!
    }
}

// ✅ Correct way
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String item = iterator.next();
    if (item.equals("B")) {
        iterator.remove(); // Safe removal
    }
}
```

### 2. **Index Out of Bounds**
```java
List<String> list = new ArrayList<>();
// ❌ Wrong - empty list
for (int i = 0; i <= list.size(); i++) { // <= is wrong!
    System.out.println(list.get(i));
}

// ✅ Correct
for (int i = 0; i < list.size(); i++) { // < is correct
    System.out.println(list.get(i));
}
```

### 3. **Null Pointer Exception**
```java
List<String> list = null;
// ❌ Wrong - no null check
for (String item : list) { // NPE!
    System.out.println(item);
}

// ✅ Correct
if (list != null && !list.isEmpty()) {
    for (String item : list) {
        System.out.println(item);
    }
}
```

## Interview Questions - Master Karo! 💪

### Q1: **Which iteration method is fastest?**
```java
// Answer demonstration
public class FastestIteration {
    public static void main(String[] args) {
        List<Integer> arrayList = new ArrayList<>();
        List<Integer> linkedList = new LinkedList<>();
        
        // Fill lists
        for (int i = 0; i < 100000; i++) {
            arrayList.add(i);
            linkedList.add(i);
        }
        
        // ArrayList: Traditional for loop is fastest
        // LinkedList: Enhanced for loop or Iterator is fastest
        
        System.out.println("ArrayList - Traditional for loop: Fastest");
        System.out.println("LinkedList - Enhanced for loop/Iterator: Fastest");
    }
}
```

### Q2: **How to iterate and modify list safely?**
```java
// Safe modification techniques
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

// Method 1: Iterator
Iterator<Integer> it = numbers.iterator();
while (it.hasNext()) {
    if (it.next() % 2 == 0) {
        it.remove();
    }
}

// Method 2: Traditional for loop (backwards)
for (int i = numbers.size() - 1; i >= 0; i--) {
    if (numbers.get(i) % 2 == 0) {
        numbers.remove(i);
    }
}

// Method 3: removeIf (Java 8+)
numbers.removeIf(n -> n % 2 == 0);
```

### Q3: **Difference between Iterator and ListIterator?**

| **Iterator** | **ListIterator** |
|--------------|------------------|
| Forward only | Bidirectional |
| All Collections | Only List |
| hasNext(), next(), remove() | hasNext(), next(), hasPrevious(), previous(), add(), set(), remove() |
| Cannot add elements | Can add elements during iteration |
| No index information | Provides index information |

```java
public class IteratorVsListIterator {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
        
        // Iterator - Forward only
        System.out.println("=== Iterator ===");
        Iterator<String> iterator = list.iterator();
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
        
        // ListIterator - Bidirectional
        System.out.println("\n=== ListIterator - Forward ===");
        ListIterator<String> listIterator = list.listIterator();
        while (listIterator.hasNext()) {
            System.out.println("Index " + listIterator.nextIndex() + ": " + listIterator.next());
        }
        
        System.out.println("\n=== ListIterator - Backward ===");
        while (listIterator.hasPrevious()) {
            System.out.println("Index " + listIterator.previousIndex() + ": " + listIterator.previous());
        }
    }
}
```

### Q4: **Can we use parallel streams for iteration?**
```java
public class ParallelStreamIteration {
    public static void main(String[] args) {
        List<Integer> largeList = IntStream.range(1, 1000000)
                                         .boxed()
                                         .collect(Collectors.toList());
        
        // Sequential stream
        long start = System.currentTimeMillis();
        long sequentialSum = largeList.stream()
                                    .mapToLong(Integer::longValue)
                                    .sum();
        long sequentialTime = System.currentTimeMillis() - start;
        
        // Parallel stream
        start = System.currentTimeMillis();
        long parallelSum = largeList.parallelStream()
                                  .mapToLong(Integer::longValue)
                                  .sum();
        long parallelTime = System.currentTimeMillis() - start;
        
        System.out.println("Sequential: " + sequentialTime + "ms");
        System.out.println("Parallel: " + parallelTime + "ms");
        System.out.println("Results equal: " + (sequentialSum == parallelSum));
    }
}
```

### Q5: **How to iterate with index using streams?**
```java
public class IndexedStreamIteration {
    public static void main(String[] args) {
        List<String> fruits = Arrays.asList("Apple", "Banana", "Cherry");
        
        // Method 1: Using IntStream.range
        IntStream.range(0, fruits.size())
                .forEach(i -> System.out.println(i + ": " + fruits.get(i)));
        
        // Method 2: Custom collector with AtomicInteger
        AtomicInteger counter = new AtomicInteger(0);
        fruits.stream()
              .forEach(fruit -> System.out.println(counter.getAndIncrement() + ": " + fruit));
        
        // Method 3: Using custom utility method
        fruits.stream()
              .collect(ArrayList::new, (list, item) -> list.add(new IndexedItem<>(list.size(), item)), ArrayList::addAll)
              .forEach(indexedItem -> System.out.println(indexedItem.index + ": " + indexedItem.item));
    }
    
    static class IndexedItem<T> {
        final int index;
        final T item;
        
        IndexedItem(int index, T item) {
            this.index = index;
            this.item = item;
        }
    }
}
```

## Best Practices 🌟

### 1. **Choose Right Method for Right Situation**
```java
public class BestPracticesExample {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("Java", "Python", "C++", "JavaScript");
        
        // ✅ Simple reading - Enhanced for loop
        System.out.println("=== Simple Reading ===");
        for (String language : list) {
            System.out.println(language);
        }
        
        // ✅ Need index - Traditional for loop
        System.out.println("\n=== With Index ===");
        for (int i = 0; i < list.size(); i++) {
            System.out.println(i + ": " + list.get(i));
        }
        
        // ✅ Safe removal - Iterator
        List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        System.out.println("\n=== Safe Removal ===");
        Iterator<Integer> it = numbers.iterator();
        while (it.hasNext()) {
            Integer num = it.next();
            if (num % 2 == 0) {
                it.remove();
                System.out.println("Removed: " + num);
            }
        }
        System.out.println("Remaining: " + numbers);
        
        // ✅ Complex operations - Stream
        System.out.println("\n=== Complex Operations ===");
        List<String> result = list.stream()
                                 .filter(lang -> lang.length() > 4)
                                 .map(String::toUpperCase)
                                 .collect(Collectors.toList());
        System.out.println("Filtered and transformed: " + result);
    }
}
```

### 2. **Null Safety**
```java
public class NullSafeIteration {
    public static void main(String[] args) {
        List<String> list = null;
        
        // ✅ Always check for null
        if (list != null && !list.isEmpty()) {
            for (String item : list) {
                System.out.println(item);
            }
        } else {
            System.out.println("List is null or empty");
        }
        
        // ✅ Using Optional (Java 8+)
        Optional.ofNullable(list)
                .filter(l -> !l.isEmpty())
                .ifPresent(l -> l.forEach(System.out::println));
        
        // ✅ Using utility method
        safeIterate(list);
    }
    
    public static void safeIterate(List<String> list) {
        if (list == null) {
            System.out.println("Cannot iterate null list");
            return;
        }
        
        if (list.isEmpty()) {
            System.out.println("List is empty");
            return;
        }
        
        for (String item : list) {
            System.out.println(item);
        }
    }
}
```

### 3. **Handle Different List Types Efficiently**
```java
public class EfficientListIteration {
    public static void main(String[] args) {
        // ArrayList - Random access is fast
        List<Integer> arrayList = new ArrayList<>();
        IntStream.range(1, 10000).forEach(arrayList::add);
        
        // LinkedList - Sequential access is better
        List<Integer> linkedList = new LinkedList<>();
        IntStream.range(1, 10000).forEach(linkedList::add);
        
        System.out.println("=== ArrayList - Use traditional for loop ===");
        long start = System.nanoTime();
        for (int i = 0; i < arrayList.size(); i++) {
            int value = arrayList.get(i); // O(1) access
        }
        long arrayListTime = System.nanoTime() - start;
        
        System.out.println("=== LinkedList - Use enhanced for loop ===");
        start = System.nanoTime();
        for (Integer value : linkedList) { // Iterator-based, O(1) per element
            // Process value
        }
        long linkedListTime = System.nanoTime() - start;
        
        System.out.println("ArrayList traditional for: " + arrayListTime/1000000 + "ms");
        System.out.println("LinkedList enhanced for: " + linkedListTime/1000000 + "ms");
    }
}
```

### 4. **Stream vs Loop Performance**
```java
public class StreamVsLoopPerformance {
    public static void main(String[] args) {
        List<Integer> numbers = IntStream.range(1, 1000000)
                                       .boxed()
                                       .collect(Collectors.toList());
        
        // Simple operations - Loop is faster
        System.out.println("=== Simple Sum Operation ===");
        
        // Traditional loop
        long start = System.nanoTime();
        long sum1 = 0;
        for (Integer num : numbers) {
            sum1 += num;
        }
        long loopTime = System.nanoTime() - start;
        
        // Stream
        start = System.nanoTime();
        long sum2 = numbers.stream()
                          .mapToLong(Integer::longValue)
                          .sum();
        long streamTime = System.nanoTime() - start;
        
        System.out.println("Loop time: " + loopTime/1000000 + "ms");
        System.out.println("Stream time: " + streamTime/1000000 + "ms");
        System.out.println("Results equal: " + (sum1 == sum2));
        
        // Complex operations - Stream is more readable
        System.out.println("\n=== Complex Filter-Map-Collect ===");
        
        // Stream (more readable for complex operations)
        start = System.nanoTime();
        List<String> result = numbers.stream()
                                   .filter(n -> n % 2 == 0)
                                   .filter(n -> n > 100)
                                   .map(n -> "Number: " + n)
                                   .limit(1000)
                                   .collect(Collectors.toList());
        streamTime = System.nanoTime() - start;
        
        System.out.println("Complex stream operation: " + streamTime/1000000 + "ms");
        System.out.println("Result size: " + result.size());
    }
}
```

## Real-World Examples 🌍

### Example 1: Student Management System
```java
import java.util.*;
import java.util.stream.Collectors;

public class StudentManagementSystem {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Rahul", 85, "Computer Science"),
            new Student("Priya", 92, "Mathematics"),
            new Student("Amit", 78, "Physics"),
            new Student("Sneha", 96, "Computer Science"),
            new Student("Vikash", 82, "Mathematics"),
            new Student("Anita", 88, "Physics")
        );
        
        System.out.println("=== All Students ===");
        students.forEach(student -> 
            System.out.println(student.name + " - " + student.marks + " (" + student.subject + ")")
        );
        
        System.out.println("\n=== Top Performers (>90) ===");
        students.stream()
                .filter(student -> student.marks > 90)
                .forEach(student -> System.out.println("🌟 " + student.name + " - " + student.marks));
        
        System.out.println("\n=== Subject-wise Grouping ===");
        Map<String, List<Student>> subjectGroups = students.stream()
                .collect(Collectors.groupingBy(student -> student.subject));
        
        subjectGroups.forEach((subject, studentList) -> {
            System.out.println(subject + ":");
            studentList.forEach(student -> System.out.println("  - " + student.name + " (" + student.marks + ")"));
        });
        
        System.out.println("\n=== Average Marks by Subject ===");
        Map<String, Double> averageMarks = students.stream()
                .collect(Collectors.groupingBy(
                    student -> student.subject,
                    Collectors.averagingDouble(student -> student.marks)
                ));
        
        averageMarks.forEach((subject, avg) -> 
            System.out.println(subject + ": " + String.format("%.2f", avg))
        );
    }
    
    static class Student {
        String name;
        int marks;
        String subject;
        
        Student(String name, int marks, String subject) {
            this.name = name;
            this.marks = marks;
            this.subject = subject;
        }
    }
}
```

### Example 2: E-commerce Order Processing
```java
import java.util.*;
import java.util.stream.Collectors;

public class EcommerceOrderProcessing {
    public static void main(String[] args) {
        List<Order> orders = Arrays.asList(
            new Order("ORD001", "Electronics", 25000, "PENDING"),
            new Order("ORD002", "Clothing", 1200, "SHIPPED"),
            new Order("ORD003", "Books", 800, "DELIVERED"),
            new Order("ORD004", "Electronics", 45000, "PENDING"),
            new Order("ORD005", "Home", 3500, "SHIPPED"),
            new Order("ORD006", "Clothing", 2200, "PENDING")
        );
        
        System.out.println("=== Order Processing Dashboard ===");
        
        // Count orders by status
        System.out.println("\n--- Order Status Summary ---");
        Map<String, Long> statusCount = orders.stream()
                .collect(Collectors.groupingBy(
                    order -> order.status,
                    Collectors.counting()
                ));
        
        statusCount.forEach((status, count) -> 
            System.out.println(status + ": " + count + " orders")
        );
        
        // High-value pending orders (need attention)
        System.out.println("\n--- High-Value Pending Orders (>10000) ---");
        orders.stream()
              .filter(order -> order.status.equals("PENDING"))
              .filter(order -> order.amount > 10000)
              .sorted((o1, o2) -> Double.compare(o2.amount, o1.amount))
              .forEach(order -> System.out.println("🚨 " + order.id + " - " + order.category + " - ₹" + order.amount));
        
        // Revenue by category
        System.out.println("\n--- Revenue by Category ---");
        Map<String, Double> revenueByCategory = orders.stream()
                .collect(Collectors.groupingBy(
                    order -> order.category,
                    Collectors.summingDouble(order -> order.amount)
                ));
        
        revenueByCategory.entrySet().stream()
                        .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
                        .forEach(entry -> System.out.println(entry.getKey() + ": ₹" + entry.getValue()));
        
        // Process pending orders (simulation)
        System.out.println("\n--- Processing Pending Orders ---");
        ListIterator<Order> iterator = orders.listIterator();
        while (iterator.hasNext()) {
            Order order = iterator.next();
            if (order.status.equals("PENDING")) {
                // Simulate processing
                order.status = "PROCESSED";
                System.out.println("✅ Processed order: " + order.id);
            }
        }
        
        // Final status check
        System.out.println("\n--- Final Status Check ---");
        orders.forEach(order -> 
            System.out.println(order.id + " - " + order.status)
        );
    }
    
    static class Order {
        String id;
        String category;
        double amount;
        String status;
        
        Order(String id, String category, double amount, String status) {
            this.id = id;
            this.category = category;
            this.amount = amount;
            this.status = status;
        }
    }
}
```

## Summary - Quick Reference Card 📋

### **🔥 Most Common Methods (80% use cases):**

```java
// 1. Enhanced For Loop (Most Popular)
for (String item : list) {
    System.out.println(item);
}

// 2. Stream forEach (Modern Java)
list.forEach(System.out::println);

// 3. Traditional For (When index needed)
for (int i = 0; i < list.size(); i++) {
    System.out.println(i + ": " + list.get(i));
}

// 4. Iterator (When removal needed)
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    String item = it.next();
    if (shouldRemove(item)) {
        it.remove();
    }
}
```

### **⚡ Performance Quick Guide:**

| **List Type** | **Best Method** | **Reason** |
|---------------|-----------------|------------|
| **ArrayList** | Traditional For | Random access O(1) |
| **LinkedList** | Enhanced For / Iterator | Sequential access O(1) |
| **Large Dataset** | Parallel Stream | Multi-core utilization |
| **Simple Operation** | Enhanced For | Clean + Fast |
| **Complex Operation** | Stream | Readability + Power |

### **🎯 Decision Tree:**

```
Need to iterate a List?
├── Need index information?
│   └── YES → Traditional For Loop
├── Need to remove elements safely?
│   └── YES → Iterator
├── Need bidirectional access?
│   └── YES → ListIterator  
├── Complex filtering/mapping needed?
│   └── YES → Stream API
├── Simple read-only iteration?
│   └── YES → Enhanced For Loop
└── Modern functional style?
    └── YES → Lambda forEach
```

### **🚨 Remember These Rules:**

1. **Enhanced For Loop** - 80% of cases, cleanest code
2. **Traditional For** - When you need index access
3. **Iterator** - When removing elements during iteration
4. **Stream** - When complex operations needed
5. **Never modify list during enhanced for loop** - Use Iterator!
6. **ArrayList + index access = Traditional For**
7. **LinkedList + sequential = Enhanced For**
8. **Large data + complex ops = Parallel Stream**

### **💡 Pro Tips:**

- **Method Reference**: `list.forEach(System.out::println)` instead of `list.forEach(item -> System.out.println(item))`
- **Null Safety**: Always check `if (list != null && !list.isEmpty())`
- **Performance**: For simple operations, traditional loops are faster than streams
- **Readability**: For complex operations, streams are more readable than loops
- **Memory**: Streams can use more memory due to intermediate collections

---

## Conclusion 🎉

List iteration एक fundamental skill है Java programming में! यहाँ सभी methods के साथ real examples और best practices cover किए गए हैं।

**Key Takeaways:**
1. 🎯 **Enhanced For Loop** - Most common and clean
2. 🔍 **Iterator** - Safe removal during iteration  
3. 🌊 **Stream API** - Modern functional programming style
4. ⚡ **Performance matters** - Choose right method for right scenario
5. 🛡️ **Safety first** - Always handle null cases
6. 📚 **Practice** - Try all methods with different scenarios

Practice these examples और तुम List iteration के master बन जाओगे! 🚀💪

---
*Happy Coding! 🎉*
|
