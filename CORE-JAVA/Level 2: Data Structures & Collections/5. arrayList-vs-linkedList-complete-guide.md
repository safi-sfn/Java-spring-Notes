# ArrayList vs LinkedList - Complete Study Notes 📚

## Introduction - Data Structure Battle! ⚔️

**Common Confusion:** ArrayList vs LinkedList - Kaunsa use karna hai aur kab?

**Simple Analogy:**
- **ArrayList** = Apartment building 🏢 (Rooms next to each other, easy to find by number)
- **LinkedList** = Train 🚂 (Cars connected by links, easy to add/remove cars anywhere)

**Real Life Example:**
- **ArrayList**: Library mein books shelf par arrange (easy to find book #5, but inserting new book between requires shifting)
- **LinkedList**: People standing in queue holding hands (easy to add/remove person anywhere, but finding 5th person requires walking)

## What are ArrayList and LinkedList? 🤔

### **ArrayList** 📋
- **Internal Structure**: Resizable array (dynamic array)
- **Memory**: Contiguous memory allocation
- **Default Capacity**: 10 elements
- **Growth**: Increases by 50% when full

### **LinkedList** 🔗
- **Internal Structure**: Doubly linked list
- **Memory**: Non-contiguous memory allocation  
- **Default Capacity**: No fixed capacity
- **Growth**: Dynamic node creation

## Visual Representation 👀

### **ArrayList Structure:**
```
Index:  [0] [1] [2] [3] [4] [5] [6] [7] [8] [9]
Memory: [A] [B] [C] [D] [E] [ ] [ ] [ ] [ ] [ ]
        ↑   ↑   ↑   ↑   ↑
    Contiguous memory blocks
```

### **LinkedList Structure:**
```
[A]→[B]→[C]→[D]→[E]→null
 ↑   ↑   ↑   ↑   ↑
Each node has data + reference to next node
```

## Complete Comparison Table 📊

| **Feature** | **ArrayList** | **LinkedList** |
|------------|--------------|----------------|
| **Internal Structure** | Dynamic Array 📋 | Doubly Linked List 🔗 |
| **Memory Allocation** | Contiguous 📐 | Non-contiguous 🔀 |
| **Default Capacity** | 10 elements | No fixed capacity |
| **Interfaces Implemented** | List, RandomAccess | List, Deque, Queue |
| **Access Time (get/set)** | O(1) - Fast ⚡ | O(n) - Slow 🐌 |
| **Search Time** | O(n) - Linear | O(n) - Linear |
| **Insertion at End** | O(1) amortized | O(1) - Fast ⚡ |
| **Insertion at Beginning** | O(n) - Slow 🐌 | O(1) - Fast ⚡ |
| **Insertion at Middle** | O(n) - Slow 🐌 | O(1) if node known ⚡ |
| **Deletion at End** | O(1) - Fast ⚡ | O(1) - Fast ⚡ |
| **Deletion at Beginning** | O(n) - Slow 🐌 | O(1) - Fast ⚡ |
| **Deletion at Middle** | O(n) - Slow 🐌 | O(1) if node known ⚡ |
| **Memory Overhead** | Lower (only data) | Higher (data + pointers) |
| **Cache Performance** | Better (locality) | Poor (scattered) |

## Detailed Analysis 🔍

### 1. **Internal Data Structure** 🏗️

#### **ArrayList - Array Based:**
```java
public class ArrayListExample {
    public static void main(String[] args) {
        ArrayList<String> arrayList = new ArrayList<>();
        
        // Internal array structure
        System.out.println("Initial capacity: " + arrayList.size()); // 0
        
        // Adding elements - stored in contiguous memory
        arrayList.add("A");  // Index 0
        arrayList.add("B");  // Index 1  
        arrayList.add("C");  // Index 2
        
        // Direct access by index - O(1)
        System.out.println("Element at index 1: " + arrayList.get(1)); // B
        
        // When capacity is exceeded, new array is created (1.5x size)
        for (int i = 0; i < 15; i++) {
            arrayList.add("Element" + i);
        }
        System.out.println("Size after adding 15 elements: " + arrayList.size());
    }
}
```

#### **LinkedList - Node Based:**
```java
public class LinkedListExample {
    public static void main(String[] args) {
        LinkedList<String> linkedList = new LinkedList<>();
        
        // Each element is a node with data + pointers
        linkedList.add("A");  // Node 1: [A, null, ref_to_B]
        linkedList.add("B");  // Node 2: [B, ref_to_A, ref_to_C]
        linkedList.add("C");  // Node 3: [C, ref_to_B, null]
        
        // Access requires traversal - O(n)
        System.out.println("Element at index 1: " + linkedList.get(1)); // Traverses from head
        
        // Easy insertion at any position
        linkedList.addFirst("START");  // O(1) - just update head pointer
        linkedList.addLast("END");     // O(1) - just update tail pointer
        
        System.out.println("Final list: " + linkedList);
    }
}
```

### 2. **Performance Analysis** ⚡

#### **Access Operations (get/set):**
```java
import java.util.*;

public class AccessPerformanceTest {
    public static void main(String[] args) {
        int size = 100000;
        
        // ArrayList - O(1) access
        ArrayList<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
        }
        
        // LinkedList - O(n) access
        LinkedList<Integer> linkedList = new LinkedList<>();
        for (int i = 0; i < size; i++) {
            linkedList.add(i);
        }
        
        // Access middle element
        long startTime = System.currentTimeMillis();
        int value1 = arrayList.get(50000);  // Direct array access
        long arrayListTime = System.currentTimeMillis() - startTime;
        
        startTime = System.currentTimeMillis();
        int value2 = linkedList.get(50000); // Traverse 50000 nodes
        long linkedListTime = System.currentTimeMillis() - startTime;
        
        System.out.println("ArrayList access time: " + arrayListTime + "ms");
        System.out.println("LinkedList access time: " + linkedListTime + "ms");
        // ArrayList will be much faster!
    }
}
```

#### **Insertion Operations:**
```java
public class InsertionPerformanceTest {
    public static void main(String[] args) {
        ArrayList<String> arrayList = new ArrayList<>();
        LinkedList<String> linkedList = new LinkedList<>();
        
        // Pre-populate
        for (int i = 0; i < 10000; i++) {
            arrayList.add("Element" + i);
            linkedList.add("Element" + i);
        }
        
        // Insertion at beginning
        long startTime = System.currentTimeMillis();
        arrayList.add(0, "NEW");  // O(n) - shift all elements
        long arrayListTime = System.currentTimeMillis() - startTime;
        
        startTime = System.currentTimeMillis();
        linkedList.addFirst("NEW"); // O(1) - just update head
        long linkedListTime = System.currentTimeMillis() - startTime;
        
        System.out.println("ArrayList insertion at start: " + arrayListTime + "ms");
        System.out.println("LinkedList insertion at start: " + linkedListTime + "ms");
        // LinkedList will be much faster!
    }
}
```

### 3. **Memory Usage** 💾

#### **ArrayList Memory:**
```java
public class ArrayListMemory {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>();
        
        // Memory layout (simplified)
        // [data1][data2][data3][empty][empty][empty]...
        // Only stores actual data + some unused slots
        
        list.add(10);  // 4 bytes (int)
        list.add(20);  // 4 bytes (int) 
        list.add(30);  // 4 bytes (int)
        
        // Total memory ≈ capacity × element_size
        // Less memory overhead
    }
}
```

#### **LinkedList Memory:**
```java
public class LinkedListMemory {
    public static void main(String[] args) {
        LinkedList<Integer> list = new LinkedList<>();
        
        // Memory layout (simplified)
        // Node1: [data][prev_ref][next_ref] → Node2: [data][prev_ref][next_ref]
        // Each node stores data + 2 references (8 bytes each on 64-bit)
        
        list.add(10);  // 4 bytes (int) + 16 bytes (references) + object overhead
        list.add(20);  // 4 bytes (int) + 16 bytes (references) + object overhead
        list.add(30);  // 4 bytes (int) + 16 bytes (references) + object overhead
        
        // Much higher memory overhead per element
    }
}
```

## Real-World Examples 🌍

### Example 1: Student Management System 🎓

```java
import java.util.*;

// Use ArrayList when frequent access by index is needed
class StudentManagementArrayList {
    private ArrayList<Student> students = new ArrayList<>();
    
    public void addStudent(Student student) {
        students.add(student);  // O(1) amortized
    }
    
    public Student getStudent(int rollNumber) {
        return students.get(rollNumber);  // O(1) - Direct access
    }
    
    public void displayToppers() {
        // Frequent random access needed
        for (int i = 0; i < Math.min(10, students.size()); i++) {
            System.out.println("Rank " + (i+1) + ": " + students.get(i).getName());
        }
    }
}

// Use LinkedList when frequent insertion/deletion needed
class StudentWaitingList {
    private LinkedList<Student> waitingQueue = new LinkedList<>();
    
    public void addToQueue(Student student) {
        waitingQueue.addLast(student);  // O(1)
    }
    
    public Student processNext() {
        return waitingQueue.removeFirst();  // O(1)
    }
    
    public void addUrgent(Student student) {
        waitingQueue.addFirst(student);  // O(1) - Emergency admission
    }
}
```

### Example 2: Music Playlist 🎵

```java
// ArrayList for shuffle/repeat operations
class ShufflePlaylist {
    private ArrayList<Song> playlist = new ArrayList<>();
    
    public void shuffle() {
        Collections.shuffle(playlist);  // Needs random access
    }
    
    public Song getSongAtPosition(int position) {
        return playlist.get(position);  // O(1) access needed
    }
    
    public void jumpToSong(int index) {
        // Direct access for seeking
        currentSong = playlist.get(index);
    }
}

// LinkedList for dynamic playlist management
class DynamicPlaylist {
    private LinkedList<Song> playlist = new LinkedList<>();
    
    public void addNext(Song song) {
        playlist.add(currentIndex + 1, song);  // Insert after current
    }
    
    public void removePlayed() {
        playlist.removeFirst();  // O(1) removal
    }
    
    public void addToEnd(Song song) {
        playlist.addLast(song);  // O(1) addition
    }
}
```

### Example 3: Web Browser History 🌐

```java
// ArrayList for history with direct access
class BrowserHistoryArrayList {
    private ArrayList<String> history = new ArrayList<>();
    private int currentIndex = -1;
    
    public void visit(String url) {
        // Remove forward history
        while (history.size() > currentIndex + 1) {
            history.remove(history.size() - 1);
        }
        history.add(url);
        currentIndex++;
    }
    
    public String back() {
        if (currentIndex > 0) {
            currentIndex--;
            return history.get(currentIndex);  // O(1) access
        }
        return null;
    }
    
    public String forward() {
        if (currentIndex < history.size() - 1) {
            currentIndex++;
            return history.get(currentIndex);  // O(1) access
        }
        return null;
    }
}

// LinkedList for browser tabs (frequent add/remove)
class BrowserTabs {
    private LinkedList<Tab> tabs = new LinkedList<>();
    
    public void openNewTab(String url) {
        tabs.addLast(new Tab(url));  // O(1)
    }
    
    public void closeTab(Tab tab) {
        tabs.remove(tab);  // O(n) but typically few tabs
    }
    
    public void moveTabToStart(Tab tab) {
        tabs.remove(tab);
        tabs.addFirst(tab);  // O(1) insertion
    }
}
```

## When to Use What? 🤷‍♂️

### **Use ArrayList When:** ✅

#### 1. **Frequent Random Access Needed**
```java
// Gaming leaderboard - need to access rank by position
class GameLeaderboard {
    private ArrayList<Player> rankings = new ArrayList<>();
    
    public Player getPlayerAtRank(int rank) {
        return rankings.get(rank - 1);  // O(1) - Fast access needed
    }
    
    public void showTop10() {
        for (int i = 0; i < 10; i++) {
            System.out.println((i+1) + ". " + rankings.get(i));
        }
    }
}
```

#### 2. **More Reads Than Writes**
```java
// Product catalog - mostly read operations
class ProductCatalog {
    private ArrayList<Product> products = new ArrayList<>();
    
    public Product getProduct(int id) {
        return products.get(id);  // Frequent reads
    }
    
    public void addProduct(Product product) {
        products.add(product);  // Occasional writes
    }
}
```

#### 3. **Memory Efficiency Important**
```java
// Large dataset with memory constraints
class SensorData {
    private ArrayList<Double> readings = new ArrayList<>(1000000);
    // Lower memory overhead per element
}
```

### **Use LinkedList When:** ✅

#### 1. **Frequent Insertion/Deletion at Beginning or Middle**
```java
// Task scheduler - tasks added/removed frequently
class TaskScheduler {
    private LinkedList<Task> tasks = new LinkedList<>();
    
    public void addUrgentTask(Task task) {
        tasks.addFirst(task);  // O(1) - No shifting needed
    }
    
    public void insertTaskAfter(Task existingTask, Task newTask) {
        int index = tasks.indexOf(existingTask);
        if (index != -1) {
            tasks.add(index + 1, newTask);  // Better for middle insertion
        }
    }
}
```

#### 2. **Queue/Deque Operations Needed**
```java
// Print queue implementation
class PrintQueue {
    private LinkedList<PrintJob> queue = new LinkedList<>();
    
    public void addJob(PrintJob job) {
        queue.addLast(job);  // O(1)
    }
    
    public PrintJob getNextJob() {
        return queue.removeFirst();  // O(1)
    }
    
    public void addUrgentJob(PrintJob job) {
        queue.addFirst(job);  // O(1) - Skip queue
    }
}
```

#### 3. **Unknown Size with Dynamic Growth**
```java
// Chat messages - unknown number, frequent additions
class ChatHistory {
    private LinkedList<Message> messages = new LinkedList<>();
    
    public void addMessage(Message message) {
        messages.addLast(message);  // No capacity planning needed
    }
    
    public void removeOldMessages() {
        while (messages.size() > 1000) {
            messages.removeFirst();  // O(1)
        }
    }
}
```

## Performance Benchmarks 📈

### **Time Complexity Comparison:**

| **Operation** | **ArrayList** | **LinkedList** | **Winner** |
|--------------|--------------|----------------|------------|
| **get(index)** | O(1) ⚡ | O(n) 🐌 | ArrayList |
| **set(index, element)** | O(1) ⚡ | O(n) 🐌 | ArrayList |
| **add(element)** | O(1) amortized | O(1) ⚡ | Tie |
| **add(0, element)** | O(n) 🐌 | O(1) ⚡ | LinkedList |
| **add(index, element)** | O(n) 🐌 | O(n)* | Tie* |
| **remove(index)** | O(n) 🐌 | O(n)* | Tie* |
| **remove(0)** | O(n) 🐌 | O(1) ⚡ | LinkedList |
| **contains(element)** | O(n) | O(n) | Tie |
| **size()** | O(1) ⚡ | O(1) ⚡ | Tie |

*\* O(1) if you have direct node reference*

### **Practical Performance Test:**
```java
import java.util.*;

public class PerformanceComparison {
    public static void main(String[] args) {
        int size = 100000;
        
        // Test 1: Random Access
        testRandomAccess(size);
        
        // Test 2: Sequential Addition
        testSequentialAddition(size);
        
        // Test 3: Insertion at Beginning
        testBeginningInsertion(1000);  // Smaller size due to O(n²) complexity
    }
    
    static void testRandomAccess(int size) {
        ArrayList<Integer> arrayList = new ArrayList<>();
        LinkedList<Integer> linkedList = new LinkedList<>();
        
        // Populate lists
        for (int i = 0; i < size; i++) {
            arrayList.add(i);
            linkedList.add(i);
        }
        
        // Test random access
        Random random = new Random();
        
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            arrayList.get(random.nextInt(size));
        }
        long arrayListTime = System.currentTimeMillis() - start;
        
        start = System.currentTimeMillis();
        for (int i = 0; i < 10000; i++) {
            linkedList.get(random.nextInt(size));
        }
        long linkedListTime = System.currentTimeMillis() - start;
        
        System.out.println("Random Access Test:");
        System.out.println("ArrayList: " + arrayListTime + "ms");
        System.out.println("LinkedList: " + linkedListTime + "ms");
        System.out.println("Winner: " + (arrayListTime < linkedListTime ? "ArrayList" : "LinkedList"));
        System.out.println();
    }
    
    static void testBeginningInsertion(int size) {
        ArrayList<Integer> arrayList = new ArrayList<>();
        LinkedList<Integer> linkedList = new LinkedList<>();
        
        long start = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            arrayList.add(0, i);  // Insert at beginning
        }
        long arrayListTime = System.currentTimeMillis() - start;
        
        start = System.currentTimeMillis();
        for (int i = 0; i < size; i++) {
            linkedList.addFirst(i);  // Insert at beginning
        }
        long linkedListTime = System.currentTimeMillis() - start;
        
        System.out.println("Beginning Insertion Test:");
        System.out.println("ArrayList: " + arrayListTime + "ms");
        System.out.println("LinkedList: " + linkedListTime + "ms");
        System.out.println("Winner: " + (arrayListTime < linkedListTime ? "ArrayList" : "LinkedList"));
        System.out.println();
    }
}
```

## Common Code Examples 💻

### **ArrayList Implementation Examples:**

#### **Basic Operations:**
```java
import java.util.*;

public class ArrayListExamples {
    public static void main(String[] args) {
        // Creation
        ArrayList<String> list = new ArrayList<>();
        
        // Adding elements
        list.add("Pen");
        list.add("Pencil");
        list.add("Book");
        list.add("Notebook");
        System.out.println("ArrayList elements: " + list);
        
        // Random access - O(1)
        System.out.println("Element at index 2: " + list.get(2));
        
        // Modification - O(1)
        list.set(1, "Marker");
        System.out.println("After modification: " + list);
        
        // Insertion in middle - O(n)
        list.add(2, "Ruler");
        System.out.println("After insertion: " + list);
        
        // Search - O(n)
        int index = list.indexOf("Book");
        System.out.println("Book found at index: " + index);
        
        // Removal - O(n) for middle, O(1) for last
        list.remove("Ruler");
        System.out.println("After removal: " + list);
        
        // Iteration
        System.out.println("Iterating through ArrayList:");
        for (String item : list) {
            System.out.println("- " + item);
        }
    }
}
```

**Output:**
```
ArrayList elements: [Pen, Pencil, Book, Notebook]
Element at index 2: Book
After modification: [Pen, Marker, Book, Notebook]
After insertion: [Pen, Marker, Ruler, Book, Notebook]
Book found at index: 3
After removal: [Pen, Marker, Book, Notebook]
Iterating through ArrayList:
- Pen
- Marker
- Book
- Notebook
```

### **LinkedList Implementation Examples:**

#### **Basic Operations:**
```java
import java.util.*;

public class LinkedListExamples {
    public static void main(String[] args) {
        // Creation
        LinkedList<String> list = new LinkedList<>();
        
        // Adding elements
        list.add("Pen");
        list.add("Pencil");
        list.add("Book");
        list.add("Notebook");
        System.out.println("LinkedList elements: " + list);
        
        // Add at first position - O(1)
        list.addFirst("Bag");
        System.out.println("After addFirst: " + list);
        
        // Add at last position - O(1)
        list.addLast("Eraser");
        System.out.println("After addLast: " + list);
        
        // Remove from first - O(1)
        String first = list.removeFirst();
        System.out.println("Removed first element: " + first);
        System.out.println("After removeFirst: " + list);
        
        // Remove from last - O(1)
        String last = list.removeLast();
        System.out.println("Removed last element: " + last);
        System.out.println("After removeLast: " + list);
        
        // Access by index - O(n)
        System.out.println("Element at index 1: " + list.get(1));
        
        // Deque operations
        list.offerFirst("Start");  // Add to beginning
        list.offerLast("End");     // Add to end
        System.out.println("After deque operations: " + list);
        
        // Poll operations
        System.out.println("Poll first: " + list.pollFirst());
        System.out.println("Poll last: " + list.pollLast());
        System.out.println("Final list: " + list);
    }
}
```

**Output:**
```
LinkedList elements: [Pen, Pencil, Book, Notebook]
After addFirst: [Bag, Pen, Pencil, Book, Notebook]
After addLast: [Bag, Pen, Pencil, Book, Notebook, Eraser]
Removed first element: Bag
After removeFirst: [Pen, Pencil, Book, Notebook, Eraser]
Removed last element: Eraser
After removeLast: [Pen, Pencil, Book, Notebook]
Element at index 1: Pencil
After deque operations: [Start, Pen, Pencil, Book, Notebook, End]
Poll first: Start
Poll last: End
Final list: [Pen, Pencil, Book, Notebook]
```

## Advanced Concepts 🚀

### 1. **ArrayList Growth Mechanism:**
```java
public class ArrayListGrowth {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>(2);  // Initial capacity = 2
        
        System.out.println("Adding elements and observing capacity:");
        
        for (int i = 1; i <= 10; i++) {
            list.add(i);
            System.out.println("Size: " + list.size());
            
            // When capacity is exceeded:
            // New capacity = (old capacity * 3/2) + 1
            // 2 → 4 → 7 → 11 → 17 → ...
        }
    }
}
```

### 2. **LinkedList as Queue and Deque:**
```java
import java.util.*;

public class LinkedListAsQueueDeque {
    public static void main(String[] args) {
        // LinkedList as Queue
        Queue<String> queue = new LinkedList<>();
        queue.offer("First");   // Add to rear
        queue.offer("Second");
        queue.offer("Third");
        
        System.out.println("Queue: " + queue);
        System.out.println("Poll: " + queue.poll());  // Remove from front
        System.out.println("After poll: " + queue);
        
        // LinkedList as Deque
        Deque<String> deque = new LinkedList<>();
        deque.addFirst("Front1");
        deque.addLast("Back1");
        deque.addFirst("Front2");
        deque.addLast("Back2");
        
        System.out.println("Deque: " + deque);
        System.out.println("Remove first: " + deque.removeFirst());
        System.out.println("Remove last: " + deque.removeLast());
        System.out.println("Final deque: " + deque);
    }
}
```

### 3. **Memory Analysis:**
```java
public class MemoryAnalysis {
    public static void main(String[] args) {
        // ArrayList memory calculation
        // For 1000 integers:
        // ArrayList: 1000 * 4 bytes (int) + some overhead = ~4KB
        
        ArrayList<Integer> arrayList = new ArrayList<>();
        for (int i = 0; i < 1000; i++) {
            arrayList.add(i);
        }
        
        // LinkedList memory calculation  
        // For 1000 integers:
        // LinkedList: 1000 * (4 bytes (int) + 16 bytes (2 references) + object overhead)
        // = ~24KB (6x more memory!)
        
        LinkedList<Integer> linkedList = new LinkedList<>();
        for (int i = 0; i < 1000; i++) {
            linkedList.add(i);
        }
        
        System.out.println("ArrayList size: " + arrayList.size());
        System.out.println("LinkedList size: " + linkedList.size());
        System.out.println("LinkedList uses ~6x more memory than ArrayList");
    }
}
```

## Interview Questions - Master Karo! 💪

### Q1: **Which is better for frequent insertions?**
```java
public class FrequentInsertions {
    public static void main(String[] args) {
        // Scenario: Insert 1000 elements at random positions
        
        ArrayList<Integer> arrayList = new ArrayList<>();
        LinkedList<Integer> linkedList = new LinkedList<>();
        
        Random random = new Random();
        
        // ArrayList - O(n) for each insertion due to shifting
        long start = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            int pos = random.nextInt(arrayList.size() + 1);
            arrayList.add(pos, i);  // Expensive due to shifting
        }
        long arrayListTime = System.currentTimeMillis() - start;
        
        // LinkedList - O(n) for finding position + O(1) for insertion
        start = System.currentTimeMillis();
        for (int i = 0; i < 1000; i++) {
            int pos = random.nextInt(linkedList.size() + 1);
            linkedList.add(pos, i);  // Better for middle insertions
        }
        long linkedListTime = System.currentTimeMillis() - start;
        
        System.out.println("ArrayList insertion time: " + arrayListTime + "ms");
        System.out.println("LinkedList insertion time: " + linkedListTime + "ms");
    }
}
```

**Answer**: LinkedList is better for frequent insertions in the middle, but ArrayList is better for insertions at the end.

### Q2: **Why ArrayList implements RandomAccess?**
```java
import java.util.*;

public class RandomAccessInterface {
    public static void main(String[] args) {
        ArrayList<Integer> arrayList = new ArrayList<>();
        LinkedList<Integer> linkedList = new LinkedList<>();
        
        // RandomAccess interface indicates O(1) random access
        if (arrayList instanceof RandomAccess) {
            System.out.println("ArrayList supports fast random access");
            // Use get(index) for iteration - faster
        }
        
        if (!(linkedList instanceof RandomAccess)) {
            System.out.println("LinkedList doesn't support fast random access");
            // Use iterator for traversal - faster than get(index)
        }
        
        // Demonstration
        for (int i = 0; i < 10000; i++) {
            arrayList.add(i);
            linkedList.add(i);
        }
        
        // Fast way to iterate ArrayList
        long start = System.currentTimeMillis();
        for (int i = 0; i < arrayList.size(); i++) {
            int value = arrayList.get(i);  // O(1) access
        }
        long arrayListTime = System.currentTimeMillis() - start;
        
        // Slow way to iterate LinkedList using get()
        start = System.currentTimeMillis();
        for (int i = 0;
