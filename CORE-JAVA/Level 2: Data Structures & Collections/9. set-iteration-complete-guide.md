# How to Iterate Set in Java - Complete Study Notes 📚

## Set Iteration Kya Hai Bhai? 🔄

**Simple Words Mein**: Set ke har element ko ek-ek karke access karna aur uske saath kuch operation perform karna!

**Real Life Example**: Jaise tum apne contact list mein har number ko ek-ek karke dekhte ho, waise hi Set ke elements ko iterate karte hain! 📱

**Why Important**: Set mein data stored hai, but usko use karne ke liye iterate karna padta hai!

## Set Kya Hai - Quick Recap! 📝

```java
// Set characteristics
Set<String> uniqueNames = new HashSet<>();
uniqueNames.add("Ram");
uniqueNames.add("Shyam"); 
uniqueNames.add("Ram");  // Duplicate - won't be added
System.out.println(uniqueNames);  // Output: [Ram, Shyam]
```

**Set Features:**
- ✅ No duplicate elements
- ❌ No indexing (unlike List)
- ❌ No guaranteed order (except TreeSet, LinkedHashSet)
- ✅ Fast lookup operations

## 4 Ways to Iterate Set in Java 🛤️

### Method 1: Using Iterator - Traditional Way! 👴

```java
import java.util.*;

public class IteratorMethod {
    public static void main(String[] args) {
        // Creating a Set
        Set<String> names = new HashSet<>();
        names.add("Rim");
        names.add("Sim"); 
        names.add("Kim");
        
        System.out.println("Set: " + names);
        
        // Creating an instance of Iterator
        Iterator<String> iterate = names.iterator();
        System.out.println("Iterating over Set using Iterator:");
        
        while (iterate.hasNext()) {
            String name = iterate.next();
            System.out.println(name);
            
            // Safe removal during iteration
            if (name.equals("Rim")) {
                iterate.remove();  // ✅ Safe way to remove
            }
        }
        
        System.out.println("After removal: " + names);
    }
}
```

**Output:**
```
Set: [Sim, Rim, Kim]
Iterating over Set using Iterator:
Sim
Rim
Kim
After removal: [Sim, Kim]
```

**Iterator Benefits:**
- ✅ Safe removal during iteration
- ✅ Works with all Collection types
- ✅ Fail-fast behavior (detects concurrent modifications)
- ✅ Memory efficient

### Method 2: Enhanced For Loop - Modern & Clean! ✨

```java
import java.util.*;

public class ForEachLoop {
    public static void main(String[] args) {
        // Creating a Set with different types
        Set<String> fruits = new HashSet<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");
        fruits.add("Date");
        
        System.out.println("Set: " + fruits);
        System.out.println("Iterating over Set using Enhanced For Loop:");
        
        // Enhanced for loop - Clean and readable
        for (String fruit : fruits) {
            System.out.println("🍎 " + fruit);
            
            // Note: Don't modify Set during this iteration
            // fruits.remove(fruit);  // ❌ Would cause ConcurrentModificationException
        }
        
        // If you need to modify, collect items first
        Set<String> toRemove = new HashSet<>();
        for (String fruit : fruits) {
            if (fruit.startsWith("A")) {
                toRemove.add(fruit);
            }
        }
        fruits.removeAll(toRemove);  // ✅ Safe removal
        
        System.out.println("After removal: " + fruits);
    }
}
```

**Output:**
```
Set: [Apple, Cherry, Date, Banana]
Iterating over Set using Enhanced For Loop:
🍎 Apple
🍎 Cherry
🍎 Date
🍎 Banana
After removal: [Cherry, Date, Banana]
```

**Enhanced For Loop Benefits:**
- ✅ Clean and readable syntax
- ✅ No need to manage Iterator manually
- ✅ Less error-prone
- ❌ Cannot remove elements safely during iteration

### Method 3: Lambda Expression - Java 8+ Style! 🔥

```java
import java.util.*;

public class LambdaExpression {
    public static void main(String[] args) {
        // Creating a Set with numbers
        Set<Integer> numbers = new HashSet<>();
        numbers.add(10);
        numbers.add(20);
        numbers.add(30);
        numbers.add(40);
        numbers.add(50);
        
        System.out.println("Set: " + numbers);
        System.out.println("Iterating over Set using Lambda Expression:");
        
        // Simple lambda expression
        numbers.forEach(number -> System.out.println("Number: " + number));
        
        System.out.println("\nConditional processing with Lambda:");
        numbers.forEach(number -> {
            if (number > 25) {
                System.out.println("🔥 Large number: " + number);
            } else {
                System.out.println("📝 Small number: " + number);
            }
        });
        
        System.out.println("\nMethod Reference style:");
        numbers.forEach(System.out::println);  // Method reference
    }
}
```

**Output:**
```
Set: [50, 20, 40, 10, 30]
Iterating over Set using Lambda Expression:
Number: 50
Number: 20
Number: 40
Number: 10
Number: 30

Conditional processing with Lambda:
🔥 Large number: 50
📝 Small number: 20
🔥 Large number: 40
📝 Small number: 10
🔥 Large number: 30

Method Reference style:
50
20
40
10
30
```

**Lambda Benefits:**
- ✅ Concise syntax
- ✅ Functional programming style
- ✅ Can include complex logic
- ✅ Method reference support

### Method 4: Stream.forEach() - Powerful Processing! 💪

```java
import java.util.*;
import java.util.stream.Collectors;

public class StreamForEach {
    public static void main(String[] args) {
        // Creating a Set with mixed data
        Set<String> cities = new HashSet<>();
        cities.add("Delhi");
        cities.add("Mumbai");
        cities.add("Bangalore");
        cities.add("Chennai");
        cities.add("Kolkata");
        
        System.out.println("Set: " + cities);
        System.out.println("Iterating over Set using Stream.forEach():");
        
        // Basic stream forEach
        cities.stream().forEach(city -> System.out.println("🏙️ " + city));
        
        System.out.println("\nFiltered iteration:");
        cities.stream()
              .filter(city -> city.length() > 5)  // Filter cities with name > 5 chars
              .forEach(city -> System.out.println("🌆 Long name city: " + city));
        
        System.out.println("\nTransformed iteration:");
        cities.stream()
              .map(String::toUpperCase)  // Transform to uppercase
              .forEach(city -> System.out.println("📢 " + city));
        
        System.out.println("\nSorted iteration:");
        cities.stream()
              .sorted()  // Sort alphabetically
              .forEach(city -> System.out.println("🔤 " + city));
        
        // Collect results after processing
        List<String> longCityNames = cities.stream()
                                          .filter(city -> city.length() > 6)
                                          .map(String::toUpperCase)
                                          .collect(Collectors.toList());
        
        System.out.println("\nFiltered and transformed cities: " + longCityNames);
    }
}
```

**Output:**
```
Set: [Delhi, Kolkata, Chennai, Mumbai, Bangalore]
Iterating over Set using Stream.forEach():
🏙️ Delhi
🏙️ Kolkata
🏙️ Chennai
🏙️ Mumbai
🏙️ Bangalore

Filtered iteration:
🌆 Long name city: Kolkata
🌆 Long name city: Chennai
🌆 Long name city: Mumbai
🌆 Long name city: Bangalore

Transformed iteration:
📢 DELHI
📢 KOLKATA
📢 CHENNAI
📢 MUMBAI
📢 BANGALORE

Sorted iteration:
🔤 Bangalore
🔤 Chennai
🔤 Delhi
🔤 Kolkata
🔤 Mumbai

Filtered and transformed cities: [KOLKATA, CHENNAI, BANGALORE]
```

**Stream.forEach() Benefits:**
- ✅ Powerful data processing capabilities
- ✅ Chain multiple operations
- ✅ Filter, map, sort, and more
- ✅ Parallel processing support
- ✅ Collect results in different forms

## Different Set Types Iteration Examples 🎯

### HashSet - Fast but Unordered 🏃‍♂️

```java
import java.util.*;

public class HashSetIteration {
    public static void main(String[] args) {
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Zebra");
        hashSet.add("Apple");
        hashSet.add("Mango");
        hashSet.add("Banana");
        
        System.out.println("HashSet iteration (no guaranteed order):");
        hashSet.forEach(item -> System.out.println("📦 " + item));
        
        // Multiple runs might show different orders!
    }
}
```

### LinkedHashSet - Maintains Insertion Order 📋

```java
import java.util.*;

public class LinkedHashSetIteration {
    public static void main(String[] args) {
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("First");
        linkedHashSet.add("Second"); 
        linkedHashSet.add("Third");
        linkedHashSet.add("Fourth");
        
        System.out.println("LinkedHashSet iteration (insertion order maintained):");
        linkedHashSet.forEach(item -> System.out.println("🔗 " + item));
        
        // Will always show: First, Second, Third, Fourth
    }
}
```

### TreeSet - Natural Sorting Order 🌳

```java
import java.util.*;

public class TreeSetIteration {
    public static void main(String[] args) {
        Set<Integer> treeSet = new TreeSet<>();
        treeSet.add(30);
        treeSet.add(10);
        treeSet.add(50);
        treeSet.add(20);
        treeSet.add(40);
        
        System.out.println("TreeSet iteration (natural sorted order):");
        treeSet.forEach(number -> System.out.println("🌳 " + number));
        
        // Will always show: 10, 20, 30, 40, 50 (sorted)
    }
}
```

## Complex Examples - Real World Scenarios! 🌍

### Example 1: Employee Management System 👨‍💼

```java
import java.util.*;

class Employee {
    private int id;
    private String name;
    private double salary;
    
    public Employee(int id, String name, double salary) {
        this.id = id;
        this.name = name;
        this.salary = salary;
    }
    
    // Getters
    public int getId() { return id; }
    public String getName() { return name; }
    public double getSalary() { return salary; }
    
    @Override
    public String toString() {
        return "Employee{id=" + id + ", name='" + name + "', salary=" + salary + "}";
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return id == employee.id;  // Only ID matters for uniqueness
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

public class EmployeeSetIteration {
    public static void main(String[] args) {
        Set<Employee> employees = new HashSet<>();
        employees.add(new Employee(1, "Rahul", 50000));
        employees.add(new Employee(2, "Priya", 60000));
        employees.add(new Employee(3, "Amit", 55000));
        employees.add(new Employee(1, "Rahul Kumar", 52000));  // Same ID - won't be added
        
        System.out.println("All Employees:");
        employees.forEach(emp -> System.out.println("👨‍💼 " + emp));
        
        System.out.println("\nHigh Salary Employees (> 55000):");
        employees.stream()
                .filter(emp -> emp.getSalary() > 55000)
                .forEach(emp -> System.out.println("💰 " + emp.getName() + " - ₹" + emp.getSalary()));
        
        System.out.println("\nEmployee Names Only:");
        employees.stream()
                .map(Employee::getName)
                .sorted()
                .forEach(name -> System.out.println("📝 " + name));
        
        // Calculate total salary
        double totalSalary = employees.stream()
                                    .mapToDouble(Employee::getSalary)
                                    .sum();
        System.out.println("\nTotal Salary Budget: ₹" + totalSalary);
    }
}
```

### Example 2: Shopping Cart System 🛒

```java
import java.util.*;

class Product {
    private String name;
    private double price;
    private String category;
    
    public Product(String name, double price, String category) {
        this.name = name;
        this.price = price;
        this.category = category;
    }
    
    // Getters
    public String getName() { return name; }
    public double getPrice() { return price; }
    public String getCategory() { return category; }
    
    @Override
    public String toString() {
        return name + " (₹" + price + ") - " + category;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Product product = (Product) o;
        return Objects.equals(name, product.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}

public class ShoppingCartIteration {
    public static void main(String[] args) {
        Set<Product> cart = new LinkedHashSet<>();  // Maintain order
        cart.add(new Product("Laptop", 50000, "Electronics"));
        cart.add(new Product("Mouse", 500, "Electronics"));
        cart.add(new Product("Book", 300, "Education"));
        cart.add(new Product("Headphones", 2000, "Electronics"));
        cart.add(new Product("Laptop", 45000, "Electronics"));  // Same name - won't be added
        
        System.out.println("🛒 Shopping Cart Items:");
        cart.forEach(product -> System.out.println("  📱 " + product));
        
        System.out.println("\n💻 Electronics Items:");
        cart.stream()
            .filter(product -> "Electronics".equals(product.getCategory()))
            .forEach(product -> System.out.println("  ⚡ " + product));
        
        System.out.println("\n💸 Expensive Items (> ₹1000):");
        cart.stream()
            .filter(product -> product.getPrice() > 1000)
            .sorted((p1, p2) -> Double.compare(p2.getPrice(), p1.getPrice()))  // Sort by price desc
            .forEach(product -> System.out.println("  💰 " + product));
        
        // Calculate total bill
        double totalBill = cart.stream()
                              .mapToDouble(Product::getPrice)
                              .sum();
        System.out.println("\n🧾 Total Bill: ₹" + totalBill);
        
        // Count items by category
        Map<String, Long> categoryCount = cart.stream()
                                             .collect(Collectors.groupingBy(
                                                 Product::getCategory, 
                                                 Collectors.counting()
                                             ));
        System.out.println("\n📊 Items by Category:");
        categoryCount.forEach((category, count) -> 
            System.out.println("  📂 " + category + ": " + count + " items"));
    }
}
```

## Performance Comparison 📊

```java
import java.util.*;

public class PerformanceComparison {
    public static void main(String[] args) {
        Set<Integer> largeSet = new HashSet<>();
        
        // Add 100,000 elements
        for (int i = 0; i < 100000; i++) {
            largeSet.add(i);
        }
        
        System.out.println("Performance Comparison for " + largeSet.size() + " elements:");
        
        // Method 1: Iterator
        long startTime = System.nanoTime();
        Iterator<Integer> iterator = largeSet.iterator();
        while (iterator.hasNext()) {
            Integer value = iterator.next();
            // Some operation
        }
        long endTime = System.nanoTime();
        System.out.println("Iterator: " + (endTime - startTime) / 1000000 + " ms");
        
        // Method 2: Enhanced For Loop
        startTime = System.nanoTime();
        for (Integer value : largeSet) {
            // Some operation
        }
        endTime = System.nanoTime();
        System.out.println("Enhanced For Loop: " + (endTime - startTime) / 1000000 + " ms");
        
        // Method 3: Lambda forEach
        startTime = System.nanoTime();
        largeSet.forEach(value -> {
            // Some operation
        });
        endTime = System.nanoTime();
        System.out.println("Lambda forEach: " + (endTime - startTime) / 1000000 + " ms");
        
        // Method 4: Stream forEach
        startTime = System.nanoTime();
        largeSet.stream().forEach(value -> {
            // Some operation
        });
        endTime = System.nanoTime();
        System.out.println("Stream forEach: " + (endTime - startTime) / 1000000 + " ms");
    }
}
```

## When to Use Which Method? 🤔

| **Scenario** | **Best Method** | **Reason** |
|-------------|----------------|------------|
| Simple iteration | Enhanced For Loop | Clean, readable, fast |
| Need to remove elements | Iterator | Safe removal during iteration |
| Complex data processing | Stream.forEach() | Powerful operations, filtering, mapping |
| Functional style coding | Lambda forEach | Concise, modern syntax |
| Large datasets | Enhanced For Loop | Best performance |
| Conditional processing | Stream API | Built-in filter, map operations |
| Legacy code compatibility | Iterator | Works with older Java versions |

## Common Mistakes - Avoid Karo! ❌

### 1. **ConcurrentModificationException**
```java
// ❌ Wrong way
Set<String> set = new HashSet<>();
set.add("A"); set.add("B"); set.add("C");

for (String item : set) {
    if (item.equals("B")) {
        set.remove(item);  // ❌ Exception!
    }
}

// ✅ Correct way
Iterator<String> it = set.iterator();
while (it.hasNext()) {
    String item = it.next();
    if (item.equals("B")) {
        it.remove();  // ✅ Safe!
    }
}
```

### 2. **Assuming Order in HashSet**
```java
// ❌ Wrong assumption
Set<String> hashSet = new HashSet<>();
hashSet.add("First");
hashSet.add("Second");
// Don't expect "First" to come before "Second" in iteration!

// ✅ Use LinkedHashSet for order
Set<String> linkedSet = new LinkedHashSet<>();
```

### 3. **Modifying Set During Stream**
```java
Set<String> set = new HashSet<>();
set.add("A"); set.add("B"); set.add("C");

// ❌ Wrong - may cause issues
set.stream().forEach(item -> {
    if (item.equals("B")) {
        set.remove(item);  // ❌ Dangerous!
    }
});

// ✅ Collect items to remove first
List<String> toRemove = set.stream()
                          .filter(item -> item.equals("B"))
                          .collect(Collectors.toList());
set.removeAll(toRemove);
```

## Interview Questions - Master Karo! 💪

### Q1: **What's the difference between forEach() and stream().forEach()?**

```java
Set<String> set = new HashSet<>();
set.add("A"); set.add("B"); set.add("C");

// Direct forEach - simpler, faster
set.forEach(System.out::println);

// Stream forEach - more powerful, can chain operations
set.stream()
   .filter(s -> !s.equals("B"))
   .forEach(System.out::println);
```

**Answer**: Direct forEach() is simpler and faster for basic iteration. Stream forEach() allows chaining operations like filter, map, etc.

### Q2: **Can we use traditional for loop with Set?**

```java
Set<String> set = new HashSet<>();
// for (int i = 0; i < set.size(); i++) // ❌ NO! Set has no indexing
```

**Answer**: No! Set doesn't have indexing like List. We must use Iterator, enhanced for loop, or forEach methods.

### Q3: **How to iterate Set in reverse order?**

```java
Set<String> set = new TreeSet<>();  // Sorted set
set.add("C"); set.add("A"); set.add("B");

// Convert to List and reverse
List<String> list = new ArrayList<>(set);
Collections.reverse(list);
list.forEach(System.out::println);

// Or using Stream
set.stream()
   .sorted(Collections.reverseOrder())
   .forEach(System.out::println);
```

### Q4: **Which iteration method is fastest?**

**Answer**: For simple iteration: Enhanced for loop > Iterator > Lambda forEach > Stream forEach

### Q5: **Can we modify Set size during iteration?**

**Answer**: 
- ✅ **Safe**: Using Iterator.remove()
- ❌ **Unsafe**: Direct Set.add()/remove() during iteration
- ✅ **Safe**: Collect items to modify, then modify after iteration

## Best Practices 🌟

### 1. **Choose Right Method for Right Task**
```java
// Simple iteration
for (String item : set) { /* process */ }

// Complex processing
set.stream()
   .filter(condition)
   .map(transformation)
   .forEach(action);

// Safe removal
Iterator<String> it = set.iterator();
while (it.hasNext()) {
    if (shouldRemove(it.next())) {
        it.remove();
    }
}
```

### 2. **Use Method References When Possible**
```java
// Instead of lambda
set.forEach(item -> System.out.println(item));

// Use method reference
set.forEach(System.out::println);
```

### 3. **Parallel Processing for Large Sets**
```java
// For CPU-intensive operations on large sets
largeSet.parallelStream()
        .filter(expensiveCondition)
        .forEach(expensiveOperation);
```

### 4. **Handle Empty Sets Gracefully**
```java
if (!set.isEmpty()) {
    set.forEach(this::processItem);
} else {
    System.out.println("No items to process");
}
```

## Summary - Quick Recap! 📝

### **4 Ways to Iterate Set:**

1. **🔄 Iterator** - Traditional, safe removal
2. **✨ Enhanced For Loop** - Clean, readable, fast
3. **🔥 Lambda forEach** - Modern, concise
4. **💪 Stream forEach** - Powerful, chainable operations

### **Key Points:**
- ✅ Set has no indexing - can't use traditional for loop
- ✅ Different Set types (HashSet, LinkedHashSet, TreeSet) affect iteration order
- ✅ Iterator allows safe removal during iteration
- ✅ Stream API provides powerful data processing capabilities
- ✅ Enhanced for loop is fastest for simple iteration

### **Memory Trick:**
**I**terator, **E**nhanced for loop, **L**ambda, **S**tream = **IELS** 😄

### **Choose Based On:**
- 🏃‍♂️ **Performance needed** → Enhanced for loop
- 🗑️ **Need to remove elements** → Iterator
- 🔧 **Complex processing** → Stream API
- 💡 **Modern clean code** → Lambda forEach

Practice all methods with different Set types and you'll become a Set iteration expert! 🚀💪

---
*Happy Coding! 🎉*
