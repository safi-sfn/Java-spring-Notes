# Java 8 Stream API - Complete Study Notes 🚀

---

## 1. Introduction with Confusion Clearing 🤔

### Simple Explanation First
Yaar, **Stream API** ko samajhna hai? 

**Simple words mein**: Stream API ek powerful tool hai jo Java 8 mein aaya, collections ko process karne ke liye. Think of it as a **magic wand** 🪄 jo tumhare list/array operations ko super easy aur clean banata hai!

### Real-life Analogy 🏭
**Imagine karo** - tumhara ek **factory** hai:
- **Input**: Raw materials (List of numbers/objects)
- **Processing**: Different machines (filter, map, sort)
- **Output**: Final products (Filtered/Processed data)

Stream API is like a **conveyor belt** jahan data ek end se enter hota hai, different operations apply hote hain, aur finally result mil jata hai!

### Technical Definition 📚
> **Stream API** is a feature introduced in Java 8 that provides a functional programming approach to process collections of data. It's available in `java.util.stream` package.

---

## 2. Key Terms/Concepts 📝

| Term | Explanation | Visual |
|------|-------------|--------|
| **Stream** | A sequence of elements that supports sequential and parallel operations | `🌊 Data Flow` |
| **Lambda Expression** | Short way to write functions `(x) -> x*2` | `⚡ Quick Function` |
| **Predicate** | Function that returns boolean (true/false) | `✅❌ Condition Check` |
| **Functional Interface** | Interface with only one abstract method | `🔧 Single Tool` |
| **Method Reference** | Shorthand for lambda expressions `System.out::println` | `📞 Direct Call` |
| **Intermediate Operations** | Operations that return a Stream (can be chained) | `🔗 Chain Links` |
| **Terminal Operations** | Operations that produce final result | `🎯 Final Target` |

---

## 3. Stream API Methods ki Family 👨‍👩‍👧‍👦

### 🔍 **Intermediate Operations** (Chain kar sakte hain):
- `filter()` - Condition lagao
- `map()` - Transform karo
- `sorted()` - Sort karo
- `distinct()` - Duplicates hatao
- `limit()` - Limit lagao

### 🎯 **Terminal Operations** (Final result):
- `collect()` - Collect karo
- `forEach()` - Har element pe action
- `count()` - Ginti karo
- `min()` / `max()` - Min/Max find karo
- `toArray()` - Array banao

---

## 4. Detailed Examples with Code 💻

### Without Stream API (Old Boring Way) 😴

```java
import java.util.ArrayList;

public class OldWay {
    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<>();
        numbers.add(10);
        numbers.add(3);
        numbers.add(5);
        numbers.add(20);
        numbers.add(40);
        
        System.out.println("Original List: " + numbers);
        
        // Finding odd numbers - kitna lamba code! 😫
        ArrayList<Integer> oddNumbers = new ArrayList<>();
        for (Integer num : numbers) {
            if (num % 2 != 0) {
                oddNumbers.add(num);
            }
        }
        System.out.println("Odd Numbers: " + oddNumbers);
    }
}
```

**Output:**
```
Original List: [10, 3, 5, 20, 40]
Odd Numbers: [3, 5]
```

### With Stream API (New Cool Way) 😎

```java
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class StreamWay {
    public static void main(String[] args) {
        ArrayList<Integer> numbers = new ArrayList<>();
        numbers.add(10);
        numbers.add(0);
        numbers.add(5);
        numbers.add(20);
        numbers.add(30);
        
        System.out.println("Original List: " + numbers);
        
        // Finding even numbers - ek line mein! 🔥
        List<Integer> evenNumbers = numbers.stream()
                                          .filter(i -> i % 2 == 0)
                                          .collect(Collectors.toList());
        
        System.out.println("Even Numbers: " + evenNumbers);
    }
}
```

**Output:**
```
Original List: [10, 0, 5, 20, 30]
Even Numbers: [10, 0, 20, 30]
```

**Dekho kitna clean aur readable hai! 💯**

---

## 5. Individual Method Examples 🎯

### 🔍 `filter()` Method

**Kya karta hai**: Condition ke basis pe elements filter karta hai

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class FilterExample {
    public static void main(String[] args) {
        List<Integer> marks = Arrays.asList(60, 50, 70, 40, 30);
        System.out.println("All Marks: " + marks);
        
        // 40 se zyada marks wale students
        List<Integer> passedStudents = marks.stream()
                                          .filter(mark -> mark > 40)
                                          .collect(Collectors.toList());
        
        System.out.println("Passed Students (>40): " + passedStudents);
        
        // String example - names starting with 'A'
        List<String> names = Arrays.asList("Arjun", "Bhavya", "Ankit", "Deepak");
        List<String> aNames = names.stream()
                                  .filter(name -> name.startsWith("A"))
                                  .collect(Collectors.toList());
        
        System.out.println("Names starting with 'A': " + aNames);
    }
}
```

**Output:**
```
All Marks: [60, 50, 70, 40, 30]
Passed Students (>40): [60, 50, 70]
Names starting with 'A': [Arjun, Ankit]
```

### 🔄 `map()` Method

**Kya karta hai**: Har element ko transform karta hai

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class MapExample {
    public static void main(String[] args) {
        List<Integer> marks = Arrays.asList(60, 50, 70, 40, 30);
        System.out.println("Original Marks: " + marks);
        
        // Grace marks add karte hain (+5)
        List<Integer> graceMarks = marks.stream()
                                       .map(mark -> mark + 5)
                                       .collect(Collectors.toList());
        
        System.out.println("After Grace (+5): " + graceMarks);
        
        // Square karte hain
        List<Integer> squaredMarks = marks.stream()
                                         .map(mark -> mark * mark)
                                         .collect(Collectors.toList());
        
        System.out.println("Squared Marks: " + squaredMarks);
        
        // String example - uppercase
        List<String> names = Arrays.asList("arjun", "bhavya", "ankit");
        List<String> upperNames = names.stream()
                                      .map(String::toUpperCase)
                                      .collect(Collectors.toList());
        
        System.out.println("Uppercase Names: " + upperNames);
    }
}
```

**Output:**
```
Original Marks: [60, 50, 70, 40, 30]
After Grace (+5): [65, 55, 75, 45, 35]
Squared Marks: [3600, 2500, 4900, 1600, 900]
Uppercase Names: [ARJUN, BHAVYA, ANKIT]
```

### 📊 `collect()` Method

**Kya karta hai**: Stream ko wapas collection mein convert karta hai

```java
import java.util.*;
import java.util.stream.Collectors;

public class CollectExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Arjun", "Bhavya", "Ankit", "Bhavya");
        
        // List mein collect
        List<String> namesList = names.stream()
                                     .filter(name -> name.length() > 4)
                                     .collect(Collectors.toList());
        System.out.println("Names > 4 chars (List): " + namesList);
        
        // Set mein collect (duplicates remove)
        Set<String> namesSet = names.stream()
                                   .collect(Collectors.toSet());
        System.out.println("Unique Names (Set): " + namesSet);
        
        // String join karna
        String joinedNames = names.stream()
                                 .collect(Collectors.joining(", "));
        System.out.println("Joined Names: " + joinedNames);
    }
}
```

**Output:**
```
Names > 4 chars (List): [Bhavya, Ankit, Bhavya]
Unique Names (Set): [Arjun, Ankit, Bhavya]
Joined Names: Arjun, Bhavya, Ankit, Bhavya
```

### 🔢 `count()` Method

```java
import java.util.Arrays;
import java.util.List;

public class CountExample {
    public static void main(String[] args) {
        List<Integer> marks = Arrays.asList(60, 50, 70, 40, 30, 80, 90);
        
        long totalStudents = marks.stream().count();
        System.out.println("Total Students: " + totalStudents);
        
        long passedStudents = marks.stream()
                                  .filter(mark -> mark >= 50)
                                  .count();
        System.out.println("Passed Students: " + passedStudents);
        
        long excellentStudents = marks.stream()
                                     .filter(mark -> mark >= 80)
                                     .count();
        System.out.println("Excellent Students (>=80): " + excellentStudents);
    }
}
```

**Output:**
```
Total Students: 7
Passed Students: 5
Excellent Students (>=80): 2
```

### 🔀 `sorted()` Method

```java
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class SortedExample {
    public static void main(String[] args) {
        List<Integer> marks = Arrays.asList(60, 50, 70, 40, 30);
        System.out.println("Original: " + marks);
        
        // Natural sorting (ascending)
        List<Integer> ascending = marks.stream()
                                      .sorted()
                                      .collect(Collectors.toList());
        System.out.println("Ascending: " + ascending);
        
        // Custom sorting (descending)
        List<Integer> descending = marks.stream()
                                       .sorted((a, b) -> b - a) // or Integer::compare
                                       .collect(Collectors.toList());
        System.out.println("Descending: " + descending);
        
        // String sorting
        List<String> names = Arrays.asList("Zebra", "Apple", "Mango", "Banana");
        List<String> sortedNames = names.stream()
                                       .sorted()
                                       .collect(Collectors.toList());
        System.out.println("Sorted Names: " + sortedNames);
    }
}
```

**Output:**
```
Original: [60, 50, 70, 40, 30]
Ascending: [30, 40, 50, 60, 70]
Descending: [70, 60, 50, 40, 30]
Sorted Names: [Apple, Banana, Mango, Zebra]
```

### 📏 `min()` and `max()` Methods

```java
import java.util.Arrays;
import java.util.List;

public class MinMaxExample {
    public static void main(String[] args) {
        List<Integer> marks = Arrays.asList(60, 50, 70, 40, 30);
        System.out.println("Marks: " + marks);
        
        // Minimum marks
        int minMark = marks.stream()
                          .min(Integer::compareTo)
                          .orElse(0); // Default value if empty
        System.out.println("Minimum Mark: " + minMark);
        
        // Maximum marks
        int maxMark = marks.stream()
                          .max(Integer::compareTo)
                          .orElse(0);
        System.out.println("Maximum Mark: " + maxMark);
        
        // String example
        List<String> names = Arrays.asList("Arjun", "Bhavya", "Ankit");
        String shortestName = names.stream()
                                  .min((a, b) -> a.length() - b.length())
                                  .orElse("None");
        System.out.println("Shortest Name: " + shortestName);
    }
}
```

**Output:**
```
Marks: [60, 50, 70, 40, 30]
Minimum Mark: 30
Maximum Mark: 70
Shortest Name: Ankit
```

### 🔄 `forEach()` Method

```java
import java.util.Arrays;
import java.util.List;

public class ForEachExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Arjun", "Bhavya", "Ankit");
        System.out.println("Original List: " + names);
        
        System.out.println("\n--- Using Lambda Expression ---");
        names.stream()
             .forEach(name -> System.out.println("Hello, " + name + "!"));
        
        System.out.println("\n--- Using Method Reference ---");
        names.stream()
             .map(String::toUpperCase)
             .forEach(System.out::println);
        
        System.out.println("\n--- With Index (Custom) ---");
        List<Integer> marks = Arrays.asList(85, 92, 78, 96, 88);
        marks.stream()
             .forEach(mark -> {
                 if (mark >= 90) {
                     System.out.println("⭐ Excellent: " + mark);
                 } else if (mark >= 80) {
                     System.out.println("👍 Good: " + mark);
                 } else {
                     System.out.println("📚 Need Improvement: " + mark);
                 }
             });
    }
}
```

**Output:**
```
Original List: [Arjun, Bhavya, Ankit]

--- Using Lambda Expression ---
Hello, Arjun!
Hello, Bhavya!
Hello, Ankit!

--- Using Method Reference ---
ARJUN
BHAVYA
ANKIT

--- With Index (Custom) ---
👍 Good: 85
⭐ Excellent: 92
📚 Need Improvement: 78
⭐ Excellent: 96
👍 Good: 88
```

### 📋 `toArray()` Method

```java
import java.util.Arrays;
import java.util.List;

public class ToArrayExample {
    public static void main(String[] args) {
        List<Integer> marks = Arrays.asList(60, 50, 70, 40, 30);
        System.out.println("Original List: " + marks);
        
        // Convert to array
        Integer[] marksArray = marks.stream()
                                   .toArray(Integer[]::new);
        
        System.out.println("Array Elements:");
        for (Integer mark : marksArray) {
            System.out.print(mark + " ");
        }
        System.out.println();
        
        // Filter and convert to array
        Integer[] passedMarks = marks.stream()
                                    .filter(mark -> mark >= 50)
                                    .toArray(Integer[]::new);
        
        System.out.println("Passed Marks Array: " + Arrays.toString(passedMarks));
    }
}
```

**Output:**
```
Original List: [60, 50, 70, 40, 30]
Array Elements:
60 50 70 40 30 
Passed Marks Array: [60, 50, 70]
```

### 🏗️ `of()` Method

```java
import java.util.stream.Stream;
import java.util.List;
import java.util.stream.Collectors;

public class OfExample {
    public static void main(String[] args) {
        // Create stream directly from values
        Stream<String> nameStream = Stream.of("Arjun", "Bhavya", "Ankit", "Deepak");
        
        System.out.println("Names from Stream.of():");
        nameStream.forEach(System.out::println);
        
        // Create stream and process
        List<Integer> evenNumbers = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
                                          .filter(n -> n % 2 == 0)
                                          .collect(Collectors.toList());
        
        System.out.println("Even Numbers: " + evenNumbers);
        
        // Create stream from array
        String[] cities = {"Delhi", "Mumbai", "Bangalore", "Chennai"};
        List<String> longCityNames = Stream.of(cities)
                                          .filter(city -> city.length() > 5)
                                          .collect(Collectors.toList());
        
        System.out.println("Cities with >5 chars: " + longCityNames);
    }
}
```

**Output:**
```
Names from Stream.of():
Arjun
Bhavya
Ankit
Deepak
Even Numbers: [2, 4, 6, 8, 10]
Cities with >5 chars: [Mumbai, Bangalore, Chennai]
```

---

## 6. Rules/Guidelines 📏

### ✅ **Do's - Ye karo bhai!**

#### Rule 1: Always use Method Chaining ⛓️
```java
// ✅ Correct - Clean and readable
List<String> result = names.stream()
                          .filter(name -> name.length() > 3)
                          .map(String::toUpperCase)
                          .sorted()
                          .collect(Collectors.toList());
```

```java
// ❌ Wrong - Multiple intermediate collections
List<String> filtered = new ArrayList<>();
for(String name : names) {
    if(name.length() > 3) filtered.add(name);
}
List<String> upperCased = new ArrayList<>();
for(String name : filtered) {
    upperCased.add(name.toUpperCase());
}
Collections.sort(upperCased);
```

#### Rule 2: Use Method References when possible 📞
```java
// ✅ Correct - Method Reference
names.stream().forEach(System.out::println);

// ❌ Okay but verbose - Lambda
names.stream().forEach(name -> System.out.println(name));
```

#### Rule 3: Handle Optional values properly 🛡️
```java
// ✅ Correct - With orElse
Integer maxValue = numbers.stream()
                         .max(Integer::compareTo)
                         .orElse(0);

// ❌ Wrong - Can throw NoSuchElementException
Integer maxValue = numbers.stream()
                         .max(Integer::compareTo)
                         .get(); // Dangerous!
```

#### Rule 4: Use parallel() for large datasets 🚀
```java
// ✅ For large collections
List<Integer> result = hugeList.parallelStream()
                               .filter(n -> n > 1000)
                               .collect(Collectors.toList());
```

### ❌ **Don'ts - Ye mat karo!**

#### Rule 1: Don't modify original collection inside Stream ⚠️
```java
// ❌ Wrong - Modifying original list
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.stream().forEach(n -> numbers.add(n * 2)); // ConcurrentModificationException!
```

#### Rule 2: Don't use Stream for simple iterations 🚫
```java
// ❌ Overkill for simple printing
list.stream().forEach(System.out::println);

// ✅ Better for simple cases
for(String item : list) {
    System.out.println(item);
}
```

#### Rule 3: Don't chain too many operations 🔗
```java
// ❌ Too complex - hard to debug
List<String> result = names.stream()
                          .filter(n -> n.length() > 2)
                          .map(String::toUpperCase)
                          .filter(n -> n.startsWith("A"))
                          .map(n -> n + "_SUFFIX")
                          .filter(n -> n.contains("R"))
                          .sorted()
                          .collect(Collectors.toList());

// ✅ Better - Break into logical steps
List<String> filtered = names.stream()
                            .filter(n -> n.length() > 2 && n.startsWith("A"))
                            .collect(Collectors.toList());

List<String> result = filtered.stream()
                             .map(String::toUpperCase)
                             .map(n -> n + "_SUFFIX")
                             .filter(n -> n.contains("R"))
                             .sorted()
                             .collect(Collectors.toList());
```

---

## 7. Real-world Applications 🌍

### 🏦 Banking System Example

```java
import java.util.*;
import java.util.stream.Collectors;

class Account {
    private String accountNumber;
    private String customerName;
    private double balance;
    private String accountType;
    
    public Account(String accountNumber, String customerName, double balance, String accountType) {
        this.accountNumber = accountNumber;
        this.customerName = customerName;
        this.balance = balance;
        this.accountType = accountType;
    }
    
    // Getters
    public String getAccountNumber() { return accountNumber; }
    public String getCustomerName() { return customerName; }
    public double getBalance() { return balance; }
    public String getAccountType() { return accountType; }
    
    @Override
    public String toString() {
        return String.format("%s: %s (%.2f) - %s", accountNumber, customerName, balance, accountType);
    }
}

public class BankingExample {
    public static void main(String[] args) {
        List<Account> accounts = Arrays.asList(
            new Account("ACC001", "Arjun Kumar", 50000.0, "SAVINGS"),
            new Account("ACC002", "Priya Singh", 125000.0, "CURRENT"),
            new Account("ACC003", "Rahul Sharma", 25000.0, "SAVINGS"),
            new Account("ACC004", "Anjali Gupta", 200000.0, "CURRENT"),
            new Account("ACC005", "Vikram Joshi", 15000.0, "SAVINGS")
        );
        
        System.out.println("🏦 BANKING SYSTEM ANALYSIS");
        System.out.println("=" * 50);
        
        // 1. High-value accounts (>100k)
        System.out.println("\n💰 High-Value Accounts (>1L):");
        accounts.stream()
                .filter(acc -> acc.getBalance() > 100000)
                .forEach(System.out::println);
        
        // 2. Savings account holders
        System.out.println("\n🏛️ Savings Account Holders:");
        List<String> savingsCustomers = accounts.stream()
                                               .filter(acc -> "SAVINGS".equals(acc.getAccountType()))
                                               .map(Account::getCustomerName)
                                               .collect(Collectors.toList());
        System.out.println(savingsCustomers);
        
        // 3. Total money in bank
        double totalBalance = accounts.stream()
                                    .mapToDouble(Account::getBalance)
                                    .sum();
        System.out.println("\n💵 Total Money in Bank: ₹" + totalBalance);
        
        // 4. Average balance
        double avgBalance = accounts.stream()
                                  .mapToDouble(Account::getBalance)
                                  .average()
                                  .orElse(0.0);
        System.out.println("📊 Average Balance: ₹" + String.format("%.2f", avgBalance));
        
        // 5. Richest customer
        Account richestCustomer = accounts.stream()
                                        .max(Comparator.comparing(Account::getBalance))
                                        .orElse(null);
        System.out.println("👑 Richest Customer: " + richestCustomer);
        
        // 6. Group by account type
        System.out.println("\n📋 Accounts by Type:");
        Map<String, List<Account>> accountsByType = accounts.stream()
                                                           .collect(Collectors.groupingBy(Account::getAccountType));
        accountsByType.forEach((type, accs) -> {
            System.out.println(type + ": " + accs.size() + " accounts");
        });
    }
}
```

**Output:**
```
🏦 BANKING SYSTEM ANALYSIS
==================================================

💰 High-Value Accounts (>1L):
ACC002: Priya Singh (125000.00) - CURRENT
ACC004: Anjali Gupta (200000.00) - CURRENT

🏛️ Savings Account Holders:
[Arjun Kumar, Rahul Sharma, Vikram Joshi]

💵 Total Money in Bank: ₹415000.0
📊 Average Balance: ₹83000.00
👑 Richest Customer: ACC004: Anjali Gupta (200000.00) - CURRENT

📋 Accounts by Type:
CURRENT: 2 accounts
SAVINGS: 3 accounts
```

### 🎓 Student Management System

```java
import java.util.*;
import java.util.stream.Collectors;

class Student {
    private String name;
    private int rollNumber;
    private List<Integer> marks;
    private String grade;
    
    public Student(String name, int rollNumber, List<Integer> marks) {
        this.name = name;
        this.rollNumber = rollNumber;
        this.marks = marks;
        this.grade = calculateGrade();
    }
    
    private String calculateGrade() {
        double avg = marks.stream().mapToInt(Integer::intValue).average().orElse(0.0);
        if (avg >= 90) return "A+";
        else if (avg >= 80) return "A";
        else if (avg >= 70) return "B";
        else if (avg >= 60) return "C";
        else return "F";
    }
    
    public double getAverage() {
        return marks.stream().mapToInt(Integer::intValue).average().orElse(0.0);
    }
    
    // Getters
    public String getName() { return name; }
    public int getRollNumber() { return rollNumber; }
    public List<Integer> getMarks() { return marks; }
    public String getGrade() { return grade; }
    
    @Override
    public String toString() {
        return String.format("%d: %s (%.1f%%) - Grade %s", rollNumber, name, getAverage(), grade);
    }
}

public class StudentExample {
    public static void main(String[] args) {
        List<Student> students = Arrays.asList(
            new Student("Arjun", 101, Arrays.asList(85, 90, 88, 92)),
            new Student("Priya", 102, Arrays.asList(78, 85, 80, 82)),
            new Student("Rahul", 103, Arrays.asList(95, 98, 94, 96)),
            new Student("Anjali", 104, Arrays.asList(65, 70, 68, 72)),
            new Student("Vikram", 105, Arrays.asList(45, 50, 48, 52))
        );
        
        System.out.println("🎓 STUDENT MANAGEMENT SYSTEM");
        System.out.println("=" * 45);
        
        // 1. All students with their grades
        System.out.println("\n📊 All Students:");
        students.forEach(System.out::println);
        
        // 2. Toppers (A+ grade)
        System.out.println("\n🏆 Toppers (A+ Grade):");
        students.stream()
                .filter(s -> "A+".equals(s.getGrade()))
                .forEach(System.out::println);
        
        // 3. Failed students
        System.out.println("\n😞 Failed Students:");
        List<Student> failedStudents = students.stream()
                                             .filter(s -> "F".equals(s.getGrade()))
                                             .collect(Collectors.toList());
        failedStudents.forEach(System.out::println);
        
        // 4. Class average
        double classAverage = students.stream()
                                    .mapToDouble(Student::getAverage)
                                    .average()
                                    .orElse(0.0);
        System.out.println("\n📈 Class Average: " + String.format("%.2f%%", classAverage));
        
        // 5. Grade distribution
        System.out.println("\n📋 Grade Distribution:");
        Map<String, Long> gradeCount = students.stream()
                                             .collect(Collectors.groupingBy(Student::getGrade, 
                                                     Collectors.counting()));
        gradeCount.forEach((grade, count) -> 
            System.out.println("Grade " + grade + ": " + count + " students"));
        
        // 6. Students above class average
        System.out.println("\n⭐ Above Average Students:");
        students.stream()
                .filter(s -> s.getAverage() > classAverage)
                .sorted((s1, s2) -> Double.compare(s2.getAverage(), s1.getAverage()))
                .forEach(System.out::println);
    }
}
```

---

## 8. Comparison Tables 📊

### Stream API vs Traditional Approach

| Aspect | Traditional Approach | Stream API |
|--------|---------------------|------------|
| **Code Length** | 🔴 Long & Verbose | ✅ Short & Concise |
| **Readability** | 🔴 Complex loops | ✅ Declarative & Clear |
| **Performance** | ✅ Good for small data | ✅ Better for large data (parallel) |
| **Debugging** | ✅ Easy step-by-step | 🔴 Harder to debug |
| **Memory Usage** | 🔴 Creates intermediate collections | ✅ Lazy evaluation |
| **Parallel Processing** | 🔴 Manual thread management | ✅ Built-in parallel support |
| **Functional Style** | 🔴 Imperative | ✅ Functional programming |

### Intermediate vs Terminal Operations

| Type | Operations | Characteristics | Example |
|------|------------|-----------------|---------|
| **Intermediate** | `filter()`, `map()`, `sorted()`, `distinct()` | ⛓️ **Chainable**<br>🔄 **Lazy** (execute only when terminal op called)<br>↩️ **Returns Stream** | `stream().filter().map()` |
| **Terminal** | `collect()`, `forEach()`, `count()`, `reduce()` | 🎯 **Final operation**<br>⚡ **Triggers execution**<br>📊 **Returns concrete result** | `.collect(Collectors.toList())` |

### Different Collection Methods

| Method | Input | Output | Use Case |
|--------|-------|--------|----------|
| `collect(Collectors.toList())` | Stream<T> | List<T> | When you need a mutable list |
| `collect(Collectors.toSet())` | Stream<T> | Set<T> | Remove duplicates |
| `collect(Collectors.joining())` | Stream<String> | String | Join strings |
| `collect(Collectors.groupingBy())` | Stream<T> | Map<K,List<T>> | Group elements by key |
| `toArray()` | Stream<T> | T[] | Convert to array |

---

## 9. Interview Questions 🎯

### Q1: What is Stream API and why was it introduced?

**Answer:**
```java
// Problem with traditional approach
List<String> names = Arrays.asList("Arjun", "Bhavya", "Ankit", "Deepak");
List<String> result = new ArrayList<>();

// Traditional way - verbose
for (String name : names) {
    if (name.length() > 4) {
        result.add(name.toUpperCase());
    }
}
Collections.sort(result);

// Stream API way - concise
List<String> streamResult = names.stream()
                                 .filter(name -> name.length() > 4)
                                 .map(String::toUpperCase)
                                 .sorted()
                                 .collect(Collectors.toList());
```

**Key Points:**
- Introduced in Java 8 for functional programming
- Makes code more readable and concise
- Supports parallel processing
- Lazy evaluation for better performance

### Q2: Difference between Intermediate and Terminal operations?

**Answer:**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// Intermediate operations (lazy - not executed yet)
Stream<Integer> intermediateStream = numbers.stream()
                                           .filter(n -> n > 2)    // Intermediate
                                           .map(n -> n * 2);      // Intermediate

// Terminal operation (triggers execution)
List<Integer> result = intermediateStream.collect(Collectors.toList()); // Terminal

System.out.println(result); // [6, 8, 10]
```

### Q3: What happens if you don't use terminal operation?

**Answer:**
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// This code does NOTHING! No terminal operation
numbers.stream()
       .filter(n -> {
           System.out.println("Filtering: " + n); // This won't print!
           return n > 2;
       })
       .map(n -> {
           System.out.println("Mapping: " + n);   // This won't print!
           return n * 2;
       });

System.out.println("Done"); // Only this will print

// To actually execute, you need terminal operation
numbers.stream()
       .filter(n -> {
           System.out.println("Filtering: " + n); // Now this will print
           return n > 2;
       })
       .map(n -> {
           System.out.println("Mapping: " + n);   // Now this will print  
           return n * 2;
       })
       .collect(Collectors.toList()); // Terminal operation
```

### Q4: How to handle null values in Stream?

**Answer:**
```java
List<String> names = Arrays.asList("Arjun", null, "Bhavya", null, "Ankit");

// ❌ Wrong - NullPointerException
try {
    List<String> upperNames = names.stream()
                                  .map(String::toUpperCase) // NPE here!
                                  .collect(Collectors.toList());
} catch (NullPointerException e) {
    System.out.println("Got NPE: " + e.getMessage());
}

// ✅ Correct - Filter nulls first
List<String> safeUpperNames = names.stream()
                                  .filter(Objects::nonNull)  // Remove nulls
                                  .map(String::toUpperCase)
                                  .collect(Collectors.toList());

System.out.println("Safe result: " + safeUpperNames);

// ✅ Alternative - Handle nulls in map
List<String> altResult = names.stream()
                             .map(name -> name == null ? "UNKNOWN" : name.toUpperCase())
                             .collect(Collectors.toList());

System.out.println("Alternative: " + altResult);
```

### Q5: Difference between map() and flatMap()?

**Answer:**
```java
// map() - One-to-one transformation
List<String> words = Arrays.asList("Hello", "World", "Java");
List<Integer> lengths = words.stream()
                            .map(String::length)  // String -> Integer
                            .collect(Collectors.toList());
System.out.println("Lengths: " + lengths); // [5, 5, 4]

// flatMap() - One-to-many transformation
List<List<Integer>> listOfLists = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5, 6),
    Arrays.asList(7, 8, 9)
);

// ❌ Wrong with map() - gives nested structure
List<Stream<Integer>> wrongResult = listOfLists.stream()
                                              .map(List::stream)
                                              .collect(Collectors.toList());

// ✅ Correct with flatMap() - flattens the structure  
List<Integer> flatResult = listOfLists.stream()
                                     .flatMap(List::stream)
                                     .collect(Collectors.toList());
System.out.println("Flattened: " + flatResult); // [1, 2, 3, 4, 5, 6, 7, 8, 9]

// Real example - Get all characters from words
List<String> sentences = Arrays.asList("Hello World", "Java Stream", "API Example");
List<String> allChars = sentences.stream()
                                .flatMap(sentence -> Arrays.stream(sentence.split("")))
                                .filter(ch -> !" ".equals(ch))
                                .collect(Collectors.toList());
System.out.println("All characters: " + allChars);
```

### Q6: How to use groupingBy() collector?

**Answer:**
```java
class Employee {
    private String name;
    private String department;
    private int salary;
    
    public Employee(String name, String department, int salary) {
        this.name = name;
        this.department = department;
        this.salary = salary;
    }
    
    // Getters
    public String getName() { return name; }
    public String getDepartment() { return department; }
    public int getSalary() { return salary; }
    
    @Override
    public String toString() {
        return name + "(" + department + ", ₹" + salary + ")";
    }
}

public class GroupingExample {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Arjun", "IT", 50000),
            new Employee("Priya", "HR", 45000),
            new Employee("Rahul", "IT", 55000),
            new Employee("Anjali", "Finance", 48000),
            new Employee("Vikram", "HR", 42000)
        );
        
        // Group by department
        Map<String, List<Employee>> byDepartment = employees.stream()
                                                           .collect(Collectors.groupingBy(Employee::getDepartment));
        
        System.out.println("👥 Employees by Department:");
        byDepartment.forEach((dept, emps) -> {
            System.out.println(dept + ": " + emps);
        });
        
        // Group by salary range
        Map<String, List<Employee>> bySalaryRange = employees.stream()
                                                            .collect(Collectors.groupingBy(emp -> 
                                                                emp.getSalary() > 50000 ? "High" : "Low"));
        
        System.out.println("\n💰 Employees by Salary Range:");
        bySalaryRange.forEach((range, emps) -> {
            System.out.println(range + " earners: " + emps);
        });
        
        // Count by department
        Map<String, Long> countByDept = employees.stream()
                                                .collect(Collectors.groupingBy(Employee::getDepartment, 
                                                        Collectors.counting()));
        
        System.out.println("\n📊 Employee Count by Department:");
        countByDept.forEach((dept, count) -> {
            System.out.println(dept + ": " + count + " employees");
        });
    }
}
```

---

## 10. Common Mistakes 🚨

### Mistake 1: Reusing Streams ❌

```java
// ❌ Wrong - Stream can be used only once!
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
Stream<Integer> stream = numbers.stream().filter(n -> n > 2);

List<Integer> list1 = stream.collect(Collectors.toList()); // Works fine
List<Integer> list2 = stream.collect(Collectors.toList()); // IllegalStateException!

// ✅ Correct - Create new stream each time
List<Integer> list1 = numbers.stream().filter(n -> n > 2).collect(Collectors.toList());
List<Integer> list2 = numbers.stream().filter(n -> n > 2).collect(Collectors.toList());
```

**Error Message:**
```
Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
```

### Mistake 2: Modifying collection during stream operation ❌

```java
// ❌ Wrong - Concurrent modification
List<Integer> numbers = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));

try {
    numbers.stream().forEach(n -> {
        if (n % 2 == 0) {
            numbers.remove(n); // ConcurrentModificationException!
        }
    });
} catch (Exception e) {
    System.out.println("Error: " + e.getClass().getSimpleName());
}

// ✅ Correct - Create new collection
List<Integer> oddNumbers = numbers.stream()
                                 .filter(n -> n % 2 != 0)
                                 .collect(Collectors.toList());
```

### Mistake 3: Not handling Optional properly ❌

```java
List<Integer> emptyList = Arrays.asList();

// ❌ Wrong - Can throw NoSuchElementException
try {
    Integer max = emptyList.stream().max(Integer::compareTo).get();
    System.out.println("Max: " + max);
} catch (Exception e) {
    System.out.println("Error: " + e.getClass().getSimpleName());
}

// ✅ Correct - Use orElse or isPresent
Integer maxSafe = emptyList.stream()
                          .max(Integer::compareTo)
                          .orElse(-1);
System.out.println("Max (safe): " + maxSafe);

// Or check if present
Optional<Integer> maxOpt = emptyList.stream().max(Integer::compareTo);
if (maxOpt.isPresent()) {
    System.out.println("Max: " + maxOpt.get());
} else {
    System.out.println("List is empty!");
}
```

### Mistake 4: Using wrong collector ❌

```java
List<String> names = Arrays.asList("Arjun", "Bhavya", "Ankit");

// ❌ Wrong - Inefficient for simple joining
String result1 = names.stream()
                     .reduce("", (a, b) -> a + ", " + b);
System.out.println("Wrong: " + result1); // ", Arjun, Bhavya, Ankit"

// ✅ Correct - Use joining collector
String result2 = names.stream()
                     .collect(Collectors.joining(", "));
System.out.println("Correct: " + result2); // "Arjun, Bhavya, Ankit"
```

### Mistake 5: Ignoring parallel stream considerations ❌

```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// ❌ Wrong - Parallel stream with non-thread-safe operations
List<Integer> resultList = new ArrayList<>(); // Not thread-safe!
numbers.parallelStream().forEach(n -> {
    resultList.add(n * 2); // Race condition!
});
System.out.println("Unsafe result size: " + resultList.size()); // May not be 5!

// ✅ Correct - Use proper collectors
List<Integer> safeResult = numbers.parallelStream()
                                 .map(n -> n * 2)
                                 .collect(Collectors.toList());
System.out.println("Safe result: " + safeResult);
```

---

## 11. Best Practices 🌟

### Practice 1: Use Method References for Readability 📖

```java
List<String> names = Arrays.asList("arjun", "bhavya", "ankit");

// ✅ Good - Method reference (clean)
List<String> upperNames = names.stream()
                              .map(String::toUpperCase)
                              .collect(Collectors.toList());

// 😐 Okay - Lambda expression (verbose)
List<String> upperNames2 = names.stream()
                                .map(name -> name.toUpperCase())
                                .collect(Collectors.toList());
```

### Practice 2: Use Appropriate Collectors 🎯

```java
List<String> words = Arrays.asList("Hello", "World", "Java", "Stream");

// ✅ Best - Use specific collectors
String joined = words.stream().collect(Collectors.joining(" "));
Set<String> uniqueWords = words.stream().collect(Collectors.toSet());
Map<Integer, List<String>> byLength = words.stream()
                                          .collect(Collectors.groupingBy(String::length));

// ❌ Avoid - Manual reduction for built-in operations
String manualJoin = words.stream().reduce("", (a, b) -> a + " " + b).trim();
```

### Practice 3: Handle Edge Cases 🛡️

```java
public static List<String> processNames(List<String> names) {
    if (names == null || names.isEmpty()) {
        return Collections.emptyList(); // Handle null/empty input
    }
    
    return names.stream()
                .filter(Objects::nonNull)           // Filter nulls
                .filter(name -> !name.trim().isEmpty()) // Filter empty strings
                .map(String::trim)                   // Clean whitespace
                .map(String::toUpperCase)           // Transform
                .distinct()                         // Remove duplicates
                .sorted()                          // Sort
                .collect(Collectors.toList());     // Collect
}

// Test with edge cases
List<String> testNames = Arrays.asList("  Arjun  ", null, "", "bhavya", "ARJUN", "  ");
List<String> result = processNames(testNames);
System.out.println("Processed: " + result); // [ARJUN, BHAVYA]
```

### Practice 4: Use Parallel Streams Wisely ⚡

```java
List<Integer> largeList = IntStream.range(1, 1000000).boxed().collect(Collectors.toList());

// ✅ Good use of parallel - CPU intensive operation
List<Double> sqrts = largeList.parallelStream()
                             .map(Math::sqrt)
                             .collect(Collectors.toList());

// ❌ Bad use of parallel - I/O or small datasets
List<String> smallList = Arrays.asList("A", "B", "C");
smallList.parallelStream().forEach(System.out::println); // Overhead not worth it

// ✅ Better for small datasets
smallList.forEach(System.out::println);
```

### Practice 5: Chain Operations Logically 🔗

```java
List<String> sentences = Arrays.asList(
    "Java is awesome",
    "Stream API rocks",
    "Functional programming is cool"
);

// ✅ Good - Logical order (filter first, then transform)
List<String> result = sentences.stream()
                               .filter(s -> s.length() > 15)     // Filter first (reduces data)
                               .map(String::toUpperCase)         // Then transform
                               .sorted()                         // Finally sort
                               .collect(Collectors.toList());

// ❌ Less efficient - Transform first, then filter
List<String> inefficient = sentences.stream()
                                   .map(String::toUpperCase)      // Transform all
                                   .filter(s -> s.length() > 15) // Then filter
                                   .sorted()
                                   .collect(Collectors.toList());
```

### Practice 6: Document Complex Stream Operations 📝

```java
public class StudentAnalyzer {
    /**
     * Analyzes students and returns high performers
     * High performer criteria:
     * 1. Average marks > 85
     * 2. No subject with marks < 60
     * 3. At least 4 subjects
     */
    public static List<Student> findHighPerformers(List<Student> students) {
        return students.stream()
                .filter(student -> student.getMarks().size() >= 4)           // At least 4 subjects
                .filter(student -> student.getMarks().stream()               // No marks < 60
                                        .allMatch(mark -> mark >= 60))
                .filter(student -> student.getAverage() > 85)               // Average > 85
                .sorted(Comparator.comparing(Student::getAverage).reversed()) // Sort by average (desc)
                .collect(Collectors.toList());
    }
}
```

---

## 12. Performance Tips 🚀

### Tip 1: Use primitive streams for numbers 🔢

```java
// ❌ Slower - Boxing/unboxing overhead
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
int sum = numbers.stream()
                .mapToInt(Integer::intValue)
                .sum();

// ✅ Faster - Direct primitive stream
int[] primitiveArray = {1, 2, 3, 4, 5};
int sumFast = Arrays.stream(primitiveArray).sum();

// ✅ Even better - IntStream range
int sumRange = IntStream.range(1, 6).sum();

// For large computations
long startTime = System.nanoTime();
IntStream.range(1, 1000000)
        .map(n -> n * n)
        .sum();
long endTime = System.nanoTime();
System.out.println("Time taken: " + (endTime - startTime) / 1000000 + "ms");
```

### Tip 2: Early termination with findFirst/findAny 🎯

```java
List<String> names = Arrays.asList("Arjun", "Bhavya", "Ankit", "Deepak", "Esha");

// ✅ Efficient - Stops at first match
Optional<String> firstLongName = names.stream()
                                     .filter(name -> {
                                         System.out.println("Checking: " + name);
                                         return name.length() > 5;
                                     })
                                     .findFirst();

System.out.println("Found: " + firstLongName.orElse("None"));
// Only prints: Checking: Arjun, Checking: Bhavya, Checking: Ankit, Checking: Deepak
// Stops at "Deepak" (length 6 > 5)

// ❌ Inefficient - Processes all elements
List<String> allLongNames = names.stream()
                                .filter(name -> {
                                    System.out.println("Checking all: " + name);
                                    return name.length() > 5;
                                })
                                .collect(Collectors.toList());
```

### Tip 3: Use limit() for large datasets 📊

```java
// ✅ Good - Limit early
List<Integer> firstFiveEven = IntStream.range(1, 1000000)
                                     .filter(n -> n % 2 == 0)
                                     .limit(5)  // Stop after finding 5
                                     .boxed()
                                     .collect(Collectors.toList());

System.out.println("First 5 even numbers: " + firstFiveEven);
// [2, 4, 6, 8, 10] - Stops processing after finding 5 numbers
```

---

## 13. Summary/Quick Recap 📚

### 🎯 **Yaad Rakhne Ka Mantra:**

#### **STREAM = S.T.R.E.A.M** 🌊
- **S**implify your code
- **T**ransform data easily  
- **R**educe boilerplate
- **E**nable parallel processing
- **A**llow functional programming
- **M**ake it more readable

#### **Key Concepts Checklist** ✅
- ✅ Stream is **one-time use only** - can't reuse!
- ✅ **Intermediate operations are lazy** - execute only when terminal operation called
- ✅ **Terminal operations trigger execution** - collect(), forEach(), count()
- ✅ Always handle **Optional** properly with orElse(), isPresent()
- ✅ Use **Method References** when possible for cleaner code
- ✅ **Filter first, transform later** for better performance
- ✅ Use **parallel()** only for large datasets and CPU-intensive operations

#### **Common Pattern to Remember** 🔄
```java
List<Result> result = collection.stream()
                                .filter(condition)      // 🔍 Filter
                                .map(transformation)    // 🔄 Transform  
                                .sorted()              // 📊 Sort
                                .collect(toList());    // 📦 Collect
```

#### **When to Use Stream API** 🤔
| ✅ **Use Stream When:** | ❌ **Don't Use Stream When:** |
|------------------------|-------------------------------|
| Filtering collections | Simple iteration (forEach) |
| Transforming data | Small datasets (< 10 elements) |
| Finding elements | Single operation |
| Grouping/Aggregation | Need index-based access |
| Chaining operations | Modifying original collection |

#### **Interview Ready Points** 🎯
1. **Stream API introduced in Java 8** for functional programming
2. **Two types of operations**: Intermediate (lazy) and Terminal (eager)
3. **Parallel processing** support with parallelStream()
4. **Immutable** - doesn't modify original collection
5. **Lazy evaluation** - better performance
6. **Method chaining** - more readable code

#### **Quick Method Reference** 📋
```java
// Creation
Stream.of(1, 2, 3)
collection.stream()
Arrays.stream(array)

// Intermediate
.filter(condition)
.map(transformation)
.sorted()
.distinct()
.limit(n)

// Terminal  
.collect(Collectors.toList())
.forEach(action)
.count()
.findFirst()
.reduce(identity, accumulator)
```

#### **Memory Trick** 🧠
**"FILM"** - Remember common stream operations:
- **F**ilter - condition lagao
- **I**terate - forEach karo  
- **L**imit - boundary set karo
- **M**ap - transform karo

---

## 🎉 **Congratulations Bhai!** 

Tumne Java Stream API master kar liya! 🏆

**Ab kya karna hai:**
1. Practice these examples 💻
2. Try creating your own scenarios 🎯  
3. Use in your projects 🚀
4. Teach others (best way to learn) 📚

**Remember**: Stream API is not just about writing less code, it's about writing **better, more readable, and maintainable** code! 

**Happy Coding! 😊**

---

> **"Code is poetry, and Stream API is your pen!"** ✍️
