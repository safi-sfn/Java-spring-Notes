# Lambda Expression in Java - Complete Study Notes ğŸ“š

## Lambda Expression Kya Hai Bhai? ğŸ¤”

**Simple Definition**: Lambda expression ek anonymous function hai jo code ko concise aur functional programming style mein likhne mein madad karta hai!

**Real Life Analogy**: 
- **Traditional Way**: Dukan jaana, owner se milna, naam batana, phir saamaan lena ğŸª
- **Lambda Way**: Online order kar diya - direct, quick, no extra steps! ğŸ“±

**Technical Definition**: Lambda expression is an anonymous function without name, return type, or modifiers, using the arrow operator `->`.

## Lambda Expression Ki History ğŸ“…

- **Introduced**: Java 8 (March 2014) ğŸ‰
- **Purpose**: Functional programming enable karna
- **Goal**: Code ko concise aur readable banana
- **Performance**: Extra .class files nahi bante, memory efficient!

## Basic Syntax - Arrow Magic! â¡ï¸

### **Lambda Syntax Structure:**
```
(parameters) -> { body }
```

### **Traditional Method vs Lambda:**

```java
// Traditional Method
public void sayHello() {
    System.out.println("Hello World!");
}

// Lambda Expression
() -> System.out.println("Hello World!");
```

```java
// Traditional Method  
public int add(int a, int b) {
    return a + b;
}

// Lambda Expression
(int a, int b) -> a + b;
```

## Lambda Expression Rules - Yaad Kar Lo! ğŸ“

### **Rule 1: Single Statement - Curly Braces Optional** âœ…
```java
// Single line - no braces needed
() -> System.out.println("Hello");

// Multiple lines - braces mandatory
() -> {
    System.out.println("Line 1");
    System.out.println("Line 2");
}
```

### **Rule 2: Type Inference - Compiler Smart Hai!** ğŸ§ 
```java
// Explicit type declaration
(int a, int b) -> a + b;

// Type inference - compiler guesses
(a, b) -> a + b;  // âœ… More concise!
```

### **Rule 3: Single Parameter - Parentheses Optional** ğŸ“
```java
// With parentheses
(n) -> n * n;

// Without parentheses - cleaner look
n -> n * n;  // âœ… Even more concise!
```

### **Rule 4: Return Statement Rules** ğŸ”„
```java
// Without braces - return implicit
n -> n * n;  

// With braces - return explicit
n -> {
    return n * n;
}

// Multiple statements with braces
n -> {
    int result = n * n;
    System.out.println("Calculating...");
    return result;
}
```

## Complete Example - Square Interface! ğŸ“

### **Traditional Approach - Too Much Code! ğŸ˜«**

```java
// Step 1: Define Functional Interface
interface Square {
    void square(int x);
}

// Step 2: Create Implementation Class
class SquareImpl implements Square {
    @Override
    public void square(int x) {
        System.out.println("Square of " + x + " is: " + (x * x));
    }
}

// Step 3: Use Implementation
public class TraditionalApproach {
    public static void main(String[] args) {
        Square sq = new SquareImpl();  // Creates SquareImpl.class file
        sq.square(10);
    }
}
```

**Output:**
```
Square of 10 is: 100
```

**Problems:**
- âŒ Extra class file (SquareImpl.class)
- âŒ More code to write
- âŒ Less readable
- âŒ More memory usage

### **Anonymous Inner Class - Better but Still Verbose! ğŸ˜**

```java
interface Square {
    void square(int x);
}

public class AnonymousApproach {
    public static void main(String[] args) {
        // Anonymous Inner Class
        Square sq = new Square() {
            @Override
            public void square(int x) {
                System.out.println("Square of " + x + " is: " + (x * x));
            }
        };
        
        sq.square(10);  // Still creates extra .class file
    }
}
```

**Output:**
```
Square of 10 is: 100
```

**Problems:**
- âŒ Still creates extra .class file
- âŒ Verbose syntax
- âŒ More boilerplate code

### **Lambda Expression - Clean & Efficient! ğŸ˜**

```java
interface Square {
    void square(int x);
}

public class LambdaApproach {
    public static void main(String[] args) {
        // Lambda Expression - One line magic!
        Square sq = x -> System.out.println("Square of " + x + " is: " + (x * x));
        
        sq.square(10);  // No extra .class file created!
    }
}
```

**Output:**
```
Square of 10 is: 100
```

**Benefits:**
- âœ… No extra .class file
- âœ… Concise code
- âœ… Better performance
- âœ… Functional programming style
- âœ… Easy to read and maintain

## Functional Interface - Lambda Ki Jaan! ğŸ’–

### **What is Functional Interface?**
Interface with exactly **ONE abstract method** (SAM - Single Abstract Method)

### **Examples of Functional Interfaces:**

```java
// Custom Functional Interface
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    
    // Default methods allowed
    default void display() {
        System.out.println("Calculator interface");
    }
    
    // Static methods allowed
    static void info() {
        System.out.println("Functional Interface");
    }
}

// Using Lambda with Custom Interface
public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Addition
        Calculator add = (a, b) -> a + b;
        System.out.println("Addition: " + add.calculate(5, 3));
        
        // Multiplication
        Calculator multiply = (a, b) -> a * b;
        System.out.println("Multiplication: " + multiply.calculate(5, 3));
        
        // Subtraction
        Calculator subtract = (a, b) -> a - b;
        System.out.println("Subtraction: " + subtract.calculate(5, 3));
    }
}
```

**Output:**
```
Addition: 8
Multiplication: 15
Subtraction: 2
```

## Built-in Functional Interfaces - Java 8 Ki Gift! ğŸ

### **1. Predicate<T> - Boolean Return** âœ…âŒ

```java
import java.util.function.Predicate;

public class PredicateExample {
    public static void main(String[] args) {
        // Check if number is even
        Predicate<Integer> isEven = num -> num % 2 == 0;
        
        System.out.println("Is 4 even? " + isEven.test(4));  // true
        System.out.println("Is 5 even? " + isEven.test(5));  // false
        
        // Check if string is not empty
        Predicate<String> isNotEmpty = str -> !str.isEmpty();
        System.out.println("Is 'Hello' not empty? " + isNotEmpty.test("Hello"));  // true
        System.out.println("Is '' not empty? " + isNotEmpty.test(""));           // false
    }
}
```

### **2. Function<T, R> - Transform Input** ğŸ”„

```java
import java.util.function.Function;

public class FunctionExample {
    public static void main(String[] args) {
        // Convert string to uppercase
        Function<String, String> toUpperCase = str -> str.toUpperCase();
        System.out.println(toUpperCase.apply("hello"));  // HELLO
        
        // Get string length
        Function<String, Integer> getLength = str -> str.length();
        System.out.println("Length of 'Java': " + getLength.apply("Java"));  // 4
        
        // Square a number
        Function<Integer, Integer> square = num -> num * num;
        System.out.println("Square of 5: " + square.apply(5));  // 25
    }
}
```

### **3. Consumer<T> - Accept Input, No Return** ğŸ“¥

```java
import java.util.function.Consumer;

public class ConsumerExample {
    public static void main(String[] args) {
        // Print with formatting
        Consumer<String> printer = msg -> System.out.println("Message: " + msg);
        printer.accept("Hello Lambda!");  // Message: Hello Lambda!
        
        // Modify list elements
        Consumer<Integer> squarePrinter = num -> System.out.println(num + " squared = " + (num * num));
        squarePrinter.accept(4);  // 4 squared = 16
        squarePrinter.accept(7);  // 7 squared = 49
    }
}
```

### **4. Supplier<T> - No Input, Return Output** ğŸ“¤

```java
import java.util.function.Supplier;
import java.util.Random;

public class SupplierExample {
    public static void main(String[] args) {
        // Generate random number
        Supplier<Integer> randomGenerator = () -> new Random().nextInt(100);
        System.out.println("Random number: " + randomGenerator.get());
        
        // Get current time
        Supplier<String> currentTime = () -> new java.util.Date().toString();
        System.out.println("Current time: " + currentTime.get());
        
        // Default message supplier
        Supplier<String> defaultMessage = () -> "Hello from Supplier!";
        System.out.println(defaultMessage.get());
    }
}
```

## Real-World Examples - Practical Usage! ğŸŒ

### **Example 1: List Processing** ğŸ“‹

```java
import java.util.*;
import java.util.stream.Collectors;

public class ListProcessingExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eva");
        
        // Traditional approach - lots of code
        List<String> upperCaseNames = new ArrayList<>();
        for (String name : names) {
            if (name.length() > 3) {
                upperCaseNames.add(name.toUpperCase());
            }
        }
        System.out.println("Traditional: " + upperCaseNames);
        
        // Lambda approach - one line!
        List<String> lambdaResult = names.stream()
            .filter(name -> name.length() > 3)      // Predicate lambda
            .map(name -> name.toUpperCase())        // Function lambda
            .collect(Collectors.toList());
        
        System.out.println("Lambda: " + lambdaResult);
        
        // Even more concise with method references
        List<String> methodRefResult = names.stream()
            .filter(name -> name.length() > 3)
            .map(String::toUpperCase)               // Method reference
            .collect(Collectors.toList());
            
        System.out.println("Method Ref: " + methodRefResult);
    }
}
```

**Output:**
```
Traditional: [ALICE, CHARLIE, DAVID]
Lambda: [ALICE, CHARLIE, DAVID]
Method Ref: [ALICE, CHARLIE, DAVID]
```

### **Example 2: Event Handling with Lambda** ğŸ–±ï¸

```java
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

public class EventHandlingExample {
    public static void main(String[] args) {
        JFrame frame = new JFrame("Lambda Event Example");
        JButton button = new JButton("Click Me!");
        
        // Traditional approach
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("Traditional: Button clicked!");
            }
        });
        
        // Lambda approach - much cleaner!
        JButton lambdaButton = new JButton("Lambda Button");
        lambdaButton.addActionListener(e -> System.out.println("Lambda: Button clicked!"));
        
        // Even shorter for simple actions
        JButton shortButton = new JButton("Short Lambda");
        shortButton.addActionListener(e -> JOptionPane.showMessageDialog(frame, "Lambda Magic!"));
        
        frame.setLayout(new java.awt.FlowLayout());
        frame.add(button);
        frame.add(lambdaButton);
        frame.add(shortButton);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(400, 100);
        frame.setVisible(true);
    }
}
```

### **Example 3: Custom Comparators** ğŸ“Š

```java
import java.util.*;

class Person {
    String name;
    int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return name + "(" + age + ")";
    }
}

public class ComparatorExample {
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 30),
            new Person("Bob", 25),
            new Person("Charlie", 35),
            new Person("David", 28)
        );
        
        System.out.println("Original: " + people);
        
        // Traditional Comparator
        Collections.sort(people, new Comparator<Person>() {
            @Override
            public int compare(Person p1, Person p2) {
                return p1.age - p2.age;
            }
        });
        System.out.println("Traditional sort by age: " + people);
        
        // Lambda Comparator - much cleaner!
        people.sort((p1, p2) -> p1.name.compareTo(p2.name));
        System.out.println("Lambda sort by name: " + people);
        
        // Even shorter with Comparator.comparing
        people.sort(Comparator.comparing(p -> p.age));
        System.out.println("Method reference sort by age: " + people);
    }
}
```

**Output:**
```
Original: [Alice(30), Bob(25), Charlie(35), David(28)]
Traditional sort by age: [Bob(25), David(28), Alice(30), Charlie(35)]
Lambda sort by name: [Alice(30), Bob(25), Charlie(35), David(28)]
Method reference sort by age: [Bob(25), David(28), Alice(30), Charlie(35)]
```

## Lambda Expression Variations - Different Styles! ğŸ¨

### **1. No Parameters** ğŸš«â¡ï¸
```java
// Traditional
Runnable r1 = new Runnable() {
    public void run() {
        System.out.println("Running traditional way");
    }
};

// Lambda
Runnable r2 = () -> System.out.println("Running lambda way");

// Usage
Thread t1 = new Thread(r1);
Thread t2 = new Thread(r2);
t1.start();
t2.start();
```

### **2. Single Parameter** 1ï¸âƒ£â¡ï¸
```java
import java.util.function.Consumer;

// Different ways to write single parameter lambda
Consumer<String> printer1 = (str) -> System.out.println(str);
Consumer<String> printer2 = str -> System.out.println(str);    // No parentheses
Consumer<String> printer3 = System.out::println;               // Method reference

printer1.accept("Hello 1");
printer2.accept("Hello 2");
printer3.accept("Hello 3");
```

### **3. Multiple Parameters** 2ï¸âƒ£â¡ï¸
```java
import java.util.function.BinaryOperator;

BinaryOperator<Integer> add1 = (a, b) -> a + b;
BinaryOperator<Integer> add2 = (Integer a, Integer b) -> a + b;  // Explicit types

System.out.println("Sum 1: " + add1.apply(5, 3));  // 8
System.out.println("Sum 2: " + add2.apply(10, 7)); // 17
```

### **4. Block Body** ğŸ“¦â¡ï¸
```java
import java.util.function.Function;

// Single expression
Function<Integer, Integer> square1 = n -> n * n;

// Block body with multiple statements
Function<Integer, Integer> square2 = n -> {
    System.out.println("Calculating square of " + n);
    int result = n * n;
    System.out.println("Result: " + result);
    return result;
};

System.out.println(square1.apply(4));  // 16
System.out.println(square2.apply(5));  
// Calculating square of 5
// Result: 25
// 25
```

## Lambda vs Method Reference - Ek Aur Shortcut! ğŸ”—

### **When Lambda becomes even shorter:**

```java
import java.util.Arrays;
import java.util.List;

public class MethodReferenceExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        // Lambda expressions
        names.forEach(name -> System.out.println(name));
        names.stream().map(name -> name.toUpperCase()).forEach(name -> System.out.println(name));
        
        // Method references - even shorter!
        names.forEach(System.out::println);                    // Static method reference
        names.stream().map(String::toUpperCase).forEach(System.out::println);  // Instance method reference
        
        // Constructor reference
        names.stream().map(String::new).forEach(System.out::println);
    }
}
```

## Performance Benefits - Why Lambda Rocks! ğŸš€

### **Memory Usage Comparison:**

```java
interface SimpleInterface {
    void doSomething();
}

public class PerformanceComparison {
    public static void main(String[] args) {
        // Traditional approach - creates .class file
        SimpleInterface traditional = new SimpleInterface() {
            @Override
            public void doSomething() {
                System.out.println("Traditional implementation");
            }
        };
        // Creates: PerformanceComparison$1.class
        
        // Lambda approach - no extra .class file
        SimpleInterface lambda = () -> System.out.println("Lambda implementation");
        // No extra .class file created!
        
        traditional.doSomething();
        lambda.doSomething();
    }
}
```

**Benefits:**
- âœ… **No extra .class files** - Better memory usage
- âœ… **Faster JVM startup** - Fewer files to load
- âœ… **Better performance** - Less overhead
- âœ… **Cleaner bytecode** - More optimized

## Common Mistakes - Avoid These! âŒ

### **1. Wrong Functional Interface Usage**
```java
interface MultipleAbstractMethods {
    void method1();
    void method2();  // More than one abstract method
}

// âŒ Cannot use lambda - not a functional interface
// MultipleAbstractMethods obj = () -> System.out.println("Error");
```

### **2. Variable Scope Issues**
```java
public class VariableScopeExample {
    public static void main(String[] args) {
        int localVar = 10;
        
        // âŒ Cannot modify local variable in lambda
        // Runnable r = () -> { localVar = 20; };  // Compilation error
        
        // âœ… Can read effectively final variables
        Runnable r = () -> System.out.println("Local var: " + localVar);
        r.run();
    }
}
```

### **3. Return Statement Confusion**
```java
import java.util.function.Function;

Function<Integer, Integer> square1 = n -> n * n;  // âœ… Implicit return

Function<Integer, Integer> square2 = n -> {       // âŒ Missing return
    n * n;  // This won't work!
};

Function<Integer, Integer> square3 = n -> {       // âœ… Explicit return
    return n * n;
};
```

### **4. Exception Handling**
```java
import java.util.function.Consumer;

// âŒ Checked exceptions need to be handled
// Consumer<String> fileReader = fileName -> {
//     Files.readAllLines(Paths.get(fileName));  // IOException not handled
// };

// âœ… Handle exceptions properly
Consumer<String> fileReader = fileName -> {
    try {
        java.nio.file.Files.readAllLines(java.nio.file.Paths.get(fileName));
    } catch (java.io.IOException e) {
        System.out.println("Error reading file: " + e.getMessage());
    }
};
```

## Interview Questions - Master Karo! ğŸ’ª

### **Q1: What is the difference between lambda expression and anonymous inner class?**

**Answer:**
| **Lambda Expression** | **Anonymous Inner Class** |
|----------------------|---------------------------|
| No extra .class file | Creates extra .class file |
| Only for functional interfaces | Can implement any interface |
| Cannot have instance variables | Can have instance variables |
| 'this' refers to enclosing class | 'this' refers to anonymous class |
| Better performance | Slightly slower |
| More concise syntax | More verbose syntax |

### **Q2: Can lambda expressions access local variables?**

```java
public void example() {
    int localVar = 10;          // Effectively final
    String message = "Hello";   // Effectively final
    
    Runnable r = () -> {
        System.out.println(localVar);  // âœ… Can access
        System.out.println(message);   // âœ… Can access
        // localVar = 20;              // âŒ Cannot modify
    };
    
    // localVar = 15;  // âŒ This would make lambda compilation fail
}
```

**Answer**: Lambda can access effectively final local variables but cannot modify them.

### **Q3: What is effectively final?**

**Answer**: Variable that is never modified after initialization, even without `final` keyword.

```java
int a = 10;        // Effectively final - never changed
int b = 20;        // Not effectively final
b = 30;            // Modified, so not effectively final

// Lambda can access 'a' but not 'b'
Runnable r = () -> System.out.println(a);  // âœ… Works
// Runnable r2 = () -> System.out.println(b); // âŒ Error
```

### **Q4: Can we use lambda for any interface?**

**Answer**: No! Only for **Functional Interfaces** (interfaces with exactly one abstract method).

```java
// âœ… Functional Interface - can use lambda
interface Runnable {
    void run();
}

// âŒ Not functional - cannot use lambda
interface NotFunctional {
    void method1();
    void method2();
}

// âœ… Still functional - default/static methods don't count
interface StillFunctional {
    void abstractMethod();
    default void defaultMethod() { }
    static void staticMethod() { }
}
```

### **Q5: What happens to 'this' keyword in lambda?**

```java
public class ThisExample {
    private String name = "Outer Class";
    
    public void traditionalApproach() {
        Runnable r = new Runnable() {
            private String name = "Anonymous Class";
            
            @Override
            public void run() {
                System.out.println(this.name);  // "Anonymous Class"
            }
        };
        r.run();
    }
    
    public void lambdaApproach() {
        Runnable r = () -> {
            System.out.println(this.name);  // "Outer Class"
        };
        r.run();
    }
}
```

**Answer**: In lambda, `this` refers to the enclosing class instance, not the lambda itself.

## Best Practices - Pro Tips! ğŸŒŸ

### **1. Use Method References When Possible**
```java
// âŒ Verbose lambda
list.forEach(item -> System.out.println(item));

// âœ… Concise method reference
list.forEach(System.out::println);
```

### **2. Keep Lambda Expressions Short**
```java
// âŒ Too long for lambda - use regular method
Function<String, String> processor = input -> {
    // 20+ lines of code
    // This should be a separate method
};

// âœ… Short and sweet
Function<String, String> processor = String::toUpperCase;
```

### **3. Use Meaningful Variable Names**
```java
// âŒ Unclear names
list.stream().filter(x -> x.length() > 5).map(x -> x.toUpperCase());

// âœ… Clear names
list.stream()
    .filter(name -> name.length() > 5)
    .map(name -> name.toUpperCase());
```

### **4. Use @FunctionalInterface Annotation**
```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);
    
    // This annotation ensures only one abstract method
}
```

## Summary - Quick Recap! ğŸ“

### **Lambda Expression Benefits:**
- âœ… **Concise syntax** - Less boilerplate code
- âœ… **Functional programming** - New programming paradigm
- âœ… **Better performance** - No extra .class files
- âœ… **Readable code** - More expressive
- âœ… **Easy maintenance** - Less code to maintain

### **Key Components:**
1. **Parameters** - Input to the function
2. **Arrow operator** - `->` separator
3. **Body** - Implementation logic

### **Syntax Variations:**
```java
() -> expression                    // No parameters
x -> expression                     // Single parameter
(x) -> expression                   // Single parameter with parentheses
(x, y) -> expression               // Multiple parameters
(x, y) -> { statements; }          // Block body
```

### **Usage Rules:**
- ğŸ¯ Only with **Functional Interfaces**
- ğŸ¯ Can access **effectively final** variables
- ğŸ¯ **No extra .class files** generated
- ğŸ¯ **this** refers to enclosing class

### **When to Use Lambda:**
- ğŸ’¡ Event handling
- ğŸ’¡ Collection processing
- ğŸ’¡ Asynchronous programming
- ğŸ’¡ Functional-style operations
- ğŸ’¡ Stream API operations

**Memory Trick**: **Lambda** = **L**ess **A**nonymous **M**ethods **B**etter **D**esign **A**pproach! ğŸ˜„

Practice these examples à¤”à¤° Lambda expressions master kar jao! ğŸš€ğŸ’ª

---
*Happy Coding! ğŸ‰*
