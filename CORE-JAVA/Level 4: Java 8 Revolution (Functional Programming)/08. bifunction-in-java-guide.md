# ğŸš€ BiFunction in Java 8 - Complete Study Notes

*"Bhai, do arguments leke ek result chahiye? BiFunction hai na!"* ğŸ˜

---

## 1ï¸âƒ£ Introduction with Confusion Clearing ğŸ¤”

### Simple Explanation First ğŸ“š
BiFunction ka matlab hai **"Bi" (à¤¦à¥‹) + "Function"** - yaani ek function jo **do arguments** leta hai aur **ek result** return karta hai, bhai! 

### Real-life Analogy ğŸŒŸ
**Soch Calculator ki tarah:**
- Normal Function = `f(x)` â†’ Ek number dalo, result nikalo
- BiFunction = `f(x,y)` â†’ Do numbers dalo, result nikalo
- Jaise: Addition, Multiplication, etc.

**Dusra example:** 
Restaurant mein order - Tumhe **dish name** aur **quantity** batana padta hai â†’ **total price** milta hai!

### Technical Definition ğŸ’»
BiFunction ek **Functional Interface** hai jo Java 8 mein aaya tha. Ye `java.util.function` package mein present hai aur **exactly 2 input parameters** leta hai + **1 result** return karta hai.

---

## 2ï¸âƒ£ Key Terms/Concepts ğŸ”‘

| Term | Hindi Meaning | Example |
|------|---------------|---------|
| **BiFunction<T,U,R>** | Do type ke input, ek type ka output | `BiFunction<String, Integer, Student>` |
| **T** | Pehla argument ka type | String, Integer, etc. |
| **U** | Dusra argument ka type | Integer, Double, etc. |
| **R** | Result ka type | Boolean, Student, List, etc. |
| **apply()** | Function ko execute karna | `biFunc.apply(arg1, arg2)` |
| **andThen()** | Chain banana functions ka | `biFunc.andThen(nextFunc)` |

### Visual Representation ğŸ“Š
```
Input 1 (T) â”€â”€â”
              â”œâ”€â”€â”€ BiFunction â”€â”€â–º Result (R)
Input 2 (U) â”€â”€â”˜
```

---

## 3ï¸âƒ£ Detailed Examples ğŸ’¡

### Example 1: Basic BiFunction - Simple Math Operations ğŸ§®

```java
import java.util.function.BiFunction;

public class BiFunctionBasics {
    public static void main(String[] args) {
        // Addition BiFunction
        BiFunction<Integer, Integer, Integer> addition = (a, b) -> a + b;
        System.out.println("5 + 3 = " + addition.apply(5, 3)); // Output: 8
        
        // Multiplication BiFunction  
        BiFunction<Integer, Integer, Integer> multiplication = (x, y) -> x * y;
        System.out.println("4 Ã— 6 = " + multiplication.apply(4, 6)); // Output: 24
        
        // String concatenation with number
        BiFunction<String, Integer, String> concat = (str, num) -> str + num;
        System.out.println(concat.apply("Roll No: ", 101)); // Output: Roll No: 101
    }
}
```

**Expected Output:**
```
5 + 3 = 8
4 Ã— 6 = 24
Roll No: 101
```

### Example 2: BiFunction with andThen() - Function Chaining ğŸ”—

```java
import java.util.function.BiFunction;
import java.util.function.Function;

public class BiFunctionChaining {
    public static void main(String[] args) {
        // Pehle add karo, phir multiply by 2
        BiFunction<Integer, Integer, Integer> addThenDouble = (a, b) -> a + b;
        addThenDouble = addThenDouble.andThen(result -> result * 2);
        
        System.out.println("(5 + 3) Ã— 2 = " + addThenDouble.apply(5, 3)); // Output: 16
        
        // String operations chaining
        BiFunction<String, String, String> concatThenUpper = (str1, str2) -> str1 + str2;
        concatThenUpper = concatThenUpper.andThen(String::toUpperCase);
        
        System.out.println(concatThenUpper.apply("hello", "world")); // Output: HELLOWORLD
    }
}
```

### Example 3: Real-world Banking Example ğŸ¦

```java
import java.util.function.BiFunction;

class BankAccount {
    String accountHolder;
    double balance;
    
    public BankAccount(String accountHolder, double balance) {
        this.accountHolder = accountHolder;
        this.balance = balance;
    }
    
    @Override
    public String toString() {
        return "Account: " + accountHolder + ", Balance: â‚¹" + balance;
    }
}

public class BankingExample {
    public static void main(String[] args) {
        // Account creation BiFunction
        BiFunction<String, Double, BankAccount> createAccount = 
            (name, amount) -> new BankAccount(name, amount);
        
        // Creating accounts
        BankAccount acc1 = createAccount.apply("Rahul Sharma", 50000.0);
        BankAccount acc2 = createAccount.apply("Priya Singh", 75000.0);
        
        System.out.println(acc1); // Account: Rahul Sharma, Balance: â‚¹50000.0
        System.out.println(acc2); // Account: Priya Singh, Balance: â‚¹75000.0
        
        // Interest calculation BiFunction
        BiFunction<Double, Double, Double> calculateInterest = 
            (principal, rate) -> principal * rate / 100;
        
        double interest = calculateInterest.apply(50000.0, 8.5);
        System.out.println("Interest on â‚¹50,000 @ 8.5% = â‚¹" + interest); // â‚¹4250.0
    }
}
```

---

## 4ï¸âƒ£ Rules/Guidelines ğŸ“‹

### Rule 1: Signature Follow Karo âœ…
```java
BiFunction<InputType1, InputType2, ReturnType> funcName = (param1, param2) -> expression;
```

âŒ **Galat:**
```java
BiFunction<String, Integer> wrong = (s, i) -> s + i; // Return type missing!
```

âœ… **Sahi:**
```java
BiFunction<String, Integer, String> correct = (s, i) -> s + i;
```

### Rule 2: Null Handling Zaroori Hai âš ï¸
```java
BiFunction<String, String, String> safeConcat = (s1, s2) -> {
    if (s1 == null) s1 = "";
    if (s2 == null) s2 = "";
    return s1 + s2;
};
```

### Rule 3: Exception Handling Karo ğŸ›¡ï¸
```java
BiFunction<Integer, Integer, Double> safeDivision = (a, b) -> {
    if (b == 0) {
        throw new ArithmeticException("Division by zero not allowed!");
    }
    return (double) a / b;
};
```

### Rule 4: andThen() Sirf Function Accept Karta Hai ğŸ”„
```java
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
// Correct - Function with single input
add = add.andThen(result -> result * 2);
// Incorrect - Can't chain another BiFunction directly
```

---

## 5ï¸âƒ£ Real-world Applications ğŸŒ

### Application 1: E-commerce Discount Calculator ğŸ›’

```java
import java.util.function.BiFunction;

public class ECommerceExample {
    public static void main(String[] args) {
        // Price after discount calculation
        BiFunction<Double, Double, Double> calculateDiscountPrice = 
            (originalPrice, discountPercent) -> {
                double discountAmount = originalPrice * discountPercent / 100;
                return originalPrice - discountAmount;
            };
        
        // Examples
        double laptopPrice = calculateDiscountPrice.apply(50000.0, 15.0);
        double mobilePrice = calculateDiscountPrice.apply(25000.0, 10.0);
        
        System.out.println("Laptop after 15% discount: â‚¹" + laptopPrice); // â‚¹42500.0
        System.out.println("Mobile after 10% discount: â‚¹" + mobilePrice); // â‚¹22500.0
        
        // Tax calculation with chaining
        BiFunction<Double, Double, Double> addTax = calculateDiscountPrice.andThen(
            finalPrice -> finalPrice + (finalPrice * 18.0 / 100) // 18% GST
        );
        
        double finalLaptopPrice = addTax.apply(50000.0, 15.0);
        System.out.println("Final laptop price with GST: â‚¹" + finalLaptopPrice); // â‚¹50150.0
    }
}
```

### Application 2: Student Grading System ğŸ“š

```java
import java.util.function.BiFunction;
import java.util.Arrays;
import java.util.List;

class Student {
    String name;
    double marks;
    String grade;
    
    public Student(String name, double marks) {
        this.name = name;
        this.marks = marks;
    }
    
    public void setGrade(String grade) {
        this.grade = grade;
    }
    
    @Override
    public String toString() {
        return name + ": " + marks + " (" + grade + ")";
    }
}

public class GradingSystem {
    public static void main(String[] args) {
        // Grade calculation BiFunction
        BiFunction<Double, Double, String> calculateGrade = (marks, totalMarks) -> {
            double percentage = (marks / totalMarks) * 100;
            if (percentage >= 90) return "A+";
            else if (percentage >= 80) return "A";
            else if (percentage >= 70) return "B+";
            else if (percentage >= 60) return "B";
            else if (percentage >= 50) return "C";
            else return "F";
        };
        
        // Student creation and grading
        List<Student> students = Arrays.asList(
            new Student("Rahul", 485),
            new Student("Priya", 520),
            new Student("Amit", 445),
            new Student("Sneha", 395)
        );
        
        students.forEach(student -> {
            String grade = calculateGrade.apply(student.marks, 600.0);
            student.setGrade(grade);
            System.out.println(student);
        });
    }
}
```

**Expected Output:**
```
Rahul: 485.0 (A)
Priya: 520.0 (A+)
Amit: 445.0 (B)
Sneha: 395.0 (C)
```

---

## 6ï¸âƒ£ Comparison Tables ğŸ“Š

### BiFunction vs Function vs Consumer

| Feature | Function<T,R> | BiFunction<T,U,R> | Consumer<T> |
|---------|---------------|-------------------|-------------|
| **Input Parameters** | 1 | 2 | 1 |
| **Return Type** | R | R | void |
| **Use Case** | Transform single input | Transform two inputs | Side effects only |
| **Example** | `String::toUpperCase` | `(a,b) -> a+b` | `System.out::println` |

### Lambda vs Method Reference with BiFunction

| Approach | Syntax | Example | When to Use |
|----------|--------|---------|-------------|
| **Lambda Expression** | `(a,b) -> expression` | `(x,y) -> x*y` | Custom logic |
| **Method Reference** | `Class::method` | `Math::max` | Existing methods |
| **Constructor Reference** | `Class::new` | `Student::new` | Object creation |

---

## 7ï¸âƒ£ Interview Questions ğŸ¯

### Q1: BiFunction aur Function mein kya difference hai?

**Answer:** 
- **Function** sirf **ek argument** leta hai: `Function<T,R>`
- **BiFunction** **do arguments** leta hai: `BiFunction<T,U,R>`

```java
Function<Integer, Integer> square = x -> x * x; // One input
BiFunction<Integer, Integer, Integer> add = (x, y) -> x + y; // Two inputs
```

### Q2: andThen() method ka use kya hai?

**Answer:** Function chaining ke liye use hota hai. Pehle BiFunction execute hota hai, phir uska result next Function mein pass hota hai.

```java
BiFunction<Integer, Integer, Integer> addThenSquare = (a, b) -> a + b;
addThenSquare = addThenSquare.andThen(result -> result * result);
// (3 + 4)Â² = 7Â² = 49
System.out.println(addThenSquare.apply(3, 4)); // Output: 49
```

### Q3: BiFunction mein exception handling kaise kare?

**Answer:** Try-catch use karo ya custom wrapper function banao:

```java
BiFunction<Integer, Integer, Optional<Integer>> safeDivision = (a, b) -> {
    try {
        return Optional.of(a / b);
    } catch (ArithmeticException e) {
        return Optional.empty();
    }
};
```

### Q4: Can we use BiFunction for different data types?

**Answer:** Haan bilkul! Different generic types use kar sakte hai:

```java
BiFunction<String, Integer, Boolean> lengthChecker = 
    (str, minLength) -> str.length() >= minLength;
    
BiFunction<List<Integer>, Integer, List<Integer>> filterGreater = 
    (list, threshold) -> list.stream()
                           .filter(x -> x > threshold)
                           .collect(Collectors.toList());
```

---

## 8ï¸âƒ£ Common Mistakes ğŸš«

### Mistake 1: Return Type Specify Nahi Karna
âŒ **Galat:**
```java
BiFunction<String, Integer> wrong = (s, i) -> s + i;
// Compile Error: BiFunction requires 3 type parameters!
```

âœ… **Sahi:**
```java
BiFunction<String, Integer, String> correct = (s, i) -> s + i;
```

### Mistake 2: Null Values Handle Nahi Karna
âŒ **Galat:**
```java
BiFunction<String, String, Integer> lengthSum = (s1, s2) -> s1.length() + s2.length();
// NullPointerException if s1 or s2 is null!
```

âœ… **Sahi:**
```java
BiFunction<String, String, Integer> safeLengthSum = (s1, s2) -> {
    int len1 = (s1 != null) ? s1.length() : 0;
    int len2 = (s2 != null) ? s2.length() : 0;
    return len1 + len2;
};
```

### Mistake 3: Method Reference Galat Use Karna
âŒ **Galat:**
```java
BiFunction<Integer, Integer, Integer> max = Integer::max; // Correct actually!
BiFunction<String, String, String> concat = String::concat; // This is correct too!

// But this is wrong:
BiFunction<Integer, Integer, Integer> add = Integer::sum; // sum method doesn't exist!
```

âœ… **Sahi:**
```java
BiFunction<Integer, Integer, Integer> max = Integer::max;
BiFunction<Integer, Integer, Integer> add = Integer::sum; // Actually, this exists in Java 8+!
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b; // Or use lambda
```

### Mistake 4: andThen() mein BiFunction Pass Karna
âŒ **Galat:**
```java
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;
BiFunction<Integer, Integer, Integer> multiply = (a, b) -> a * b;
// This won't work - andThen expects Function, not BiFunction
add.andThen(multiply); // Compile Error!
```

âœ… **Sahi:**
```java
BiFunction<Integer, Integer, Integer> addThenDouble = (a, b) -> a + b;
addThenDouble = addThenDouble.andThen(result -> result * 2); // Function with single input
```

---

## 9ï¸âƒ£ Best Practices ğŸŒŸ

### Practice 1: Meaningful Variable Names ğŸ“
```java
// âŒ Bad
BiFunction<Double, Double, Double> f = (a, b) -> a * b;

// âœ… Good
BiFunction<Double, Double, Double> calculateArea = (length, width) -> length * width;
```

### Practice 2: Use Method References When Possible ğŸ”—
```java
// âœ… Preferred - More readable
BiFunction<Integer, Integer, Integer> findMax = Integer::max;

// âœ… Alternative - But lambda is more verbose
BiFunction<Integer, Integer, Integer> findMaxLambda = (a, b) -> Integer.max(a, b);
```

### Practice 3: Handle Edge Cases ğŸ›¡ï¸
```java
BiFunction<List<Integer>, Integer, Optional<Integer>> safeGet = (list, index) -> {
    if (list == null || index < 0 || index >= list.size()) {
        return Optional.empty();
    }
    return Optional.of(list.get(index));
};
```

### Practice 4: Use Generic Types Properly ğŸ“‹
```java
// âœ… Good - Specific types
BiFunction<String, Integer, Student> createStudent = Student::new;

// âœ… Better - More flexible with wildcards when needed
BiFunction<? extends Number, ? extends Number, Double> average = 
    (num1, num2) -> (num1.doubleValue() + num2.doubleValue()) / 2.0;
```

### Practice 5: Document Complex Logic ğŸ“š
```java
/**
 * Calculates compound interest
 * @param BiFunction<Double, Double, Double> - (principal, rate) -> amount
 */
BiFunction<Double, Double, Double> compoundInterest = (principal, rate) -> {
    // A = P(1 + r/100)^t, assuming t=1 year
    return principal * (1 + rate/100);
};
```

---

## ğŸ”Ÿ Summary/Quick Recap ğŸ“

### Key Takeaways ğŸ¯
1. **BiFunction = 2 inputs, 1 output** ğŸ’¡
2. **Signature:** `BiFunction<T, U, R>` where T,U are inputs, R is result
3. **Main Method:** `apply(T t, U u)` - function execute karta hai
4. **Chaining:** `andThen(Function<R, V>)` - result ko next function mein pass karta hai
5. **Package:** `java.util.function.BiFunction`

### Memory Tricks ğŸ§ 
- **"Bi" = à¤¦à¥‹** â†’ Two inputs
- **"Function" = à¤•à¤¾à¤®** â†’ Some work/transformation
- **"Apply" = à¤²à¤¾à¤—à¥‚ à¤•à¤°à¤¨à¤¾** â†’ Execute the function
- **"andThen" = à¤‰à¤¸à¤•à¥‡ à¤¬à¤¾à¤¦** â†’ Chain next function

### When to Use What? ğŸ¤”

| Scenario | Use This |
|----------|----------|
| **Single input, single output** | `Function<T,R>` |
| **Two inputs, single output** | `BiFunction<T,U,R>` |
| **No output (side effects)** | `Consumer<T>` or `BiConsumer<T,U>` |
| **No input, single output** | `Supplier<T>` |
| **Input validation (true/false)** | `Predicate<T>` or `BiPredicate<T,U>` |

### Interview Cheat Sheet ğŸ“„
```java
// Basic syntax
BiFunction<Type1, Type2, ResultType> funcName = (param1, param2) -> result;

// Method reference
BiFunction<Integer, Integer, Integer> max = Integer::max;

// Chaining
BiFunction<Integer, Integer, Integer> addThenSquare = 
    ((BiFunction<Integer, Integer, Integer>) (a, b) -> a + b)
    .andThen(sum -> sum * sum);

// Real-world example
BiFunction<String, Double, Employee> createEmployee = Employee::new;
```

---

## ğŸ‰ Conclusion

Bhai, BiFunction ek powerful tool hai Java 8 mein! **Do arguments leke ek result dena hai** toh BiFunction use karo. **Lambda expressions** ke saath **functional programming** ka mazaa hi alag hai! 

**Yaad rakhna:**
- Always handle **null values** ğŸ›¡ï¸
- Use **meaningful names** ğŸ“  
- **Method references** when possible ğŸ”—
- **Exception handling** zaroori hai âš ï¸

**Happy Coding! ğŸš€ğŸ’»**

---

*"Code karo, practice karo, aur BiFunction master karo!"* ğŸ˜âœ¨
