# Functional Interface Java 8 - Complete Study Notes üöÄ

## Functional Interface Kya Hai Bhai? ü§î

**Simple Words Mein**: Ek aisi interface jo sirf ek abstract method rakhti hai! 

**Real Life Analogy**: 
- Jaise TV remote mein main button sirf ek hai (ON/OFF), baaki sab extra features! üì∫
- Functional Interface = One main job + Extra helpers! 

**Technical Definition**: 
An interface which contains exactly one abstract method and can have any number of default and static methods.

## Key Features üîë

### ‚úÖ **What Makes it Functional:**
- **Exactly 1 abstract method** (SAM - Single Abstract Method)
- **Any number of default methods** 
- **Any number of static methods**
- **Can inherit from Object class methods**

### ‚úÖ **Why Important:**
- **Lambda expressions** ke liye zaroori hai!
- **Functional programming** enable karta hai Java mein
- **Code concise** banata hai
- **OOP + Functional Programming** ka combination!

## Basic Syntax & Structure üìù

### **Valid Functional Interface:**
```java
@FunctionalInterface  // Optional but recommended annotation
interface MyFunctionalInterface {
    // Exactly one abstract method (SAM)
    public void doSomething();
    
    // Default methods allowed (any number)
    default void helperMethod1() {
        System.out.println("Helper method 1");
    }
    
    default void helperMethod2() {
        System.out.println("Helper method 2");
    }
    
    // Static methods allowed (any number)
    public static void utilityMethod1() {
        System.out.println("Utility method 1");
    }
    
    public static void utilityMethod2() {
        System.out.println("Utility method 2");
    }
}
```

### **Invalid Functional Interface Examples:**
```java
// ‚ùå More than one abstract method
interface NotFunctional1 {
    public void method1();
    public void method2();  // Second abstract method - Invalid!
}

// ‚ùå No abstract method
interface NotFunctional2 {
    default void method1() { }
    static void method2() { }
    // No abstract method - Invalid!
}

// ‚ùå Only default/static methods
interface NotFunctional3 {
    default void defaultMethod() { }
    static void staticMethod() { }
    // No abstract method - Invalid!
}
```

## @FunctionalInterface Annotation üè∑Ô∏è

### **Why Use This Annotation?**
```java
@FunctionalInterface
interface Calculator {
    int calculate(int a, int b);  // One abstract method
    
    // If you accidentally add another abstract method:
    // int subtract(int a, int b);  // ‚ùå Compiler error with annotation!
}
```

**Benefits:**
- ‚úÖ **Compile-time checking** - Extra abstract method add karne par error
- ‚úÖ **Code documentation** - Clear intent that it's functional interface  
- ‚úÖ **IDE support** - Better autocomplete and warnings
- ‚úÖ **Refactoring safety** - Accidental changes prevent karta hai

## Predefined Functional Interfaces üì¶

Java mein already kuch ready-made functional interfaces hain:

### **1. Runnable Interface:**
```java
@FunctionalInterface
public interface Runnable {
    public void run();  // Single abstract method
}

// Traditional way
class MyThread implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread running traditionally");
    }
}

// Java 8 Lambda way
public class RunnableExample {
    public static void main(String[] args) {
        // Lambda expression
        Runnable task = () -> System.out.println("Thread running with lambda!");
        
        Thread thread = new Thread(task);
        thread.start();
    }
}
```

### **2. Callable Interface:**
```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;  // Single abstract method with return type
}

// Usage example
Callable<String> task = () -> {
    Thread.sleep(1000);
    return "Task completed!";
};
```

### **3. Comparable Interface:**
```java
@FunctionalInterface
public interface Comparable<T> {
    public int compareTo(T o);  // Single abstract method
}

// Usage example
class Student implements Comparable<Student> {
    private String name;
    private int marks;
    
    // Constructor
    public Student(String name, int marks) {
        this.name = name;
        this.marks = marks;
    }
    
    @Override
    public int compareTo(Student other) {
        return Integer.compare(this.marks, other.marks);
    }
}
```

### **4. ActionListener Interface (Swing):**
```java
@FunctionalInterface
public interface ActionListener {
    public void actionPerformed(ActionEvent e);  // Single abstract method
}

// Usage in GUI
JButton button = new JButton("Click Me");
button.addActionListener(e -> System.out.println("Button clicked!"));
```

## Without Lambda vs With Lambda üîÑ

### **Traditional Approach (Before Java 8):**
```java
@FunctionalInterface
interface Greeting {
    public void sayHello(String name);
}

// Traditional implementation with separate class
class TraditionalGreeting implements Greeting {
    @Override
    public void sayHello(String name) {
        System.out.println("Hello " + name + " (Traditional way)");
    }
}

public class TraditionalExample {
    public static void main(String[] args) {
        // Create object and call method
        Greeting greeting = new TraditionalGreeting();
        greeting.sayHello("Raj");
        
        // Using anonymous class
        Greeting anonymousGreeting = new Greeting() {
            @Override
            public void sayHello(String name) {
                System.out.println("Hello " + name + " (Anonymous class)");
            }
        };
        anonymousGreeting.sayHello("Priya");
    }
}
```

**Problems with Traditional Approach:**
- ‚ùå **Extra .class files** generate hote hain
- ‚ùå **Boilerplate code** zyada hai
- ‚ùå **Less readable** code
- ‚ùå **Memory overhead** due to extra objects

### **Modern Approach (Java 8+ with Lambda):**
```java
@FunctionalInterface
interface Greeting {
    public void sayHello(String name);
}

public class ModernExample {
    public static void main(String[] args) {
        // Lambda expression - One liner!
        Greeting greeting = (name) -> System.out.println("Hello " + name + " (Lambda way)");
        greeting.sayHello("Raj");
        
        // Even more concise
        Greeting shortGreeting = name -> System.out.println("Hi " + name + "!");
        shortGreeting.sayHello("Priya");
        
        // Multi-line lambda
        Greeting detailedGreeting = (name) -> {
            System.out.println("=== Greeting ===");
            System.out.println("Hello " + name);
            System.out.println("Have a nice day!");
        };
        detailedGreeting.sayHello("Amit");
    }
}
```

**Benefits of Lambda Approach:**
- ‚úÖ **Less .class files** 
- ‚úÖ **Concise code**
- ‚úÖ **Better readability**
- ‚úÖ **Functional programming** support
- ‚úÖ **Less memory overhead**

## Real-World Examples üåç

### **Example 1: Calculator with Different Operations**
```java
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

public class CalculatorExample {
    public static void main(String[] args) {
        // Different operations using lambda
        MathOperation addition = (a, b) -> a + b;
        MathOperation subtraction = (a, b) -> a - b;
        MathOperation multiplication = (a, b) -> a * b;
        MathOperation division = (a, b) -> {
            if (b != 0) {
                return a / b;
            } else {
                System.out.println("Division by zero!");
                return 0;
            }
        };
        
        // Using the operations
        System.out.println("Addition: " + addition.operate(10, 5));        // 15
        System.out.println("Subtraction: " + subtraction.operate(10, 5));   // 5
        System.out.println("Multiplication: " + multiplication.operate(10, 5)); // 50
        System.out.println("Division: " + division.operate(10, 5));         // 2
        
        // Method to execute any operation
        executeOperation(addition, 20, 30, "Addition");
        executeOperation(multiplication, 7, 8, "Multiplication");
    }
    
    public static void executeOperation(MathOperation operation, int a, int b, String operationName) {
        int result = operation.operate(a, b);
        System.out.println(operationName + " of " + a + " and " + b + " = " + result);
    }
}
```

**Output:**
```
Addition: 15
Subtraction: 5
Multiplication: 50
Division: 2
Addition of 20 and 30 = 50
Multiplication of 7 and 8 = 56
```

### **Example 2: String Processing**
```java
@FunctionalInterface
interface StringProcessor {
    String process(String input);
}

public class StringProcessingExample {
    public static void main(String[] args) {
        String text = "hello world java programming";
        
        // Different string processing operations
        StringProcessor upperCase = str -> str.toUpperCase();
        StringProcessor reverse = str -> new StringBuilder(str).reverse().toString();
        StringProcessor removeSpaces = str -> str.replaceAll("\\s+", "");
        StringProcessor capitalize = str -> {
            String[] words = str.split(" ");
            StringBuilder result = new StringBuilder();
            for (String word : words) {
                if (word.length() > 0) {
                    result.append(Character.toUpperCase(word.charAt(0)))
                          .append(word.substring(1).toLowerCase())
                          .append(" ");
                }
            }
            return result.toString().trim();
        };
        
        // Apply different processors
        System.out.println("Original: " + text);
        System.out.println("Upper Case: " + upperCase.process(text));
        System.out.println("Reverse: " + reverse.process(text));
        System.out.println("Remove Spaces: " + removeSpaces.process(text));
        System.out.println("Capitalize: " + capitalize.process(text));
        
        // Chain processors
        String result = processString(text, upperCase);
        result = processString(result, removeSpaces);
        System.out.println("Chained (Upper + Remove Spaces): " + result);
    }
    
    public static String processString(String input, StringProcessor processor) {
        return processor.process(input);
    }
}
```

### **Example 3: Event Handling System**
```java
@FunctionalInterface
interface EventHandler<T> {
    void handle(T event);
}

class LoginEvent {
    private String username;
    private boolean successful;
    
    public LoginEvent(String username, boolean successful) {
        this.username = username;
        this.successful = successful;
    }
    
    public String getUsername() { return username; }
    public boolean isSuccessful() { return successful; }
}

public class EventHandlingExample {
    public static void main(String[] args) {
        // Different event handlers using lambda
        EventHandler<LoginEvent> successHandler = (event) -> {
            if (event.isSuccessful()) {
                System.out.println("‚úÖ Login successful for: " + event.getUsername());
                System.out.println("Redirecting to dashboard...");
            }
        };
        
        EventHandler<LoginEvent> failureHandler = (event) -> {
            if (!event.isSuccessful()) {
                System.out.println("‚ùå Login failed for: " + event.getUsername());
                System.out.println("Please check credentials.");
            }
        };
        
        EventHandler<LoginEvent> auditHandler = (event) -> {
            System.out.println("üìù Audit Log: " + event.getUsername() + 
                             " login attempt at " + java.time.LocalDateTime.now());
        };
        
        // Simulate login events
        LoginEvent successfulLogin = new LoginEvent("john_doe", true);
        LoginEvent failedLogin = new LoginEvent("hacker123", false);
        
        // Handle events
        handleLoginEvent(successfulLogin, successHandler, auditHandler);
        System.out.println();
        handleLoginEvent(failedLogin, failureHandler, auditHandler);
    }
    
    @SafeVarargs
    public static void handleLoginEvent(LoginEvent event, EventHandler<LoginEvent>... handlers) {
        for (EventHandler<LoginEvent> handler : handlers) {
            handler.handle(event);
        }
    }
}
```

## Functional Interface Inheritance üß¨

### **Inheritance Rules:**
```java
@FunctionalInterface
interface Parent {
    void parentMethod();
}

// Child interface is also functional if it doesn't add new abstract methods
@FunctionalInterface
interface Child extends Parent {
    // No new abstract methods - Still functional!
    
    // Default and static methods are allowed
    default void childHelper() {
        System.out.println("Child helper method");
    }
    
    static void childUtility() {
        System.out.println("Child utility method");
    }
}

// This would make it non-functional
interface NotFunctionalChild extends Parent {
    void childMethod();  // ‚ùå Second abstract method - Not functional anymore!
}

public class InheritanceExample {
    public static void main(String[] args) {
        // Child interface ka lambda
        Child child = () -> System.out.println("Implementing parent method through child");
        child.parentMethod();
        child.childHelper();
        Child.childUtility();
    }
}
```

### **Object Class Methods:**
```java
@FunctionalInterface
interface MyInterface {
    void myMethod();  // Single abstract method
    
    // Object class methods don't count as abstract methods
    boolean equals(Object obj);     // ‚úÖ Allowed - from Object class
    int hashCode();                 // ‚úÖ Allowed - from Object class
    String toString();              // ‚úÖ Allowed - from Object class
}
```

## Lambda Expression Syntax üéØ

### **Basic Syntax:**
```java
// Parameter list -> Method body
(parameters) -> { method body }

// Single parameter (parentheses optional)
parameter -> { method body }

// No parameters
() -> { method body }

// Single expression (braces optional)
(parameters) -> expression
```

### **Different Lambda Variations:**
```java
@FunctionalInterface
interface TestInterface {
    void test(String message);
}

public class LambdaSyntaxExample {
    public static void main(String[] args) {
        // 1. Full syntax
        TestInterface t1 = (String message) -> {
            System.out.println("Full syntax: " + message);
        };
        
        // 2. Type inference (compiler guesses parameter type)
        TestInterface t2 = (message) -> {
            System.out.println("Type inference: " + message);
        };
        
        // 3. Single parameter (parentheses optional)
        TestInterface t3 = message -> {
            System.out.println("Single parameter: " + message);
        };
        
        // 4. Single expression (braces optional)
        TestInterface t4 = message -> System.out.println("Single expression: " + message);
        
        // Use them
        t1.test("Hello");
        t2.test("World");
        t3.test("Java");
        t4.test("Lambda");
    }
}
```

## Common Built-in Functional Interfaces (Java 8+) üìö

### **java.util.function Package:**

#### **1. Predicate<T> - Boolean Testing**
```java
import java.util.function.Predicate;
import java.util.Arrays;
import java.util.List;

public class PredicateExample {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        
        // Different predicates
        Predicate<Integer> isEven = num -> num % 2 == 0;
        Predicate<Integer> isGreaterThan5 = num -> num > 5;
        Predicate<Integer> isPositive = num -> num > 0;
        
        // Filter and display
        System.out.println("Even numbers:");
        numbers.stream().filter(isEven).forEach(System.out::println);
        
        System.out.println("Numbers greater than 5:");
        numbers.stream().filter(isGreaterThan5).forEach(System.out::println);
        
        // Combine predicates
        Predicate<Integer> evenAndGreaterThan5 = isEven.and(isGreaterThan5);
        System.out.println("Even numbers greater than 5:");
        numbers.stream().filter(evenAndGreaterThan5).forEach(System.out::println);
    }
}
```

#### **2. Function<T,R> - Transformation**
```java
import java.util.function.Function;
import java.util.Arrays;
import java.util.List;

public class FunctionExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("john", "jane", "bob", "alice");
        
        // Different functions
        Function<String, String> toUpperCase = str -> str.toUpperCase();
        Function<String, Integer> getLength = str -> str.length();
        Function<String, String> addGreeting = name -> "Hello, " + name + "!";
        
        // Transform and display
        System.out.println("Uppercase names:");
        names.stream().map(toUpperCase).forEach(System.out::println);
        
        System.out.println("Name lengths:");
        names.stream().map(getLength).forEach(System.out::println);
        
        System.out.println("With greetings:");
        names.stream().map(addGreeting).forEach(System.out::println);
        
        // Chain functions
        Function<String, String> upperCaseWithGreeting = addGreeting.andThen(toUpperCase);
        System.out.println("Chained transformation:");
        names.stream().map(upperCaseWithGreeting).forEach(System.out::println);
    }
}
```

#### **3. Consumer<T> - Action without Return**
```java
import java.util.function.Consumer;
import java.util.Arrays;
import java.util.List;

public class ConsumerExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Ram", "Shyam", "Gita", "Sita");
        
        // Different consumers
        Consumer<String> printName = name -> System.out.println("Name: " + name);
        Consumer<String> printLength = name -> System.out.println("Length: " + name.length());
        Consumer<String> printUpperCase = name -> System.out.println("Upper: " + name.toUpperCase());
        
        // Use consumers
        System.out.println("Using individual consumers:");
        names.forEach(printName);
        
        // Chain consumers
        Consumer<String> combinedConsumer = printName.andThen(printLength).andThen(printUpperCase);
        System.out.println("\nUsing chained consumers:");
        names.forEach(combinedConsumer);
    }
}
```

#### **4. Supplier<T> - Value Provider**
```java
import java.util.function.Supplier;
import java.time.LocalDateTime;
import java.util.Random;

public class SupplierExample {
    public static void main(String[] args) {
        // Different suppliers
        Supplier<String> currentTime = () -> LocalDateTime.now().toString();
        Supplier<Integer> randomNumber = () -> new Random().nextInt(100);
        Supplier<String> greeting = () -> "Hello from Supplier!";
        
        // Use suppliers
        System.out.println("Current time: " + currentTime.get());
        System.out.println("Random number: " + randomNumber.get());
        System.out.println("Greeting: " + greeting.get());
        
        // Lazy evaluation example
        System.out.println("Generating 5 random numbers:");
        for (int i = 0; i < 5; i++) {
            System.out.println((i + 1) + ": " + randomNumber.get());
        }
    }
}
```

## Common Mistakes & Best Practices ‚ö†Ô∏è

### **Common Mistakes:**

#### **1. Multiple Abstract Methods:**
```java
// ‚ùå Wrong
@FunctionalInterface  // This will cause compile error
interface WrongInterface {
    void method1();
    void method2();  // Second abstract method - Invalid!
}
```

#### **2. No Abstract Methods:**
```java
// ‚ùå Wrong
@FunctionalInterface  // This will cause compile error
interface WrongInterface2 {
    default void defaultMethod() { }
    static void staticMethod() { }
    // No abstract method - Invalid!
}
```

#### **3. Overriding Object Methods:**
```java
// ‚ùå This is fine, but confusing
@FunctionalInterface
interface ConfusingInterface {
    void myMethod();
    
    // These don't count as abstract methods (from Object class)
    boolean equals(Object obj);
    int hashCode();
}
```

### **Best Practices:**

#### **1. Always Use @FunctionalInterface Annotation:**
```java
// ‚úÖ Good practice
@FunctionalInterface
interface MyInterface {
    void doSomething();
}
```

#### **2. Clear Method Names:**
```java
// ‚úÖ Clear and descriptive
@FunctionalInterface
interface DataValidator {
    boolean isValid(String data);
}

@FunctionalInterface
interface MessageProcessor {
    String processMessage(String message);
}
```

#### **3. Use Generic Types When Appropriate:**
```java
// ‚úÖ Flexible with generics
@FunctionalInterface
interface Converter<T, R> {
    R convert(T input);
}

// Usage
Converter<String, Integer> stringToInt = Integer::parseInt;
Converter<Integer, String> intToString = String::valueOf;
```

#### **4. Provide Default Methods for Common Operations:**
```java
@FunctionalInterface
interface Calculator {
    double calculate(double a, double b);
    
    // Useful default methods
    default double calculateAndRound(double a, double b) {
        return Math.round(calculate(a, b));
    }
    
    default double calculateSquare(double a) {
        return calculate(a, a);
    }
}
```

## Interview Questions & Answers üí™

### **Q1: What is a Functional Interface?**
**Answer**: Functional Interface ek aisi interface hai jo exactly one abstract method contain karti hai. Isme koi bhi number ke default aur static methods ho sakte hain. Yeh Lambda expressions ke saath use hoti hai functional programming enable karne ke liye.

### **Q2: @FunctionalInterface annotation compulsory hai kya?**
**Answer**: Nahi! @FunctionalInterface annotation optional hai. But use karna chahiye because:
- Compile-time checking milti hai
- Code documentation improve hota hai  
- Accidental mistakes prevent hote hain

### **Q3: Can a functional interface extend another interface?**
```java
@FunctionalInterface
interface Parent {
    void parentMethod();
}

@FunctionalInterface  
interface Child extends Parent {
    // Child is functional if it doesn't add new abstract methods
    default void childHelper() {
        System.out.println("Helper method");
    }
}
```
**Answer**: Haan! Child interface functional reh sakti hai agar woh koi naya abstract method add nahi karti.

### **Q4: Object class methods count karte hain kya?**
```java
@FunctionalInterface
interface MyInterface {
    void myMethod();  // This counts
    
    // These don't count (inherited from Object)
    boolean equals(Object obj);
    int hashCode();
    String toString();
}
```
**Answer**: Nahi! Object class ke methods (equals, hashCode, toString) count nahi karte abstract methods mein.

### **Q5: Can we have multiple default methods?**
```java
@FunctionalInterface
interface MyInterface {
    void abstractMethod();  // Only one abstract method
    
    // Multiple default methods allowed
    default void helper1() { }
    default void helper2() { }
    default void helper3() { }
}
```
**Answer**: Haan! Kitne bhi default methods rakh sakte hain.

## Real Project Usage Examples üèóÔ∏è

### **Example 1: Custom Validation Framework**
```java
@FunctionalInterface
interface Validator<T> {
    ValidationResult validate(T value);
}

class ValidationResult {
    private boolean valid;
    private String message;
    
    public ValidationResult(boolean valid, String message) {
        this.valid = valid;
        this.message = message;
    }
    
    public boolean isValid() { return valid; }
    public String getMessage() { return message; }
}

class User {
    private String name;
    private String email;
    private int age;
    
    // Constructor and getters
    public User(String name, String email, int age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
    
    public String getName() { return name; }
    public String getEmail() { return email; }
    public int getAge() { return age; }
}

public class ValidationFramework {
    public static void main(String[] args) {
        // Different validators using lambda
        Validator<String> emailValidator = email -> {
            if (email != null && email.contains("@") && email.contains(".")) {
                return new ValidationResult(true, "Valid email");
            }
            return new ValidationResult(false, "Invalid email format");
        };
        
        Validator<String> nameValidator = name -> {
            if (name != null && name.trim().length() >= 2) {
                return new ValidationResult(true, "Valid name");
            }
            return new ValidationResult(false, "Name must be at least 2 characters");
        };
        
        Validator<Integer> ageValidator = age -> {
            if (age >= 18 && age <= 100) {
                return new ValidationResult(true, "Valid age");
            }
            return new ValidationResult(false, "Age must be between 18 and 100");
        };
        
        // Test user
        User user = new User("John Doe", "john@email.com", 25);
        
        // Validate user
        System.out.println("=== User Validation ===");
        validateAndPrint(user.getName(), nameValidator, "Name");
        validateAndPrint(user.getEmail(), emailValidator, "Email");
        validateAndPrint(user.getAge(), ageValidator, "Age");
    }
    
    public static <T> void validateAndPrint(T value, Validator<T> validator, String fieldName) {
        ValidationResult result = validator.validate(value);
        System.out.println(fieldName + ": " + (result.isValid() ? "‚úÖ" : "‚ùå") + " " + result.getMessage());
    }
}
```

### **Example 2: Custom Sort & Filter Framework**
```java
@FunctionalInterface
interface Sorter<T> {
    int compare(T obj1, T obj2);
}

@FunctionalInterface
interface Filter<T> {
    boolean test(T obj);
}

class Product {
    private String name;
    private double price;
    private String category;
    
    public Product(String name, double price, String category) {
        this.name = name;
        this.price = price;
        this.category = category;
    }
    
    // Getters
    public String getName() { return name; }
    public double getPrice() { return price; }
    public String getCategory() { return category; }
    
    @Override
    public String toString() {
        return String.format("%s (%.2f) - %s", name, price, category);
    }
}

public class ProductManager {
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("Laptop", 50000.0, "Electronics"),
            new Product("Phone", 20000.0, "Electronics"),
            new Product("Book", 500.0, "Education"),
            new Product("Tablet", 15000.0, "Electronics"),
            new Product("Pen", 50.0, "Education")
        );
        
        // Different sorters
        Sorter<Product> priceAscending = (p1, p2) -> Double.compare(p1.getPrice(), p2.getPrice());
        Sorter<Product> priceDescending = (p1, p2) -> Double.compare(p2.getPrice(), p1.getPrice());
        Sorter<Product> nameAlphabetical = (p1, p2) -> p1.getName().compareTo(p2.getName());
        
        // Different filters
        Filter<Product> electronicsOnly = product -> "Electronics".equals(product.getCategory());
        Filter<Product> expensiveItems = product -> product.getPrice() > 1000.0;
        Filter<Product> cheapItems = product -> product.getPrice() <= 1000.0;
        
        System.out.println("=== All Products ===");
        products.forEach(System.out::println);
        
        System.out.println("\n=== Electronics Only (Price Descending) ===");
        filterAndSort(products, electronicsOnly, priceDescending).forEach(System.out::println);
        
        System.out.println("\n=== Expensive Items (Name Alphabetical) ===");
        filterAndSort(products, expensiveItems, nameAlphabetical).forEach(System.out::println);
        
        System.out.println("\n=== Cheap Items (Price Ascending) ===");
        filterAndSort(products, cheapItems, priceAscending).forEach(System.out::println);
    }
    
    public static <T> List<T> filterAndSort(List<T> items, Filter<T> filter, Sorter<T> sorter) {
        return items.stream()
                   .filter(filter::test)
                   .sorted(sorter::compare)
                   .collect(Collectors.toList());
    }
}
```

## Summary - Quick Recap! üìù

### **Key Points to Remember:**

1. **üéØ Definition**: Exactly 1 abstract method + any number of default/static methods
2. **üè∑Ô∏è Annotation**: @FunctionalInterface optional but recommended
3. **üöÄ Purpose**: Lambda expressions enable karne ke liye
4. **üîÑ Benefits**: Concise code, functional programming, less boilerplate
5. **üì¶ Built-in**: Runnable, Callable, Comparable, Predicate, Function, Consumer, Supplier
6. **üß¨ Inheritance**: Child interface functional reh sakti hai agar new abstract method add nahi kare
7. **üé≠ Lambda**: (parameters) -> { method body } syntax
8. **‚ö° Performance**: Less .class files, better memory usage

### **Functional Interface Checklist:**
- ‚úÖ Exactly one abstract method
- ‚úÖ Any number of default methods
- ‚úÖ Any number of static methods
- ‚úÖ Can inherit Object class methods (equals, hashCode, toString)
- ‚úÖ @FunctionalInterface annotation for safety
- ‚úÖ Can be used with lambda expressions

### **Common Functional Interfaces Quick Reference:**

| **Interface** | **Method** | **Purpose** | **Example** |
|-------------|-----------|------------|-------------|
| **Runnable** | `void run()` | Execute code | `() -> System.out.println("Hello")` |
| **Callable<T>** | `T call()` | Return result | `() -> "Result"` |
| **Predicate<T>** | `boolean test(T t)` | Test condition | `x -> x > 0` |
| **Function<T,R>** | `R apply(T t)` | Transform data | `x -> x.toString()` |
| **Consumer<T>** | `void accept(T t)` | Process data | `x -> System.out.println(x)` |
| **Supplier<T>** | `T get()` | Provide data | `() -> new Date()` |

## Advanced Concepts üöÄ

### **Method References (Alternative to Lambda):**
```java
@FunctionalInterface
interface StringProcessor {
    String process(String input);
}

public class MethodReferenceExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("john", "jane", "bob");
        
        // Lambda expression
        StringProcessor toUpperLambda = str -> str.toUpperCase();
        
        // Method reference (cleaner syntax)
        StringProcessor toUpperMethodRef = String::toUpperCase;
        
        // Using both approaches
        System.out.println("Lambda: " + toUpperLambda.process("hello"));
        System.out.println("Method Reference: " + toUpperMethodRef.process("world"));
        
        // Different types of method references:
        
        // 1. Static method reference
        Function<String, Integer> parseInt = Integer::parseInt;
        System.out.println("Parsed: " + parseInt.apply("123"));
        
        // 2. Instance method reference
        String text = "Hello World";
        Supplier<String> getUpperCase = text::toUpperCase;
        System.out.println("Instance method: " + getUpperCase.get());
        
        // 3. Constructor reference
        Supplier<StringBuilder> stringBuilderSupplier = StringBuilder::new;
        StringBuilder sb = stringBuilderSupplier.get();
        sb.append("Created using constructor reference");
        System.out.println(sb.toString());
    }
}
```

### **Functional Interface with Generics:**
```java
@FunctionalInterface
interface Processor<T, R> {
    R process(T input);
    
    // Default method with generic support
    default <U> Processor<T, U> andThen(Function<R, U> after) {
        return input -> after.apply(this.process(input));
    }
}

@FunctionalInterface
interface BiProcessor<T, U, R> {
    R process(T first, U second);
}

public class GenericFunctionalInterface {
    public static void main(String[] args) {
        // Single input processor
        Processor<String, Integer> stringLength = str -> str.length();
        Processor<Integer, String> intToString = num -> "Number: " + num;
        
        // Chain processors
        Processor<String, String> chainedProcessor = stringLength.andThen(intToString::process);
        
        System.out.println(chainedProcessor.process("Hello World")); // Number: 11
        
        // Two input processor
        BiProcessor<Integer, Integer, String> calculator = (a, b) -> {
            int sum = a + b;
            return String.format("%d + %d = %d", a, b, sum);
        };
        
        System.out.println(calculator.process(10, 20)); // 10 + 20 = 30
    }
}
```

### **Functional Interface in Collections (Streams):**
```java
import java.util.*;
import java.util.stream.Collectors;

class Employee {
    private String name;
    private String department;
    private double salary;
    
    public Employee(String name, String department, double salary) {
        this.name = name;
        this.department = department;
        this.salary = salary;
    }
    
    // Getters
    public String getName() { return name; }
    public String getDepartment() { return department; }
    public double getSalary() { return salary; }
    
    @Override
    public String toString() {
        return String.format("%s (%s) - ‚Çπ%.0f", name, department, salary);
    }
}

public class StreamFunctionalInterface {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Raj", "IT", 75000),
            new Employee("Priya", "HR", 60000),
            new Employee("Amit", "IT", 85000),
            new Employee("Sunita", "Finance", 70000),
            new Employee("Rohit", "IT", 65000)
        );
        
        System.out.println("=== All Employees ===");
        employees.forEach(System.out::println);
        
        // Using Predicate for filtering
        System.out.println("\n=== IT Department Only ===");
        employees.stream()
                .filter(emp -> "IT".equals(emp.getDepartment()))  // Predicate
                .forEach(System.out::println);
        
        // Using Function for transformation
        System.out.println("\n=== Employee Names (Uppercase) ===");
        employees.stream()
                .map(emp -> emp.getName().toUpperCase())  // Function<Employee, String>
                .forEach(System.out::println);
        
        // Using Consumer for processing
        System.out.println("\n=== Salary Analysis ===");
        employees.stream()
                .forEach(emp -> {  // Consumer<Employee>
                    if (emp.getSalary() > 70000) {
                        System.out.println("üí∞ High Salary: " + emp);
                    } else {
                        System.out.println("üíº Regular Salary: " + emp);
                    }
                });
        
        // Complex operations with multiple functional interfaces
        System.out.println("\n=== Department-wise Average Salary ===");
        employees.stream()
                .collect(Collectors.groupingBy(
                    Employee::getDepartment,  // Function for grouping
                    Collectors.averagingDouble(Employee::getSalary)  // Function for averaging
                ))
                .forEach((dept, avgSalary) ->   // BiConsumer
                    System.out.printf("%s: ‚Çπ%.0f%n", dept, avgSalary)
                );
    }
}
```

## Exception Handling in Lambda Expressions ‚ö†Ô∏è

### **Problem with Checked Exceptions:**
```java
import java.io.*;
import java.util.*;

// This won't compile directly
public class LambdaExceptionProblem {
    public static void main(String[] args) {
        List<String> files = Arrays.asList("file1.txt", "file2.txt", "file3.txt");
        
        // ‚ùå This won't compile - checked exception in lambda
        /*
        files.forEach(fileName -> {
            FileReader reader = new FileReader(fileName);  // IOException
            // Process file
        });
        */
        
        // Solution 1: Handle exception inside lambda
        files.forEach(fileName -> {
            try {
                FileReader reader = new FileReader(fileName);
                System.out.println("Reading: " + fileName);
                reader.close();
            } catch (IOException e) {
                System.err.println("Error reading " + fileName + ": " + e.getMessage());
            }
        });
    }
}
```

### **Custom Functional Interface for Exception Handling:**
```java
@FunctionalInterface
interface ThrowingConsumer<T> {
    void accept(T t) throws Exception;
    
    // Helper method to wrap checked exceptions
    static <T> Consumer<T> unchecked(ThrowingConsumer<T> consumer) {
        return item -> {
            try {
                consumer.accept(item);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

@FunctionalInterface
interface ThrowingFunction<T, R> {
    R apply(T t) throws Exception;
    
    static <T, R> Function<T, R> unchecked(ThrowingFunction<T, R> function) {
        return item -> {
            try {
                return function.apply(item);
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        };
    }
}

public class ExceptionHandlingExample {
    public static void main(String[] args) {
        List<String> numbers = Arrays.asList("1", "2", "invalid", "4", "5");
        
        // Using custom functional interface
        System.out.println("=== Processing Numbers ===");
        numbers.forEach(ThrowingConsumer.unchecked(num -> {
            int value = Integer.parseInt(num);  // Can throw NumberFormatException
            System.out.println("Processed: " + value);
        }));
        
        // Alternative: Handle exceptions gracefully
        System.out.println("\n=== Safe Processing ===");
        numbers.stream()
               .map(num -> {
                   try {
                       return Optional.of(Integer.parseInt(num));
                   } catch (NumberFormatException e) {
                       System.err.println("Invalid number: " + num);
                       return Optional.<Integer>empty();
                   }
               })
               .filter(Optional::isPresent)
               .map(Optional::get)
               .forEach(value -> System.out.println("Safely processed: " + value));
    }
}
```

## Performance Considerations üöÄ

### **Lambda vs Anonymous Class Performance:**
```java
@FunctionalInterface
interface Task {
    void execute();
}

public class PerformanceComparison {
    public static void main(String[] args) {
        // Warm up JVM
        for (int i = 0; i < 10000; i++) {
            testAnonymousClass();
            testLambda();
        }
        
        // Measure performance
        int iterations = 1_000_000;
        
        // Anonymous class
        long startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            testAnonymousClass();
        }
        long anonymousTime = System.nanoTime() - startTime;
        
        // Lambda expression
        startTime = System.nanoTime();
        for (int i = 0; i < iterations; i++) {
            testLambda();
        }
        long lambdaTime = System.nanoTime() - startTime;
        
        System.out.println("Anonymous class time: " + (anonymousTime / 1_000_000) + " ms");
        System.out.println("Lambda expression time: " + (lambdaTime / 1_000_000) + " ms");
        System.out.println("Performance improvement: " + 
                          ((double) anonymousTime / lambdaTime) + "x");
    }
    
    private static void testAnonymousClass() {
        Task task = new Task() {
            @Override
            public void execute() {
                // Some work
                int result = 2 + 2;
            }
        };
        task.execute();
    }
    
    private static void testLambda() {
        Task task = () -> {
            // Some work
            int result = 2 + 2;
        };
        task.execute();
    }
}
```

### **Memory Usage Analysis:**
```java
import java.lang.management.ManagementFactory;
import java.lang.management.MemoryMXBean;

public class MemoryUsageExample {
    public static void main(String[] args) {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        
        // Measure memory before creating objects
        long beforeMemory = memoryBean.getHeapMemoryUsage().getUsed();
        
        // Create many lambda expressions
        List<Runnable> lambdas = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            final int index = i;
            lambdas.add(() -> System.out.println("Lambda " + index));
        }
        
        long afterLambdaMemory = memoryBean.getHeapMemoryUsage().getUsed();
        
        // Create many anonymous classes
        List<Runnable> anonymousClasses = new ArrayList<>();
        for (int i = 0; i < 10000; i++) {
            final int index = i;
            anonymousClasses.add(new Runnable() {
                @Override
                public void run() {
                    System.out.println("Anonymous " + index);
                }
            });
        }
        
        long afterAnonymousMemory = memoryBean.getHeapMemoryUsage().getUsed();
        
        System.out.println("Memory used by lambdas: " + 
                          ((afterLambdaMemory - beforeMemory) / 1024) + " KB");
        System.out.println("Memory used by anonymous classes: " + 
                          ((afterAnonymousMemory - afterLambdaMemory) / 1024) + " KB");
    }
}
```

## Testing Functional Interfaces üß™

### **Unit Testing with Mockito:**
```java
import org.junit.Test;
import org.mockito.Mockito;
import static org.junit.Assert.*;

@FunctionalInterface
interface DataProcessor {
    String processData(String input);
}

class DataService {
    private DataProcessor processor;
    
    public DataService(DataProcessor processor) {
        this.processor = processor;
    }
    
    public String handleRequest(String request) {
        if (request == null || request.trim().isEmpty()) {
            return "Invalid request";
        }
        return processor.processData(request);
    }
}

public class FunctionalInterfaceTest {
    
    @Test
    public void testDataServiceWithLambda() {
        // Test with lambda expression
        DataProcessor upperCaseProcessor = input -> input.toUpperCase();
        DataService service = new DataService(upperCaseProcessor);
        
        String result = service.handleRequest("hello world");
        assertEquals("HELLO WORLD", result);
    }
    
    @Test
    public void testDataServiceWithMock() {
        // Test with mock
        DataProcessor mockProcessor = Mockito.mock(DataProcessor.class);
        Mockito.when(mockProcessor.processData("test")).thenReturn("processed");
        
        DataService service = new DataService(mockProcessor);
        String result = service.handleRequest("test");
        
        assertEquals("processed", result);
        Mockito.verify(mockProcessor).processData("test");
    }
    
    @Test
    public void testDataServiceWithDifferentProcessors() {
        // Test with multiple processors
        DataProcessor[] processors = {
            input -> input.toLowerCase(),
            input -> input.replaceAll("\\s+", "_"),
            input -> "PREFIX_" + input + "_SUFFIX"
        };
        
        String[] expectedResults = {
            "hello world",
            "hello_world", 
            "PREFIX_Hello World_SUFFIX"
        };
        
        for (int i = 0; i < processors.length; i++) {
            DataService service = new DataService(processors[i]);
            String result = service.handleRequest("Hello World");
            assertEquals(expectedResults[i], result);
        }
    }
}
```

## Comparison with Other Languages üåç

### **Java vs JavaScript Functions:**
```java
// Java - Functional Interface required
@FunctionalInterface
interface MathOperation {
    int operate(int a, int b);
}

public class JavaFunctional {
    public static void main(String[] args) {
        MathOperation add = (a, b) -> a + b;
        System.out.println(add.operate(5, 3)); // 8
    }
}

/*
JavaScript equivalent:
const add = (a, b) => a + b;
console.log(add(5, 3)); // 8

Python equivalent:
add = lambda a, b: a + b
print(add(5, 3)) # 8
*/
```

## Migration from Old Code to Functional Interface üîÑ

### **Before Java 8 (Traditional Approach):**
```java
// Old way - Before Java 8
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;

public class OldStyleExample {
    public static void main(String[] args) {
        JButton button = new JButton("Click Me");
        
        // Anonymous class approach
        button.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println("Button clicked!");
            }
        });
        
        // Separate class approach
        button.addActionListener(new MyActionListener());
        
        // Thread creation old way
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread running old way");
            }
        });
        thread.start();
    }
}

class MyActionListener implements ActionListener {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Button clicked via separate class!");
    }
}
```

### **After Java 8 (Modern Approach):**
```java
// Modern way - Java 8+
import java.awt.event.ActionEvent;
import javax.swing.*;

public class ModernStyleExample {
    public static void main(String[] args) {
        JButton button = new JButton("Click Me");
        
        // Lambda expression approach
        button.addActionListener(e -> System.out.println("Button clicked with lambda!"));
        
        // Method reference approach
        button.addActionListener(ModernStyleExample::handleButtonClick);
        
        // Thread creation modern way
        Thread thread = new Thread(() -> System.out.println("Thread running with lambda"));
        thread.start();
        
        // Multiple listeners easily
        button.addActionListener(e -> System.out.println("First listener"));
        button.addActionListener(e -> System.out.println("Second listener"));
        button.addActionListener(e -> {
            System.out.println("Third listener with multiple lines");
            System.out.println("Can do complex operations here");
        });
    }
    
    private static void handleButtonClick(ActionEvent e) {
        System.out.println("Handled by method reference");
    }
}
```

## Final Summary & Best Practices üéØ

### **Quick Decision Tree:**

```
Need to pass behavior as parameter?
‚îú‚îÄ YES ‚Üí Use Functional Interface
‚îÇ   ‚îú‚îÄ Single method needed? ‚Üí Use existing (Predicate, Function, etc.)
‚îÇ   ‚îî‚îÄ Complex behavior? ‚Üí Create custom @FunctionalInterface
‚îî‚îÄ NO ‚Üí Use regular interface/class
```

### **Memory Tricks for Interview:**

1. **"One Abstract, Many Helpers"** - 1 abstract + N default/static methods
2. **"SAM-urai Warrior"** - Single Abstract Method warrior fights complexity
3. **"Lambda's Best Friend"** - Functional Interface + Lambda = Perfect pair
4. **"@FunctionalInterface Guard"** - Annotation protects from mistakes

### **Common Use Cases:**
- ‚úÖ **Event Handling** (Button clicks, etc.)
- ‚úÖ **Stream Operations** (filter, map, reduce)
- ‚úÖ **Callback Functions** (Success/failure handling)
- ‚úÖ **Strategy Pattern** (Different algorithms)
- ‚úÖ **Template Method** (Customizable steps)
- ‚úÖ **Observer Pattern** (Event notifications)

### **When NOT to Use:**
- ‚ùå Multiple abstract methods needed
- ‚ùå Complex state management required  
- ‚ùå Heavy inheritance hierarchy needed
- ‚ùå Mutable shared state access

### **Final Checklist for Creating Functional Interface:**
1. ‚úÖ Exactly one abstract method
2. ‚úÖ Add @FunctionalInterface annotation
3. ‚úÖ Use meaningful method names
4. ‚úÖ Consider generics for flexibility
5. ‚úÖ Add useful default methods if needed
6. ‚úÖ Document the purpose clearly
7. ‚úÖ Test with lambda expressions
8. ‚úÖ Consider method references

Practice these concepts ‡§î‡§∞ ‡§§‡•Å‡§Æ Functional Interfaces ‡§ï‡•á master ‡§¨‡§® ‡§ú‡§æ‡§ì‡§ó‡•á! üöÄüí™

---
*Happy Coding with Functional Programming! üéâüî•*
