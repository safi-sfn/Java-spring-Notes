# Consumer Functional Interface - Complete Study Notes 📚

## Consumer Kya Hai Bhai? 🤔

**Simple Definition**: Consumer ek predefined functional interface hai jo kuch **consume** karta hai but kuch **return nahi** karta!

**Real Life Analogy**: 
- जैसे आप pizza **खाते (consume)** हो but कुछ **वापस नही करते** - यही Consumer है! 🍕
- TV **देखते (consume)** हो but कुछ **return नही करते** 📺
- Song **सुनते (consume)** हो but कुछ **वापस नही मिलता** 🎵

**Technical Definition**: Consumer takes input, performs some operation, but doesn't return anything (void).

## Consumer Interface Structure 🏗️

```java
@FunctionalInterface
public interface Consumer<T> {
    // Abstract method - must implement
    public void accept(T t);
    
    // Default method - for chaining
    default Consumer<T> andThen(Consumer<? super T> after) {
        Objects.requireNonNull(after);
        return (T t) -> { accept(t); after.accept(t); };
    }
}
```

**Key Points:**
- 📦 Package: `java.util.function`
- 📝 Type: Functional Interface (only one abstract method)
- 📥 Input: Takes one parameter of type T
- 📤 Output: Returns nothing (void)
- 🔗 Chaining: Supports `andThen()` method

## Basic Consumer Example - Names Print Karna! 📝

```java
import java.util.function.Consumer;

public class BasicConsumerExample {
    public static void main(String[] args) {
        // Method 1: Lambda Expression
        Consumer<String> nameConsumer = name -> System.out.println("Hello, " + name + "!");
        
        nameConsumer.accept("Peter");    // Hello, Peter!
        nameConsumer.accept("Parker");   // Hello, Parker!
        nameConsumer.accept("William");  // Hello, William!
        
        // Method 2: Method Reference
        Consumer<String> simplePrint = System.out::println;
        
        simplePrint.accept("Smith");     // Smith
        simplePrint.accept("John");      // John
        simplePrint.accept("Robert");    // Robert
        
        // Method 3: Anonymous Class (Old way)
        Consumer<String> oldWayConsumer = new Consumer<String>() {
            @Override
            public void accept(String name) {
                System.out.println("Old way: " + name);
            }
        };
        
        oldWayConsumer.accept("Legacy");  // Old way: Legacy
    }
}
```

**Output:**
```
Hello, Peter!
Hello, Parker!
Hello, William!
Smith
John
Robert
Old way: Legacy
```

## Student Management System - Real World Example! 🎓

```java
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.Arrays;
import java.util.List;

class Student {
    String name;
    int marks;
    String subject;
    
    public Student(String name, int marks, String subject) {
        this.name = name;
        this.marks = marks;
        this.subject = subject;
    }
    
    @Override
    public String toString() {
        return "Student{name='" + name + "', marks=" + marks + ", subject='" + subject + "'}";
    }
}

public class StudentManagementSystem {
    public static void main(String[] args) {
        // Function to calculate grade
        Function<Student, String> gradeCalculator = student -> {
            int marks = student.marks;
            if (marks >= 90) return "A+";
            else if (marks >= 80) return "A";
            else if (marks >= 70) return "B+";
            else if (marks >= 60) return "B";
            else if (marks >= 50) return "C";
            else if (marks >= 40) return "D";
            else return "F";
        };
        
        // Predicate to check if student passed
        Predicate<Student> isPassed = student -> student.marks >= 40;
        
        // Consumer to print student information
        Consumer<Student> studentPrinter = student -> {
            System.out.println("╔═══════════════════════════════╗");
            System.out.println("║        STUDENT DETAILS        ║");
            System.out.println("╠═══════════════════════════════╣");
            System.out.println("║ Name: " + String.format("%-20s", student.name) + "║");
            System.out.println("║ Subject: " + String.format("%-17s", student.subject) + "║");
            System.out.println("║ Marks: " + String.format("%-19d", student.marks) + "║");
            System.out.println("║ Grade: " + String.format("%-19s", gradeCalculator.apply(student)) + "║");
            System.out.println("║ Status: " + String.format("%-18s", isPassed.test(student) ? "PASSED ✅" : "FAILED ❌") + "║");
            System.out.println("╚═══════════════════════════════╝");
            System.out.println();
        };
        
        // Sample students
        List<Student> students = Arrays.asList(
            new Student("Raghav Kumar", 95, "Mathematics"),
            new Student("Priya Sharma", 88, "Physics"),
            new Student("Amit Singh", 72, "Chemistry"),
            new Student("Sneha Patel", 65, "Biology"),
            new Student("Rohit Verma", 45, "English"),
            new Student("Ananya Das", 38, "History"),
            new Student("Vikash Yadav", 82, "Computer Science")
        );
        
        System.out.println("🎓 STUDENT MANAGEMENT SYSTEM 🎓");
        System.out.println("═".repeat(50));
        System.out.println();
        
        // Print all students
        System.out.println("📋 ALL STUDENTS:");
        students.forEach(studentPrinter);
        
        // Print only passed students
        System.out.println("✅ PASSED STUDENTS ONLY:");
        students.stream()
                .filter(isPassed)
                .forEach(studentPrinter);
        
        // Print failed students
        System.out.println("❌ FAILED STUDENTS:");
        students.stream()
                .filter(student -> !isPassed.test(student))
                .forEach(studentPrinter);
    }
}
```

## Different Types of Consumers 🎭

### 1. **Simple String Consumer**
```java
Consumer<String> stringConsumer = str -> {
    System.out.println("Processing: " + str);
    System.out.println("Length: " + str.length());
    System.out.println("Uppercase: " + str.toUpperCase());
    System.out.println("---");
};

stringConsumer.accept("Java Programming");
```

### 2. **Number Processing Consumer**
```java
Consumer<Integer> numberProcessor = num -> {
    System.out.println("Number: " + num);
    System.out.println("Square: " + (num * num));
    System.out.println("Cube: " + (num * num * num));
    System.out.println("Even/Odd: " + (num % 2 == 0 ? "Even" : "Odd"));
    System.out.println("---");
};

numberProcessor.accept(5);
numberProcessor.accept(8);
```

### 3. **List Processing Consumer**
```java
Consumer<List<String>> listProcessor = list -> {
    System.out.println("📝 List Processing:");
    System.out.println("Total items: " + list.size());
    System.out.println("Items: " + list);
    
    System.out.println("Processed items:");
    list.forEach(item -> System.out.println("  ➤ " + item.toUpperCase()));
    System.out.println();
};

List<String> fruits = Arrays.asList("apple", "banana", "orange", "mango");
listProcessor.accept(fruits);
```

## Consumer Chaining - Power of andThen()! 🔗

```java
import java.util.function.Consumer;

class Movie {
    String name;
    String genre;
    double rating;
    
    public Movie(String name, String genre, double rating) {
        this.name = name;
        this.genre = genre;
        this.rating = rating;
    }
}

public class ConsumerChainingExample {
    public static void main(String[] args) {
        // Step 1: Announce movie
        Consumer<Movie> announcer = movie -> 
            System.out.println("🎬 " + movie.name + " (" + movie.genre + ") is releasing soon!");
        
        // Step 2: Show reviews
        Consumer<Movie> reviewer = movie -> {
            System.out.println("⭐ Rating: " + movie.rating + "/10");
            if (movie.rating >= 8.0) {
                System.out.println("🏆 Critics say: BLOCKBUSTER!");
            } else if (movie.rating >= 6.0) {
                System.out.println("👍 Critics say: Good movie!");
            } else {
                System.out.println("👎 Critics say: Average movie.");
            }
        };
        
        // Step 3: Box office prediction
        Consumer<Movie> boxOfficePredictor = movie -> {
            if (movie.rating >= 8.0) {
                System.out.println("💰 Box Office Prediction: 100+ Crores!");
            } else if (movie.rating >= 6.0) {
                System.out.println("💰 Box Office Prediction: 50-100 Crores");
            } else {
                System.out.println("💰 Box Office Prediction: Below 50 Crores");
            }
            System.out.println("═".repeat(50));
            System.out.println();
        };
        
        // Chain all consumers together
        Consumer<Movie> completeMovieReview = announcer
            .andThen(reviewer)
            .andThen(boxOfficePredictor);
        
        // Test movies
        Movie[] movies = {
            new Movie("RRR", "Action", 9.2),
            new Movie("Dangal", "Biography", 8.8),
            new Movie("3 Idiots", "Comedy", 9.0),
            new Movie("Student of the Year", "Drama", 5.2),
            new Movie("Bahubali 2", "Epic", 9.5)
        };
        
        System.out.println("🎭 MOVIE REVIEW SYSTEM 🎭");
        System.out.println("═".repeat(50));
        System.out.println();
        
        for (Movie movie : movies) {
            completeMovieReview.accept(movie);
        }
    }
}
```

## Practical Use Cases - Real World Applications! 🌍

### 1. **File Processing System**
```java
import java.util.function.Consumer;
import java.util.Arrays;
import java.util.List;

class FileInfo {
    String fileName;
    String fileType;
    double fileSizeInMB;
    
    public FileInfo(String fileName, String fileType, double fileSizeInMB) {
        this.fileName = fileName;
        this.fileType = fileType;
        this.fileSizeInMB = fileSizeInMB;
    }
}

public class FileProcessingSystem {
    public static void main(String[] args) {
        // Consumer for file validation
        Consumer<FileInfo> fileValidator = file -> {
            System.out.println("🔍 Validating: " + file.fileName);
            if (file.fileSizeInMB > 100) {
                System.out.println("⚠️  Warning: Large file size!");
            } else {
                System.out.println("✅ File size is acceptable");
            }
        };
        
        // Consumer for file processing
        Consumer<FileInfo> fileProcessor = file -> {
            System.out.println("⚙️  Processing: " + file.fileName);
            System.out.println("📁 Type: " + file.fileType);
            System.out.println("💾 Size: " + file.fileSizeInMB + " MB");
        };
        
        // Consumer for backup
        Consumer<FileInfo> fileBackup = file -> {
            System.out.println("💾 Creating backup for: " + file.fileName);
            System.out.println("✅ Backup completed successfully!");
            System.out.println("─".repeat(40));
            System.out.println();
        };
        
        // Chain all operations
        Consumer<FileInfo> completeFileOperation = fileValidator
            .andThen(fileProcessor)
            .andThen(fileBackup);
        
        List<FileInfo> files = Arrays.asList(
            new FileInfo("document.pdf", "PDF", 15.5),
            new FileInfo("video.mp4", "Video", 250.8),
            new FileInfo("image.jpg", "Image", 5.2),
            new FileInfo("presentation.pptx", "PowerPoint", 45.3)
        );
        
        System.out.println("📂 FILE PROCESSING SYSTEM 📂");
        System.out.println("═".repeat(50));
        System.out.println();
        
        files.forEach(completeFileOperation);
    }
}
```

### 2. **E-commerce Order Processing**
```java
import java.util.function.Consumer;
import java.util.Arrays;
import java.util.List;

class Order {
    String orderId;
    String customerName;
    String product;
    double amount;
    String status;
    
    public Order(String orderId, String customerName, String product, double amount) {
        this.orderId = orderId;
        this.customerName = customerName;
        this.product = product;
        this.amount = amount;
        this.status = "PENDING";
    }
}

public class ECommerceOrderProcessing {
    public static void main(String[] args) {
        // Consumer for order validation
        Consumer<Order> orderValidator = order -> {
            System.out.println("🔍 Validating Order: " + order.orderId);
            if (order.amount <= 0) {
                System.out.println("❌ Invalid amount!");
                order.status = "INVALID";
            } else {
                System.out.println("✅ Order validation successful");
                order.status = "VALIDATED";
            }
        };
        
        // Consumer for payment processing
        Consumer<Order> paymentProcessor = order -> {
            if ("VALIDATED".equals(order.status)) {
                System.out.println("💳 Processing payment for ₹" + order.amount);
                System.out.println("💰 Payment successful!");
                order.status = "PAID";
            }
        };
        
        // Consumer for inventory check
        Consumer<Order> inventoryChecker = order -> {
            if ("PAID".equals(order.status)) {
                System.out.println("📦 Checking inventory for: " + order.product);
                System.out.println("✅ Product available in stock");
                order.status = "CONFIRMED";
            }
        };
        
        // Consumer for shipping
        Consumer<Order> shippingProcessor = order -> {
            if ("CONFIRMED".equals(order.status)) {
                System.out.println("🚚 Preparing for shipment...");
                System.out.println("📧 Tracking details sent to: " + order.customerName);
                order.status = "SHIPPED";
            }
        };
        
        // Consumer for notification
        Consumer<Order> notificationSender = order -> {
            System.out.println("📱 Sending SMS/Email notification");
            System.out.println("📊 Final Status: " + order.status);
            System.out.println("═".repeat(60));
            System.out.println();
        };
        
        // Complete order processing chain
        Consumer<Order> completeOrderProcessing = orderValidator
            .andThen(paymentProcessor)
            .andThen(inventoryChecker)
            .andThen(shippingProcessor)
            .andThen(notificationSender);
        
        List<Order> orders = Arrays.asList(
            new Order("ORD001", "Rahul Sharma", "iPhone 15", 79999.00),
            new Order("ORD002", "Priya Singh", "MacBook Air", 114999.00),
            new Order("ORD003", "Amit Kumar", "AirPods Pro", 24999.00),
            new Order("ORD004", "Invalid Order", "Test Product", -100.00)
        );
        
        System.out.println("🛒 E-COMMERCE ORDER PROCESSING SYSTEM 🛒");
        System.out.println("═".repeat(60));
        System.out.println();
        
        orders.forEach(completeOrderProcessing);
    }
}
```

## BiConsumer - Two Parameters Lene Wala! 👥

```java
import java.util.function.BiConsumer;
import java.util.HashMap;
import java.util.Map;

public class BiConsumerExample {
    public static void main(String[] args) {
        // BiConsumer for key-value operations
        BiConsumer<String, Integer> keyValuePrinter = (key, value) -> {
            System.out.println("Key: " + key + " | Value: " + value + " | Square: " + (value * value));
        };
        
        // BiConsumer for mathematical operations
        BiConsumer<Integer, Integer> mathOperations = (a, b) -> {
            System.out.println("Numbers: " + a + " and " + b);
            System.out.println("Sum: " + (a + b));
            System.out.println("Product: " + (a * b));
            System.out.println("Difference: " + Math.abs(a - b));
            System.out.println("---");
        };
        
        // Using BiConsumer with Map
        Map<String, Integer> studentMarks = new HashMap<>();
        studentMarks.put("Alice", 85);
        studentMarks.put("Bob", 92);
        studentMarks.put("Charlie", 78);
        studentMarks.put("Diana", 96);
        
        System.out.println("📊 STUDENT MARKS:");
        System.out.println("─".repeat(30));
        studentMarks.forEach(keyValuePrinter);
        
        System.out.println("\n🔢 MATHEMATICAL OPERATIONS:");
        System.out.println("─".repeat(30));
        mathOperations.accept(15, 25);
        mathOperations.accept(48, 32);
        mathOperations.accept(7, 13);
    }
}
```

## Consumer with Streams - Power Combo! 🌊

```java
import java.util.function.Consumer;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

class Employee {
    String name;
    String department;
    double salary;
    int experience;
    
    public Employee(String name, String department, double salary, int experience) {
        this.name = name;
        this.department = department;
        this.salary = salary;
        this.experience = experience;
    }
    
    @Override
    public String toString() {
        return String.format("%-15s %-12s ₹%-8.0f %d years", name, department, salary, experience);
    }
}

public class ConsumerWithStreams {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Rajesh Kumar", "IT", 75000, 5),
            new Employee("Priya Sharma", "HR", 65000, 3),
            new Employee("Amit Singh", "Finance", 80000, 7),
            new Employee("Sneha Patel", "IT", 95000, 8),
            new Employee("Vikash Yadav", "Marketing", 55000, 2),
            new Employee("Ananya Das", "IT", 85000, 6)
        );
        
        // Consumer for employee info printing
        Consumer<Employee> employeeInfoPrinter = emp -> {
            System.out.printf("👤 %-15s | 🏢 %-12s | 💰 ₹%-8.0f | 📅 %d years%n", 
                emp.name, emp.department, emp.salary, emp.experience);
        };
        
        // Consumer for salary analysis
        Consumer<List<Employee>> salaryAnalyzer = empList -> {
            double avgSalary = empList.stream()
                .mapToDouble(emp -> emp.salary)
                .average()
                .orElse(0.0);
            
            Employee highestPaid = empList.stream()
                .max((e1, e2) -> Double.compare(e1.salary, e2.salary))
                .orElse(null);
                
            System.out.println("\n📈 SALARY ANALYSIS:");
            System.out.println("─".repeat(50));
            System.out.println("Average Salary: ₹" + String.format("%.0f", avgSalary));
            if (highestPaid != null) {
                System.out.println("Highest Paid: " + highestPaid.name + " (₹" + String.format("%.0f", highestPaid.salary) + ")");
            }
            System.out.println();
        };
        
        System.out.println("👥 EMPLOYEE MANAGEMENT SYSTEM 👥");
        System.out.println("═".repeat(60));
        
        // Print all employees
        System.out.println("\n📋 ALL EMPLOYEES:");
        System.out.println("─".repeat(60));
        employees.forEach(employeeInfoPrinter);
        
        // Print IT department employees
        System.out.println("\n💻 IT DEPARTMENT:");
        System.out.println("─".repeat(60));
        employees.stream()
                 .filter(emp -> "IT".equals(emp.department))
                 .forEach(employeeInfoPrinter);
        
        // Print high salary employees (>70000)
        System.out.println("\n💎 HIGH SALARY EMPLOYEES (>₹70,000):");
        System.out.println("─".repeat(60));
        employees.stream()
                 .filter(emp -> emp.salary > 70000)
                 .forEach(employeeInfoPrinter);
        
        // Salary analysis
        salaryAnalyzer.accept(employees);
        
        // Department wise analysis
        System.out.println("🏢 DEPARTMENT WISE ANALYSIS:");
        System.out.println("─".repeat(50));
        employees.stream()
                 .collect(Collectors.groupingBy(emp -> emp.department))
                 .forEach((dept, empList) -> {
                     System.out.println("\n" + dept + " Department:");
                     empList.forEach(emp -> System.out.println("  " + emp.name + " - ₹" + String.format("%.0f", emp.salary)));
                 });
    }
}
```

## Error Handling with Consumer 🚨

```java
import java.util.function.Consumer;
import java.util.Arrays;
import java.util.List;

public class ConsumerErrorHandling {
    
    // Safe Consumer wrapper
    public static <T> Consumer<T> safeConsumer(Consumer<T> consumer, Consumer<Exception> errorHandler) {
        return item -> {
            try {
                consumer.accept(item);
            } catch (Exception e) {
                errorHandler.accept(e);
            }
        };
    }
    
    public static void main(String[] args) {
        // Error-prone consumer
        Consumer<String> riskyConsumer = str -> {
            if (str == null) {
                throw new IllegalArgumentException("String cannot be null!");
            }
            if (str.isEmpty()) {
                throw new IllegalArgumentException("String cannot be empty!");
            }
            System.out.println("Processing: " + str.toUpperCase());
        };
        
        // Error handler
        Consumer<Exception> errorHandler = ex -> {
            System.err.println("❌ Error occurred: " + ex.getMessage());
            System.err.println("⚠️  Skipping this item and continuing...");
        };
        
        // Safe consumer
        Consumer<String> safeStringConsumer = safeConsumer(riskyConsumer, errorHandler);
        
        // Test data with problematic values
        List<String> testData = Arrays.asList(
            "Hello World",
            null,           // This will cause error
            "Java 8",
            "",             // This will cause error
            "Consumer Interface",
            "Functional Programming"
        );
        
        System.out.println("🛡️  SAFE CONSUMER PROCESSING 🛡️");
        System.out.println("═".repeat(50));
        System.out.println();
        
        testData.forEach(safeStringConsumer);
        
        System.out.println("\n✅ Processing completed successfully!");
    }
}
```

## Consumer vs Other Functional Interfaces 🆚

### **Comparison Table:**

| **Interface** | **Input** | **Output** | **Method** | **Use Case** |
|---------------|-----------|------------|------------|--------------|
| **Consumer<T>** | 1 parameter | void | `accept(T t)` | Processing without returning 🔄 |
| **BiConsumer<T,U>** | 2 parameters | void | `accept(T t, U u)` | Processing two inputs 👥 |
| **Function<T,R>** | 1 parameter | Returns R | `apply(T t)` | Transformation 🔄➡️📤 |
| **Predicate<T>** | 1 parameter | boolean | `test(T t)` | Testing/Filtering ✅❌ |
| **Supplier<T>** | No parameter | Returns T | `get()` | Data generation 📤 |

### **Practical Comparison:**

```java
import java.util.function.*;
import java.util.Arrays;
import java.util.List;

public class FunctionalInterfacesComparison {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "Diana");
        
        System.out.println("🔄 FUNCTIONAL INTERFACES COMPARISON 🔄");
        System.out.println("═".repeat(50));
        
        // 1. Consumer - Takes input, returns nothing
        System.out.println("\n1️⃣ CONSUMER (Input → Process → Nothing):");
        Consumer<String> nameProcessor = name -> 
            System.out.println("   Processing: " + name.toUpperCase());
        names.forEach(nameProcessor);
        
        // 2. Function - Takes input, returns something
        System.out.println("\n2️⃣ FUNCTION (Input → Process → Output):");
        Function<String, Integer> nameLength = String::length;
        names.stream()
             .map(nameLength)
             .forEach(length -> System.out.println("   Length: " + length));
        
        // 3. Predicate - Takes input, returns boolean
        System.out.println("\n3️⃣ PREDICATE (Input → Test → boolean):");
        Predicate<String> isLongName = name -> name.length() > 4;
        names.stream()
             .filter(isLongName)
             .forEach(name -> System.out.println("   Long name: " + name));
        
        // 4. Supplier - Takes nothing, returns something
        System.out.println("\n4️⃣ SUPPLIER (Nothing → Generate → Output):");
        Supplier<String> randomGreeting = () -> "Hello from Supplier!";
        System.out.println("   " + randomGreeting.get());
        
        // 5. BiConsumer - Takes two inputs, returns nothing
        System.out.println("\n5️⃣ BICONSUMER (Input1, Input2 → Process → Nothing):");
        BiConsumer<String, Integer> nameWithIndex = (name, index) ->
            System.out.println("   " + index + ". " + name);
        
        for (int i = 0; i < names.size(); i++) {
            nameWithIndex.accept(names.get(i), i + 1);
        }
    }
}
```

## Interview Questions - Master Karo! 💪

### Q1: **Consumer vs Function interface difference?**
```java
// Consumer - Takes input, doesn't return anything
Consumer<String> consumer = str -> System.out.println(str.toUpperCase());
consumer.accept("hello");  // Prints: HELLO

// Function - Takes input, returns something
Function<String, String> function = str -> str.toUpperCase();
String result = function.apply("hello");  // Returns: "HELLO"
```
**Answer**: Wrapper function banake null check kar sakte hain before calling actual consumer.

## Advanced Consumer Patterns 🚀

### 1. **Conditional Consumer Pattern**
```java
import java.util.function.Consumer;
import java.util.function.Predicate;

public class ConditionalConsumer {
    
    public static <T> Consumer<T> conditionalConsumer(Predicate<T> condition, 
                                                     Consumer<T> trueConsumer, 
                                                     Consumer<T> falseConsumer) {
        return item -> {
            if (condition.test(item)) {
                trueConsumer.accept(item);
            } else {
                falseConsumer.accept(item);
            }
        };
    }
    
    public static void main(String[] args) {
        // Conditional processing based on number
        Consumer<Integer> positiveHandler = num -> 
            System.out.println("✅ Positive number: " + num);
            
        Consumer<Integer> negativeHandler = num -> 
            System.out.println("❌ Negative number: " + num);
        
        Consumer<Integer> numberProcessor = conditionalConsumer(
            num -> num > 0,
            positiveHandler,
            negativeHandler
        );
        
        Arrays.asList(10, -5, 7, -3, 0).forEach(numberProcessor);
    }
}
```

### 2. **Batch Processing Consumer**
```java
import java.util.function.Consumer;
import java.util.List;
import java.util.ArrayList;

public class BatchProcessingConsumer {
    
    public static <T> Consumer<T> batchConsumer(int batchSize, Consumer<List<T>> batchProcessor) {
        List<T> batch = new ArrayList<>();
        
        return item -> {
            batch.add(item);
            if (batch.size() >= batchSize) {
                batchProcessor.accept(new ArrayList<>(batch));
                batch.clear();
            }
        };
    }
    
    public static void main(String[] args) {
        Consumer<List<Integer>> batchProcessor = batch -> {
            System.out.println("📦 Processing batch of " + batch.size() + " items: " + batch);
            int sum = batch.stream().mapToInt(Integer::intValue).sum();
            System.out.println("   Total sum: " + sum);
            System.out.println();
        };
        
        Consumer<Integer> processor = batchConsumer(3, batchProcessor);
        
        // Process numbers in batches of 3
        for (int i = 1; i <= 10; i++) {
            processor.accept(i);
        }
    }
}
```

### 3. **Logging Consumer Decorator**
```java
import java.util.function.Consumer;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class LoggingConsumerDecorator {
    
    public static <T> Consumer<T> withLogging(Consumer<T> consumer, String operationName) {
        return item -> {
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            System.out.println("📝 [" + timestamp + "] Starting " + operationName + " for: " + item);
            
            try {
                consumer.accept(item);
                System.out.println("✅ [" + timestamp + "] Completed " + operationName + " successfully");
            } catch (Exception e) {
                System.err.println("❌ [" + timestamp + "] Failed " + operationName + ": " + e.getMessage());
                throw e;
            }
            System.out.println();
        };
    }
    
    public static void main(String[] args) {
        Consumer<String> fileProcessor = fileName -> {
            System.out.println("   🔄 Processing file: " + fileName);
            // Simulate file processing
            if (fileName.contains("error")) {
                throw new RuntimeException("File processing failed!");
            }
            try {
                Thread.sleep(1000); // Simulate processing time
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        };
        
        Consumer<String> loggedProcessor = withLogging(fileProcessor, "File Processing");
        
        List<String> files = Arrays.asList("document.pdf", "image.jpg", "error-file.txt", "presentation.pptx");
        
        files.forEach(fileName -> {
            try {
                loggedProcessor.accept(fileName);
            } catch (Exception e) {
                System.err.println("Skipping failed file: " + fileName);
                System.out.println();
            }
        });
    }
}
```

## Performance Considerations ⚡

### 1. **Memory Efficient Consumer**
```java
import java.util.function.Consumer;
import java.util.stream.IntStream;

public class MemoryEfficientConsumer {
    
    // Memory inefficient - creates unnecessary objects
    static Consumer<Integer> inefficientConsumer = num -> {
        String result = "Number: " + num + ", Square: " + (num * num) + ", Cube: " + (num * num * num);
        System.out.println(result);
    };
    
    // Memory efficient - reuses StringBuilder
    static Consumer<Integer> efficientConsumer = num -> {
        StringBuilder sb = new StringBuilder(50); // Pre-sized
        sb.append("Number: ").append(num)
          .append(", Square: ").append(num * num)
          .append(", Cube: ").append(num * num * num);
        System.out.println(sb.toString());
    };
    
    // Even more efficient - direct printing
    static Consumer<Integer> mostEfficientConsumer = num -> {
        System.out.printf("Number: %d, Square: %d, Cube: %d%n", num, num * num, num * num * num);
    };
    
    public static void main(String[] args) {
        System.out.println("🚀 PERFORMANCE COMPARISON 🚀");
        System.out.println("═".repeat(40));
        
        // Test with large dataset
        IntStream.rangeClosed(1, 5)
                 .forEach(mostEfficientConsumer);
    }
}
```

### 2. **Parallel Processing with Consumer**
```java
import java.util.function.Consumer;
import java.util.List;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicInteger;

public class ParallelConsumerProcessing {
    
    public static void main(String[] args) {
        List<String> data = Arrays.asList(
            "File1.txt", "File2.txt", "File3.txt", "File4.txt", "File5.txt",
            "File6.txt", "File7.txt", "File8.txt", "File9.txt", "File10.txt"
        );
        
        AtomicInteger processedCount = new AtomicInteger(0);
        
        Consumer<String> fileProcessor = fileName -> {
            try {
                // Simulate file processing
                Thread.sleep(1000);
                System.out.println("🔄 Processed: " + fileName + " on thread: " + 
                    Thread.currentThread().getName());
                processedCount.incrementAndGet();
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        };
        
        System.out.println("📊 SEQUENTIAL PROCESSING:");
        System.out.println("─".repeat(40));
        long startTime = System.currentTimeMillis();
        
        data.stream()
            .limit(3) // Process only 3 for demo
            .forEach(fileProcessor);
            
        long sequentialTime = System.currentTimeMillis() - startTime;
        System.out.println("Sequential time: " + sequentialTime + "ms\n");
        
        System.out.println("🚀 PARALLEL PROCESSING:");
        System.out.println("─".repeat(40));
        startTime = System.currentTimeMillis();
        processedCount.set(0);
        
        data.parallelStream()
            .limit(3) // Process only 3 for demo
            .forEach(fileProcessor);
            
        long parallelTime = System.currentTimeMillis() - startTime;
        System.out.println("Parallel time: " + parallelTime + "ms");
        System.out.println("Speedup: " + (sequentialTime / (double) parallelTime) + "x");
    }
}
```

## Best Practices 🌟

### 1. **Use Method References When Possible**
```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

// ❌ Less readable
names.forEach(name -> System.out.println(name));

// ✅ More readable
names.forEach(System.out::println);

// ❌ Verbose
Consumer<String> upperCasePrinter = name -> System.out.println(name.toUpperCase());

// ✅ Clean
Consumer<String> upperCasePrinter2 = name -> System.out.println(name.toUpperCase());
```

### 2. **Meaningful Variable Names**
```java
// ❌ Poor naming
Consumer<Employee> c = e -> System.out.println(e.getName());

// ✅ Descriptive naming
Consumer<Employee> employeeNamePrinter = employee -> 
    System.out.println(employee.getName());
```

### 3. **Handle Exceptions Properly**
```java
// ✅ Proper exception handling
public static <T> Consumer<T> safeConsumer(Consumer<T> consumer) {
    return item -> {
        try {
            consumer.accept(item);
        } catch (Exception e) {
            System.err.println("Error processing item " + item + ": " + e.getMessage());
            // Log the error properly in real applications
        }
    };
}
```

### 4. **Use Builder Pattern for Complex Consumers**
```java
public class ConsumerBuilder<T> {
    private Consumer<T> consumer = item -> {};
    
    public ConsumerBuilder<T> addStep(Consumer<T> step) {
        consumer = consumer.andThen(step);
        return this;
    }
    
    public ConsumerBuilder<T> addConditionalStep(Predicate<T> condition, Consumer<T> step) {
        return addStep(item -> {
            if (condition.test(item)) {
                step.accept(item);
            }
        });
    }
    
    public Consumer<T> build() {
        return consumer;
    }
    
    // Usage example
    public static void main(String[] args) {
        Consumer<String> complexConsumer = new ConsumerBuilder<String>()
            .addStep(str -> System.out.println("Step 1: " + str))
            .addConditionalStep(str -> str.length() > 5, 
                              str -> System.out.println("Step 2: Long string " + str))
            .addStep(str -> System.out.println("Step 3: Final processing"))
            .build();
            
        complexConsumer.accept("Hello World");
    }
}
```

## Common Pitfalls - Avoid Karo! ⚠️

### 1. **Modifying External State (Side Effects)**
```java
// ❌ Dangerous - modifying external state
List<String> results = new ArrayList<>();
Consumer<String> badConsumer = str -> {
    results.add(str.toUpperCase()); // Side effect!
};

// ✅ Better - use dedicated methods for state changes
public void processStrings(List<String> input, List<String> output) {
    Consumer<String> processor = str -> output.add(str.toUpperCase());
    input.forEach(processor);
}
```

### 2. **Not Handling Null Values**
```java
// ❌ Will throw NullPointerException
Consumer<String> unsafeConsumer = str -> System.out.println(str.toUpperCase());

// ✅ Null-safe consumer
Consumer<String> safeConsumer = str -> {
    if (str != null) {
        System.out.println(str.toUpperCase());
    } else {
        System.out.println("Null value encountered");
    }
};
```

### 3. **Long Running Operations**
```java
// ❌ Blocking operation in consumer
Consumer<String> slowConsumer = fileName -> {
    try {
        Thread.sleep(10000); // 10 seconds!
        System.out.println("Processed: " + fileName);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
};

// ✅ Use async processing for long operations
Consumer<String> asyncConsumer = fileName -> {
    CompletableFuture.runAsync(() -> {
        // Long running operation
        System.out.println("Processing: " + fileName);
    });
};
```

## Real-World Integration Examples 🌍

### 1. **Spring Boot with Consumer**
```java
@Service
public class UserService {
    
    // Consumer for user notification
    private final Consumer<User> notificationSender = user -> {
        emailService.sendWelcomeEmail(user.getEmail());
        smsService.sendWelcomeSMS(user.getPhone());
        logger.info("Notifications sent to user: " + user.getUsername());
    };
    
    // Consumer for user analytics
    private final Consumer<User> analyticsTracker = user -> {
        analyticsService.trackUserRegistration(user);
        metricsService.incrementUserCount();
    };
    
    // Chained consumer for complete user processing
    private final Consumer<User> completeUserProcessor = notificationSender
        .andThen(analyticsTracker);
    
    public void registerUser(User user) {
        // Save user
        userRepository.save(user);
        
        // Process user with consumer chain
        completeUserProcessor.accept(user);
    }
}
```

### 2. **Database Operations with Consumer**
```java
@Repository
public class ProductRepository {
    
    // Consumer for batch processing
    public void processBatch(List<Product> products, Consumer<Product> processor) {
        products.forEach(processor);
    }
    
    // Usage
    public void updateProductPrices() {
        Consumer<Product> priceUpdater = product -> {
            // Update price logic
            product.setPrice(product.getPrice() * 1.1); // 10% increase
            save(product);
            logger.info("Updated price for product: " + product.getName());
        };
        
        List<Product> products = findAll();
        processBatch(products, priceUpdater);
    }
}
```

## Summary & Key Takeaways 📝

### **Consumer Interface का सार:**

1. **🎯 Purpose**: Input लेकर कोई operation perform करना without returning anything
2. **📦 Package**: `java.util.function.Consumer<T>`
3. **🔧 Method**: `void accept(T t)` 
4. **🔗 Chaining**: `andThen()` method से multiple consumers chain kar sakte hain
5. **💡 Use Cases**: Logging, printing, saving, notifications, processing

### **Key Benefits:**
- ✅ **Code Reusability**: Same consumer multiple jagah use kar sakte hain
- ✅ **Functional Programming**: Lambda expressions ke saath perfect
- ✅ **Chaining**: Multiple operations ko chain kar sakte hain
- ✅ **Stream Integration**: Streams के साथ seamless integration
- ✅ **Separation of Concerns**: Processing logic को separate kar sakte hain

### **When to Use Consumer:**
- 🖨️ **Printing/Logging**: Data को print या log करना
- 💾 **Saving Data**: Database या file में save करना
- 📧 **Notifications**: Email, SMS, push notifications भेजना
- 🔄 **Processing**: Data को process करना without returning
- 📊 **Analytics**: Metrics और analytics track करना

### **Memory Tricks:**
- **CONSUMER** = **CONSUME** करता है but कुछ **RETURN नहीं करता** 🍕➡️😋
- **accept()** method = Accept करके process कर देता है ✅
- **andThen()** = एक के बाद एक (chain) 🔗

### **Interview Quick Points:**
1. Consumer takes input, returns void
2. BiConsumer takes two inputs, returns void
3. Can be chained using andThen()
4. Commonly used with streams and forEach
5. Different from Function (which returns something)
6. Exception handling needs try-catch wrapper
7. Method references make code cleaner

Practice करते रहो different scenarios के साथ! Consumer mastery से functional programming strong हो जाएगी! 🚀💪

---
*Happy Functional Programming! 🎉✨* Consumer sirf processing karta hai, Function transformation karta hai aur result return karta hai.

### Q2: **How does Consumer chaining work?**
```java
Consumer<String> first = str -> System.out.print("First: " + str);
Consumer<String> second = str -> System.out.print(" | Second: " + str);
Consumer<String> third = str -> System.out.println(" | Third: " + str);

Consumer<String> chained = first.andThen(second).andThen(third);
chained.accept("Test");
// Output: First: Test | Second: Test | Third: Test
```
**Answer**: `andThen()` method se multiple consumers ko chain kar sakte hain. Sequence mein execute hote hain.

### Q3: **Can Consumer throw checked exceptions?**
```java
// This won't compile because Consumer doesn't declare checked exceptions
Consumer<String> badConsumer = str -> {
    try {
        Thread.sleep(1000);  // Checked exception
    } catch (InterruptedException e) {
        // Handle or wrap in runtime exception
        throw new RuntimeException(e);
    }
};
```
**Answer**: Consumer checked exceptions throw nahi kar sakta directly. Try-catch use karke runtime exception mein wrap karna padta hai.

### Q4: **Difference between forEach and Consumer?**
```java
List<String> list = Arrays.asList("A", "B", "C");

// forEach with lambda (internally uses Consumer)
list.forEach(item -> System.out.println(item));

// Explicit Consumer
Consumer<String> printer = System.out::println;
list.forEach(printer);

// Both are same! forEach accepts Consumer as parameter
```
**Answer**: `forEach()` method Consumer को parameter के रूप में लेता है. Lambda expressions internally Consumer implement करते हैं.

### Q5: **How to make Consumer null-safe?**
```java
public static <T> Consumer<T> nullSafeConsumer(Consumer<T> consumer) {
    return item -> {
        if (item != null) {
            consumer.accept(item);
        } else {
            System.out.println("Null value encountered, skipping...");
        }
    };
}

// Usage
Consumer<String> safePrinter = nullSafeConsumer(System.out::println);
```
**Answer**:
