# Predicate Functional Interface - Complete Study Notes 📚

## Predicate Kya Hai Bhai? 🤔

**Simple Words Mein**: Predicate ek tester hai jo koi condition check karta hai aur true/false return karta hai!

**Real Life Example**: 
- Bouncer club ke gate pe - "Kya tum 18+ ho?" (Age predicate) 👮‍♂️
- ATM machine - "Kya password sahi hai?" (Authentication predicate) 💳
- Traffic signal - "Kya light green hai?" (Color predicate) 🚦

**Technical Definition**: Predicate is a functional interface that represents a boolean-valued function of one argument. It's used for conditional checks.

## Why Predicate? Lambda Expression Ki Zaroorat! 🚀

**Old Way (Before Java 8):**
```java
// Traditional way - Lots of code! 😤
public boolean isEven(int number) {
    if (number % 2 == 0) {
        return true;
    } else {
        return false;
    }
}
```

**New Way (Java 8+ with Predicate):**
```java
// Modern way - Clean & concise! 😎
Predicate<Integer> isEven = n -> n % 2 == 0;
```

## Predicate Interface Structure 🏗️

```java
// Predicate interface signature
@FunctionalInterface
public interface Predicate<T> {
    // Abstract method - Sirf ek hi method allowed in functional interface
    boolean test(T t);
    
    // Default methods - Additional functionality
    default Predicate<T> and(Predicate<? super T> other) { ... }
    default Predicate<T> or(Predicate<? super T> other) { ... }
    default Predicate<T> negate() { ... }
    
    // Static method
    static <T> Predicate<T> isEqual(Object targetRef) { ... }
}
```

**Key Points:**
- `T` = Input type ka placeholder
- `test(T t)` = Main method jo boolean return karta hai
- Package: `java.util.function.Predicate`

## Basic Examples - Samjhao Bhai! 💡

### Example 1: Even Number Checker

```java
import java.util.function.Predicate;

public class EvenNumberChecker {
    public static void main(String[] args) {
        // Predicate to check if number is even
        Predicate<Integer> isEven = i -> i % 2 == 0;
        
        // Testing different numbers
        System.out.println("Is 10 even? " + isEven.test(10));  // true
        System.out.println("Is 15 even? " + isEven.test(15));  // false
        System.out.println("Is 20 even? " + isEven.test(20));  // true
        System.out.println("Is 5 even? " + isEven.test(5));    // false
    }
}
```

**Output:**
```
Is 10 even? true
Is 15 even? false
Is 20 even? true
Is 5 even? false
```

**Explanation:** 
- `i -> i % 2 == 0` = Lambda expression for even check
- `test()` method call karke result milta hai

### Example 2: String Length Checker

```java
import java.util.function.Predicate;

public class StringLengthChecker {
    public static void main(String[] args) {
        String[] names = {
            "Ramesh",    // 6 characters
            "Ravi",      // 4 characters  
            "Raju",      // 4 characters
            "Raghav",    // 6 characters
            "Dinesh"     // 6 characters
        };
        
        // Predicate to check if string length > 5
        Predicate<String> isLongName = name -> name.length() > 5;
        
        System.out.println("Names with length > 5:");
        for (String name : names) {
            if (isLongName.test(name)) {
                System.out.println(name);
            }
        }
    }
}
```

**Output:**
```
Names with length > 5:
Ramesh
Raghav
Dinesh
```

### Example 3: Student Marks Filter

```java
import java.util.function.Predicate;
import java.util.ArrayList;
import java.util.List;

class Student {
    String name;
    int marks;
    
    public Student(String name, int marks) {
        this.name = name;
        this.marks = marks;
    }
    
    @Override
    public String toString() {
        return "Name: " + name + ", Marks: " + marks;
    }
}

public class StudentFilter {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Raj", 70));
        students.add(new Student("Vineet", 60));
        students.add(new Student("Raghav", 40));
        students.add(new Student("Sham", 30));
        students.add(new Student("Dinesh", 50));
        
        // Predicate to check if student passed (marks > 40)
        Predicate<Student> isPassed = student -> student.marks > 40;
        
        System.out.println("Students who passed:");
        for (Student student : students) {
            if (isPassed.test(student)) {
                System.out.println(student);
            }
        }
    }
}
```

**Output:**
```
Students who passed:
Name: Raj, Marks: 70
Name: Vineet, Marks: 60
Name: Dinesh, Marks: 50
```

## Predicate Joining - Multiple Conditions! 🔗

**Real Life Analogy**: Job interview mein multiple rounds - "Kya technical clear hai AND kya HR round clear hai?"

Java mein 3 main joining operations hain:

### 1. **AND Operation** - Dono conditions true honi chahiye ✅✅

```java
import java.util.function.Predicate;

public class PredicateAndExample {
    public static void main(String[] args) {
        int[] numbers = {6, 8, 30, 25, 30, 45, 40, 50};
        
        // Two separate predicates
        Predicate<Integer> isEven = i -> i % 2 == 0;       // Even check
        Predicate<Integer> isGreaterThan10 = i -> i >= 10; // Greater than 10
        
        // Combined predicate using AND
        Predicate<Integer> evenAndGreater10 = isEven.and(isGreaterThan10);
        
        System.out.println("Numbers that are EVEN AND >= 10:");
        for (int num : numbers) {
            if (evenAndGreater10.test(num)) {
                System.out.println(num);
            }
        }
        
        // Alternative way - direct combination
        System.out.println("\nDirect combination:");
        for (int num : numbers) {
            if (isEven.and(isGreaterThan10).test(num)) {
                System.out.println(num);
            }
        }
    }
}
```

**Output:**
```
Numbers that are EVEN AND >= 10:
30
30
40
50
```

### 2. **OR Operation** - Koi bhi ek condition true ho ✅ or ✅

```java
import java.util.function.Predicate;

public class PredicateOrExample {
    public static void main(String[] args) {
        int[] numbers = {5, 6, 8, 25, 30, 45, 40, 50};
        
        Predicate<Integer> isEven = i -> i % 2 == 0;       // Even check
        Predicate<Integer> isGreaterThan10 = i -> i >= 10; // Greater than 10
        
        System.out.println("Numbers that are EVEN OR >= 10:");
        for (int num : numbers) {
            if (isEven.or(isGreaterThan10).test(num)) {
                System.out.println(num);
            }
        }
    }
}
```

**Output:**
```
Numbers that are EVEN OR >= 10:
6
8
25
30
45
40
50
```

**Explanation:** 
- 5 neither even nor >= 10, so excluded
- 6 is even, so included
- 25 is >= 10, so included

### 3. **NEGATE Operation** - Opposite result ❌

```java
import java.util.function.Predicate;

public class PredicateNegateExample {
    public static void main(String[] args) {
        int[] numbers = {5, 6, 8, 25, 30, 45, 40, 50};
        
        Predicate<Integer> isEven = i -> i % 2 == 0;
        
        System.out.println("Numbers that are NOT even (odd numbers):");
        for (int num : numbers) {
            if (isEven.negate().test(num)) {
                System.out.println(num);
            }
        }
    }
}
```

**Output:**
```
Numbers that are NOT even (odd numbers):
5
25
45
```

## Complex Predicate Combinations 🧩

```java
import java.util.function.Predicate;

public class ComplexPredicateExample {
    public static void main(String[] args) {
        int[] numbers = {1, 2, 5, 6, 8, 10, 15, 20, 25, 30};
        
        Predicate<Integer> isEven = n -> n % 2 == 0;
        Predicate<Integer> isGreaterThan5 = n -> n > 5;
        Predicate<Integer> isLessThan20 = n -> n < 20;
        
        // Complex combination: (Even AND > 5) OR < 20
        Predicate<Integer> complexCondition = 
            isEven.and(isGreaterThan5).or(isLessThan20);
        
        System.out.println("Numbers satisfying complex condition:");
        for (int num : numbers) {
            if (complexCondition.test(num)) {
                System.out.println(num + " -> " + 
                    "Even: " + isEven.test(num) + 
                    ", >5: " + isGreaterThan5.test(num) + 
                    ", <20: " + isLessThan20.test(num));
            }
        }
    }
}
```

## Real-World Applications 🌍

### 1. **Employee Management System**

```java
import java.util.function.Predicate;
import java.util.List;
import java.util.ArrayList;
import java.util.stream.Collectors;

class Employee {
    private String name;
    private int age;
    private double salary;
    private String department;
    
    public Employee(String name, int age, double salary, String department) {
        this.name = name;
        this.age = age;
        this.salary = salary;
        this.department = department;
    }
    
    // Getters
    public String getName() { return name; }
    public int getAge() { return age; }
    public double getSalary() { return salary; }
    public String getDepartment() { return department; }
    
    @Override
    public String toString() {
        return String.format("%s (Age: %d, Salary: %.0f, Dept: %s)", 
                           name, age, salary, department);
    }
}

public class EmployeeFilter {
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Employee("Alice", 28, 50000, "IT"));
        employees.add(new Employee("Bob", 35, 75000, "Finance"));
        employees.add(new Employee("Charlie", 42, 60000, "IT"));
        employees.add(new Employee("Diana", 29, 55000, "HR"));
        employees.add(new Employee("Eve", 31, 80000, "IT"));
        
        // Different predicates for filtering
        Predicate<Employee> isITEmployee = emp -> "IT".equals(emp.getDepartment());
        Predicate<Employee> isHighSalary = emp -> emp.getSalary() > 60000;
        Predicate<Employee> isYoung = emp -> emp.getAge() < 35;
        
        System.out.println("IT Employees with high salary:");
        employees.stream()
                .filter(isITEmployee.and(isHighSalary))
                .forEach(System.out::println);
        
        System.out.println("\nYoung employees OR high salary:");
        employees.stream()
                .filter(isYoung.or(isHighSalary))
                .forEach(System.out::println);
        
        System.out.println("\nNon-IT employees:");
        employees.stream()
                .filter(isITEmployee.negate())
                .forEach(System.out::println);
    }
}
```

### 2. **E-commerce Product Filter**

```java
import java.util.function.Predicate;
import java.util.List;
import java.util.ArrayList;

class Product {
    private String name;
    private double price;
    private String category;
    private double rating;
    private boolean inStock;
    
    public Product(String name, double price, String category, double rating, boolean inStock) {
        this.name = name;
        this.price = price;
        this.category = category;
        this.rating = rating;
        this.inStock = inStock;
    }
    
    // Getters
    public String getName() { return name; }
    public double getPrice() { return price; }
    public String getCategory() { return category; }
    public double getRating() { return rating; }
    public boolean isInStock() { return inStock; }
    
    @Override
    public String toString() {
        return String.format("%s - ₹%.0f (%.1f★) [%s]", 
                           name, price, rating, inStock ? "In Stock" : "Out of Stock");
    }
}

public class ProductFilter {
    public static void main(String[] args) {
        List<Product> products = new ArrayList<>();
        products.add(new Product("Laptop", 50000, "Electronics", 4.5, true));
        products.add(new Product("Phone", 25000, "Electronics", 4.2, false));
        products.add(new Product("Book", 500, "Education", 4.8, true));
        products.add(new Product("Headphones", 3000, "Electronics", 4.0, true));
        products.add(new Product("Shirt", 1200, "Clothing", 3.9, true));
        
        // Business logic predicates
        Predicate<Product> isExpensive = p -> p.getPrice() > 10000;
        Predicate<Product> isHighRated = p -> p.getRating() >= 4.5;
        Predicate<Product> isAvailable = Product::isInStock;
        Predicate<Product> isElectronics = p -> "Electronics".equals(p.getCategory());
        
        System.out.println("Premium Electronics (Expensive + High Rated + In Stock):");
        products.stream()
                .filter(isExpensive.and(isHighRated).and(isAvailable).and(isElectronics))
                .forEach(System.out::println);
        
        System.out.println("\nBudget Options (Not expensive but available):");
        products.stream()
                .filter(isExpensive.negate().and(isAvailable))
                .forEach(System.out::println);
        
        System.out.println("\nRecommended (High rated OR expensive electronics):");
        products.stream()
                .filter(isHighRated.or(isExpensive.and(isElectronics)))
                .forEach(System.out::println);
    }
}
```

## Predicate with Streams - Power Combo! 🔥

```java
import java.util.function.Predicate;
import java.util.List;
import java.util.Arrays;
import java.util.stream.Collectors;

public class PredicateStreamExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList(
            "Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace"
        );
        
        // Predicate definitions
        Predicate<String> startsWithVowel = name -> 
            name.toLowerCase().matches("^[aeiou].*");
        Predicate<String> isLongName = name -> name.length() > 5;
        Predicate<String> containsE = name -> 
            name.toLowerCase().contains("e");
        
        // Using predicates with streams
        System.out.println("Names starting with vowel:");
        names.stream()
             .filter(startsWithVowel)
             .forEach(System.out::println);
        
        System.out.println("\nLong names containing 'e':");
        List<String> result = names.stream()
                                   .filter(isLongName.and(containsE))
                                   .collect(Collectors.toList());
        result.forEach(System.out::println);
        
        System.out.println("\nNames NOT starting with vowel:");
        names.stream()
             .filter(startsWithVowel.negate())
             .forEach(System.out::println);
    }
}
```

## Custom Predicate Factory 🏭

```java
import java.util.function.Predicate;

public class PredicateFactory {
    
    // Static methods to create common predicates
    public static Predicate<Integer> isEven() {
        return n -> n % 2 == 0;
    }
    
    public static Predicate<Integer> isGreaterThan(int threshold) {
        return n -> n > threshold;
    }
    
    public static Predicate<String> hasLength(int length) {
        return s -> s.length() == length;
    }
    
    public static Predicate<String> containsIgnoreCase(String substring) {
        return s -> s.toLowerCase().contains(substring.toLowerCase());
    }
    
    public static <T> Predicate<T> isNull() {
        return obj -> obj == null;
    }
    
    public static <T> Predicate<T> isNotNull() {
        return obj -> obj != null;
    }
    
    // Range predicate
    public static Predicate<Integer> isBetween(int min, int max) {
        return n -> n >= min && n <= max;
    }
    
    public static void main(String[] args) {
        int[] numbers = {1, 2, 5, 8, 10, 15, 20, 25, 30};
        String[] words = {"Java", "Python", "JavaScript", "Go", "Rust"};
        
        // Using factory methods
        System.out.println("Even numbers between 5 and 25:");
        for (int num : numbers) {
            if (isEven().and(isBetween(5, 25)).test(num)) {
                System.out.println(num);
            }
        }
        
        System.out.println("\nLanguages containing 'a':");
        for (String word : words) {
            if (containsIgnoreCase("a").test(word)) {
                System.out.println(word);
            }
        }
    }
}
```

## Method Reference with Predicates 🎯

```java
import java.util.function.Predicate;
import java.util.List;
import java.util.Arrays;

public class PredicateMethodReference {
    
    // Custom methods for method reference
    public static boolean isEvenNumber(Integer n) {
        return n % 2 == 0;
    }
    
    public static boolean isLongString(String s) {
        return s.length() > 5;
    }
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        List<String> words = Arrays.asList("Java", "Python", "JavaScript", "Go", "Rust");
        
        // Method reference as predicate
        Predicate<Integer> isEven = PredicateMethodReference::isEvenNumber;
        Predicate<String> isLong = PredicateMethodReference::isLongString;
        
        // Built-in method references
        Predicate<String> isEmpty = String::isEmpty;
        Predicate<Integer> isPositive = n -> n > 0;
        
        System.out.println("Even numbers:");
        numbers.stream()
               .filter(isEven)
               .forEach(System.out::println);
        
        System.out.println("\nLong words:");
        words.stream()
             .filter(isLong)
             .forEach(System.out::println);
    }
}
```

## Predicate Chaining - Advanced Patterns 🔗

```java
import java.util.function.Predicate;
import java.util.List;
import java.util.Arrays;

public class PredicateChaining {
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(-5, -2, 0, 1, 3, 4, 6, 8, 9, 12, 15, 18, 20);
        
        // Building complex conditions step by step
        Predicate<Integer> isPositive = n -> n > 0;
        Predicate<Integer> isEven = n -> n % 2 == 0;
        Predicate<Integer> isGreaterThan5 = n -> n > 5;
        Predicate<Integer> isLessThan15 = n -> n < 15;
        
        // Complex chaining
        Predicate<Integer> complexCondition = 
            isPositive
            .and(isEven)
            .and(isGreaterThan5)
            .and(isLessThan15);
        
        System.out.println("Numbers that are: positive AND even AND >5 AND <15");
        numbers.stream()
               .filter(complexCondition)
               .forEach(System.out::println);
        
        // Alternative complex condition
        Predicate<Integer> alternativeCondition = 
            isEven.and(isGreaterThan5)
            .or(isPositive.and(n -> n % 3 == 0));
        
        System.out.println("\nNumbers that are: (even AND >5) OR (positive AND divisible by 3)");
        numbers.stream()
               .filter(alternativeCondition)
               .forEach(System.out::println);
    }
}
```

## Common Use Cases & Patterns 📋

### 1. **Validation Pattern**

```java
import java.util.function.Predicate;

public class ValidationExample {
    
    // Email validation predicates
    private static final Predicate<String> isNotEmpty = s -> s != null && !s.trim().isEmpty();
    private static final Predicate<String> containsAt = s -> s.contains("@");
    private static final Predicate<String> containsDot = s -> s.contains(".");
    private static final Predicate<String> hasValidLength = s -> s.length() >= 5 && s.length() <= 50;
    
    // Combined email validator
    private static final Predicate<String> isValidEmail = 
        isNotEmpty
        .and(containsAt)
        .and(containsDot)
        .and(hasValidLength);
    
    // Password validation predicates
    private static final Predicate<String> hasMinLength = s -> s.length() >= 8;
    private static final Predicate<String> hasUpperCase = s -> !s.equals(s.toLowerCase());
    private static final Predicate<String> hasLowerCase = s -> !s.equals(s.toUpperCase());
    private static final Predicate<String> hasDigit = s -> s.matches(".*\\d.*");
    private static final Predicate<String> hasSpecialChar = s -> s.matches(".*[!@#$%^&*()_+].*");
    
    // Combined password validator
    private static final Predicate<String> isValidPassword = 
        hasMinLength
        .and(hasUpperCase)
        .and(hasLowerCase)
        .and(hasDigit)
        .and(hasSpecialChar);
    
    public static void main(String[] args) {
        String[] emails = {
            "test@example.com",
            "invalid-email",
            "user@domain.co.in",
            "a@b.c",
            ""
        };
        
        String[] passwords = {
            "Password123!",
            "weak",
            "NoDigits!",
            "noupppercase123!",
            "NOLOWERCASE123!"
        };
        
        System.out.println("Email Validation:");
        for (String email : emails) {
            System.out.println(email + " -> " + isValidEmail.test(email));
        }
        
        System.out.println("\nPassword Validation:");
        for (String password : passwords) {
            System.out.println(password + " -> " + isValidPassword.test(password));
        }
    }
}
```

### 2. **Filtering Pattern**

```java
import java.util.function.Predicate;
import java.util.List;
import java.util.ArrayList;

public class FilteringPattern {
    
    public static <T> List<T> filter(List<T> list, Predicate<T> predicate) {
        List<T> result = new ArrayList<>();
        for (T item : list) {
            if (predicate.test(item)) {
                result.add(item);
            }
        }
        return result;
    }
    
    public static <T> List<T> filterMultiple(List<T> list, Predicate<T>... predicates) {
        List<T> result = new ArrayList<>(list);
        for (Predicate<T> predicate : predicates) {
            result = filter(result, predicate);
        }
        return result;
    }
    
    public static void main(String[] args) {
        List<Integer> numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 18, 20);
        
        // Multiple filtering steps
        List<Integer> result = filterMultiple(numbers,
            n -> n > 5,           // Greater than 5
            n -> n % 2 == 0,      // Even numbers
            n -> n < 20           // Less than 20
        );
        
        System.out.println("Filtered result: " + result);
    }
}
```

## Performance Tips & Best Practices 🚀

### 1. **Predicate Reusability**

```java
import java.util.function.Predicate;

public class PredicateReusability {
    
    // Reusable predicates as constants
    public static final Predicate<String> IS_NOT_EMPTY = s -> s != null && !s.trim().isEmpty();
    public static final Predicate<String> IS_NUMERIC = s -> s.matches("\\d+");
    public static final Predicate<Integer> IS_POSITIVE = n -> n > 0;
    public static final Predicate<Integer> IS_EVEN = n -> n % 2 == 0;
    
    // Factory methods for parameterized predicates
    public static Predicate<String> hasMinLength(int minLength) {
        return s -> s.length() >= minLength;
    }
    
    public static Predicate<Integer> isGreaterThan(int threshold) {
        return n -> n > threshold;
    }
    
    // Combining predicates into commonly used patterns
    public static final Predicate<String> IS_VALID_POSITIVE_NUMBER = 
        IS_NOT_EMPTY.and(IS_NUMERIC).and(s -> Integer.parseInt(s) > 0);
    
    public static void main(String[] args) {
        String[] inputs = {"", "abc", "123", "-5", "42"};
        
        System.out.println("Valid positive numbers:");
        for (String input : inputs) {
            if (IS_VALID_POSITIVE_NUMBER.test(input)) {
                System.out.println(input);
            }
        }
    }
}
```

### 2. **Early Termination & Short-Circuit**

```java
import java.util.function.Predicate;
import java.util.List;
import java.util.Arrays;

public class PredicatePerformance {
    
    // Expensive operations - simulate with sleep
    public static Predicate<Integer> expensiveCheck1 = n -> {
        // System.out.println("Expensive check 1 for: " + n);
        // Simulate expensive operation
        return n % 7 == 0;
    };
    
    public static Predicate<Integer> expensiveCheck2 = n -> {
        // System.out.println("Expensive check 2 for: " + n);
        // Simulate expensive operation
        return n > 50;
    };
    
    public static Predicate<Integer> cheapCheck = n -> n % 2 == 0;  // Fast check
    
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 14, 28, 49, 56, 77, 84, 91, 98);
        
        // Good: Put cheap checks first for AND operations
        Predicate<Integer> optimizedAnd = cheapCheck.and(expensiveCheck1).and(expensiveCheck2);
        
        // Good: Put expensive checks first for OR operations (if they're likely to be true)
        Predicate<Integer> optimizedOr = expensiveCheck1.or(expensiveCheck2).or(cheapCheck);
        
        System.out.println("Testing AND operation (cheap check first):");
        numbers.stream()
               .filter(optimizedAnd)
               .forEach(System.out::println);
    }
}
```

## Error Handling with Predicates 🛡️

```java
import java.util.function.Predicate;

public class PredicateErrorHandling {
    
    // Safe predicate that handles null values
    public static Predicate<String> safeStringCheck(Predicate<String> predicate) {
        return s -> s != null && predicate.test(s);
    }
    
    // Predicate with exception handling
    public static Predicate<String> safeNumericCheck() {
        return s -> {
            try {
                Integer.parseInt(s);
                return true;
            } catch (NumberFormatException e) {
                return false;
            }
        };
    }
    
    public static void main(String[] args) {
        String[] inputs = {"hello", null, "123", "", "abc123", "456"};
        
        // Unsafe predicate (will throw NullPointerException)
        // Predicate<String> unsafePredicate = s -> s.length() > 3;
        
        // Safe predicate
        Predicate<String> safeLengthCheck = safeStringCheck(s -> s.length() > 3);
        Predicate<String> isNumeric = safeNumericCheck();
        
        System.out.println("Safe length check results:");
        for (String input : inputs) {
            System.out.println("'" + input + "' -> " + safeLengthCheck.test(input));
        }
        
        System.out.println("\nNumeric check results:");
        for (String input : inputs) {
            System.out.println("'" + input + "' -> " + isNumeric.test(input));
        }
    }
}
```

## Interview Questions - Master Karo! 💪

### Q1: **What is Predicate functional interface?**
**Answer**: 
```java
// Predicate is a functional interface that:
// 1. Takes one argument of type T
// 2. Returns boolean result
// 3. Used for conditional checks
// 4. Has one abstract method: test(T t)

@FunctionalInterface
public interface Predicate<T> {
    boolean test(T t);  // Main method
}
```

### Q2: **Difference between Predicate and Function?**
**Answer**:
```java
// Predicate<T> - Returns boolean
Predicate<String> isEmpty = s -> s.isEmpty();
boolean result1 = isEmpty.test("hello");  // false

// Function<T, R> - Returns any type R
Function<String, Integer> getLength = s -> s.length();
int result2 = getLength.apply("hello");   // 5
```

### Q3: **How does Predicate joining work?**
**Answer**:
```java
Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<Integer> isPositive = n -> n > 0;

// AND - Both conditions must be true
Predicate<Integer> evenAndPositive = isEven.and(isPositive);
System.out.println(evenAndPositive.test(4));   // true
System.out.println(evenAndPositive.test(-4));  // false

// OR - Any one condition can be true
Predicate<Integer> evenOrPositive = isEven.or(isPositive);
System.out.println(evenOrPositive.test(-4));   // true (even)
System.out.println(evenOrPositive.test(3));    // true (positive)

// NEGATE - Opposite result
Predicate<Integer> isOdd = isEven.negate();
System.out.println(isOdd.test(5));  // true
```

### Q4: **Can you use Predicate with streams?**
**Answer**:
```java
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<Integer> isGreaterThan5 = n -> n > 5;

// Using with filter
List<Integer> result = numbers.stream()
    .filter(isEven.and(isGreaterThan5))
    .collect(Collectors.toList());
// Result: [6, 8, 10]
```

### Q5: **How to create reusable predicates?**
**Answer**:
```java
public class PredicateUtils {
    // Static predicates for reuse
    public static final Predicate<String> IS_NOT_EMPTY = 
        s -> s != null && !s.trim().isEmpty();
    
    // Factory methods for parameterized predicates
    public static Predicate<Integer> isGreaterThan(int threshold) {
        return n -> n > threshold;
    }
    
    public static Predicate<String> hasLength(int length) {
        return s -> s.length() == length;
    }
}

// Usage
Predicate<Integer> greaterThan10 = PredicateUtils.isGreaterThan(10);
Predicate<String> hasLength5 = PredicateUtils.hasLength(5);
```

## Predicate vs Traditional Approach 🆚

### **Traditional Approach:**
```java
// Old way - Lots of if-else statements
public class TraditionalFiltering {
    
    public static List<Student> filterStudents(List<Student> students) {
        List<Student> result = new ArrayList<>();
        
        for (Student student : students) {
            if (student.getMarks() > 40 && 
                student.getAge() < 25 && 
                student.getDepartment().equals("IT")) {
                result.add(student);
            }
        }
        return result;
    }
    
    public static List<Student> filterHighPerformers(List<Student> students) {
        List<Student> result = new ArrayList<>();
        
        for (Student student : students) {
            if (student.getMarks() > 80 && 
                student.getAge() > 20) {
                result.add(student);
            }
        }
        return result;
    }
    
    // More methods with similar patterns... 😤
}
```

### **Predicate Approach:**
```java
// Modern way - Flexible and reusable
public class PredicateFiltering {
    
    // Reusable predicates
    public static final Predicate<Student> PASSED = s -> s.getMarks() > 40;
    public static final Predicate<Student> YOUNG = s -> s.getAge() < 25;
    public static final Predicate<Student> HIGH_PERFORMER = s -> s.getMarks() > 80;
    public static final Predicate<Student> EXPERIENCED = s -> s.getAge() > 20;
    
    // Factory methods
    public static Predicate<Student> fromDepartment(String dept) {
        return s -> s.getDepartment().equals(dept);
    }
    
    // Generic filter method
    public static List<Student> filter(List<Student> students, Predicate<Student> condition) {
        return students.stream()
                      .filter(condition)
                      .collect(Collectors.toList());
    }
    
    public static void main(String[] args) {
        List<Student> students = getStudents(); // Assume this method exists
        
        // Easy combinations
        List<Student> itStudents = filter(students, 
            PASSED.and(YOUNG).and(fromDepartment("IT")));
            
        List<Student> topPerformers = filter(students, 
            HIGH_PERFORMER.and(EXPERIENCED));
            
        // Can create any combination on the fly! 😎
    }
}
```

## BiPredicate - Two Arguments! 👥

```java
import java.util.function.BiPredicate;

public class BiPredicateExample {
    public static void main(String[] args) {
        // BiPredicate takes two arguments
        BiPredicate<Integer, Integer> isSum10 = (a, b) -> a + b == 10;
        BiPredicate<String, String> areEqual = (s1, s2) -> s1.equals(s2);
        BiPredicate<Integer, Integer> isFirstGreater = (a, b) -> a > b;
        
        System.out.println("5 + 5 = 10? " + isSum10.test(5, 5));  // true
        System.out.println("3 + 8 = 10? " + isSum10.test(3, 8));  // false
        
        System.out.println("Are 'hello' and 'hello' equal? " + 
                          areEqual.test("hello", "hello"));  // true
        
        // BiPredicate joining
        BiPredicate<Integer, Integer> complexCondition = 
            isFirstGreater.and((a, b) -> a % 2 == 0);  // First is greater AND first is even
        
        System.out.println("8 > 5 and 8 is even? " + 
                          complexCondition.test(8, 5));  // true
        System.out.println("7 > 5 and 7 is even? " + 
                          complexCondition.test(7, 5));  // false
    }
}
```

## Predicate with Collections - Advanced! 🗂️

```java
import java.util.function.Predicate;
import java.util.*;
import java.util.stream.Collectors;

public class PredicateCollections {
    
    static class Person {
        private String name;
        private int age;
        private String city;
        private List<String> hobbies;
        
        public Person(String name, int age, String city, String... hobbies) {
            this.name = name;
            this.age = age;
            this.city = city;
            this.hobbies = Arrays.asList(hobbies);
        }
        
        // Getters
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getCity() { return city; }
        public List<String> getHobbies() { return hobbies; }
        
        @Override
        public String toString() {
            return String.format("%s (%d, %s) - %s", name, age, city, hobbies);
        }
    }
    
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("Alice", 25, "Mumbai", "Reading", "Swimming"),
            new Person("Bob", 30, "Delhi", "Gaming", "Coding"),
            new Person("Charlie", 22, "Bangalore", "Reading", "Gaming", "Music"),
            new Person("Diana", 28, "Mumbai", "Swimming", "Dancing"),
            new Person("Eve", 24, "Chennai", "Coding", "Reading")
        );
        
        // Complex predicates
        Predicate<Person> isYoung = p -> p.getAge() < 26;
        Predicate<Person> liveInMumbai = p -> "Mumbai".equals(p.getCity());
        Predicate<Person> likesReading = p -> p.getHobbies().contains("Reading");
        Predicate<Person> hasMultipleHobbies = p -> p.getHobbies().size() > 2;
        Predicate<Person> nameStartsWithVowel = p -> "AEIOUaeiou".contains(p.getName().substring(0, 1));
        
        System.out.println("Young people who like reading:");
        people.stream()
              .filter(isYoung.and(likesReading))
              .forEach(System.out::println);
        
        System.out.println("\nPeople from Mumbai OR those with multiple hobbies:");
        people.stream()
              .filter(liveInMumbai.or(hasMultipleHobbies))
              .forEach(System.out::println);
        
        System.out.println("\nPeople whose name starts with vowel and are NOT young:");
        people.stream()
              .filter(nameStartsWithVowel.and(isYoung.negate()))
              .forEach(System.out::println);
        
        // Group by predicate results
        Map<Boolean, List<Person>> groupedByAge = people.stream()
            .collect(Collectors.partitioningBy(isYoung));
        
        System.out.println("\nYoung people: " + groupedByAge.get(true).size());
        System.out.println("Older people: " + groupedByAge.get(false).size());
    }
}
```

## Common Mistakes - Avoid Karo! ❌

### 1. **Null Pointer Exception**
```java
// ❌ Wrong - Will throw NPE if string is null
Predicate<String> badPredicate = s -> s.length() > 5;

// ✅ Correct - Safe null check
Predicate<String> safePredicate = s -> s != null && s.length() > 5;
```

### 2. **Expensive Operations in Predicates**
```java
// ❌ Wrong - Database call in predicate (expensive!)
Predicate<User> badPredicate = user -> {
    return database.isUserActive(user.getId());  // Expensive call
};

// ✅ Correct - Pre-fetch data or use caching
Set<Long> activeUserIds = database.getActiveUserIds();  // One call
Predicate<User> goodPredicate = user -> activeUserIds.contains(user.getId());
```

### 3. **Complex Logic in Single Predicate**
```java
// ❌ Wrong - Complex, hard to read
Predicate<Student> complexPredicate = s -> 
    s.getMarks() > 40 && s.getAge() < 25 && 
    s.getDepartment().equals("IT") && s.getAttendance() > 75 && 
    !s.getSubjects().isEmpty() && s.getGPA() > 3.0;

// ✅ Correct - Break into smaller, reusable predicates
Predicate<Student> passed = s -> s.getMarks() > 40;
Predicate<Student> young = s -> s.getAge() < 25;
Predicate<Student> itStudent = s -> "IT".equals(s.getDepartment());
Predicate<Student> goodAttendance = s -> s.getAttendance() > 75;
Predicate<Student> hasSubjects = s -> !s.getSubjects().isEmpty();
Predicate<Student> goodGPA = s -> s.getGPA() > 3.0;

Predicate<Student> eligibleStudent = passed.and(young).and(itStudent)
                                           .and(goodAttendance).and(hasSubjects)
                                           .and(goodGPA);
```

### 4. **Incorrect AND/OR Logic**
```java
// ❌ Wrong understanding
// This checks: (even AND >10) OR (odd AND >10)
// But developer might think: (even OR odd) AND >10
Predicate<Integer> confusing = isEven.and(isGreaterThan10)
                                   .or(isOdd.and(isGreaterThan10));

// ✅ Clear intention
Predicate<Integer> clear = (isEven.or(isOdd)).and(isGreaterThan10);
```

## Best Practices - Follow Karo! ✅

### 1. **Use Descriptive Names**
```java
// ✅ Good - Clear intent
Predicate<User> isActiveUser = user -> user.isActive();
Predicate<Order> isHighValueOrder = order -> order.getAmount() > 10000;
Predicate<Email> isValidEmail = email -> email.contains("@");

// ❌ Bad - Unclear names
Predicate<User> p1 = user -> user.isActive();
Predicate<Order> check = order -> order.getAmount() > 10000;
```

### 2. **Create Predicate Constants**
```java
public class PredicateConstants {
    public static final Predicate<String> IS_NOT_EMPTY = 
        s -> s != null && !s.trim().isEmpty();
    public static final Predicate<Integer> IS_POSITIVE = n -> n > 0;
    public static final Predicate<Integer> IS_EVEN = n -> n % 2 == 0;
    
    // Use throughout application
}
```

### 3. **Use Factory Methods for Parameterized Predicates**
```java
public class PredicateFactory {
    public static Predicate<Integer> isGreaterThan(int threshold) {
        return n -> n > threshold;
    }
    
    public static Predicate<String> hasMinLength(int minLength) {
        return s -> s.length() >= minLength;
    }
    
    public static Predicate<Date> isAfter(Date date) {
        return d -> d.after(date);
    }
}
```

### 4. **Combine with Streams Effectively**
```java
// ✅ Good - Chain operations efficiently
List<Product> result = products.stream()
    .filter(inStock.and(isAffordable))  // Filter first
    .sorted(byPrice)                    // Then sort
    .limit(10)                         // Then limit
    .collect(toList());

// ❌ Less efficient - Sorting before filtering
List<Product> inefficient = products.stream()
    .sorted(byPrice)                    // Sorting all items
    .filter(inStock.and(isAffordable))  // Then filtering
    .limit(10)
    .collect(toList());
```

## Summary - Quick Recap! 📝

### **Key Points to Remember:**

1. **🎯 Predicate = Boolean tester**
   - Takes one input, returns true/false
   - Functional interface with `test(T t)` method

2. **🔗 Predicate Joining:**
   - `and()` = Both conditions true ✅✅
   - `or()` = Any one condition true ✅ or ✅  
   - `negate()` = Opposite result ❌

3. **💪 Real-world Applications:**
   - Data filtering and validation
   - Business rule implementation  
   - Stream operations
   - Collection processing

4. **🚀 Best Practices:**
   - Use descriptive names
   - Create reusable constants
   - Handle null values safely
   - Break complex logic into smaller predicates

5. **⚡ Performance Tips:**
   - Put cheap checks first in AND operations
   - Cache expensive predicate results
   - Use method references when possible

### **When to Use Predicate:**
- ✅ **Filtering collections/streams**
- ✅ **Validation logic**
- ✅ **Business rules**
- ✅ **Conditional processing**
- ✅ **Search criteria**

### **Memory Trick:**
**PREDICATE** = **PRE**-**DICT** karna (Predict/Test करना) ✨

```java
// Simple template to remember:
Predicate<Type> descriptiveName = input -> booleanCondition;

// Examples:
Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<String> isEmail = s -> s.contains("@");
Predicate<User> isActive = u -> u.isActive();
```

Practice these concepts aur tum Predicate master ban jaoge! Functional programming ka ye foundation hai, so isko strong karo! 🎯💪

---
*Happy Functional Programming! 🎉*
