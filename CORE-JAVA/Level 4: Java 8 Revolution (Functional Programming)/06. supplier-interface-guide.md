# Java 8 Supplier Interface - Complete Study Notes üìö

## Supplier Interface Kya Hai Bhai? ü§î

**Simple Words Mein**: Supplier ek **vending machine** ki tarah hai - tum kuch input nahi dete, sirf button dabao aur output mil jata hai! üçø

**Real Life Example**: 
- **Vending Machine** ‚Üí Press button ‚Üí Get snack üç´
- **Supplier Interface** ‚Üí Call get() ‚Üí Get object üì¶

**Technical Definition**: Supplier ek predefined functional interface hai Java 8 mein jo **no input leke output deta hai**.

## Basic Concept - Samajh Jao! üí°

```java
// Traditional way (Java 7 and before)
Date currentDate = new Date();
System.out.println(currentDate);

// Supplier way (Java 8+) 
Supplier<Date> dateSupplier = () -> new Date();
System.out.println(dateSupplier.get());
```

**Key Points:**
- **No Input** leta hai ‚ùå
- **Output** deta hai ‚úÖ  
- **Lambda Expression** support karta hai üéØ
- **Functional Programming** enable karta hai üöÄ

## Supplier Interface Structure üèóÔ∏è

```java
@FunctionalInterface
public interface Supplier<T> {
    /**
     * Gets a result.
     * @return a result
     */
    T get();
}
```

**Important:**
- **Generic Interface**: `<T>` type parameter use karta hai
- **Single Abstract Method**: Sirf `get()` method hai
- **@FunctionalInterface**: Lambda expressions ke liye designed hai
- **Package**: `java.util.function.Supplier`

## Basic Examples - Shuru Karte Hain! üöÄ

### Example 1: Date Supplier (Time Machine!) ‚è∞

```java
import java.util.Date;
import java.util.function.Supplier;

public class DateSupplierExample {
    public static void main(String[] args) {
        // Date supplier create karo
        Supplier<Date> dateSupplier = () -> new Date();
        
        System.out.println("Current Date: " + dateSupplier.get());
        
        // Multiple times call kar sakte ho
        try {
            Thread.sleep(1000); // 1 second wait
            System.out.println("After 1 second: " + dateSupplier.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

**Output:**
```
Current Date: Mon Aug 24 15:30:45 IST 2025
After 1 second: Mon Aug 24 15:30:46 IST 2025
```

### Example 2: Random Number Generator üé≤

```java
import java.util.Random;
import java.util.function.Supplier;

public class RandomSupplierExample {
    public static void main(String[] args) {
        // Random number supplier
        Supplier<Integer> randomSupplier = () -> new Random().nextInt(100);
        
        System.out.println("Random numbers:");
        for (int i = 0; i < 5; i++) {
            System.out.println("Number " + (i + 1) + ": " + randomSupplier.get());
        }
        
        // Different types ke suppliers
        Supplier<Double> doubleSupplier = () -> Math.random() * 100;
        System.out.println("\nRandom double: " + doubleSupplier.get());
    }
}
```

**Output:**
```
Random numbers:
Number 1: 42
Number 2: 17
Number 3: 89
Number 4: 3
Number 5: 66

Random double: 73.45621
```

### Example 3: String Supplier (Message Factory!) üí¨

```java
import java.util.function.Supplier;

public class StringSupplierExample {
    public static void main(String[] args) {
        // Different message suppliers
        Supplier<String> greetingSupplier = () -> "Hello, World!";
        Supplier<String> motivationSupplier = () -> "Keep coding, keep learning!";
        Supplier<String> timeBasedGreeting = () -> {
            int hour = java.time.LocalTime.now().getHour();
            if (hour < 12) return "Good Morning!";
            else if (hour < 18) return "Good Afternoon!";
            else return "Good Evening!";
        };
        
        System.out.println(greetingSupplier.get());
        System.out.println(motivationSupplier.get());
        System.out.println(timeBasedGreeting.get());
    }
}
```

## Real-World Example - Student Management! üéì

### Example 4: Single Student Supplier

```java
import java.util.function.Supplier;

class Student {
    private int id;
    private String name;
    private String gender;
    private String course;
    
    // Constructors
    public Student() {}
    
    public Student(int id, String name, String gender, String course) {
        this.id = id;
        this.name = name;
        this.gender = gender;
        this.course = course;
    }
    
    // Getters and Setters
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public String getGender() { return gender; }
    public void setGender(String gender) { this.gender = gender; }
    
    public String getCourse() { return course; }
    public void setCourse(String course) { this.course = course; }
    
    @Override
    public String toString() {
        return "Student{id=" + id + ", name='" + name + "', gender='" + gender + "', course='" + course + "'}";
    }
}

public class StudentSupplierExample {
    public static void main(String[] args) {
        // Student supplier with lambda expression
        Supplier<Student> studentSupplier = () -> {
            Student student = new Student();
            student.setId(1);
            student.setName("Raj Kumar");
            student.setGender("Male");
            student.setCourse("Computer Science");
            return student;
        };
        
        // Get student object
        Student student = studentSupplier.get();
        System.out.println("Student Details:");
        System.out.println("ID: " + student.getId());
        System.out.println("Name: " + student.getName());
        System.out.println("Gender: " + student.getGender());
        System.out.println("Course: " + student.getCourse());
        System.out.println("\nUsing toString(): " + student);
        
        // Multiple calls - har baar naya object milega
        Student student2 = studentSupplier.get();
        System.out.println("\nAre both objects same? " + (student == student2)); // false
    }
}
```

**Output:**
```
Student Details:
ID: 1
Name: Raj Kumar
Gender: Male
Course: Computer Science

Using toString(): Student{id=1, name='Raj Kumar', gender='Male', course='Computer Science'}

Are both objects same? false
```

### Example 5: Student List Supplier (Bulk Data!) üìã

```java
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

public class StudentListSupplierExample {
    public static void main(String[] args) {
        // List of students supplier
        Supplier<List<Student>> studentsSupplier = () -> {
            List<Student> students = new ArrayList<>();
            
            students.add(new Student(1, "Alice Johnson", "Female", "Computer Science"));
            students.add(new Student(2, "Bob Smith", "Male", "Mathematics"));
            students.add(new Student(3, "Charlie Brown", "Male", "Physics"));
            students.add(new Student(4, "Diana Prince", "Female", "Chemistry"));
            students.add(new Student(5, "Eve Wilson", "Female", "Biology"));
            
            return students;
        };
        
        // Get list of students
        List<Student> studentList = studentsSupplier.get();
        
        System.out.println("List of Students:");
        System.out.println("==================");
        for (Student student : studentList) {
            System.out.printf("ID: %d | Name: %-15s | Gender: %-6s | Course: %s%n", 
                student.getId(), student.getName(), student.getGender(), student.getCourse());
        }
        
        System.out.println("\nTotal Students: " + studentList.size());
    }
}
```

**Output:**
```
List of Students:
==================
ID: 1 | Name: Alice Johnson   | Gender: Female | Course: Computer Science
ID: 2 | Name: Bob Smith       | Gender: Male   | Course: Mathematics
ID: 3 | Name: Charlie Brown   | Gender: Male   | Course: Physics
ID: 4 | Name: Diana Prince    | Gender: Female | Course: Chemistry
ID: 5 | Name: Eve Wilson      | Gender: Female | Course: Biology

Total Students: 5
```

## Advanced Examples - Level Up! üöÄ

### Example 6: Configuration Supplier (Settings Factory!) ‚öôÔ∏è

```java
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

class DatabaseConfig {
    private String host;
    private int port;
    private String username;
    private String database;
    
    public DatabaseConfig(String host, int port, String username, String database) {
        this.host = host;
        this.port = port;
        this.username = username;
        this.database = database;
    }
    
    // Getters
    public String getHost() { return host; }
    public int getPort() { return port; }
    public String getUsername() { return username; }
    public String getDatabase() { return database; }
    
    @Override
    public String toString() {
        return String.format("DatabaseConfig{host='%s', port=%d, username='%s', database='%s'}", 
            host, port, username, database);
    }
}

public class ConfigSupplierExample {
    public static void main(String[] args) {
        // Development config supplier
        Supplier<DatabaseConfig> devConfigSupplier = () -> 
            new DatabaseConfig("localhost", 3306, "dev_user", "dev_database");
        
        // Production config supplier  
        Supplier<DatabaseConfig> prodConfigSupplier = () ->
            new DatabaseConfig("prod.example.com", 5432, "prod_user", "prod_database");
        
        // Test config supplier
        Supplier<DatabaseConfig> testConfigSupplier = () ->
            new DatabaseConfig("test.example.com", 3306, "test_user", "test_database");
        
        // Application properties supplier
        Supplier<Map<String, String>> propertiesSupplier = () -> {
            Map<String, String> props = new HashMap<>();
            props.put("app.name", "Student Management System");
            props.put("app.version", "1.0.0");
            props.put("app.environment", "development");
            return props;
        };
        
        System.out.println("=== Configuration Examples ===");
        System.out.println("Dev Config: " + devConfigSupplier.get());
        System.out.println("Prod Config: " + prodConfigSupplier.get());
        System.out.println("Test Config: " + testConfigSupplier.get());
        
        System.out.println("\n=== Application Properties ===");
        Map<String, String> props = propertiesSupplier.get();
        props.forEach((key, value) -> System.out.println(key + " = " + value));
    }
}
```

### Example 7: Lazy Initialization Pattern! üò¥

```java
import java.util.function.Supplier;

class ExpensiveResource {
    private String resourceData;
    
    public ExpensiveResource() {
        // Simulate expensive initialization
        System.out.println("Creating expensive resource... Please wait!");
        try {
            Thread.sleep(2000); // 2 second delay
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        this.resourceData = "Important data loaded successfully!";
        System.out.println("Expensive resource created!");
    }
    
    public String getData() {
        return resourceData;
    }
}

public class LazyInitializationExample {
    public static void main(String[] args) {
        System.out.println("=== Lazy Initialization with Supplier ===");
        
        // Resource tab create hoga jab get() call karenge
        Supplier<ExpensiveResource> lazyResource = () -> new ExpensiveResource();
        
        System.out.println("Supplier created, but resource not yet initialized!");
        System.out.println("Doing other work...");
        
        // Simulate other work
        for (int i = 1; i <= 3; i++) {
            System.out.println("Working on task " + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        
        System.out.println("\nNow accessing the resource...");
        ExpensiveResource resource = lazyResource.get(); // Ab resource create hoga
        System.out.println("Resource data: " + resource.getData());
        
        // Second call - naya resource create hoga (not cached)
        System.out.println("\nCalling again...");
        ExpensiveResource resource2 = lazyResource.get();
        System.out.println("Are same objects? " + (resource == resource2)); // false
    }
}
```

### Example 8: Stream Integration! üåä

```java
import java.util.List;
import java.util.Random;
import java.util.function.Supplier;
import java.util.stream.Stream;

public class StreamWithSupplierExample {
    public static void main(String[] args) {
        // Random number supplier
        Supplier<Integer> randomSupplier = () -> new Random().nextInt(100);
        
        System.out.println("=== Stream with Supplier ===");
        
        // Generate infinite stream of random numbers
        List<Integer> randomNumbers = Stream.generate(randomSupplier)
                                          .limit(10)  // Limit to 10 numbers
                                          .sorted()   // Sort them
                                          .toList();  // Collect to list
        
        System.out.println("10 Random numbers (sorted): " + randomNumbers);
        
        // Generate stream of messages
        Supplier<String> messageSupplier = () -> {
            String[] messages = {"Hello", "Hi", "Hey", "Greetings", "Welcome"};
            return messages[new Random().nextInt(messages.length)];
        };
        
        System.out.println("\n5 Random greetings:");
        Stream.generate(messageSupplier)
              .limit(5)
              .forEach(System.out::println);
        
        // Generate student IDs
        Supplier<Integer> idSupplier = new Supplier<Integer>() {
            private int counter = 1;
            
            @Override
            public Integer get() {
                return counter++;
            }
        };
        
        System.out.println("\nGenerate 5 sequential IDs:");
        Stream.generate(idSupplier)
              .limit(5)
              .forEach(id -> System.out.println("Student ID: " + id));
    }
}
```

## Method Reference with Supplier üéØ

```java
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Supplier;

public class MethodReferenceSupplierExample {
    public static void main(String[] args) {
        System.out.println("=== Method Reference Examples ===");
        
        // Constructor reference
        Supplier<List<String>> listSupplier = ArrayList::new;
        Supplier<StringBuilder> builderSupplier = StringBuilder::new;
        
        List<String> list = listSupplier.get();
        list.add("Hello");
        list.add("World");
        System.out.println("List: " + list);
        
        StringBuilder sb = builderSupplier.get();
        sb.append("Hello").append(" ").append("Method Reference");
        System.out.println("StringBuilder: " + sb.toString());
        
        // Static method reference
        Supplier<LocalDateTime> timeSupplier = LocalDateTime::now;
        System.out.println("Current time: " + timeSupplier.get());
        
        // Custom method reference
        Supplier<String> customSupplier = MethodReferenceSupplierExample::getWelcomeMessage;
        System.out.println("Custom message: " + customSupplier.get());
    }
    
    public static String getWelcomeMessage() {
        return "Welcome to Java 8 Functional Programming!";
    }
}
```

## Practical Applications - Real World Usage! üåç

### Example 9: Factory Pattern Implementation

```java
import java.util.HashMap;
import java.util.Map;
import java.util.function.Supplier;

// Abstract product
abstract class Vehicle {
    protected String type;
    public abstract void start();
    public String getType() { return type; }
}

// Concrete products
class Car extends Vehicle {
    public Car() { this.type = "Car"; }
    @Override
    public void start() { System.out.println("Car started with ignition key"); }
}

class Bike extends Vehicle {
    public Bike() { this.type = "Bike"; }
    @Override
    public void start() { System.out.println("Bike started with kick/button"); }
}

class Truck extends Vehicle {
    public Truck() { this.type = "Truck"; }
    @Override
    public void start() { System.out.println("Truck started with heavy ignition"); }
}

// Factory using Supplier
class VehicleFactory {
    private static Map<String, Supplier<Vehicle>> vehicleSuppliers = new HashMap<>();
    
    static {
        vehicleSuppliers.put("car", Car::new);
        vehicleSuppliers.put("bike", Bike::new);
        vehicleSuppliers.put("truck", Truck::new);
    }
    
    public static Vehicle createVehicle(String type) {
        Supplier<Vehicle> supplier = vehicleSuppliers.get(type.toLowerCase());
        if (supplier != null) {
            return supplier.get();
        }
        throw new IllegalArgumentException("Unknown vehicle type: " + type);
    }
    
    public static void listAvailableVehicles() {
        System.out.println("Available vehicles: " + vehicleSuppliers.keySet());
    }
}

public class FactoryPatternExample {
    public static void main(String[] args) {
        System.out.println("=== Vehicle Factory Example ===");
        
        VehicleFactory.listAvailableVehicles();
        
        try {
            Vehicle car = VehicleFactory.createVehicle("car");
            Vehicle bike = VehicleFactory.createVehicle("bike");
            Vehicle truck = VehicleFactory.createVehicle("truck");
            
            System.out.println("\nTesting vehicles:");
            car.start();
            bike.start();
            truck.start();
            
        } catch (IllegalArgumentException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
}
```

### Example 10: Caching with Supplier (Memoization!)

```java
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Supplier;

class MemoizedSupplier<T> implements Supplier<T> {
    private final Supplier<T> delegate;
    private volatile T value;
    private volatile boolean computed = false;
    
    public MemoizedSupplier(Supplier<T> delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public T get() {
        if (!computed) {
            synchronized (this) {
                if (!computed) {
                    value = delegate.get();
                    computed = true;
                }
            }
        }
        return value;
    }
    
    public static <T> Supplier<T> memoize(Supplier<T> supplier) {
        return new MemoizedSupplier<>(supplier);
    }
}

public class MemoizationExample {
    public static void main(String[] args) {
        System.out.println("=== Memoization Example ===");
        
        // Expensive computation
        Supplier<String> expensiveComputation = () -> {
            System.out.println("Performing expensive computation...");
            try {
                Thread.sleep(2000); // Simulate expensive work
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            return "Computed Result: " + System.currentTimeMillis();
        };
        
        // Memoized version - result cached after first call
        Supplier<String> memoized = MemoizedSupplier.memoize(expensiveComputation);
        
        System.out.println("First call:");
        long start1 = System.currentTimeMillis();
        String result1 = memoized.get();
        long end1 = System.currentTimeMillis();
        System.out.println("Result: " + result1);
        System.out.println("Time taken: " + (end1 - start1) + "ms");
        
        System.out.println("\nSecond call:");
        long start2 = System.currentTimeMillis();
        String result2 = memoized.get();
        long end2 = System.currentTimeMillis();
        System.out.println("Result: " + result2);
        System.out.println("Time taken: " + (end2 - start2) + "ms");
        
        System.out.println("\nSame result? " + result1.equals(result2));
    }
}
```

## Common Use Cases - Kahan Use Karte Hain! üéØ

### 1. **Factory Methods** üè≠
```java
Supplier<List<String>> listFactory = ArrayList::new;
Supplier<Map<String, Object>> mapFactory = HashMap::new;
```

### 2. **Default Values** üìù
```java
public String getValue(Supplier<String> defaultValue) {
    String value = getFromCache();
    return value != null ? value : defaultValue.get();
}
```

### 3. **Lazy Initialization** üò¥
```java
class LazyService {
    private final Supplier<DatabaseConnection> connectionSupplier;
    
    public LazyService(Supplier<DatabaseConnection> connectionSupplier) {
        this.connectionSupplier = connectionSupplier;
    }
    
    public void doWork() {
        DatabaseConnection conn = connectionSupplier.get(); // Only when needed
        // use connection
    }
}
```

### 4. **Configuration Loading** ‚öôÔ∏è
```java
Supplier<Properties> configSupplier = () -> {
    Properties props = new Properties();
    // Load from file or environment
    return props;
};
```

## Comparison with Other Functional Interfaces üìä

| **Interface** | **Input** | **Output** | **Method** | **Use Case** |
|-------------|----------|-----------|-----------|-------------|
| **Supplier<T>** | None ‚ùå | T ‚úÖ | `get()` | Object creation, factories |
| **Consumer<T>** | T ‚úÖ | None ‚ùå | `accept()` | Side effects, printing |
| **Function<T,R>** | T ‚úÖ | R ‚úÖ | `apply()` | Transformation, mapping |
| **Predicate<T>** | T ‚úÖ | boolean ‚úÖ | `test()` | Filtering, validation |

```java
import java.util.function.*;

public class FunctionalInterfaceComparison {
    public static void main(String[] args) {
        // Supplier - No input, gives output
        Supplier<String> supplier = () -> "Hello World";
        System.out.println("Supplier: " + supplier.get());
        
        // Consumer - Takes input, no output
        Consumer<String> consumer = (s) -> System.out.println("Consumer: " + s);
        consumer.accept("Hello");
        
        // Function - Takes input, gives output
        Function<String, Integer> function = String::length;
        System.out.println("Function: " + function.apply("Hello"));
        
        // Predicate - Takes input, gives boolean
        Predicate<String> predicate = s -> s.startsWith("H");
        System.out.println("Predicate: " + predicate.test("Hello"));
    }
}
```

## Error Handling in Supplier üö®

```java
import java.util.function.Supplier;

public class SupplierErrorHandlingExample {
    public static void main(String[] args) {
        // Supplier that might throw exception
        Supplier<Integer> riskySupplier = () -> {
            if (Math.random() < 0.5) {
                throw new RuntimeException("Random failure!");
            }
            return 42;
        };
        
        // Safe wrapper
        Supplier<Integer> safeSupplier = () -> {
            try {
                return riskySupplier.get();
            } catch (Exception e) {
                System.out.println("Error occurred: " + e.getMessage());
                return -1; // Default value
            }
        };
        
        // Test multiple times
        for (int i = 0; i < 5; i++) {
            System.out.println("Attempt " + (i + 1) + ": " + safeSupplier.get());
        }
        
        // Optional-based error handling
        Supplier<String> optionalSupplier = () -> {
            try {
                // Some operation that might fail
                return "Success!";
            } catch (Exception e) {
                return null;
            }
        };
    }
}
```

## Interview Questions - Master Karo! üí™

### Q1: **Supplier vs Factory Method pattern?**
```java
// Traditional Factory Method
class VehicleFactory {
    public static Vehicle createVehicle(String type) {
        if ("car".equals(type)) return new Car();
        if ("bike".equals(type)) return new Bike();
        return null;
    }
}

// Supplier-based Factory
Map<String, Supplier<Vehicle>> factories = Map.of(
    "car", Car::new,
    "bike", Bike::new
);
Vehicle vehicle = factories.get("car").get();
```
**Answer**: Supplier zyada flexible hai aur lambda expressions support karta hai.

### Q2: **Can Supplier throw checked exceptions?**
```java
// This won't compile - Supplier doesn't declare checked exceptions
// Supplier<String> supplier = () -> {
//     throw new IOException("File not found");
// };

// Solution: Wrap in RuntimeException or use custom functional interface
Supplier<String> supplier = () -> {
    try {
        // operation that throws IOException
        return readFile();
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
};
```
**Answer**: Directly nahi, but RuntimeException mein wrap kar sakte hain.

### Q3: **Supplier vs Callable?**
```java
import java.util.concurrent.Callable;

// Supplier - no checked exception
Supplier<String> supplier = () -> "Hello";

// Callable - can throw checked exception
Callable<String> callable = () -> "Hello";
```
**Answer**: Callable checked exceptions throw kar sakta hai, Supplier nahi.

### Q4: **Lazy evaluation with Supplier?**
```java
public class LazyEvaluation {
    public static void processIfNeeded(boolean condition, Supplier<String> expensiveOperation) {
        if (condition) {
            String result = expensiveOperation.get(); // Only execute if needed
            System.out.println(result);
        }
    }
    
    public static void main(String[] args) {
        processIfNeeded(false, () -> {
            System.out.println("Expensive operation"); // Won't execute
            return "Result";
        });
    }
}
```
**Answer**: Supplier lazy evaluation provide karta hai - sirf tab execute hota hai jab get() call karo.

## Best Practices üåü

### 1. **Use Method References When Possible**
```java
// ‚úÖ Good
Supplier<List<String>> listSupplier = ArrayList::new;
Supplier<String> stringSupplier = String::new;

// ‚ùå Unnecessary lambda
Supplier<List<String>> listSupplier2 = () -> new ArrayList<>();
```

### 2. **Avoid Side Effects in Suppliers**
```java
// ‚ùå Bad - side effects
private int counter = 0;
Supplier<Integer> badSupplier = () -> ++counter;

// ‚úÖ Good - pure function
Supplier<Integer> goodSupplier = () -> new Random().nextInt();
```

### 3. **Use for Expensive Object Creation**
```java
// ‚úÖ Good - create only when needed
public class ServiceManager {
    private final Supplier<ExpensiveService> serviceSupplier;
    
    public ServiceManager(Supplier<ExpensiveService> serviceSupplier) {
        this.serviceSupplier = serviceSupplier;
    }
    
    public void doWork() {
        if (needsService()) {
            ExpensiveService service = serviceSupplier.get();
            service.performWork();
        }
    }
}
```

### 4. **Combine with Optional for Null Safety**
```java
import java.util.Optional;

public class SafeSupplier {
    public static <T> Optional<T> safeGet(Supplier<T> supplier) {
        try {
            return Optional.ofNullable(supplier.get());
        } catch (Exception e) {
            return Optional.empty();
        }
    }
    
    public static void main(String[] args) {
        Supplier<String> riskySupplier = () -> null;
        
        Optional<String> result = safeGet(riskySupplier);
        result.ifPresentOrElse(
            System.out::println,
            () -> System.out.println("No value available")
        );
    }
}
```

## Summary - Quick Recap! üìù

### **Key Points to Remember:**
1. üéØ **No Input**: Supplier ‡§ï‡•ã‡§à parameter ‡§®‡§π‡•Ä‡§Ç ‡§≤‡•á‡§§‡§æ
2. üì¶ **Returns Output**: ‡§π‡§Æ‡•á‡§∂‡§æ ‡§ï‡•Å‡§õ ‡§® ‡§ï‡•Å‡§õ return ‡§ï‡§∞‡§§‡§æ ‡§π‡•à
3. üöÄ **Lazy Execution**: ‡§ú‡§¨ ‡§ö‡§æ‡§π‡•ã ‡§§‡§¨ object ‡§¨‡§®‡§æ‡§ì
4. üè≠ **Factory Pattern**: Object creation ‡§ï‡•á ‡§≤‡§ø‡§è perfect
5. üåä **Stream Integration**: Stream.generate() ‡§ï‡•á ‡§∏‡§æ‡§• use ‡§π‡•ã‡§§‡§æ ‡§π‡•à
6. üîÑ **Reusable**: Multiple times call ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•ã
7. ‚ö° **Functional Programming**: Lambda expressions support

### **When to Use Supplier:**
- ‚úÖ Object factories ‡§¨‡§®‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è
- ‚úÖ Lazy initialization ‡§ï‡•á ‡§≤‡§ø‡§è  
- ‚úÖ Default values provide ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è
- ‚úÖ Configuration loading ‡§ï‡•á ‡§≤‡§ø‡§è
- ‚úÖ Random data generation ‡§ï‡•á ‡§≤‡§ø‡§è
- ‚úÖ Stream data sources ‡§ï‡•á ‡§≤‡§ø‡§è

### **Common Patterns:**
```java
// Factory Pattern
Supplier<DatabaseConnection> connectionFactory = DatabaseConnection::new;

// Lazy Loading
Supplier<ExpensiveResource> lazyResource = () -> new ExpensiveResource();

// Default Value Provider
public String getConfigValue(String key, Supplier<String> defaultValue) {
    String value = config.get(key);
    return value != null ? value : defaultValue.get();
}

// Stream Generation
Stream<Integer> randomNumbers = Stream.generate(() -> new Random().nextInt(100));
```

### **Memory Tricks:**
- **SUPPLIER** = **SUPPLY** karta hai objects üì¶
- **No INPUT** = ‡§ï‡•Å‡§õ ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§æ‡§Ç‡§ó‡§§‡§æ üö´
- **Only OUTPUT** = ‡§∏‡§ø‡§∞‡•ç‡§´ ‡§¶‡•á‡§§‡§æ ‡§π‡•à ‚úÖ
- **GET() method** = ‡§ú‡•ã ‡§ö‡§æ‡§π‡§ø‡§è ‡§µ‡•ã ‡§Æ‡§ø‡§≤‡§§‡§æ ‡§π‡•à üéØ

### **Advantages:**
1. üéØ **Lazy Evaluation** - ‡§ú‡§¨ ‡§ö‡§æ‡§π‡§ø‡§è ‡§§‡§¨ ‡§¨‡§®‡§æ‡§ì
2. üîÑ **Reusability** - ‡§¨‡§æ‡§∞-‡§¨‡§æ‡§∞ use ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•ã  
3. üèóÔ∏è **Factory Pattern** - Clean object creation
4. ‚ö° **Performance** - Memory efficient (lazy loading)
5. üåä **Stream Integration** - Infinite streams ‡§¨‡§®‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•ã
6. üß™ **Testing** - Easy to mock ‡§î‡§∞ test
7. üìù **Clean Code** - Lambda expressions ‡§ï‡•á ‡§∏‡§æ‡§• readable

### **Disadvantages:**
1. ‚ö†Ô∏è **No Caching** - ‡§π‡§∞ ‡§¨‡§æ‡§∞ ‡§®‡§Ø‡§æ object (unless memoized)
2. üö® **Exception Handling** - Checked exceptions handle ‡§ï‡§∞‡§®‡§æ tricky
3. üí≠ **Memory Usage** - ‡§Ö‡§ó‡§∞ heavy objects ‡§¨‡§®‡§æ ‡§∞‡§π‡•á ‡§π‡•ã
4. üîç **Debugging** - Lambda expressions debug ‡§ï‡§∞‡§®‡§æ mushkil

### **Real-World Applications:**
- üè≠ **Factory Methods** - Object creation factories
- üîß **Configuration Management** - Settings aur properties
- üìä **Data Generation** - Test data, random values
- üéÆ **Game Development** - Random events, power-ups
- üåê **Web Services** - Default responses, fallback values
- üì± **Mobile Apps** - Lazy resource loading
- üîê **Security** - Token generation, random keys

### **Integration with Other Java 8 Features:**

#### **With Optional:**
```java
public Optional<String> getValueSafely(Supplier<String> supplier) {
    try {
        return Optional.ofNullable(supplier.get());
    } catch (Exception e) {
        return Optional.empty();
    }
}
```

#### **With CompletableFuture:**
```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // Expensive computation
    return "Result";
});
```

#### **With Streams:**
```java
// Generate infinite stream
Stream<Double> randomNumbers = Stream.generate(Math::random);

// Generate finite stream  
List<Integer> numbers = Stream.generate(() -> new Random().nextInt(100))
                             .limit(10)
                             .collect(toList());
```

## Performance Tips üöÄ

### 1. **Memoization for Expensive Operations**
```java
public static <T> Supplier<T> memoize(Supplier<T> original) {
    return new Supplier<T>() {
        T value;
        boolean cached = false;
        
        @Override
        public synchronized T get() {
            if (!cached) {
                value = original.get();
                cached = true;
            }
            return value;
        }
    };
}

// Usage
Supplier<ExpensiveObject> expensive = () -> new ExpensiveObject();
Supplier<ExpensiveObject> memoized = memoize(expensive);
```

### 2. **Thread-Safe Suppliers**
```java
public class ThreadSafeSupplier<T> implements Supplier<T> {
    private final Supplier<T> delegate;
    private volatile T instance;
    
    public ThreadSafeSupplier(Supplier<T> delegate) {
        this.delegate = delegate;
    }
    
    @Override
    public T get() {
        T result = instance;
        if (result == null) {
            synchronized (this) {
                result = instance;
                if (result == null) {
                    instance = result = delegate.get();
                }
            }
        }
        return result;
    }
}
```

### 3. **Batch Processing with Suppliers**
```java
public class BatchSupplier<T> implements Supplier<List<T>> {
    private final Supplier<T> itemSupplier;
    private final int batchSize;
    
    public BatchSupplier(Supplier<T> itemSupplier, int batchSize) {
        this.itemSupplier = itemSupplier;
        this.batchSize = batchSize;
    }
    
    @Override
    public List<T> get() {
        return Stream.generate(itemSupplier)
                    .limit(batchSize)
                    .collect(toList());
    }
}

// Usage
Supplier<List<Integer>> batchSupplier = new BatchSupplier<>(() -> new Random().nextInt(100), 50);
```

## Testing with Suppliers üß™

```java
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

public class SupplierTest {
    
    @Test
    public void testStudentSupplier() {
        // Arrange
        Supplier<Student> studentSupplier = () -> 
            new Student(1, "Test Student", "Male", "Computer Science");
        
        // Act
        Student student = studentSupplier.get();
        
        // Assert
        assertNotNull(student);
        assertEquals(1, student.getId());
        assertEquals("Test Student", student.getName());
    }
    
    @Test
    public void testSupplierWithMocking() {
        // Mock expensive service
        Supplier<String> mockSupplier = () -> "Mocked Result";
        
        // Test
        String result = mockSupplier.get();
        assertEquals("Mocked Result", result);
    }
    
    @Test
    public void testLazyInitialization() {
        // Counter to track calls
        AtomicInteger callCount = new AtomicInteger(0);
        
        Supplier<String> lazySupplier = () -> {
            callCount.incrementAndGet();
            return "Lazy Result";
        };
        
        // No calls yet
        assertEquals(0, callCount.get());
        
        // First call
        lazySupplier.get();
        assertEquals(1, callCount.get());
        
        // Second call - new object created
        lazySupplier.get();
        assertEquals(2, callCount.get());
    }
}
```

## Advanced Patterns üéì

### 1. **Conditional Supplier**
```java
public static <T> Supplier<T> conditional(boolean condition, 
                                         Supplier<T> trueSupplier, 
                                         Supplier<T> falseSupplier) {
    return () -> condition ? trueSupplier.get() : falseSupplier.get();
}

// Usage
Supplier<String> messageSupplier = conditional(
    isDebugMode(),
    () -> "Debug: Detailed message",
    () -> "Info: Simple message"
);
```

### 2. **Chaining Suppliers**
```java
public static <T, R> Supplier<R> chain(Supplier<T> supplier, Function<T, R> mapper) {
    return () -> mapper.apply(supplier.get());
}

// Usage
Supplier<Integer> numberSupplier = () -> 10;
Supplier<String> stringSupplier = chain(numberSupplier, Object::toString);
```

### 3. **Retry Supplier**
```java
public static <T> Supplier<T> retry(Supplier<T> supplier, int maxAttempts) {
    return () -> {
        Exception lastException = null;
        for (int i = 0; i < maxAttempts; i++) {
            try {
                return supplier.get();
            } catch (Exception e) {
                lastException = e;
                if (i < maxAttempts - 1) {
                    try {
                        Thread.sleep(100); // Wait before retry
                    } catch (InterruptedException ie) {
                        Thread.currentThread().interrupt();
                        throw new RuntimeException(ie);
                    }
                }
            }
        }
        throw new RuntimeException("Failed after " + maxAttempts + " attempts", lastException);
    };
}
```

## Supplier Variants in Java 8+ üîÑ

### **Primitive Specialized Suppliers:**

```java
import java.util.function.*;

public class PrimitiveSuppliers {
    public static void main(String[] args) {
        // IntSupplier - returns int
        IntSupplier intSupplier = () -> new Random().nextInt(100);
        System.out.println("Random int: " + intSupplier.getAsInt());
        
        // LongSupplier - returns long
        LongSupplier longSupplier = () -> System.currentTimeMillis();
        System.out.println("Current timestamp: " + longSupplier.getAsLong());
        
        // DoubleSupplier - returns double
        DoubleSupplier doubleSupplier = Math::random;
        System.out.println("Random double: " + doubleSupplier.getAsDouble());
        
        // BooleanSupplier - returns boolean
        BooleanSupplier booleanSupplier = () -> new Random().nextBoolean();
        System.out.println("Random boolean: " + booleanSupplier.getAsBoolean());
    }
}
```

### **Benefits of Primitive Suppliers:**
- üì¶ **No Boxing/Unboxing** - Better performance
- üíæ **Memory Efficient** - Direct primitive types
- ‚ö° **Faster Execution** - No object wrapper overhead

## Final Example - Complete Application! üéØ

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.function.Supplier;
import java.util.stream.Collectors;

// Complete Student Management System using Suppliers
class StudentManagementSystem {
    
    // Student class
    static class Student {
        private final int id;
        private final String name;
        private final String course;
        private final LocalDateTime enrollmentDate;
        
        public Student(int id, String name, String course) {
            this.id = id;
            this.name = name;
            this.course = course;
            this.enrollmentDate = LocalDateTime.now();
        }
        
        // Getters
        public int getId() { return id; }
        public String getName() { return name; }
        public String getCourse() { return course; }
        public LocalDateTime getEnrollmentDate() { return enrollmentDate; }
        
        @Override
        public String toString() {
            return String.format("Student{id=%d, name='%s', course='%s', enrolled=%s}", 
                id, name, course, enrollmentDate.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
        }
    }
    
    // ID Generator using Supplier
    static class IdGenerator {
        private static int counter = 1;
        
        public static final Supplier<Integer> NEXT_ID = () -> counter++;
    }
    
    // Student Factory
    static class StudentFactory {
        private static final List<String> COURSES = Arrays.asList(
            "Computer Science", "Mathematics", "Physics", "Chemistry", "Biology"
        );
        
        private static final List<String> NAMES = Arrays.asList(
            "Alice", "Bob", "Charlie", "Diana", "Eve", "Frank", "Grace", "Henry"
        );
        
        // Random student supplier
        public static final Supplier<Student> RANDOM_STUDENT = () -> {
            Random random = new Random();
            String name = NAMES.get(random.nextInt(NAMES.size()));
            String course = COURSES.get(random.nextInt(COURSES.size()));
            return new Student(IdGenerator.NEXT_ID.get(), name, course);
        };
        
        // Specific student suppliers
        public static Supplier<Student> createStudentSupplier(String name, String course) {
            return () -> new Student(IdGenerator.NEXT_ID.get(), name, course);
        }
        
        // Batch student supplier
        public static Supplier<List<Student>> createBatchSupplier(int count) {
            return () -> {
                return Collections.nCopies(count, RANDOM_STUDENT)
                                 .stream()
                                 .map(Supplier::get)
                                 .collect(Collectors.toList());
            };
        }
    }
    
    // Main application
    public static void main(String[] args) {
        System.out.println("=== Student Management System ===\n");
        
        // 1. Create individual students
        System.out.println("1. Creating individual students:");
        Student student1 = StudentFactory.createStudentSupplier("John Doe", "Computer Science").get();
        Student student2 = StudentFactory.createStudentSupplier("Jane Smith", "Mathematics").get();
        
        System.out.println(student1);
        System.out.println(student2);
        
        // 2. Create random students
        System.out.println("\n2. Creating random students:");
        for (int i = 0; i < 3; i++) {
            System.out.println(StudentFactory.RANDOM_STUDENT.get());
        }
        
        // 3. Create batch of students
        System.out.println("\n3. Creating batch of students:");
        List<Student> batch = StudentFactory.createBatchSupplier(5).get();
        batch.forEach(System.out::println);
        
        // 4. Statistics using suppliers
        System.out.println("\n4. Statistics:");
        Supplier<Long> totalStudentsSupplier = () -> (long) IdGenerator.counter - 1;
        
        System.out.println("Total students created: " + totalStudentsSupplier.get());
        
        // 5. Course distribution
        System.out.println("\n5. Course distribution in batch:");
        Map<String, Long> courseDistribution = batch.stream()
            .collect(Collectors.groupingBy(Student::getCourse, Collectors.counting()));
        
        courseDistribution.forEach((course, count) -> 
            System.out.println(course + ": " + count + " students"));
        
        // 6. Lazy report generation
        System.out.println("\n6. Lazy report generation:");
        Supplier<String> reportSupplier = () -> {
            StringBuilder report = new StringBuilder();
            report.append("=== STUDENT REPORT ===\n");
            report.append("Generated at: ").append(LocalDateTime.now()).append("\n");
            report.append("Total students: ").append(totalStudentsSupplier.get()).append("\n");
            report.append("Latest batch size: ").append(batch.size()).append("\n");
            return report.toString();
        };
        
        // Report generated only when needed
        System.out.println(reportSupplier.get());
    }
}
```

**Output Example:**
```
=== Student Management System ===

1. Creating individual students:
Student{id=1, name='John Doe', course='Computer Science', enrolled=2025-08-24 15:30}
Student{id=2, name='Jane Smith', course='Mathematics', enrolled=2025-08-24 15:30}

2. Creating random students:
Student{id=3, name='Alice', course='Physics', enrolled=2025-08-24 15:30}
Student{id=4, name='Bob', course='Chemistry', enrolled=2025-08-24 15:30}
Student{id=5, name='Charlie', course='Biology', enrolled=2025-08-24 15:30}

3. Creating batch of students:
Student{id=6, name='Diana', course='Computer Science', enrolled=2025-08-24 15:30}
Student{id=7, name='Eve', course='Mathematics', enrolled=2025-08-24 15:30}
Student{id=8, name='Frank', course='Physics', enrolled=2025-08-24 15:30}
Student{id=9, name='Grace', course='Chemistry', enrolled=2025-08-24 15:30}
Student{id=10, name='Henry', course='Biology', enrolled=2025-08-24 15:30}

4. Statistics:
Total students created: 10

5. Course distribution in batch:
Computer Science: 1 students
Mathematics: 1 students
Physics: 1 students
Chemistry: 1 students
Biology: 1 students

6. Lazy report generation:
=== STUDENT REPORT ===
Generated at: 2025-08-24T15:30:45.123
Total students: 10
Latest batch size: 5
```

## Conclusion - Mastery Complete! üèÜ

**Supplier Interface** Java 8 ka ‡§è‡§ï powerful tool ‡§π‡•à ‡§ú‡•ã **functional programming** ‡§ï‡•ã enable ‡§ï‡§∞‡§§‡§æ ‡§π‡•à‡•§ ‡§Ø‡§π especially useful ‡§π‡•à ‡§ú‡§¨ ‡§Ü‡§™‡§ï‡•ã:

### **‚úÖ Key Benefits:**
1. **Lazy Object Creation** - ‡§ú‡§¨ ‡§ö‡§æ‡§π‡§ø‡§è ‡§§‡§¨ ‡§¨‡§®‡§æ‡§ì
2. **Clean Factory Pattern** - Elegant object factories
3. **Functional Programming** - Lambda expressions ‡§ï‡•á ‡§∏‡§æ‡§•
4. **Stream Integration** - Infinite data generation
5. **Testing Friendly** - Easy mocking ‡§î‡§∞ testing
6. **Memory Efficient** - Resource optimization

### **üéØ Remember:**
- **No Parameters** - ‡§ï‡•Å‡§õ input ‡§®‡§π‡•Ä‡§Ç ‡§≤‡•á‡§§‡§æ
- **Returns Value** - ‡§π‡§Æ‡•á‡§∂‡§æ ‡§ï‡•Å‡§õ output ‡§¶‡•á‡§§‡§æ ‡§π‡•à  
- **Functional Interface** - Single abstract method (`get()`)
- **Lambda Ready** - Modern Java programming style

### **üöÄ Practice Tips:**
1. Real projects ‡§Æ‡•á‡§Ç factory patterns implement ‡§ï‡§∞‡•ã
2. Stream.generate() ‡§ï‡•á ‡§∏‡§æ‡§• experiment ‡§ï‡§∞‡•ã  
3. Lazy initialization patterns practice ‡§ï‡§∞‡•ã
4. Different primitive suppliers try ‡§ï‡§∞‡•ã
5. Error handling techniques master ‡§ï‡§∞‡•ã

**Final Mantra:**
*"‡§ú‡§¨ Object factory ‡§¨‡§®‡§æ‡§®‡•Ä ‡§π‡•ã, Supplier ‡§ï‡•ã ‡§Ø‡§æ‡§¶ ‡§ï‡§∞‡•ã!"* üéØ

---

**Happy Coding with Java 8 Functional Programming! üéâ**
