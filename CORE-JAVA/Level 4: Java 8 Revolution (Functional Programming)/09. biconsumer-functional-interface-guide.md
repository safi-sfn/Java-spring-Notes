# üéØ BiConsumer Functional Interface in Java 8 - Complete Study Notes

---

## ü§î Introduction - Confusion Clear Karte Hain!

### Simple Explanation First üìù
Bhai, **BiConsumer** matlab "‡§¶‡•ã ‡§ö‡•Ä‡§ú‡§º‡•á‡§Ç ‡§≤‡•á‡§ï‡§∞ ‡§ï‡•Å‡§õ ‡§ï‡§∞‡§®‡§æ"! Simple words mein - ye ek functional interface hai jo **‡§¶‡•ã arguments** ‡§≤‡•á‡§§‡§æ ‡§π‡•à, ‡§â‡§® ‡§™‡§∞ ‡§ï‡•ã‡§à operation perform ‡§ï‡§∞‡§§‡§æ ‡§π‡•à, ‡§î‡§∞ **‡§ï‡•Å‡§õ return ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡§æ**.

### Real-Life Analogy üçï
Socho ki tum pizza banane wale cook ho:
- **Input 1**: Pizza base (T type)
- **Input 2**: Toppings (U type) 
- **Action**: Toppings ‡§ï‡•ã base ‡§™‡§∞ ‡§°‡§æ‡§≤‡§®‡§æ
- **Output**: Kuch return ‡§®‡§π‡•Ä‡§Ç, bas pizza ready ho ‡§ó‡§Ø‡§æ!

```java
BiConsumer<PizzaBase, Toppings> makePizza = (base, toppings) -> {
    base.addToppings(toppings); // Kaam ho gaya, return kuch nahi!
};
```

### Technical Definition üéì
> BiConsumer<T,U> ek predefined functional interface hai jo exactly **‡§¶‡•ã parameters** accept ‡§ï‡§∞‡§§‡§æ ‡§π‡•à ‡§î‡§∞ **void return type** ‡§∞‡§ñ‡§§‡§æ ‡§π‡•à‡•§

---

## üîë Key Terms/Concepts

### üìö Important Terminology

| Term | Hindi Meaning | Explanation |
|------|---------------|-------------|
| **BiConsumer** | ‡§¶‡•ã-‡§â‡§™‡§≠‡•ã‡§ï‡•ç‡§§‡§æ | Takes 2 inputs, returns nothing |
| **Functional Interface** | ‡§´‡§Ç‡§ï‡•ç‡§∂‡§®‡§≤ ‡§á‡§Ç‡§ü‡§∞‡§´‡§º‡•á‡§∏ | Interface with exactly 1 abstract method |
| **SAM** | ‡§è‡§ï ‡§Ö‡§Æ‡•Ç‡§∞‡•ç‡§§ ‡§µ‡§ø‡§ß‡§ø | Single Abstract Method |
| **Lambda Expression** | ‡§≤‡•à‡§Æ‡•ç‡§¨‡•ç‡§°‡§æ ‡§è‡§ï‡•ç‡§∏‡§™‡•ç‡§∞‡•á‡§∂‡§® | Short form to write functions |

### üèóÔ∏è Structure Samjhte Hain:

```
      BiConsumer<T, U>
            |
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ   accept()     ‚îÇ  ‚Üê SAM Method
    ‚îÇ   andThen()    ‚îÇ  ‚Üê Default Method
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üí° Detailed Examples

### üéØ Basic BiConsumer Example

```java
import java.util.function.BiConsumer;

public class BiConsumerBasic {
    public static void main(String[] args) {
        // Simple addition operation
        BiConsumer<Integer, Integer> addNumbers = (a, b) -> {
            System.out.println("Sum: " + (a + b));
        };
        
        addNumbers.accept(5, 3); // Output: Sum: 8
        
        // String concatenation
        BiConsumer<String, String> combineNames = (firstName, lastName) -> {
            System.out.println("Full Name: " + firstName + " " + lastName);
        };
        
        combineNames.accept("Rahul", "Sharma"); // Output: Full Name: Rahul Sharma
    }
}
```

**Expected Output:**
```
Sum: 8
Full Name: Rahul Sharma
```

### üè¢ Real-World Employee Example (From Source)

```java
import java.util.ArrayList;
import java.util.List;
import java.util.function.BiConsumer;

class Employee {
    String name;
    double salary;
    
    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }
    
    @Override
    public String toString() {
        return "Employee{name='" + name + "', salary=" + salary + "}";
    }
}

public class BiConsumerEmployeeExample {
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        
        // Employee list banate hain
        employees.add(new Employee("Raj", 25000));
        employees.add(new Employee("Priya", 30000));
        employees.add(new Employee("Amit", 35000));
        
        System.out.println("=== Original Salaries ===");
        employees.forEach(System.out::println);
        
        // BiConsumer for salary increment
        BiConsumer<Employee, Double> incrementSalary = (emp, increment) -> {
            emp.salary += increment;
            System.out.println("üí∞ " + emp.name + " ki salary badh gayi by " + increment);
        };
        
        // Sabko 5000 increment dete hain
        System.out.println("\n=== Applying Increments ===");
        employees.forEach(emp -> incrementSalary.accept(emp, 5000.0));
        
        System.out.println("\n=== Updated Salaries ===");
        employees.forEach(System.out::println);
    }
}
```

**Expected Output:**
```
=== Original Salaries ===
Employee{name='Raj', salary=25000.0}
Employee{name='Priya', salary=30000.0}
Employee{name='Amit', salary=35000.0}

=== Applying Increments ===
üí∞ Raj ki salary badh gayi by 5000.0
üí∞ Priya ki salary badh gayi by 5000.0
üí∞ Amit ki salary badh gayi by 5000.0

=== Updated Salaries ===
Employee{name='Raj', salary=30000.0}
Employee{name='Priya', salary=35000.0}
Employee{name='Amit', salary=40000.0}
```

### üîó andThen() Method Example

```java
import java.util.function.BiConsumer;

public class BiConsumerAndThenExample {
    public static void main(String[] args) {
        // First BiConsumer - Print info
        BiConsumer<String, Integer> printInfo = (name, age) -> {
            System.out.println("üìù Processing: " + name + " (Age: " + age + ")");
        };
        
        // Second BiConsumer - Check eligibility
        BiConsumer<String, Integer> checkEligibility = (name, age) -> {
            if (age >= 18) {
                System.out.println("‚úÖ " + name + " is eligible to vote!");
            } else {
                System.out.println("‚ùå " + name + " is not eligible to vote yet!");
            }
        };
        
        // Chain karte hain using andThen()
        BiConsumer<String, Integer> processAndCheck = printInfo.andThen(checkEligibility);
        
        System.out.println("=== Processing Voters ===");
        processAndCheck.accept("Rahul", 25);
        System.out.println();
        processAndCheck.accept("Ananya", 16);
    }
}
```

**Expected Output:**
```
=== Processing Voters ===
üìù Processing: Rahul (Age: 25)
‚úÖ Rahul is eligible to vote!

üìù Processing: Ananya (Age: 16)
‚ùå Ananya is not eligible to vote yet!
```

---

## üìã Rules/Guidelines

### ‚úÖ Correct Usage Rules

1. **Rule 1**: BiConsumer ‡§π‡§Æ‡•á‡§∂‡§æ exactly 2 parameters ‡§≤‡•á‡§§‡§æ ‡§π‡•à
   ```java
   ‚úÖ BiConsumer<String, Integer> correct = (s, i) -> System.out.println(s + i);
   ‚ùå BiConsumer<String> wrong; // Compilation Error!
   ```

2. **Rule 2**: Return type ‡§π‡§Æ‡•á‡§∂‡§æ void ‡§π‡•ã‡§§‡§æ ‡§π‡•à
   ```java
   ‚úÖ BiConsumer<Integer, Integer> add = (a, b) -> System.out.println(a + b);
   ‚ùå BiConsumer<Integer, Integer> wrong = (a, b) -> return a + b; // Error!
   ```

3. **Rule 3**: Lambda expression ‡§Ø‡§æ method reference use ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç
   ```java
   ‚úÖ BiConsumer<String, String> lambda = (a, b) -> System.out.println(a + b);
   ‚úÖ BiConsumer<PrintStream, String> methodRef = PrintStream::println;
   ```

4. **Rule 4**: andThen() null parameter accept ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡§§‡§æ
   ```java
   ‚úÖ consumer1.andThen(consumer2);
   ‚ùå consumer1.andThen(null); // NullPointerException!
   ```

### Common Error Examples:

```java
// ‚ùå Wrong - Too many parameters
BiConsumer<String, Integer, Double> wrong = (s, i, d) -> {}; 
// Error: BiConsumer cannot be applied to <String,Integer,Double>

// ‚ùå Wrong - Trying to return something
BiConsumer<Integer, Integer> wrongReturn = (a, b) -> return a + b;
// Error: Unexpected return value

// ‚ùå Wrong - Not enough parameters
BiConsumer<String> incomplete = s -> System.out.println(s);
// Error: BiConsumer expects 2 type parameters
```

---

## üåç Real-world Applications

### üè¶ Banking System Example

```java
import java.util.function.BiConsumer;
import java.time.LocalDateTime;

class BankAccount {
    private String accountNumber;
    private double balance;
    
    public BankAccount(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }
    
    // Getters and setters
    public String getAccountNumber() { return accountNumber; }
    public double getBalance() { return balance; }
    public void setBalance(double balance) { this.balance = balance; }
    
    @Override
    public String toString() {
        return "Account: " + accountNumber + ", Balance: ‚Çπ" + balance;
    }
}

public class BankingBiConsumerExample {
    public static void main(String[] args) {
        BankAccount account = new BankAccount("ACC001", 10000);
        
        System.out.println("Initial State: " + account);
        
        // BiConsumer for deposit
        BiConsumer<BankAccount, Double> deposit = (acc, amount) -> {
            acc.setBalance(acc.getBalance() + amount);
            System.out.println("üí≥ Deposited ‚Çπ" + amount + " at " + LocalDateTime.now());
        };
        
        // BiConsumer for withdrawal
        BiConsumer<BankAccount, Double> withdraw = (acc, amount) -> {
            if (acc.getBalance() >= amount) {
                acc.setBalance(acc.getBalance() - amount);
                System.out.println("üí∏ Withdrawn ‚Çπ" + amount + " at " + LocalDateTime.now());
            } else {
                System.out.println("‚ùå Insufficient balance!");
            }
        };
        
        // Transactions
        deposit.accept(account, 5000.0);
        System.out.println("After Deposit: " + account);
        
        withdraw.accept(account, 3000.0);
        System.out.println("After Withdrawal: " + account);
    }
}
```

### üõí E-commerce Cart System

```java
import java.util.function.BiConsumer;

class Product {
    String name;
    double price;
    
    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
    
    @Override
    public String toString() {
        return name + " (‚Çπ" + price + ")";
    }
}

class ShoppingCart {
    double totalAmount = 0;
    int itemCount = 0;
    
    @Override
    public String toString() {
        return "Cart: " + itemCount + " items, Total: ‚Çπ" + totalAmount;
    }
}

public class EcommerceBiConsumerExample {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        
        // BiConsumer to add product to cart
        BiConsumer<ShoppingCart, Product> addToCart = (c, product) -> {
            c.totalAmount += product.price;
            c.itemCount++;
            System.out.println("üõí Added " + product + " to cart");
        };
        
        // Products
        Product laptop = new Product("Laptop", 45000);
        Product mouse = new Product("Mouse", 800);
        Product keyboard = new Product("Keyboard", 1200);
        
        System.out.println("=== Shopping Session ===");
        System.out.println("Initial: " + cart);
        
        addToCart.accept(cart, laptop);
        System.out.println("Current: " + cart);
        
        addToCart.accept(cart, mouse);
        System.out.println("Current: " + cart);
        
        addToCart.accept(cart, keyboard);
        System.out.println("Final: " + cart);
    }
}
```

---

## üÜö Comparison Tables

### BiConsumer vs Consumer vs BiFunction

| Feature | Consumer<T> | BiConsumer<T,U> | BiFunction<T,U,R> |
|---------|-------------|-----------------|-------------------|
| **Parameters** | 1 | 2 | 2 |
| **Return Type** | void | void | R (Generic) |
| **Use Case** | Single input operation | Two input operation | Two input with result |
| **Example** | `s -> print(s)` | `(s,i) -> print(s,i)` | `(a,b) -> a+b` |

### BiConsumer vs Other Bi- Interfaces

| Interface | Purpose | Return Type | Example |
|-----------|---------|-------------|---------|
| **BiConsumer<T,U>** | Consume 2 inputs | void | `(a,b) -> print(a,b)` |
| **BiFunction<T,U,R>** | Transform 2 inputs | R | `(a,b) -> a.concat(b)` |
| **BiPredicate<T,U>** | Test 2 inputs | boolean | `(a,b) -> a.equals(b)` |
| **BinaryOperator<T>** | Operate on same type | T | `(a,b) -> a + b` |

---

## üé§ Interview Questions

### Q1: BiConsumer ‡§î‡§∞ Consumer ‡§Æ‡•á‡§Ç ‡§ï‡•ç‡§Ø‡§æ difference ‡§π‡•à?

**Answer:**
```java
// Consumer - Single parameter
Consumer<String> consumer = name -> System.out.println("Hello " + name);
consumer.accept("Raj"); // Output: Hello Raj

// BiConsumer - Two parameters  
BiConsumer<String, Integer> biConsumer = (name, age) -> 
    System.out.println("Hello " + name + ", you are " + age + " years old");
biConsumer.accept("Raj", 25); // Output: Hello Raj, you are 25 years old
```

### Q2: andThen() method ‡§ï‡•à‡§∏‡•á ‡§ï‡§æ‡§Æ ‡§ï‡§∞‡§§‡§æ ‡§π‡•à?

**Answer:**
```java
BiConsumer<String, Integer> first = (name, age) -> 
    System.out.println("Step 1: Processing " + name);

BiConsumer<String, Integer> second = (name, age) -> 
    System.out.println("Step 2: Age verification for " + name + ": " + 
    (age >= 18 ? "Adult" : "Minor"));

// Chain ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç
BiConsumer<String, Integer> combined = first.andThen(second);
combined.accept("Priya", 22);

/* Output:
Step 1: Processing Priya
Step 2: Age verification for Priya: Adult
*/
```

### Q3: BiConsumer ‡§Æ‡•á‡§Ç exception handling ‡§ï‡•à‡§∏‡•á ‡§ï‡§∞‡•á‡§Ç?

**Answer:**
```java
BiConsumer<Integer, Integer> safeDivision = (a, b) -> {
    try {
        if (b == 0) {
            System.out.println("‚ùå Cannot divide by zero!");
            return;
        }
        System.out.println("‚úÖ " + a + " √∑ " + b + " = " + (a/b));
    } catch (Exception e) {
        System.out.println("‚ùå Error: " + e.getMessage());
    }
};

safeDivision.accept(10, 2);  // ‚úÖ 10 √∑ 2 = 5
safeDivision.accept(10, 0);  // ‚ùå Cannot divide by zero!
```

### Q4: Method Reference ‡§ï‡•á ‡§∏‡§æ‡§• BiConsumer ‡§ï‡•à‡§∏‡•á use ‡§ï‡§∞‡•á‡§Ç?

**Answer:**
```java
class MathUtils {
    public static void printSum(Integer a, Integer b) {
        System.out.println("Sum: " + (a + b));
    }
    
    public static void printProduct(Integer a, Integer b) {
        System.out.println("Product: " + (a * b));
    }
}

public class MethodReferenceExample {
    public static void main(String[] args) {
        // Method reference with BiConsumer
        BiConsumer<Integer, Integer> sumPrinter = MathUtils::printSum;
        BiConsumer<Integer, Integer> productPrinter = MathUtils::printProduct;
        
        // Chain ‡§ï‡§∞‡§§‡•á ‡§π‡•à‡§Ç
        BiConsumer<Integer, Integer> mathOperations = sumPrinter.andThen(productPrinter);
        
        mathOperations.accept(5, 3);
        /* Output:
        Sum: 8
        Product: 15
        */
    }
}
```

---

## ‚ö†Ô∏è Common Mistakes

### Mistake 1: Wrong Generic Types
```java
‚ùå // Wrong - String cannot be added to Integer
BiConsumer<String, Integer> wrong = (s, i) -> {
    int result = s + i; // Compilation Error!
};

‚úÖ // Correct - Proper type handling
BiConsumer<String, Integer> correct = (s, i) -> {
    String result = s + " - " + i; // String concatenation
    System.out.println(result);
};
```

### Mistake 2: Trying to Return Values
```java
‚ùå // Wrong - BiConsumer cannot return anything
BiConsumer<Integer, Integer> wrong = (a, b) -> return a + b; // Error!

‚úÖ // Correct - Use BiFunction for return values
BiFunction<Integer, Integer, Integer> correct = (a, b) -> a + b;
```

### Mistake 3: Null Handling in andThen()
```java
‚ùå // Wrong - Will throw NullPointerException
BiConsumer<String, String> first = (a, b) -> System.out.println(a + b);
BiConsumer<String, String> second = null;
first.andThen(second); // NullPointerException!

‚úÖ // Correct - Null check karo
BiConsumer<String, String> first = (a, b) -> System.out.println(a + b);
BiConsumer<String, String> second = null;

if (second != null) {
    first.andThen(second);
} else {
    first.accept("Hello", "World");
}
```

### Mistake 4: Modifying Immutable Objects
```java
‚ùå // Wrong - String is immutable
BiConsumer<String, String> wrong = (s1, s2) -> {
    s1 = s1 + s2; // Ye local variable change karega, original nahi!
};

‚úÖ // Correct - Use mutable objects or return new values
BiConsumer<StringBuilder, String> correct = (sb, s) -> {
    sb.append(s); // StringBuilder is mutable
};
```

---

## üåü Best Practices

### 1. üìù Clear Naming Conventions
```java
‚úÖ // Good - Clear purpose
BiConsumer<Employee, Double> salaryIncrement = (emp, amount) -> emp.salary += amount;
BiConsumer<String, String> logMessage = (level, message) -> 
    System.out.println("[" + level + "] " + message);

‚ùå // Bad - Unclear names  
BiConsumer<Employee, Double> bc = (e, d) -> e.salary += d;
BiConsumer<String, String> x = (a, b) -> System.out.println(a + b);
```

### 2. üîç Input Validation
```java
‚úÖ // Good - Always validate inputs
BiConsumer<String, Integer> safeProcessor = (name, age) -> {
    if (name == null || name.trim().isEmpty()) {
        System.out.println("‚ùå Invalid name provided");
        return;
    }
    if (age < 0 || age > 150) {
        System.out.println("‚ùå Invalid age: " + age);
        return;
    }
    System.out.println("‚úÖ Processing: " + name + " (Age: " + age + ")");
};
```

### 3. üéØ Single Responsibility
```java
‚úÖ // Good - Each BiConsumer has one job
BiConsumer<Product, ShoppingCart> addToCart = (product, cart) -> {
    cart.addItem(product);
};

BiConsumer<Product, ShoppingCart> logAddition = (product, cart) -> {
    System.out.println("Added " + product.getName() + " to cart");
};

// Chain them for complex operations
addToCart.andThen(logAddition).accept(laptop, myCart);

‚ùå // Bad - Doing too much in one BiConsumer
BiConsumer<Product, ShoppingCart> doEverything = (product, cart) -> {
    cart.addItem(product);
    System.out.println("Added to cart");
    cart.calculateTotal();
    cart.applyDiscount();
    cart.sendNotification();
    // Too many responsibilities!
};
```

### 4. üõ°Ô∏è Exception Safety
```java
‚úÖ // Good - Proper exception handling
BiConsumer<String, String> safeFileWriter = (filename, content) -> {
    try {
        Files.write(Paths.get(filename), content.getBytes());
        System.out.println("‚úÖ File written successfully: " + filename);
    } catch (IOException e) {
        System.err.println("‚ùå Failed to write file: " + e.getMessage());
    }
};
```

### 5. üìö Documentation
```java
/**
 * BiConsumer to update employee salary with proper validation and logging
 * @param employee The employee whose salary needs to be updated
 * @param increment The increment amount (should be positive)
 */
BiConsumer<Employee, Double> updateSalary = (employee, increment) -> {
    if (employee == null) {
        System.out.println("‚ùå Employee cannot be null");
        return;
    }
    if (increment <= 0) {
        System.out.println("‚ùå Increment must be positive");
        return;
    }
    
    double oldSalary = employee.getSalary();
    employee.setSalary(oldSalary + increment);
    System.out.println("üí∞ " + employee.getName() + "'s salary updated from ‚Çπ" + 
                      oldSalary + " to ‚Çπ" + employee.getSalary());
};
```

---

## üìù Summary/Quick Recap

### üîë Key Takeaways

1. **BiConsumer<T,U>** = **2 inputs** + **No return** + **Some operation**
2. **Two methods**: `accept(T t, U u)` ‡§î‡§∞ `andThen(BiConsumer after)`
3. **Perfect for**: Side effects, logging, updating objects, chaining operations
4. **Lambda syntax**: `(param1, param2) -> { /* operation */ }`

### üß† Memory Tricks

| ‡§Ø‡§æ‡§¶ ‡§∞‡§ñ‡§®‡•á ‡§ï‡§æ ‡§§‡§∞‡•Ä‡§ï‡§æ | Example |
|-------------------|---------|
| **Bi = Two** | BiConsumer = **Two** parameters |
| **Consumer = Eats** | **Consumes** input, returns nothing |
| **Chain with andThen** | Like cooking steps: first this, **then** that |

### üéØ When to Use What

```java
// ‚úÖ Use BiConsumer when:
// - You need to perform operation on 2 inputs
// - You don't need return value
// - Side effects like logging, updating objects

BiConsumer<String, Integer> logger = (msg, level) -> log(msg, level);
BiConsumer<Employee, Double> updater = (emp, sal) -> emp.setSalary(sal);

// ‚ùå Don't use BiConsumer when:
// - You need return value (use BiFunction instead)
// - You have only 1 parameter (use Consumer instead)  
// - You need to test conditions (use BiPredicate instead)
```

### üöÄ Pro Tips for Interviews

1. **‡§π‡§Æ‡•á‡§∂‡§æ mention ‡§ï‡§∞‡•ã**: "BiConsumer functional interface hai with exactly 2 parameters ‡§î‡§∞ void return type"
2. **andThen() example ‡§¶‡•á‡§®‡§æ**: Shows advanced understanding
3. **Real-world examples**: Employee salary, logging, cart operations
4. **Exception handling**: Shows production-ready thinking
5. **Method reference knowledge**: `ClassName::methodName` syntax

---

## üéâ Conclusion

Yaar, **BiConsumer** ek ‡§¨‡§π‡•Å‡§§ powerful functional interface ‡§π‡•à! Java 8 ke functional programming paradigm ‡§ï‡§æ ‡§Ø‡•á important part ‡§π‡•à. 

**Remember the golden rule**: 
> "Do ChIzEiN lEkAr KuCh KaRnA, kUcH rEtUrN nAhI kArNa!" üéØ

Practice ‡§ï‡§∞‡§§‡•á ‡§∞‡§π‡•ã different scenarios ‡§ï‡•á ‡§∏‡§æ‡§•, ‡§î‡§∞ interviews ‡§Æ‡•á‡§Ç confident ‡§∞‡§π‡•ã‡§ó‡•á! 

Happy Coding! üíª‚ú®

---

*Made with ‚ù§Ô∏è for Java developers by Java developers*

---
