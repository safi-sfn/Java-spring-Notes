# String Reverse Methods - Complete Study Notes 🔄

## Introduction - String Ko Ulta Karne Ke Tarike! 🤔

**Problem Statement:** Java mein String ko reverse kaise karte hain?

**Real Life Analogy:** Jaise aap "RACECAR" ko ulta padho toh bhi same lagta hai, waise hi programming mein bhi string ko reverse karna padta hai! 🏎️

**Fun Fact:** String class mein built-in reverse() method nahi hai, but StringBuilder aur StringBuffer mein hai! 🤯

## Why String Reversal Important Hai? 🎯

### **Use Cases:**
- **Palindrome checking** 📝
- **Data validation** ✅
- **Cryptography algorithms** 🔐
- **Interview questions** 💪
- **String manipulation tasks** 🛠️

## Method 1: Using charAt() Method 📍

**Concept:** Har character ko individually access karke reverse order mein new string banana.

```java
public class CharAtMethod {
    public static void main(String[] args) {
        String str = "springjava", reversedStr = "";
        char ch;
        
        System.out.println("Original String: " + str);
        
        // Getting each character and adding to front
        for (int i = 0; i < str.length(); i++) {
            ch = str.charAt(i);           // Gets character at index i
            reversedStr = ch + reversedStr; // Adds character to front
        }
        
        System.out.println("Reversed String: " + reversedStr);
    }
}
```

**Output:**
```
Original String: springjava
Reversed String: avajgnirps
```

### **Step-by-Step Execution:**
```
i=0: ch='s', reversedStr = 's' + "" = "s"
i=1: ch='p', reversedStr = 'p' + "s" = "ps" 
i=2: ch='r', reversedStr = 'r' + "ps" = "rps"
i=3: ch='i', reversedStr = 'i' + "rps" = "irps"
...and so on
```

### **Pros & Cons:**
- ✅ **Pros:** Simple logic, easy to understand
- ❌ **Cons:** Creates many String objects (inefficient), O(n²) time complexity

## Method 2: Using toCharArray() Method 🎭

**Concept:** String ko character array mein convert karke last se first tak iterate karna.

```java
public class ToCharArrayMethod {
    public static void main(String[] args) {
        String input = "springjava";
        
        System.out.println("Original String: " + input);
        System.out.print("Reversed String: ");
        
        // Converting String to character array
        char[] charArr = input.toCharArray();
        
        // Iterating from last to first
        for (int i = charArr.length - 1; i >= 0; i--) {
            System.out.print(charArr[i]);
        }
        System.out.println(); // New line
    }
}
```

**Output:**
```
Original String: springjava
Reversed String: avajgnirps
```

### **Enhanced Version with String Building:**
```java
public class ToCharArrayEnhanced {
    public static String reverseString(String str) {
        char[] charArray = str.toCharArray();
        StringBuilder reversed = new StringBuilder();
        
        for (int i = charArray.length - 1; i >= 0; i--) {
            reversed.append(charArray[i]);
        }
        
        return reversed.toString();
    }
    
    public static void main(String[] args) {
        String original = "Hello World!";
        String reversed = reverseString(original);
        
        System.out.println("Original: " + original);
        System.out.println("Reversed: " + reversed);
    }
}
```

### **Pros & Cons:**
- ✅ **Pros:** More efficient than charAt(), single array creation
- ✅ **Pros:** O(n) time complexity
- ❌ **Cons:** Uses extra space for array

## Method 3: Using getBytes() Method 📦

**Concept:** String ko byte array mein convert karke reverse order mein new byte array banana.

```java
public class GetBytesMethod {
    public static void main(String[] args) {
        String input = "springjava";
        
        System.out.println("Original String: " + input);
        
        // Converting String to byte array
        byte[] sourceBytes = input.getBytes();
        byte[] reversedBytes = new byte[sourceBytes.length];
        
        // Copying bytes in reverse order
        for (int i = 0; i < sourceBytes.length; i++) {
            reversedBytes[i] = sourceBytes[sourceBytes.length - 1 - i];
        }
        
        // Converting byte array back to String
        String reversedString = new String(reversedBytes);
        System.out.println("Reversed String: " + reversedString);
    }
}
```

**Output:**
```
Original String: springjava
Reversed String: avajgnirps
```

### **Unicode Safe Version:**
```java
import java.nio.charset.StandardCharsets;

public class GetBytesUnicode {
    public static String reverseString(String str) {
        byte[] sourceBytes = str.getBytes(StandardCharsets.UTF_8);
        byte[] reversedBytes = new byte[sourceBytes.length];
        
        for (int i = 0; i < sourceBytes.length; i++) {
            reversedBytes[i] = sourceBytes[sourceBytes.length - 1 - i];
        }
        
        return new String(reversedBytes, StandardCharsets.UTF_8);
    }
    
    public static void main(String[] args) {
        String hindi = "नमस्ते";
        System.out.println("Original: " + hindi);
        System.out.println("Reversed: " + reverseString(hindi));
        // Note: This may not work correctly with multi-byte characters
    }
}
```

### **Pros & Cons:**
- ✅ **Pros:** Works with byte-level data
- ❌ **Cons:** Not suitable for Unicode characters, complex approach
- ⚠️ **Warning:** May not work correctly with multi-byte characters

## Method 4: Using StringBuilder.reverse() Method 🔄

**Concept:** StringBuilder ka built-in reverse() method use karna - **Most Efficient!**

```java
public class StringBuilderMethod {
    public static void main(String[] args) {
        String input = "springjava";
        
        System.out.println("Original String: " + input);
        
        // Creating StringBuilder and appending string
        StringBuilder sb = new StringBuilder();
        sb.append(input);
        
        // Using built-in reverse method
        sb.reverse();
        
        System.out.println("Reversed String: " + sb.toString());
    }
}
```

### **One-liner Version:**
```java
public class StringBuilderOneLiner {
    public static String reverseString(String str) {
        return new StringBuilder(str).reverse().toString();
    }
    
    public static void main(String[] args) {
        String original = "Hello Java World!";
        String reversed = reverseString(original);
        
        System.out.println("Original: " + original);
        System.out.println("Reversed: " + reversed);
    }
}
```

### **Method with Error Handling:**
```java
public class StringBuilderSafe {
    public static String reverseString(String str) {
        if (str == null || str.isEmpty()) {
            return str;
        }
        return new StringBuilder(str).reverse().toString();
    }
    
    public static void main(String[] args) {
        // Test cases
        System.out.println("'" + reverseString("hello") + "'");     // 'olleh'
        System.out.println("'" + reverseString("") + "'");         // ''
        System.out.println("'" + reverseString(null) + "'");       // 'null'
        System.out.println("'" + reverseString("a") + "'");        // 'a'
    }
}
```

### **Pros & Cons:**
- ✅ **Pros:** Most efficient, built-in method, thread-safe operations
- ✅ **Pros:** O(n) time complexity, optimized implementation
- ✅ **Pros:** Handles Unicode properly
- ❌ **Cons:** Creates StringBuilder object (minimal overhead)

## Method 5: Using StringBuffer.reverse() Method 🛡️

**Concept:** StringBuffer ka built-in reverse() method use karna - **Thread Safe!**

```java
public class StringBufferMethod {
    public static void main(String[] args) {
        String str = "springjava";
        
        System.out.println("Original String: " + str);
        
        // Converting String to StringBuffer
        StringBuffer sbr = new StringBuffer(str);
        
        // Using built-in reverse method
        sbr.reverse();
        
        System.out.println("Reversed String: " + sbr.toString());
    }
}
```

### **Thread-Safe Example:**
```java
public class StringBufferThreadSafe {
    private static StringBuffer globalBuffer = new StringBuffer();
    
    public static synchronized String reverseString(String str) {
        globalBuffer.setLength(0);  // Clear buffer
        globalBuffer.append(str);   // Add string
        globalBuffer.reverse();     // Reverse it
        return globalBuffer.toString();
    }
    
    public static void main(String[] args) {
        // Multiple threads can safely use this method
        String[] testStrings = {"hello", "world", "java", "programming"};
        
        for (String test : testStrings) {
            System.out.println(test + " → " + reverseString(test));
        }
    }
}
```

### **Pros & Cons:**
- ✅ **Pros:** Thread-safe, built-in method
- ✅ **Pros:** Good for multi-threaded applications
- ❌ **Cons:** Slightly slower than StringBuilder due to synchronization
- ❌ **Cons:** Overkill for single-threaded applications

## Advanced Methods - Bonus! 🚀

### Method 6: Using Recursion 🔁

```java
public class RecursiveReverse {
    public static String reverseStringRecursive(String str) {
        // Base case
        if (str == null || str.length() <= 1) {
            return str;
        }
        
        // Recursive case: last char + reverse of remaining string
        return str.charAt(str.length() - 1) + 
               reverseStringRecursive(str.substring(0, str.length() - 1));
    }
    
    public static void main(String[] args) {
        String original = "recursion";
        String reversed = reverseStringRecursive(original);
        
        System.out.println("Original: " + original);
        System.out.println("Reversed: " + reversed);
    }
}
```

**Execution Trace:**
```
reverseStringRecursive("hello")
= 'o' + reverseStringRecursive("hell")
= 'o' + 'l' + reverseStringRecursive("hel")  
= 'o' + 'l' + 'l' + reverseStringRecursive("he")
= 'o' + 'l' + 'l' + 'e' + reverseStringRecursive("h")
= 'o' + 'l' + 'l' + 'e' + 'h'
= "olleh"
```

### Method 7: Using Stack Data Structure 📚

```java
import java.util.Stack;

public class StackReverse {
    public static String reverseUsingStack(String str) {
        Stack<Character> stack = new Stack<>();
        
        // Push all characters to stack
        for (char c : str.toCharArray()) {
            stack.push(c);
        }
        
        // Pop all characters (LIFO order gives reverse)
        StringBuilder reversed = new StringBuilder();
        while (!stack.isEmpty()) {
            reversed.append(stack.pop());
        }
        
        return reversed.toString();
    }
    
    public static void main(String[] args) {
        String original = "stack";
        String reversed = reverseUsingStack(original);
        
        System.out.println("Original: " + original);
        System.out.println("Reversed: " + reversed);
    }
}
```

### Method 8: Using Collections.reverse() 🔄

```java
import java.util.*;

public class CollectionsReverse {
    public static String reverseUsingCollections(String str) {
        List<Character> charList = new ArrayList<>();
        
        // Convert string to character list
        for (char c : str.toCharArray()) {
            charList.add(c);
        }
        
        // Reverse the list
        Collections.reverse(charList);
        
        // Convert back to string
        StringBuilder sb = new StringBuilder();
        for (char c : charList) {
            sb.append(c);
        }
        
        return sb.toString();
    }
    
    public static void main(String[] args) {
        String original = "collections";
        String reversed = reverseUsingCollections(original);
        
        System.out.println("Original: " + original);
        System.out.println("Reversed: " + reversed);
    }
}
```

### Method 9: Using Streams (Java 8+) 🌊

```java
import java.util.stream.Collectors;

public class StreamReverse {
    public static String reverseUsingStreams(String str) {
        return str.chars()                    // IntStream of characters
                  .mapToObj(c -> (char) c)    // Convert to Character objects
                  .reduce("", (s, c) -> c + s, (s1, s2) -> s2 + s1);
    }
    
    // Alternative using collect
    public static String reverseUsingStreamCollect(String str) {
        return str.chars()
                  .mapToObj(c -> String.valueOf((char) c))
                  .collect(Collectors.collectingAndThen(
                      Collectors.toList(),
                      list -> {
                          Collections.reverse(list);
                          return String.join("", list);
                      }
                  ));
    }
    
    public static void main(String[] args) {
        String original = "streams";
        
        System.out.println("Original: " + original);
        System.out.println("Reversed (reduce): " + reverseUsingStreams(original));
        System.out.println("Reversed (collect): " + reverseUsingStreamCollect(original));
    }
}
```

## Performance Comparison 📊

```java
public class PerformanceTest {
    public static void main(String[] args) {
        String testString = "This is a test string for performance measurement";
        int iterations = 100000;
        
        // Test StringBuilder method
        long start = System.currentTimeMillis();
        for (int i = 0; i < iterations; i++) {
            new StringBuilder(testString).reverse().toString();
        }
        long stringBuilderTime = System.currentTimeMillis() - start;
        
        // Test StringBuffer method
        start = System.currentTimeMillis();
        for (int i = 0; i < iterations; i++) {
            new StringBuffer(testString).reverse().toString();
        }
        long stringBufferTime = System.currentTimeMillis() - start;
        
        // Test charAt method
        start = System.currentTimeMillis();
        for (int i = 0; i < iterations; i++) {
            String reversed = "";
            for (int j = 0; j < testString.length(); j++) {
                reversed = testString.charAt(j) + reversed;
            }
        }
        long charAtTime = System.currentTimeMillis() - start;
        
        System.out.println("Performance Results (" + iterations + " iterations):");
        System.out.println("StringBuilder: " + stringBuilderTime + "ms");
        System.out.println("StringBuffer: " + stringBufferTime + "ms");
        System.out.println("charAt(): " + charAtTime + "ms");
    }
}
```

**Typical Results:**
```
Performance Results (100000 iterations):
StringBuilder: 45ms    ⚡ Fastest
StringBuffer: 78ms     🛡️ Thread-safe but slower
charAt(): 2840ms       🐌 Slowest due to O(n²) complexity
```

## Comparison Table - Choose The Right Method! 📋

| **Method** | **Time Complexity** | **Space Complexity** | **Thread Safe** | **Best For** |
|------------|--------------------|--------------------|-----------------|--------------|
| `charAt()` | O(n²) | O(n) | ❌ | Learning/Small strings |
| `toCharArray()` | O(n) | O(n) | ❌ | Character manipulation |
| `getBytes()` | O(n) | O(n) | ❌ | Byte-level operations |
| `StringBuilder.reverse()` | O(n) | O(n) | ❌ | **Most cases (Recommended)** ⭐ |
| `StringBuffer.reverse()` | O(n) | O(n) | ✅ | Multi-threaded applications |
| Recursion | O(n) | O(n) | ❌ | Educational/Functional style |
| Stack | O(n) | O(n) | ❌ | Data structure practice |
| Collections | O(n) | O(n) | ❌ | Collection manipulation |
| Streams | O(n) | O(n) | ❌ | Functional programming |

## Real-World Applications 🌍

### 1. Palindrome Checker 🔍

```java
public class PalindromeChecker {
    public static boolean isPalindrome(String str) {
        // Clean the string (remove spaces, convert to lowercase)
        String cleaned = str.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();
        
        // Reverse using StringBuilder
        String reversed = new StringBuilder(cleaned).reverse().toString();
        
        return cleaned.equals(reversed);
    }
    
    public static void main(String[] args) {
        String[] testCases = {
            "racecar",
            "A man a plan a canal Panama", 
            "race a car",
            "hello"
        };
        
        for (String test : testCases) {
            System.out.println("'" + test + "' is palindrome: " + isPalindrome(test));
        }
    }
}
```

### 2. String Rotation Checker 🔄

```java
public class StringRotation {
    public static boolean isRotation(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }
        
        // Check if s2 is rotation of s1
        String doubled = s1 + s1;
        return doubled.contains(s2);
    }
    
    public static String rotateString(String str, int positions) {
        int len = str.length();
        positions = positions % len;  // Handle cases where positions > length
        
        return str.substring(positions) + str.substring(0, positions);
    }
    
    public static void main(String[] args) {
        String original = "abcdef";
        String rotated = rotateString(original, 2);
        
        System.out.println("Original: " + original);
        System.out.println("Rotated by 2: " + rotated);
        System.out.println("Is rotation: " + isRotation(original, rotated));
    }
}
```

### 3. Password Validator 🔐

```java
public class PasswordValidator {
    public static boolean isStrongPassword(String password) {
        // Check if password is not same when reversed (security check)
        String reversed = new StringBuilder(password).reverse().toString();
        if (password.equals(reversed)) {
            System.out.println("Password should not be palindromic!");
            return false;
        }
        
        // Other validations...
        return password.length() >= 8 && 
               password.matches(".*[A-Z].*") && 
               password.matches(".*[0-9].*");
    }
    
    public static void main(String[] args) {
        String[] passwords = {"Password123", "12321", "abccba", "SecurePass2024"};
        
        for (String pwd : passwords) {
            System.out.println("'" + pwd + "' is strong: " + isStrongPassword(pwd));
        }
    }
}
```

## Interview Questions - Master Karo! 💪

### Q1: **Most efficient way to reverse string?**
```java
// ✅ Best Answer
public static String reverseString(String str) {
    if (str == null || str.length() <= 1) {
        return str;
    }
    return new StringBuilder(str).reverse().toString();
}
```
**Explanation:** StringBuilder.reverse() is most efficient with O(n) time complexity and optimized implementation.

### Q2: **Reverse string without using built-in methods?**
```java
public static String reverseManually(String str) {
    if (str == null) return null;
    
    char[] chars = str.toCharArray();
    int left = 0, right = chars.length - 1;
    
    while (left < right) {
        // Swap characters
        char temp = chars[left];
        chars[left] = chars[right];
        chars[right] = temp;
        
        left++;
        right--;
    }
    
    return new String(chars);
}
```

### Q3: **Reverse each word in a sentence?**
```java
public static String reverseWords(String sentence) {
    String[] words = sentence.split("\\s+");
    StringBuilder result = new StringBuilder();
    
    for (String word : words) {
        result.append(new StringBuilder(word).reverse()).append(" ");
    }
    
    return result.toString().trim();
}

// Example: "Hello World" → "olleH dlroW"
```

### Q4: **Check if string can form palindrome after removing one character?**
```java
public static boolean canFormPalindrome(String str) {
    int left = 0, right = str.length() - 1;
    
    while (left < right) {
        if (str.charAt(left) != str.charAt(right)) {
            // Try removing left character
            if (isPalindrome(str.substring(left + 1, right + 1))) {
                return true;
            }
            // Try removing right character  
            if (isPalindrome(str.substring(left, right))) {
                return true;
            }
            return false;
        }
        left++;
        right--;
    }
    return true;  // Already palindrome
}

private static boolean isPalindrome(String s) {
    return s.equals(new StringBuilder(s).reverse().toString());
}
```

### Q5: **Memory efficient string reversal for very large strings?**
```java
public static void reverseInPlace(char[] chars) {
    int left = 0, right = chars.length - 1;
    
    while (left < right) {
        char temp = chars[left];
        chars[left] = chars[right];
        chars[right] = temp;
        
        left++;
        right--;
    }
    // O(1) space complexity!
}
```

## Common Mistakes - Avoid Karo! ❌

### 1. **Creating too many String objects**
```java
// ❌ Wrong - Creates many objects
String reversed = "";
for (int i = 0; i < str.length(); i++) {
    reversed = str.charAt(i) + reversed;  // New String object each time!
}

// ✅ Correct - Use StringBuilder
StringBuilder sb = new StringBuilder();
for (int i = str.length() - 1; i >= 0; i--) {
    sb.append(str.charAt(i));
}
String reversed = sb.toString();
```

### 2. **Not handling null/empty strings**
```java
// ❌ Wrong - Can cause NullPointerException
public static String reverse(String str) {
    return new StringBuilder(str).reverse().toString();
}

// ✅ Correct - Handle edge cases
public static String reverse(String str) {
    if (str == null || str.isEmpty()) {
        return str;
    }
    return new StringBuilder(str).reverse().toString();
}
```

### 3. **Using wrong method for Unicode**
```java
// ❌ Wrong - Doesn't handle multi-byte characters properly
String hindi = "हैलो";
byte[] bytes = hindi.getBytes();
// Reversing bytes may corrupt Unicode characters

// ✅ Correct - Use StringBuilder for Unicode safety
String reversed = new StringBuilder(hindi).reverse().toString();
```

### 4. **Choosing wrong method for thread safety**
```java
// ❌ Wrong - StringBuilder not thread-safe
public static String reverseInMultiThreading(String str) {
    return new StringBuilder(str).reverse().toString();
}

// ✅ Correct - Use StringBuffer for thread safety
public static synchronized String reverseThreadSafe(String str) {
    return new StringBuffer(str).reverse().toString();
}
```

## Best Practices 🌟

### 1. **Choose Right Method for Right Scenario**
```java
public class StringReverseUtils {
    // For general use
    public static String reverse(String str) {
        return str == null ? null : new StringBuilder(str).reverse().toString();
    }
    
    // For thread-safe operations
    public static String reverseThreadSafe(String str) {
        return str == null ? null : new StringBuffer(str).reverse().toString();
    }
    
    // For in-place reversal (memory efficient)
    public static void reverseInPlace(char[] chars) {
        if (chars == null) return;
        
        int left = 0, right = chars.length - 1;
        while (left < right) {
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;
            left++;
            right--;
        }
    }
}
```

### 2. **Handle Edge Cases**
```java
public static String safeReverse(String str) {
    // Handle null
    if (str == null) {
        return null;
    }
    
    // Handle empty string
    if (str.isEmpty()) {
        return str;
    }
    
    // Handle single character
    if (str.length() == 1) {
        return str;
    }
    
    // Normal case
    return new StringBuilder(str).reverse().toString();
}
```

### 3. **Write Unit Tests**
```java
import org.junit.Test;
import static org.junit.Assert.*;

public class StringReverseTest {
    @Test
    public void testNormalString() {
        assertEquals("olleh", reverse("hello"));
    }
    
    @Test
    public void testEmptyString() {
        assertEquals("", reverse(""));
    }
    
    @Test
    public void testNullString() {
        assertNull(reverse(null));
    }
    
    @Test
    public void testSingleCharacter() {
        assertEquals("a", reverse("a"));
    }
    
    @Test
    public void testPalindrome() {
        assertEquals("racecar", reverse("racecar"));
    }
}
```

## Summary - Quick Reference! 📝

### **Top 3 Recommended Methods:**

#### 1. **StringBuilder.reverse()** ⭐ (Most Popular)
```java
String reversed = new StringBuilder(original).reverse().toString();
```
- **Use for:** 95% of cases
- **Pros:** Fast, efficient, Unicode-safe

#### 2. **StringBuffer.reverse()** 🛡️ (Thread-Safe)
```java  
String reversed = new StringBuffer(original).reverse().toString();
```
- **Use for:** Multi-threaded applications
- **Pros:** Thread-safe, efficient

#### 3. **Two-pointer approach** 💾 (Memory Efficient)
```java
char[] chars = str.toCharArray();
// Swap from both ends towards center
```
- **Use for:** Very large strings, memory constraints
- **Pros:** O(1) extra space

### **When to Use What:**
- 🏠 **Single-threaded app:** StringBuilder
- 🏢 **Multi-threaded app:** StringBuffer  
- 🎓 **Learning/Interview:** Manual methods
- 💾 **Memory critical:** In-place reversal
- 🚀 **Performance critical:** StringBuilder

### **Memory Tricks:**
- **StringBuilder** = **Speed** (single-threaded) 🏃‍♂️
- **StringBuffer** = **Safety** (multi-threaded) 🛡️
- **Manual methods** = **Learning** (understanding) 🎓

Practice these methods and you'll master string reversal in Java! 🚀💪

---
*Happy Coding! 🎉*
