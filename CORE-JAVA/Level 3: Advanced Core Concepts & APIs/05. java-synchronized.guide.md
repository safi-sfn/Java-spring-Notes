# Java Synchronized - Complete Study Notes üìö

## Synchronized Kya Hai Bhai? ü§î

**Simple Words Mein**: Jab multiple threads same resource ko use karna chahte hain, toh synchronized keyword use karke ek time mein sirf ek thread ko permission dete hain!

**Real Life Example**: 
- **Without Synchronized** = 10 log ek hi ATM machine use kar rahe hain simultaneously (Chaos! üòµ‚Äçüí´)
- **With Synchronized** = Queue system - ek time mein ek hi person ATM use kar sakta hai (Organized! ‚úÖ)

**Technical Definition**: Synchronized is a keyword that provides thread safety by allowing only one thread at a time to access the synchronized resource.

## Thread Safety Problem - Samjho Pehle! ‚ö†Ô∏è

### Problem Without Synchronized:

```java
class BankAccount {
    private int balance = 1000;
    
    public void withdraw(String person, int amount) {
        System.out.println(person + " checking balance...");
        
        if (balance >= amount) {
            System.out.println(person + " has sufficient balance: " + balance);
            
            // Simulate some processing time
            try { Thread.sleep(1000); } catch (InterruptedException e) {}
            
            balance = balance - amount;
            System.out.println(person + " withdrew " + amount + ". Remaining: " + balance);
        } else {
            System.out.println(person + " insufficient balance!");
        }
    }
}

public class WithoutSynchronized {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        
        // Two people trying to withdraw simultaneously
        Thread husband = new Thread(() -> account.withdraw("Husband", 800));
        Thread wife = new Thread(() -> account.withdraw("Wife", 800));
        
        husband.start();
        wife.start();
    }
}
```

**Output (Race Condition):**
```
Husband checking balance...
Wife checking balance...
Husband has sufficient balance: 1000
Wife has sufficient balance: 1000
Husband withdrew 800. Remaining: 200
Wife withdrew 800. Remaining: -600  ‚Üê Problem! Negative balance!
```

**Problem**: Dono threads ne same time mein balance check kiya, dono ko laga sufficient hai, and dono ne withdraw kar diya! üò±

## Synchronized Keyword - Solution! üõ°Ô∏è

**Synchronized keyword do cheezon pe use hota hai:**
1. **Methods** mein (entire method ko synchronize karta hai)
2. **Blocks** mein (specific code block ko synchronize karta hai)

### Key Concepts:
- **Lock/Monitor**: Har object ka ek lock hota hai
- **Mutex (Mutual Exclusion)**: Ek time mein sirf ek thread access kar sakta hai
- **Thread Safety**: Multiple threads safely run kar sakte hain

## 1. Synchronized Method üîí

### Syntax:
```java
<access_modifier> synchronized return_type methodName(parameters) {
    // Thread-safe code here
}
```

### Example - Banking Problem Solved:

```java
class BankAccount {
    private int balance = 1000;
    
    // ‚úÖ Synchronized method - Thread safe!
    public synchronized void withdraw(String person, int amount) {
        System.out.println(person + " checking balance...");
        
        if (balance >= amount) {
            System.out.println(person + " has sufficient balance: " + balance);
            
            // Simulate processing time
            try { Thread.sleep(1000); } catch (InterruptedException e) {}
            
            balance = balance - amount;
            System.out.println(person + " withdrew " + amount + ". Remaining: " + balance);
        } else {
            System.out.println(person + " insufficient balance!");
        }
    }
}

public class WithSynchronized {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        
        Thread husband = new Thread(() -> account.withdraw("Husband", 800));
        Thread wife = new Thread(() -> account.withdraw("Wife", 800));
        
        husband.start();
        wife.start();
    }
}
```

**Output (Thread Safe):**
```
Husband checking balance...
Husband has sufficient balance: 1000
Husband withdrew 800. Remaining: 200
Wife checking balance...
Wife insufficient balance!  ‚Üê Correct! Wife has to wait
```

### Number Printing Example:

```java
class NumberPrinter {
    public synchronized void printNumbers(int n) throws InterruptedException {
        for (int i = 1; i <= n; i++) {
            System.out.println(Thread.currentThread().getName() + " : " + i);
            Thread.sleep(500);  // 500ms delay
        }
    }
}

public class SynchronizedMethodExample {
    public static void main(String args[]) {
        NumberPrinter printer = new NumberPrinter();
        
        Runnable task = new Runnable() {
            public void run() {
                try {
                    printer.printNumbers(5);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        
        new Thread(task, "Thread1").start();
        new Thread(task, "Thread2").start();
    }
}
```

**Output:**
```
Thread1 : 1
Thread1 : 2
Thread1 : 3
Thread1 : 4
Thread1 : 5
Thread2 : 1  ‚Üê Thread2 waits for Thread1 to complete
Thread2 : 2
Thread2 : 3
Thread2 : 4
Thread2 : 5
```

## 2. Synchronized Block üéØ

### Syntax:
```java
synchronized(object) {
    // Thread-safe code here
}
```

**Advantages of Synchronized Block:**
- ‚úÖ More flexible than synchronized method
- ‚úÖ Can synchronize only specific part of method
- ‚úÖ Better performance (smaller critical section)
- ‚úÖ Can use different objects as locks

### Example - Synchronized Block:

```java
class NumberPrinter {
    public void printNumbers(int n) throws InterruptedException {
        // Some non-critical code here
        System.out.println("Starting " + Thread.currentThread().getName());
        
        // ‚úÖ Only this block is synchronized
        synchronized(this) {
            for (int i = 1; i <= n; i++) {
                System.out.println(Thread.currentThread().getName() + " : " + i);
                Thread.sleep(500);
            }
        }
        
        // Some more non-critical code
        System.out.println("Ending " + Thread.currentThread().getName());
    }
}

public class SynchronizedBlockExample {
    public static void main(String args[]) {
        NumberPrinter printer = new NumberPrinter();
        
        Runnable task = () -> {
            try {
                printer.printNumbers(3);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        };
        
        new Thread(task, "Thread1").start();
        new Thread(task, "Thread2").start();
    }
}
```

**Output:**
```
Starting Thread1
Starting Thread2  ‚Üê Both can execute non-critical part simultaneously
Thread1 : 1       ‚Üê Only synchronized block executes one at a time
Thread1 : 2
Thread1 : 3
Ending Thread1
Thread2 : 1       ‚Üê Thread2's synchronized block starts after Thread1 ends
Thread2 : 2
Thread2 : 3
Ending Thread2
```

## 3. Synchronized Static Method üèõÔ∏è

**Static methods class-level lock use karte hain, object-level lock nahi!**

### Example - Static Synchronized:

```java
class Counter {
    private static int count = 0;
    
    // ‚úÖ Static synchronized method - Class level lock
    public static synchronized void increment() {
        for (int i = 0; i < 5; i++) {
            count++;
            System.out.println(Thread.currentThread().getName() + " Count: " + count);
            try { Thread.sleep(300); } catch (InterruptedException e) {}
        }
    }
}

public class StaticSynchronizedExample {
    public static void main(String args[]) {
        Runnable task = () -> Counter.increment();
        
        new Thread(task, "Thread1").start();
        new Thread(task, "Thread2").start();
    }
}
```

**Output:**
```
Thread1 Count: 1
Thread1 Count: 2
Thread1 Count: 3
Thread1 Count: 4
Thread1 Count: 5
Thread2 Count: 6  ‚Üê Thread2 starts after Thread1 completes
Thread2 Count: 7
Thread2 Count: 8
Thread2 Count: 9
Thread2 Count: 10
```

## Different Types of Locks üîê

### 1. **Object Level Lock (Instance Methods)**
```java
class MyClass {
    public synchronized void method1() { }  // Uses 'this' object lock
    public synchronized void method2() { }  // Uses same 'this' object lock
    
    public void method3() {
        synchronized(this) { }  // Same as synchronized method
    }
}
```

### 2. **Class Level Lock (Static Methods)**
```java
class MyClass {
    public static synchronized void staticMethod() { }  // Uses MyClass.class lock
    
    public void instanceMethod() {
        synchronized(MyClass.class) { }  // Same as static synchronized method
    }
}
```

### 3. **Custom Object Lock**
```java
class MyClass {
    private Object lock1 = new Object();
    private Object lock2 = new Object();
    
    public void method1() {
        synchronized(lock1) {
            // Critical section 1
        }
    }
    
    public void method2() {
        synchronized(lock2) {  // Different lock - can run simultaneously
            // Critical section 2
        }
    }
}
```

## Real-World Example - Shopping Cart üõí

```java
class ShoppingCart {
    private int totalItems = 0;
    private double totalAmount = 0.0;
    
    // ‚úÖ Synchronized method for thread safety
    public synchronized void addItem(String customerName, String item, double price) {
        System.out.println(customerName + " is adding " + item + " worth $" + price);
        
        // Simulate some processing time
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
        
        totalItems++;
        totalAmount += price;
        
        System.out.println(customerName + " added " + item + 
                          ". Total items: " + totalItems + 
                          ", Total amount: $" + totalAmount);
    }
    
    public synchronized void getCartInfo() {
        System.out.println("Cart Info - Items: " + totalItems + ", Amount: $" + totalAmount);
    }
}

public class ShoppingCartExample {
    public static void main(String[] args) {
        ShoppingCart cart = new ShoppingCart();
        
        // Multiple customers adding items simultaneously
        Thread customer1 = new Thread(() -> {
            cart.addItem("Alice", "Laptop", 999.99);
            cart.addItem("Alice", "Mouse", 25.50);
        });
        
        Thread customer2 = new Thread(() -> {
            cart.addItem("Bob", "Phone", 699.99);
            cart.addItem("Bob", "Cover", 15.99);
        });
        
        customer1.start();
        customer2.start();
        
        // Wait for both customers to complete
        try {
            customer1.join();
            customer2.join();
            cart.getCartInfo();
        } catch (InterruptedException e) {}
    }
}
```

## Producer-Consumer Problem Example üè≠

```java
class Buffer {
    private int[] buffer = new int[5];
    private int count = 0;
    
    // ‚úÖ Synchronized producer method
    public synchronized void produce(int item) throws InterruptedException {
        while (count == buffer.length) {
            System.out.println("Buffer is full, producer waiting...");
            wait();  // Wait until buffer has space
        }
        
        buffer[count] = item;
        count++;
        System.out.println("Produced: " + item + " (Buffer size: " + count + ")");
        
        notify();  // Notify waiting consumer
    }
    
    // ‚úÖ Synchronized consumer method
    public synchronized int consume() throws InterruptedException {
        while (count == 0) {
            System.out.println("Buffer is empty, consumer waiting...");
            wait();  // Wait until buffer has items
        }
        
        count--;
        int item = buffer[count];
        System.out.println("Consumed: " + item + " (Buffer size: " + count + ")");
        
        notify();  // Notify waiting producer
        return item;
    }
}

public class ProducerConsumerExample {
    public static void main(String[] args) {
        Buffer buffer = new Buffer();
        
        // Producer thread
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 10; i++) {
                    buffer.produce(i);
                    Thread.sleep(200);
                }
            } catch (InterruptedException e) {}
        });
        
        // Consumer thread
        Thread consumer = new Thread(() -> {
            try {
                for (int i = 1; i <= 10; i++) {
                    buffer.consume();
                    Thread.sleep(500);  // Consumer is slower
                }
            } catch (InterruptedException e) {}
        });
        
        producer.start();
        consumer.start();
    }
}
```

## Synchronized vs Other Approaches üîÑ

### 1. **Synchronized vs Volatile**

| **Synchronized** | **Volatile** |
|------------------|--------------|
| Provides mutual exclusion | No mutual exclusion |
| Thread-safe operations | Only visibility guarantee |
| Can cause blocking | Non-blocking |
| Works with any data type | Primitive types and references |
| Performance overhead | Minimal overhead |

```java
class SynchronizedExample {
    private int counter = 0;
    
    public synchronized void increment() {  // Thread-safe
        counter++;  // Atomic operation due to synchronization
    }
}

class VolatileExample {
    private volatile int counter = 0;  // Visible to all threads
    
    public void increment() {  // NOT thread-safe!
        counter++;  // counter++ is not atomic (read-modify-write)
    }
}
```

### 2. **Synchronized vs ReentrantLock**

```java
import java.util.concurrent.locks.ReentrantLock;

class ReentrantLockExample {
    private ReentrantLock lock = new ReentrantLock();
    private int counter = 0;
    
    public void increment() {
        lock.lock();  // Acquire lock
        try {
            counter++;
        } finally {
            lock.unlock();  // Always release in finally
        }
    }
}
```

**ReentrantLock Advantages:**
- ‚úÖ More flexible than synchronized
- ‚úÖ Try-lock capability
- ‚úÖ Timeout support
- ‚úÖ Interruptible lock acquisition

## Common Mistakes - Avoid Karo! ‚ùå

### 1. **Synchronizing on Wrong Object**
```java
class WrongSync {
    private String name = "test";
    
    public void method1() {
        synchronized(name) {  // ‚ùå Wrong! String literals are shared
            // Critical section
        }
    }
    
    // ‚úÖ Correct approach
    private final Object lock = new Object();
    
    public void method2() {
        synchronized(lock) {  // ‚úÖ Correct! Private lock object
            // Critical section
        }
    }
}
```

### 2. **Deadlock Situation**
```java
class DeadlockExample {
    private Object lock1 = new Object();
    private Object lock2 = new Object();
    
    public void method1() {
        synchronized(lock1) {
            System.out.println("Method1 acquired lock1");
            synchronized(lock2) {  // ‚ùå Potential deadlock!
                System.out.println("Method1 acquired lock2");
            }
        }
    }
    
    public void method2() {
        synchronized(lock2) {
            System.out.println("Method2 acquired lock2");
            synchronized(lock1) {  // ‚ùå Opposite order - deadlock!
                System.out.println("Method2 acquired lock1");
            }
        }
    }
}
```

**Deadlock Solution - Always acquire locks in same order!**

### 3. **Over-Synchronization**
```java
class OverSynchronized {
    // ‚ùå Don't synchronize everything
    public synchronized void simpleGetter() {
        return someVariable;  // Read operations often don't need sync
    }
    
    public synchronized void heavyComputation() {
        // Long running computation - blocks other threads unnecessarily
        for(int i = 0; i < 1000000; i++) {
            // Some calculation
        }
    }
}
```

## Performance Considerations üöÄ

### 1. **Minimize Synchronized Block Size**
```java
class PerformanceOptimized {
    private int counter = 0;
    
    // ‚ùå Poor performance - entire method synchronized
    public synchronized void badMethod() {
        // Non-critical code
        someCalculation();
        
        // Critical code
        counter++;
        
        // More non-critical code
        someOtherCalculation();
    }
    
    // ‚úÖ Better performance - only critical section synchronized
    public void goodMethod() {
        // Non-critical code
        someCalculation();
        
        // Only critical section synchronized
        synchronized(this) {
            counter++;
        }
        
        // More non-critical code
        someOtherCalculation();
    }
}
```

### 2. **Use Appropriate Lock Granularity**
```java
class GranularityExample {
    private int account1Balance = 1000;
    private int account2Balance = 2000;
    
    // ‚ùå Coarse-grained locking - both accounts blocked
    public synchronized void transferCoarse(int amount) {
        account1Balance -= amount;
        account2Balance += amount;
    }
    
    // ‚úÖ Fine-grained locking - separate locks for each account
    private Object account1Lock = new Object();
    private Object account2Lock = new Object();
    
    public void transferFine(int amount) {
        synchronized(account1Lock) {
            account1Balance -= amount;
        }
        synchronized(account2Lock) {
            account2Balance += amount;
        }
    }
}
```

## Interview Questions - Master Karo! üí™

### Q1: **What is difference between synchronized method and synchronized block?**
```java
class Comparison {
    // Synchronized method - entire method locked
    public synchronized void synchronizedMethod() {
        // Entire method is critical section
    }
    
    // Synchronized block - only specific part locked
    public void methodWithSynchronizedBlock() {
        // Non-critical code
        someCalculation();
        
        synchronized(this) {
            // Only this part is critical section
            criticalOperation();
        }
        
        // More non-critical code
    }
}
```

### Q2: **Can we use synchronized with constructor?**
**Answer**: Nahi! Constructor synchronized nahi ho sakta because constructor call karte time sirf ek thread involved hota hai (jo object create kar raha hai).

### Q3: **What happens if we call synchronized method from another synchronized method?**
```java
class ReentrantExample {
    public synchronized void method1() {
        System.out.println("In method1");
        method2();  // ‚úÖ Same thread can acquire lock again (Reentrant)
    }
    
    public synchronized void method2() {
        System.out.println("In method2");
    }
}
```
**Answer**: Java locks are reentrant, so same thread lock ko multiple times acquire kar sakta hai.

### Q4: **Difference between synchronized and volatile?**
**Answer**: 
- **Synchronized**: Mutual exclusion + visibility guarantee
- **Volatile**: Only visibility guarantee, no mutual exclusion

### Q5: **Can two threads execute two different synchronized methods simultaneously?**
```java
class TwoMethods {
    public synchronized void method1() { }
    public synchronized void method2() { }
}
```
**Answer**: Nahi! Dono methods same object lock use karte hain, so ek time mein sirf ek method execute ho sakta hai.

## Best Practices üåü

### 1. **Always Use Private Lock Objects**
```java
class BestPractice {
    private final Object lock = new Object();  // ‚úÖ Private lock
    
    public void method() {
        synchronized(lock) {  // ‚úÖ Use private lock
            // Critical section
        }
    }
}
```

### 2. **Use try-finally with Manual Locks**
```java
import java.util.concurrent.locks.ReentrantLock;

class ManualLocking {
    private ReentrantLock lock = new ReentrantLock();
    
    public void method() {
        lock.lock();
        try {
            // Critical section
        } finally {
            lock.unlock();  // ‚úÖ Always unlock in finally
        }
    }
}
```

### 3. **Document Thread Safety**
```java
/**
 * Thread-safe counter implementation
 * All public methods are synchronized for thread safety
 */
class ThreadSafeCounter {
    private int count = 0;
    
    /**
     * Thread-safe increment operation
     */
    public synchronized void increment() {
        count++;
    }
    
    /**
     * Thread-safe get operation
     */
    public synchronized int getCount() {
        return count;
    }
}
```

### 4. **Prefer High-Level Concurrency Utilities**
```java
import java.util.concurrent.atomic.AtomicInteger;

class ModernApproach {
    private AtomicInteger counter = new AtomicInteger(0);  // ‚úÖ Lock-free
    
    public void increment() {
        counter.incrementAndGet();  // Thread-safe without synchronization
    }
    
    public int getCount() {
        return counter.get();
    }
}
```

## Summary - Quick Recap! üìù

### **Key Points to Remember:**

1. üîí **Synchronized** provides thread safety through mutual exclusion
2. üè† **Object-level lock** for instance methods
3. üèõÔ∏è **Class-level lock** for static methods  
4. üéØ **Synchronized block** offers more flexibility
5. ‚ö° **Performance impact** due to blocking nature
6. üîÑ **Reentrant locks** - same thread can acquire multiple times
7. üíÄ **Deadlock risk** with multiple locks

### **When to Use Synchronized:**
- ‚úÖ Simple thread safety requirements
- ‚úÖ Legacy codebases
- ‚úÖ Basic mutual exclusion needs

### **When NOT to Use Synchronized:**
- ‚ùå High-performance applications
- ‚ùå Complex locking scenarios
- ‚ùå When you need timeout/interruptible locks

### **Modern Alternatives:**
- `java.util.concurrent` package
- `ReentrantLock`, `ReadWriteLock`
- `AtomicInteger`, `AtomicReference`
- `ConcurrentHashMap`, `BlockingQueue`

### **Memory Tricks:**
- **SYNCHRONIZED** = **SYNC** karo threads ko, **SERIAL** execution
- **Lock** = ‡§è‡§ï ‡§∏‡§Æ‡§Ø ‡§Æ‡•á‡§Ç ‡§è‡§ï ‡§π‡•Ä ‡§ö‡§æ‡§¨‡•Ä (key) üîë
- **Thread Safety** = Traffic signals ‡§ú‡•à‡§∏‡•á - organized flow! üö¶

Practice these concepts with real multithreading examples and you'll master synchronized keyword! üöÄüí™

---
*Happy Multithreading! üéâ*
