# Lambda Expression with Multithreading - Complete Study Notes 📚

## Introduction - Thread Creation Ki Evolution! 🧬

**Story Time:** Pehle Thread banane ke liye kitna struggle karna padta tha! 😅
- Extra classes banani padti thi
- Boilerplate code likhna padta tha
- Multiple .class files generate hoti thi

**But then came Lambda Expressions!** 🌟
- Clean code
- Less boilerplate
- Easy to understand
- Modern Java style!

## Thread Creation Methods - Evolution Story! 📈

### Method 1: Extending Thread Class (Old School) 👴

```java
// ❌ Old way - Not recommended
class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 9; i++) {
            System.out.println("Child Thread: " + i);
        }
    }
}

public class ThreadByExtending {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start();
        
        for (int i = 0; i < 9; i++) {
            System.out.println("Main Thread: " + i);
        }
    }
}
```

**Output:**
```
Main Thread: 0
Main Thread: 1
Main Thread: 2
Main Thread: 3
Main Thread: 4
Main Thread: 5
Main Thread: 6
Main Thread: 7
Main Thread: 8
Child Thread: 0
Child Thread: 1
Child Thread: 2
Child Thread: 3
Child Thread: 4
Child Thread: 5
Child Thread: 6
Child Thread: 7
Child Thread: 8
```

**Problems with this approach:**
- ❌ Extra class `MyThread` create karni padi
- ❌ Multiple inheritance nahi kar sakte (Java limitation)
- ❌ Code length badhta hai
- ❌ Two `.class` files generate hoti hain: `MyThread.class` + `Test.class`

### Method 2: Implementing Runnable Interface (Better) 👍

```java
// ✅ Better approach
class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 9; i++) {
            System.out.println("Child Thread: " + i);
        }
    }
}

public class ThreadByRunnable {
    public static void main(String[] args) {
        MyRunnable r = new MyRunnable();
        Thread t = new Thread(r);
        t.start();
        
        for (int i = 0; i < 9; i++) {
            System.out.println("Main Thread: " + i);
        }
    }
}
```

**Advantages:**
- ✅ Multiple inheritance possible (can extend another class)
- ✅ Better design pattern

**Still Problems:**
- ❌ Extra class `MyRunnable` create karni pad rahi
- ❌ Two `.class` files: `MyRunnable.class` + `Test.class`
- ❌ Boilerplate code

### Method 3: Anonymous Inner Class (Better++) 👌

```java
// ✅ Even better - No extra class needed
public class ThreadByAnonymous {
    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 9; i++) {
                    System.out.println("Child Thread: " + i);
                }
            }
        }).start();
        
        for (int i = 0; i < 9; i++) {
            System.out.println("Main Thread: " + i);
        }
    }
}
```

**Advantages:**
- ✅ No extra class needed
- ✅ Code concise ho gaya

**Still Problems:**
- ❌ Still generates: `Test$1.class` + `Test.class`
- ❌ Anonymous class syntax thoda complex

### Method 4: Lambda Expression (Modern & Clean!) 🚀

```java
// ✅ Best approach - Modern Java way!
public class ThreadByLambda {
    public static void main(String[] args) {
        // Method 4a: Lambda with variable
        Runnable r = () -> {
            for (int i = 0; i < 9; i++) {
                System.out.println("Child Thread: " + i);
            }
        };
        Thread t = new Thread(r);
        t.start();
        
        for (int i = 0; i < 9; i++) {
            System.out.println("Main Thread: " + i);
        }
    }
}
```

**Ultra Clean Version:**
```java
public class ThreadByLambdaClean {
    public static void main(String[] args) {
        // Method 4b: Direct lambda
        new Thread(() -> {
            for (int i = 0; i < 9; i++) {
                System.out.println("Child Thread: " + i);
            }
        }).start();
        
        for (int i = 0; i < 9; i++) {
            System.out.println("Main Thread: " + i);
        }
    }
}
```

**Why Lambda is Best:**
- ✅ No extra class needed
- ✅ Clean and readable code
- ✅ Only one `.class` file: `Test.class`
- ✅ Modern Java 8+ style
- ✅ Less boilerplate code
- ✅ Functional programming approach

## Lambda Expression Deep Dive 🏊‍♂️

### What is Lambda Expression?

**Simple Definition:** Anonymous function jo concise way mein write kar sakte hain!

**Syntax:**
```java
(parameters) -> { body }
```

### Lambda with Runnable Interface

**Runnable Interface:**
```java
@FunctionalInterface
public interface Runnable {
    public void run();
}
```

**Traditional way vs Lambda way:**

#### Traditional Anonymous Class:
```java
Runnable r = new Runnable() {
    @Override
    public void run() {
        System.out.println("Traditional way");
    }
};
```

#### Lambda Way:
```java
Runnable r = () -> {
    System.out.println("Lambda way");
};

// Even shorter for single statement:
Runnable r = () -> System.out.println("Lambda way - one liner");
```

## Multiple Threading Examples with Lambda 🎯

### Example 1: Simple Thread with Lambda

```java
public class LambdaThreadExample1 {
    public static void main(String[] args) {
        System.out.println("Main thread: " + Thread.currentThread().getName());
        
        // Create and start thread using lambda
        Thread thread = new Thread(() -> {
            System.out.println("Lambda thread: " + Thread.currentThread().getName());
            
            for (int i = 1; i <= 5; i++) {
                System.out.println("Count: " + i);
                try {
                    Thread.sleep(1000); // Sleep for 1 second
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });
        
        thread.start();
        
        // Main thread continues
        for (int i = 1; i <= 3; i++) {
            System.out.println("Main thread working: " + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

**Output:**
```
Main thread: main
Lambda thread: Thread-0
Main thread working: 1
Count: 1
Main thread working: 2
Count: 2
Main thread working: 3
Count: 3
Count: 4
Count: 5
```

### Example 2: Multiple Threads with Lambda

```java
public class MultipleLambdaThreads {
    public static void main(String[] args) {
        // Create multiple threads using lambda
        
        // Thread 1: Print even numbers
        Thread evenThread = new Thread(() -> {
            System.out.println("Even numbers thread started");
            for (int i = 0; i <= 10; i += 2) {
                System.out.println("Even: " + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        // Thread 2: Print odd numbers
        Thread oddThread = new Thread(() -> {
            System.out.println("Odd numbers thread started");
            for (int i = 1; i <= 10; i += 2) {
                System.out.println("Odd: " + i);
                try {
                    Thread.sleep(700);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        // Thread 3: Print alphabets
        Thread alphabetThread = new Thread(() -> {
            System.out.println("Alphabet thread started");
            for (char c = 'A'; c <= 'E'; c++) {
                System.out.println("Letter: " + c);
                try {
                    Thread.sleep(600);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        
        // Start all threads
        evenThread.start();
        oddThread.start();
        alphabetThread.start();
        
        System.out.println("All threads started!");
    }
}
```

### Example 3: Thread with Parameters (Using Lambda)

```java
public class ParameterizedLambdaThread {
    public static void main(String[] args) {
        // Method to create thread with parameters
        createCounterThread("Counter-1", 1, 5, 500);
        createCounterThread("Counter-2", 10, 15, 300);
        createCounterThread("Counter-3", 100, 103, 700);
    }
    
    public static void createCounterThread(String name, int start, int end, int delay) {
        Thread thread = new Thread(() -> {
            System.out.println(name + " started");
            for (int i = start; i <= end; i++) {
                System.out.println(name + ": " + i);
                try {
                    Thread.sleep(delay);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return;
                }
            }
            System.out.println(name + " completed");
        });
        
        thread.setName(name);
        thread.start();
    }
}
```

### Example 4: Producer-Consumer with Lambda

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;

public class ProducerConsumerLambda {
    public static void main(String[] args) {
        BlockingQueue<Integer> queue = new LinkedBlockingQueue<>(5);
        
        // Producer thread using lambda
        Thread producer = new Thread(() -> {
            try {
                for (int i = 1; i <= 10; i++) {
                    queue.put(i);
                    System.out.println("Produced: " + i);
                    Thread.sleep(100);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        // Consumer thread using lambda
        Thread consumer = new Thread(() -> {
            try {
                while (true) {
                    Integer item = queue.take();
                    System.out.println("Consumed: " + item);
                    Thread.sleep(200);
                    
                    if (item == 10) break; // Exit condition
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
        
        producer.start();
        consumer.start();
    }
}
```

## Advanced Lambda Threading Concepts 🎓

### 1. Thread Pool with Lambda

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolLambda {
    public static void main(String[] args) {
        // Create thread pool
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        // Submit tasks using lambda
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            executor.submit(() -> {
                System.out.println("Task " + taskId + " executed by: " + 
                    Thread.currentThread().getName());
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                System.out.println("Task " + taskId + " completed");
            });
        }
        
        executor.shutdown();
    }
}
```

### 2. Callable with Lambda (Returns Result)

```java
import java.util.concurrent.*;

public class CallableLambda {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executor = Executors.newSingleThreadExecutor();
        
        // Callable that returns result
        Future<String> future = executor.submit(() -> {
            Thread.sleep(2000);
            return "Hello from Callable Lambda!";
        });
        
        System.out.println("Doing other work...");
        
        // Get result (blocks until completion)
        String result = future.get();
        System.out.println("Result: " + result);
        
        executor.shutdown();
    }
}
```

### 3. CompletableFuture with Lambda

```java
import java.util.concurrent.CompletableFuture;

public class CompletableFutureLambda {
    public static void main(String[] args) {
        // Asynchronous computation
        CompletableFuture<String> future = CompletableFuture
            .supplyAsync(() -> {
                System.out.println("Computing in background...");
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
                return "Async Result";
            })
            .thenApply(result -> result.toUpperCase())
            .thenApply(result -> "Final: " + result);
        
        System.out.println("Main thread continues...");
        
        // Get result (blocks)
        future.thenAccept(System.out::println);
        
        // Keep main thread alive
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

## Comparison Table - All Methods! 📊

| **Method** | **Code Lines** | **Extra Classes** | **Generated .class Files** | **Readability** | **Modern** |
|------------|---------------|-------------------|----------------------------|-----------------|------------|
| Extending Thread | High 📈 | Yes ❌ | 2+ | Medium 📊 | Old 👴 |
| Implementing Runnable | High 📈 | Yes ❌ | 2+ | Medium 📊 | Old 👴 |
| Anonymous Inner Class | Medium 📊 | No ✅ | 2 | Medium 📊 | Okay 👌 |
| **Lambda Expression** | **Low 📉** | **No ✅** | **1** | **High 📈** | **Modern 🚀** |

## Benefits of Lambda in Threading 🎯

### 1. **Concise Code**
```java
// Before Lambda (Anonymous Inner Class)
Thread t1 = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("Hello World");
    }
});

// After Lambda
Thread t2 = new Thread(() -> System.out.println("Hello World"));
```

### 2. **Better Readability**
```java
// Multiple threads with different tasks
Thread fileReader = new Thread(() -> readFile("data.txt"));
Thread dataProcessor = new Thread(() -> processData());
Thread reportGenerator = new Thread(() -> generateReport());

fileReader.start();
dataProcessor.start();
reportGenerator.start();
```

### 3. **Easy Parameterization**
```java
public static Thread createTask(String name, Runnable task) {
    return new Thread(() -> {
        System.out.println("Starting task: " + name);
        task.run();
        System.out.println("Completed task: " + name);
    });
}

// Usage
createTask("File Processing", () -> System.out.println("Processing file...")).start();
createTask("Data Validation", () -> System.out.println("Validating data...")).start();
```

### 4. **Functional Style Programming**
```java
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class FunctionalThreading {
    public static void main(String[] args) {
        List<String> tasks = Arrays.asList("Task1", "Task2", "Task3", "Task4");
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // Functional style with lambda
        tasks.stream()
             .map(taskName -> (Runnable) () -> {
                 System.out.println("Processing: " + taskName + 
                     " on " + Thread.currentThread().getName());
                 try {
                     Thread.sleep(1000);
                 } catch (InterruptedException e) {
                     Thread.currentThread().interrupt();
                 }
             })
             .forEach(executor::submit);
        
        executor.shutdown();
    }
}
```

## Real-World Examples 🌍

### Example 1: File Processing System

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.Arrays;
import java.util.List;

public class FileProcessingSystem {
    public static void main(String[] args) {
        List<String> files = Arrays.asList(
            "document1.txt", "document2.txt", "document3.txt", 
            "image1.jpg", "image2.jpg", "data.csv"
        );
        
        ExecutorService executor = Executors.newFixedThreadPool(3);
        
        files.forEach(fileName -> 
            executor.submit(() -> processFile(fileName))
        );
        
        executor.shutdown();
    }
    
    private static void processFile(String fileName) {
        System.out.println("Processing file: " + fileName + 
            " on thread: " + Thread.currentThread().getName());
        
        // Simulate file processing
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
        }
        
        System.out.println("Completed processing: " + fileName);
    }
}
```

### Example 2: Web Server Request Handler

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class WebServerSimulation {
    private static final ExecutorService requestHandler = Executors.newFixedThreadPool(10);
    
    public static void main(String[] args) {
        // Simulate incoming requests
        for (int i = 1; i <= 20; i++) {
            final int requestId = i;
            handleRequest(requestId);
        }
        
        requestHandler.shutdown();
    }
    
    public static void handleRequest(int requestId) {
        requestHandler.submit(() -> {
            System.out.println("Processing request " + requestId + 
                " on thread: " + Thread.currentThread().getName());
            
            // Simulate request processing time
            try {
                Thread.sleep(1000 + (int)(Math.random() * 2000));
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return;
            }
            
            System.out.println("Request " + requestId + " completed");
        });
    }
}
```

### Example 3: Data Pipeline with Lambda

```java
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

public class DataPipeline {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // Data processing pipeline using CompletableFuture and Lambda
        
        CompletableFuture<String> dataFetch = CompletableFuture
            .supplyAsync(() -> {
                System.out.println("Fetching data from database...");
                sleep(1000);
                return "Raw Data from DB";
            });
        
        CompletableFuture<String> dataTransform = dataFetch
            .thenApplyAsync(data -> {
                System.out.println("Transforming data...");
                sleep(800);
                return data.toUpperCase().replace(" ", "_");
            });
        
        CompletableFuture<String> dataValidation = dataTransform
            .thenApplyAsync(data -> {
                System.out.println("Validating data...");
                sleep(600);
                return "VALIDATED_" + data;
            });
        
        CompletableFuture<Void> dataSave = dataValidation
            .thenAcceptAsync(data -> {
                System.out.println("Saving data: " + data);
                sleep(500);
                System.out.println("Data saved successfully!");
            });
        
        // Wait for completion
        dataSave.get();
        System.out.println("Pipeline completed!");
    }
    
    private static void sleep(int millis) {
        try {
            Thread.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

## Common Mistakes & Best Practices ⚠️

### ❌ Common Mistakes:

#### 1. **Not Handling InterruptedException Properly**
```java
// ❌ Wrong way
Thread t = new Thread(() -> {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        // Just printing - not good!
        e.printStackTrace();
    }
});

// ✅ Correct way
Thread t = new Thread(() -> {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt(); // Restore interrupted status
        return; // Exit gracefully
    }
});
```

#### 2. **Not Using Thread Pools**
```java
// ❌ Wrong - Creating too many threads
for (int i = 0; i < 1000; i++) {
    new Thread(() -> doSomeWork()).start(); // Resource wastage!
}

// ✅ Correct - Using thread pool
ExecutorService executor = Executors.newFixedThreadPool(10);
for (int i = 0; i < 1000; i++) {
    executor.submit(() -> doSomeWork());
}
executor.shutdown();
```

#### 3. **Forgetting to Shutdown ExecutorService**
```java
// ❌ Wrong - Program won't terminate
ExecutorService executor = Executors.newFixedThreadPool(5);
executor.submit(() -> System.out.println("Task completed"));
// Missing shutdown() - program hangs!

// ✅ Correct
ExecutorService executor = Executors.newFixedThreadPool(5);
executor.submit(() -> System.out.println("Task completed"));
executor.shutdown(); // Always shutdown!
```

### ✅ Best Practices:

#### 1. **Use Method References When Possible**
```java
// Good
Thread t1 = new Thread(() -> System.out.println("Hello"));

// Even better
Thread t2 = new Thread(System.out::println);
```

#### 2. **Name Your Threads**
```java
Thread worker = new Thread(() -> {
    // Heavy work
}, "WorkerThread-1");
worker.start();
```

#### 3. **Use CompletableFuture for Complex Async Operations**
```java
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> fetchDataFromAPI())
    .thenApply(this::transformData)
    .thenApply(this::validateData)
    .exceptionally(throwable -> {
        System.err.println("Error: " + throwable.getMessage());
        return "Default Value";
    });
```

## Interview Questions - Master Karo! 💪

### Q1: **What are the advantages of using Lambda with threads?**

**Answer:**
- ✅ **Concise Code**: Less boilerplate code
- ✅ **No Extra Classes**: Eliminates need for separate classes
- ✅ **Better Readability**: Code is more readable and maintainable
- ✅ **Functional Style**: Supports functional programming paradigm
- ✅ **Less Memory**: Only one .class file generated

### Q2: **Can we use Lambda with Thread constructors directly?**

```java
// ✅ Yes! Multiple ways:

// Method 1: Direct lambda in constructor
new Thread(() -> System.out.println("Direct lambda")).start();

// Method 2: Lambda with variable
Runnable task = () -> System.out.println("Lambda with variable");
new Thread(task).start();

// Method 3: Method reference (if applicable)
new Thread(SomeClass::someStaticMethod).start();
```

### Q3: **What is the difference between Runnable and Callable with Lambda?**

```java
// Runnable - No return value, no checked exceptions
Runnable runnable = () -> {
    System.out.println("Runnable task");
    // Cannot return anything
    // Cannot throw checked exceptions directly
};

// Callable - Returns value, can throw exceptions
Callable<String> callable = () -> {
    Thread.sleep(1000); // Can throw InterruptedException
    return "Callable result"; // Returns value
};

ExecutorService executor = Executors.newSingleThreadExecutor();
executor.submit(runnable);
Future<String> future = executor.submit(callable);
```

### Q4: **How to handle exceptions in Lambda threads?**

```java
// Method 1: Try-catch inside lambda
Thread t1 = new Thread(() -> {
    try {
        riskyMethod();
    } catch (Exception e) {
        System.err.println("Error in thread: " + e.getMessage());
    }
});

// Method 2: Using CompletableFuture for better exception handling
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> {
        // This can throw exceptions
        return riskyMethod();
    })
    .exceptionally(throwable -> {
        System.err.println("Exception: " + throwable.getMessage());
        return "Default value";
    });
```

### Q5: **Can we access local variables in Lambda threads?**

```java
public void example() {
    int localVar = 10;
    final int finalVar = 20;
    
    // ✅ Can access final variables
    Thread t1 = new Thread(() -> {
        System.out.println("Final var: " + finalVar);
    });
    
    // ✅ Can access effectively final variables (not modified after initialization)
    Thread t2 = new Thread(() -> {
        System.out.println("Local var: " + localVar);
    });
    
    // ❌ Cannot access variables that are modified later
    // localVar = 30; // This would cause compilation error in lambda above
}
```

## Summary - Quick Recap! 📝

### **Evolution of Thread Creation:**
1. 👴 **Thread Class Extension** - Old, rigid
2. 👍 **Runnable Interface** - Better, but verbose
3. 👌 **Anonymous Inner Class** - Good, but still verbose
4. 🚀 **Lambda Expression** - Modern, clean, concise!

### **Why Lambda is Best for Threading:**
- ✅ **Minimal Code**: Less boilerplate
- ✅ **Single .class File**: Reduced memory footprint
- ✅ **Functional Style**: Modern programming approach
- ✅ **Easy to Read**: Self-documenting code
- ✅ **Flexible**: Easy to modify and maintain

### **Key Syntax Patterns:**
```java
// Basic syntax
() -> { /* code */ }

// With parameters
(param1, param2) -> { /* code */ }

// Single statement (no braces needed)
() -> System.out.println("Hello")

// With return value
() -> "Return value"
```

### **Best Use Cases:**
- 🎯 **Simple Thread Tasks**: Quick background operations
- 🎯 **Thread Pool Tasks**: ExecutorService submissions
- 🎯 **Async Operations**: CompletableFuture chains
- 🎯 **Event Handling**: UI thread operations
- 🎯 **Parallel Processing**: Stream parallel operations

### **Remember This:**
*"Lambda with threading = Clean code + Modern approach + Better performance!"* 🚀

Practice these examples aur tum multithreading with lambda master kar jaoge! 💪

---
*Happy Coding! 🎉*
