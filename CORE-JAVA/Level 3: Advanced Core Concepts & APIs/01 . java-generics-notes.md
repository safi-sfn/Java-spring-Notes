# Java Generics - Complete Study Notes 📚

## Generics Kya Hai Bhai? 🤔

**Simple Words Mein**: Generics matlab "Generic Medicine" ki tarah - ek hi medicine multiple diseases ke liye! 💊

**Real Life Example**: 
- Jaise ek container mein alag-alag cheezein store kar sakte ho (rice, dal, sugar)
- Waise hi Generic class mein different data types store kar sakte ho! 📦

**Technical Definition**: Generics allow us to create classes, interfaces, and methods that work with different data types while providing compile-time type safety.

**Before Generics (Java 1.4)**:
```java
// Purane zamaane mein - Type safety nahi thi! 😱
ArrayList list = new ArrayList();
list.add(10);          // Integer
list.add("Hello");     // String
list.add(3.14);        // Double

// Runtime pe crash ho jaata tha!
String str = (String) list.get(0);  // ClassCastException! 💥
```

**After Generics (Java 1.5+)**:
```java
// Ab safe hai! 😊
ArrayList<String> list = new ArrayList<String>();
list.add("Hello");
// list.add(10);       // ❌ Compile-time error!
String str = list.get(0);  // ✅ No casting needed!
```

## Why Use Generics? - Fayde Kya Hain? 🎯

### 1. **Type Safety** 🛡️

**Problem Without Generics:**
```java
// Purane style - Dangerous! ⚠️
ArrayList dangerousList = new ArrayList();
dangerousList.add(1001);
dangerousList.add("SpringJava");  // Different type!

// Runtime crash hoga!
Integer number = (Integer) dangerousList.get(1);  // 💥 ClassCastException!
```

**Solution With Generics:**
```java
// Safe approach! ✅
ArrayList<Integer> safeList = new ArrayList<Integer>();
safeList.add(1001);
// safeList.add("SpringJava");  // ❌ Compiler error - prevented!

Integer number = safeList.get(0);  // ✅ Safe!
```

### 2. **No Type Casting Required** 🎭

**Before Generics:**
```java
ArrayList list = new ArrayList();
list.add("Hello");
list.add("World");

// Har baar casting karna padta tha! 😵
String str1 = (String) list.get(0);  // Casting required
String str2 = (String) list.get(1);  // Casting required
```

**After Generics:**
```java
ArrayList<String> list = new ArrayList<String>();
list.add("Hello");
list.add("World");

// No casting needed! 🎉
String str1 = list.get(0);  // Direct access
String str2 = list.get(1);  // Direct access
```

### 3. **Code Reusability** ♻️

```java
// One class, multiple data types! 🚀
ArrayList<String> stringList = new ArrayList<String>();     // For strings
ArrayList<Integer> intList = new ArrayList<Integer>();      // For integers  
ArrayList<Float> floatList = new ArrayList<Float>();        // For floats
ArrayList<Character> charList = new ArrayList<Character>(); // For characters

// Same ArrayList class, different behaviors!
```

## Types of Generics - Kitne Prakar Ke Hain? 📝

### 1. **Generic Class** 🏠

**Definition**: Class ko type parameter ke saath declare karna.

```java
// Generic Class Definition
class Container<T> {
    private T item;  // T can be any type!
    
    // Constructor
    public Container(T item) {
        this.item = item;
    }
    
    // Getter method
    public T getItem() {
        return this.item;
    }
    
    // Setter method  
    public void setItem(T item) {
        this.item = item;
    }
    
    // Display method
    public void displayInfo() {
        System.out.println("Item: " + item);
        System.out.println("Type: " + item.getClass().getSimpleName());
    }
}

// Usage Examples
public class GenericClassTest {
    public static void main(String[] args) {
        // Integer container
        Container<Integer> intContainer = new Container<Integer>(1001);
        intContainer.displayInfo();
        System.out.println("Integer Value: " + intContainer.getItem());
        
        // String container
        Container<String> stringContainer = new Container<String>("SpringJava");
        stringContainer.displayInfo();
        System.out.println("String Value: " + stringContainer.getItem());
        
        // Float container
        Container<Float> floatContainer = new Container<Float>(20.55f);
        floatContainer.displayInfo();
        System.out.println("Float Value: " + floatContainer.getItem());
        
        // Character container
        Container<Character> charContainer = new Container<Character>('S');
        charContainer.displayInfo();
        System.out.println("Character Value: " + charContainer.getItem());
    }
}
```

**Output:**
```
Item: 1001
Type: Integer
Integer Value: 1001
Item: SpringJava
Type: String
String Value: SpringJava
Item: 20.55
Type: Float
Float Value: 20.55
Item: S
Type: Character
Character Value: S
```

### 2. **Generic Method** 🔧

**Definition**: Method ko type parameter ke saath declare karna.

```java
public class GenericMethodExample {
    
    // Generic method - can accept any type
    public static <T> void printData(T data) {
        System.out.println("Data: " + data);
        System.out.println("Type: " + data.getClass().getSimpleName());
        System.out.println("-------------------------");
    }
    
    // Generic method with multiple types
    public static <T, U> void printTwoData(T first, U second) {
        System.out.println("First: " + first + " (Type: " + first.getClass().getSimpleName() + ")");
        System.out.println("Second: " + second + " (Type: " + second.getClass().getSimpleName() + ")");
        System.out.println("-------------------------");
    }
    
    // Generic method with return type
    public static <T> T getFirstElement(T[] array) {
        if (array.length > 0) {
            return array[0];
        }
        return null;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Generic Method Examples ===");
        
        // Different data types
        printData(1001);              // Integer
        printData("SpringJava");      // String
        printData(20.55f);           // Float
        printData(true);             // Boolean
        
        // Multiple types
        printTwoData("Name", 25);
        printTwoData(3.14, "Pi");
        
        // Array examples
        Integer[] intArray = {10, 20, 30};
        String[] strArray = {"Hello", "World", "Java"};
        
        System.out.println("First Integer: " + getFirstElement(intArray));
        System.out.println("First String: " + getFirstElement(strArray));
    }
}
```

**Output:**
```
=== Generic Method Examples ===
Data: 1001
Type: Integer
-------------------------
Data: SpringJava
Type: String
-------------------------
Data: 20.55
Type: Float
-------------------------
Data: true
Type: Boolean
-------------------------
First: Name (Type: String)
Second: 25 (Type: Integer)
-------------------------
First: 3.14 (Type: Double)
Second: Pi (Type: String)
-------------------------
First Integer: 10
First String: Hello
```

### 3. **Generic Interface** 🔌

```java
// Generic Interface
interface Comparable<T> {
    int compareTo(T other);
}

// Implementation
class Student implements Comparable<Student> {
    private String name;
    private int age;
    
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    @Override
    public int compareTo(Student other) {
        return Integer.compare(this.age, other.age);
    }
    
    @Override
    public String toString() {
        return name + " (Age: " + age + ")";
    }
}
```

## Type Parameters - Symbol Kya Hain? 🔤

| **Symbol** | **Meaning** | **Example Usage** |
|-----------|-------------|-------------------|
| **T** | Type | `class Box<T>` |
| **E** | Element | `List<E>`, `Set<E>` |
| **K** | Key | `Map<K, V>` |
| **V** | Value | `Map<K, V>` |
| **N** | Number | `class Calculator<N extends Number>` |
| **?** | Wildcard | `List<?>` |

### Example: HashMap with K and V

```java
import java.util.HashMap;
import java.util.Map;

public class KeyValueExample {
    public static void main(String[] args) {
        // K = Integer (Key type), V = String (Value type)
        HashMap<Integer, String> studentMap = new HashMap<>();
        
        // Adding data
        studentMap.put(1001, "Peter");
        studentMap.put(1002, "Robert");
        studentMap.put(1003, "John");
        studentMap.put(1004, "Alice");
        
        System.out.println("=== Student Database ===");
        
        // Iterating through map
        for (Map.Entry<Integer, String> entry : studentMap.entrySet()) {
            System.out.println("ID: " + entry.getKey() + " → Name: " + entry.getValue());
        }
        
        // Different type combinations
        HashMap<String, Integer> ageMap = new HashMap<>();
        ageMap.put("Peter", 25);
        ageMap.put("Alice", 23);
        
        System.out.println("\n=== Age Database ===");
        for (Map.Entry<String, Integer> entry : ageMap.entrySet()) {
            System.out.println("Name: " + entry.getKey() + " → Age: " + entry.getValue());
        }
    }
}
```

**Output:**
```
=== Student Database ===
ID: 1001 → Name: Peter
ID: 1002 → Name: Robert
ID: 1003 → Name: John
ID: 1004 → Name: Alice

=== Age Database ===
Name: Peter → Age: 25
Name: Alice → Age: 23
```

## Wildcards in Generics - Advanced Level! 🃏

### 1. **Upper Bound Wildcards** (`<? extends T>`) ⬆️

**Concept**: "T ya uske subclasses accept karo"

```java
import java.util.ArrayList;
import java.util.Arrays;

public class UpperBoundExample {
    
    // Method accepts List of Number or its subtypes
    private static double calculateSum(ArrayList<? extends Number> numbers) {
        double sum = 0.0;
        for (Number num : numbers) {
            sum += num.doubleValue();
        }
        return sum;
    }
    
    public static void main(String[] args) {
        System.out.println("=== Upper Bound Wildcards Example ===");
        
        // Integer list (Integer extends Number)
        ArrayList<Integer> intList = new ArrayList<>();
        intList.addAll(Arrays.asList(10, 20, 30, 40));
        System.out.println("Integer List: " + intList);
        System.out.println("Sum: " + calculateSum(intList));
        
        // Float list (Float extends Number)
        ArrayList<Float> floatList = new ArrayList<>();
        floatList.addAll(Arrays.asList(1.5f, 2.0f, 2.5f));
        System.out.println("Float List: " + floatList);
        System.out.println("Sum: " + calculateSum(floatList));
        
        // Double list (Double extends Number)
        ArrayList<Double> doubleList = new ArrayList<>();
        doubleList.addAll(Arrays.asList(3.14, 2.71, 1.41));
        System.out.println("Double List: " + doubleList);
        System.out.println("Sum: " + calculateSum(doubleList));
        
        // String list won't work
        // ArrayList<String> stringList = new ArrayList<>();
        // calculateSum(stringList);  // ❌ Compile error!
    }
}
```

**Output:**
```
=== Upper Bound Wildcards Example ===
Integer List: [10, 20, 30, 40]
Sum: 100.0
Float List: [1.5, 2.0, 2.5]
Sum: 6.0
Double List: [3.14, 2.71, 1.41]
Sum: 7.26
```

### 2. **Lower Bound Wildcards** (`<? super T>`) ⬇️

**Concept**: "T ya uske superclasses accept karo"

```java
import java.util.ArrayList;
import java.util.Arrays;

public class LowerBoundExample {
    
    // Method accepts List of Integer or its supertypes
    private static void addIntegers(ArrayList<? super Integer> list) {
        list.add(100);
        list.add(200);
        list.add(300);
        System.out.println("Added integers to list: " + list);
    }
    
    public static void main(String[] args) {
        System.out.println("=== Lower Bound Wildcards Example ===");
        
        // Integer list (exactly Integer)
        ArrayList<Integer> intList = new ArrayList<>();
        intList.addAll(Arrays.asList(10, 20));
        System.out.println("Before - Integer List: " + intList);
        addIntegers(intList);
        
        // Number list (Number is supertype of Integer)
        ArrayList<Number> numberList = new ArrayList<>();
        numberList.addAll(Arrays.asList(1.5, 2.7));
        System.out.println("Before - Number List: " + numberList);
        addIntegers(numberList);
        
        // Object list (Object is supertype of Integer)
        ArrayList<Object> objectList = new ArrayList<>();
        objectList.addAll(Arrays.asList("Hello", "World"));
        System.out.println("Before - Object List: " + objectList);
        addIntegers(objectList);
        
        // Double list won't work (Double is not supertype of Integer)
        // ArrayList<Double> doubleList = new ArrayList<>();
        // addIntegers(doubleList);  // ❌ Compile error!
    }
}
```

**Output:**
```
=== Lower Bound Wildcards Example ===
Before - Integer List: [10, 20]
Added integers to list: [10, 20, 100, 200, 300]
Before - Number List: [1.5, 2.7]
Added integers to list: [1.5, 2.7, 100, 200, 300]
Before - Object List: [Hello, World]
Added integers to list: [Hello, World, 100, 200, 300]
```

### 3. **Unbounded Wildcards** (`<?>`) 🌟

**Concept**: "Koi bhi type accept karo"

```java
import java.util.ArrayList;
import java.util.Arrays;

public class UnboundedWildcardExample {
    
    // Method accepts List of any type
    private static void printList(ArrayList<?> list) {
        System.out.println("List contents: " + list);
        System.out.println("List size: " + list.size());
        System.out.println("List type: " + list.getClass().getSimpleName());
        System.out.println("-------------------------");
    }
    
    private static int getListSize(ArrayList<?> list) {
        return list.size();
    }
    
    public static void main(String[] args) {
        System.out.println("=== Unbounded Wildcards Example ===");
        
        // Integer list
        ArrayList<Integer> intList = new ArrayList<>();
        intList.addAll(Arrays.asList(10, 20, 30));
        printList(intList);
        
        // String list
        ArrayList<String> stringList = new ArrayList<>();
        stringList.addAll(Arrays.asList("Hello", "Generics", "Wildcards"));
        printList(stringList);
        
        // Boolean list
        ArrayList<Boolean> boolList = new ArrayList<>();
        boolList.addAll(Arrays.asList(true, false, true));
        printList(boolList);
        
        // Double list
        ArrayList<Double> doubleList = new ArrayList<>();
        doubleList.addAll(Arrays.asList(3.14, 2.71));
        printList(doubleList);
        
        // Size comparison
        System.out.println("Sizes: Int=" + getListSize(intList) + 
                          ", String=" + getListSize(stringList) + 
                          ", Boolean=" + getListSize(boolList) +
                          ", Double=" + getListSize(doubleList));
    }
}
```

**Output:**
```
=== Unbounded Wildcards Example ===
List contents: [10, 20, 30]
List size: 3
List type: ArrayList
-------------------------
List contents: [Hello, Generics, Wildcards]
List size: 3
List type: ArrayList
-------------------------
List contents: [true, false, true]
List size: 3
List type: ArrayList
-------------------------
List contents: [3.14, 2.71]
List size: 2
List type: ArrayList
-------------------------
Sizes: Int=3, String=3, Boolean=3, Double=2
```

## Real-World Examples 🌍

### Example 1: Generic Stack Implementation 📚

```java
import java.util.ArrayList;
import java.util.EmptyStackException;

public class GenericStack<T> {
    private ArrayList<T> stack;
    
    public GenericStack() {
        stack = new ArrayList<>();
    }
    
    // Push element
    public void push(T item) {
        stack.add(item);
        System.out.println("Pushed: " + item);
    }
    
    // Pop element
    public T pop() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        T item = stack.remove(stack.size() - 1);
        System.out.println("Popped: " + item);
        return item;
    }
    
    // Peek top element
    public T peek() {
        if (isEmpty()) {
            throw new EmptyStackException();
        }
        return stack.get(stack.size() - 1);
    }
    
    // Check if empty
    public boolean isEmpty() {
        return stack.isEmpty();
    }
    
    // Get size
    public int size() {
        return stack.size();
    }
    
    // Display stack
    public void display() {
        System.out.println("Stack: " + stack);
    }
    
    // Test the stack
    public static void main(String[] args) {
        System.out.println("=== Generic Stack Example ===");
        
        // String Stack
        GenericStack<String> stringStack = new GenericStack<>();
        stringStack.push("First");
        stringStack.push("Second");
        stringStack.push("Third");
        stringStack.display();
        System.out.println("Top element: " + stringStack.peek());
        stringStack.pop();
        stringStack.display();
        
        System.out.println();
        
        // Integer Stack
        GenericStack<Integer> intStack = new GenericStack<>();
        intStack.push(100);
        intStack.push(200);
        intStack.push(300);
        intStack.display();
        System.out.println("Top element: " + intStack.peek());
        intStack.pop();
        intStack.display();
    }
}
```

### Example 2: Generic Pair Class 👥

```java
public class Pair<T, U> {
    private T first;
    private U second;
    
    public Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }
    
    public T getFirst() { return first; }
    public U getSecond() { return second; }
    
    public void setFirst(T first) { this.first = first; }
    public void setSecond(U second) { this.second = second; }
    
    @Override
    public String toString() {
        return "(" + first + ", " + second + ")";
    }
    
    // Swap method
    public Pair<U, T> swap() {
        return new Pair<>(second, first);
    }
    
    public static void main(String[] args) {
        // Name and Age pair
        Pair<String, Integer> person = new Pair<>("John", 25);
        System.out.println("Person: " + person);
        
        // Coordinates pair
        Pair<Double, Double> coordinates = new Pair<>(3.14, 2.71);
        System.out.println("Coordinates: " + coordinates);
        
        // Key-Value pair
        Pair<String, String> keyValue = new Pair<>("username", "john123");
        System.out.println("Key-Value: " + keyValue);
        
        // Swap example
        Pair<Integer, String> swapped = person.swap();
        System.out.println("Swapped: " + swapped);
    }
}
```

## Bounded Type Parameters 📏

### Single Bound

```java
// T must extend Number
class NumberContainer<T extends Number> {
    private T value;
    
    public NumberContainer(T value) {
        this.value = value;
    }
    
    public double getDoubleValue() {
        return value.doubleValue();  // Can call Number methods
    }
    
    public void compare(NumberContainer<T> other) {
        if (this.getDoubleValue() > other.getDoubleValue()) {
            System.out.println(this.value + " is greater than " + other.value);
        } else {
            System.out.println(this.value + " is less than or equal to " + other.value);
        }
    }
}

// Usage
public class BoundedTypeExample {
    public static void main(String[] args) {
        NumberContainer<Integer> intContainer = new NumberContainer<>(100);
        NumberContainer<Double> doubleContainer = new NumberContainer<>(99.5);
        
        System.out.println("Integer value as double: " + intContainer.getDoubleValue());
        System.out.println("Double value: " + doubleContainer.getDoubleValue());
        
        // NumberContainer<String> stringContainer = new NumberContainer<>("Hello"); // ❌ Error!
    }
}
```

### Multiple Bounds

```java
interface Printable {
    void print();
}

class Document implements Printable {
    private String content;
    
    public Document(String content) {
        this.content = content;
    }
    
    @Override
    public void print() {
        System.out.println("Printing: " + content);
    }
    
    public String getContent() {
        return content;
    }
}

// T must extend Document AND implement Printable
class DocumentProcessor<T extends Document & Printable> {
    private T document;
    
    public DocumentProcessor(T document) {
        this.document = document;
    }
    
    public void processAndPrint() {
        System.out.println("Processing document: " + document.getContent());
        document.print();  // Can call both Document and Printable methods
    }
}
```

## Common Mistakes - Avoid Karo! ❌

### 1. **Raw Types Ka Use**
```java
// ❌ Wrong - Raw type
ArrayList list = new ArrayList();
list.add("String");
list.add(123);  // Runtime error possible

// ✅ Correct - Generic type
ArrayList<String> list = new ArrayList<String>();
list.add("String");
// list.add(123);  // Compile error - caught early!
```

### 2. **Primitive Types Ka Use**
```java
// ❌ Wrong - Primitives not allowed
// ArrayList<int> intList = new ArrayList<int>();

// ✅ Correct - Use wrapper classes
ArrayList<Integer> intList = new ArrayList<Integer>();
```

### 3. **Type Erasure Confusion**
```java
// ❌ Wrong - Cannot create generic array
// T[] array = new T[10];

// ✅ Correct - Use ArrayList or Object array
ArrayList<T> list = new ArrayList<>();
// or
Object[] array = new Object[10];
```

### 4. **Static Context Confusion**
```java
class GenericClass<T> {
    private T instance;
    
    // ❌ Wrong - Cannot use T in static context
    // public static T staticMethod() { return null; }
    
    // ✅ Correct - Make method generic
    public static <U> U staticMethod(U param) { 
        return param; 
    }
}
```

## Interview Questions - Master Karo! 💪

### Q1: **What is type erasure in Java generics?**
```java
// At compile time
ArrayList<String> stringList = new ArrayList<String>();
ArrayList<Integer> intList = new ArrayList<Integer>();

// At runtime (after type erasure)
// Both become just ArrayList
// Generic type information is removed
```
**Answer**: Compile time pe generic type information remove ho jaati hai. Runtime pe sab Object ke saath deal karta hai.

### Q2: **Can we create generic array?**
```java
// ❌ Wrong
// T[] array = new T[10];  // Cannot create generic array

// ✅ Correct alternatives
ArrayList<T> list = new ArrayList<>();
Object[] array = new Object[10];
```
**Answer**: Direct generic array create nahi kar sakte due to type erasure.

### Q3: **What's the difference between `<?>` and `<Object>`?**
```java
List<?> wildcardList = new ArrayList<String>();  // ✅ Valid
List<Object> objectList = new ArrayList<String>();  // ❌ Compile error

// ? means "any type"
// Object means "exactly Object type"
```

### Q4: **Can we override method with different generic signature?**
```java
class Parent {
    public void method(List<String> list) { }
}

class Child extends Parent {
    // ❌ This is overloading, not overriding
    public void method(List<Integer> list) { }
}
```
**Answer**: Nahi! Generic signature bhi same hona chahiye overriding ke liye.

### Q5: **What is PECS principle?**
**Answer**: **P**roducer **E**xtends, **C**onsumer **S**uper
- **Producer** (`<? extends T>`): Data produce/read karte time use karo
- **Consumer** (`<? super T>`): Data consume/write karte time use karo

```java
// Producer - reading data
List<? extends Number> producer = Arrays.asList(1, 2, 3);
Number num = producer.get(0);  // Reading

// Consumer - writing data  
List<? super Integer> consumer = new ArrayList<Number>();
consumer.add(10);  // Writing
```

## Best Practices 🌟

### 1. **Use Diamond Operator (Java 7+)**
```java
// ✅ Good - Diamond operator
ArrayList<String> list = new ArrayList<>();

// ❌ Verbose - Not needed
ArrayList<String> list = new ArrayList<String>();
```

### 2. **Choose Right Wildcard**
```java
// Reading data - use extends
public double sum(List<? extends Number> numbers) { }

// Writing data - use super
public void addNumbers(List<? super Integer> numbers) { }

// Neither reading nor writing specific type - use unbounded
public int size(List<?> list) { return list.size(); }
```

### 3. **Use Meaningful Type Parameter Names**
```java
// ✅ Good - Meaningful names
class Repository<Entity, ID> { }
class Cache<Key, Value> { }

// ❌ Okay but less clear
class Repository<T, U> { }
```

### 4. **Prefer Generics Over Raw Types**
```java
// ✅ Good
List<String> stringList = new ArrayList<>();

// ❌ Bad - Raw type
List stringList = new ArrayList();
```

## Benefits Summary 📋

### ✅ **Type Safety**
- Compile-time error detection
- No ClassCastException at runtime
- IDE support with auto-completion

### ✅ **Performance**  
- No boxing/unboxing with primitives
- No type casting overhead
- Compiler optimizations

### ✅ **Code Clarity**
- Clear intent in API design
- Better documentation
- Less confusion about types

### ✅ **Reusability**
- One class/method for multiple types
- Generic algorithms
- Framework development

## Summary - Quick Recap! 📝

### **Key Points to Remember:**

1. 🛡️ **Type Safety**: Compile-time checking
2. 🎭 **No Casting**: Direct type access
3. ♻️ **Reusability**: One code, multiple types
4. 🔤 **Type Parameters**: T, E, K, V, N, ?
5. 🃏 **Wildcards**: extends, super, unbounded
6. 📏 **Bounded Types**: Restrict type parameters
7. 🚫 **Limitations**: Type erasure, no primitive types

### **When to Use What:**

- **Generic Class**: When entire class works with types
- **Generic Method**: When specific method needs flexibility
- **Upper Bound** (`extends`): Reading/consuming data
- **Lower Bound** (`super`): Writing/producing data  
- **Unbounded** (`?`): Size, null checks, etc.

### **Memory Tricks:**
- **PECS**: Producer Extends, Consumer Super
- **Diamond** (`<>`): Less typing, same functionality
- **Wrapper**: Primitive types need wrapper classes

Practice these concepts aur tum Generic programming mein expert ban jaoge! 🚀💪

---
*Generic Programming rocks! 🎸*
