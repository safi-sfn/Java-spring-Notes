# üöÄ Spring Data JPA Update Queries - Complete Study Guide

## üìö Introduction with Confusion Clearing

### Simple Explanation First ü§î
**Bhai, ye concept samjho:** JPA Repository mein normally hum sirf data fetch karte hain, lekin kabhi-kabhi database mein existing records ko update bhi karna hota hai. Direct UPDATE query run karne ke liye Spring Data JPA mein special annotations ka use karna padta hai.

### Real-life Analogy üè†
**Life example:** Jaise tumhare paas ek address book hai, aur tumhe kisi friend ka phone number change karna hai. Tum sirf us particular friend ka number edit karoge, na ki poori address book dobara likhoge. Similarly, database mein specific fields update karte hain!

### Technical Definition üìñ
Spring Data JPA mein custom UPDATE queries likhne ke liye `@Query`, `@Modifying`, aur `@Transactional` annotations ka combination use karte hain. Ye annotations SQL UPDATE operations ko efficiently handle karte hain.

---

## üîë Key Terms/Concepts

### Important Terminology üìù

| Term | Purpose |
|------|---------|
| `@Query`  | Custom JPQL/SQL queries likhne ke liye |
| `@Modifying`  | Database modification operations ke liye |
| `@Transactional`  | Database transactions handle karne ke liye |
| JPQL |  Object-oriented query language |

### Visual Representation üéØ
```
JPA Repository Method
        ‚Üì
@Transactional ‚Üê Transaction management
        ‚Üì
@Modifying ‚Üê Tells Spring it's a modification operation
        ‚Üì
@Query ‚Üê Custom JPQL/SQL query
        ‚Üì
Database UPDATE
```

---

## üíª Detailed Examples

### Complete Working Example üõ†Ô∏è

#### 1. Entity Class (User.java) ‚úÖ
```java
package com.springjava.entity;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import lombok.Data;

@Data
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    private boolean active;
    
    // Lombok @Data annotation automatically generates:
    // - Constructors
    // - Getters/Setters
    // - toString()
    // - equals() & hashCode()
}
```

#### 2. Repository Interface (UserRepository.java) ‚úÖ
```java
package com.springjava.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.transaction.annotation.Transactional;
import com.springjava.entity.User;

public interface UserRepository extends JpaRepository<User, Long> {
    
    // Basic Update Query
    @Transactional
    @Modifying
    @Query("UPDATE User SET active = ?1 WHERE id = ?2")
    int updateUserActive(boolean active, Long id);
    
    // Multiple Fields Update
    @Transactional
    @Modifying
    @Query("UPDATE User SET name = ?1, email = ?2 WHERE id = ?3")
    int updateUserDetails(String name, String email, Long id);
    
    // Named Parameters (Better Practice)
    @Transactional
    @Modifying
    @Query("UPDATE User SET active = :active WHERE email = :email")
    int updateUserActiveByEmail(@Param("active") boolean active, 
                               @Param("email") String email);
}
```

#### 3. Service Class (UserServiceImpl.java) ‚úÖ
```java
package com.springjava.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.springjava.entity.User;
import com.springjava.repository.UserRepository;

@Service
public class UserServiceImpl implements UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    @Override
    public int updateUserActive(boolean active, Long id) {
        return userRepository.updateUserActive(active, id);
    }
    
    @Override
    public int updateUserDetails(String name, String email, Long id) {
        return userRepository.updateUserDetails(name, email, id);
    }
}
```

#### 4. Controller Class (UserController.java) ‚úÖ
```java
package com.springjava.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.springjava.service.UserService;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @PutMapping("/update-status/{id}/{active}")
    public ResponseEntity<String> updateUserStatus(
            @PathVariable Long id, 
            @PathVariable boolean active) {
        
        int updatedRecords = userService.updateUserActive(active, id);
        
        if (updatedRecords > 0) {
            return ResponseEntity.ok("‚úÖ User status updated successfully!");
        } else {
            return ResponseEntity.notFound().build();
        }
    }
}
```

### Expected Output üìä
```json
// Successful Update Response
{
    "status": 1,
    "message": "‚úÖ Record updated successfully!",
    "recordsAffected": 1
}

// No Records Found Response  
{
    "status": 0,
    "message": "‚ùå No records found to update"
}
```

---

## üìú Rules/Guidelines

### 1. ‚úÖ Always Use @Transactional
```java
// ‚úÖ CORRECT
@Transactional
@Modifying
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
int updateUserActive(boolean active, Long id);

// ‚ùå INCORRECT - Will throw exception
@Modifying
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
int updateUserActive(boolean active, Long id);
```

**Error Message without @Transactional:**
```
org.springframework.dao.InvalidDataAccessApiUsageException: 
Executing an update/delete query; nested exception is 
javax.persistence.TransactionRequiredException: Executing an update/delete query
```

### 2. ‚úÖ Use @Modifying for UPDATE/DELETE
```java
// ‚úÖ CORRECT
@Modifying
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
int updateUserActive(boolean active, Long id);

// ‚ùå INCORRECT - Won't work for updates
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
List<User> updateUserActive(boolean active, Long id);
```

### 3. ‚úÖ Return Type Should Be int/Integer
```java
// ‚úÖ CORRECT - Returns number of affected rows
@Modifying
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
int updateUserActive(boolean active, Long id);

// ‚ùå INCORRECT - Update queries don't return entities
@Modifying
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
User updateUserActive(boolean active, Long id);
```

### 4. ‚úÖ Use Named Parameters for Better Readability
```java
// ‚úÖ BEST PRACTICE
@Query("UPDATE User SET active = :active WHERE email = :email")
int updateUserByEmail(@Param("active") boolean active, 
                     @Param("email") String email);

// ‚úÖ ACCEPTABLE
@Query("UPDATE User SET active = ?1 WHERE email = ?2")
int updateUserByEmail(boolean active, String email);
```

---

## üåç Real-world Applications

### 1. Banking System Example üè¶
```java
@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    // Update account balance
    @Transactional
    @Modifying
    @Query("UPDATE Account SET balance = balance + :amount WHERE accountNumber = :accNum")
    int creditAmount(@Param("amount") Double amount, 
                    @Param("accNum") String accountNumber);
    
    // Debit amount
    @Transactional
    @Modifying
    @Query("UPDATE Account SET balance = balance - :amount WHERE accountNumber = :accNum AND balance >= :amount")
    int debitAmount(@Param("amount") Double amount, 
                   @Param("accNum") String accountNumber);
    
    // Block/Unblock account
    @Transactional
    @Modifying
    @Query("UPDATE Account SET isBlocked = :status WHERE accountNumber = :accNum")
    int updateAccountStatus(@Param("status") boolean isBlocked, 
                           @Param("accNum") String accountNumber);
}
```

### 2. E-commerce Product Management üõçÔ∏è
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Update stock quantity
    @Transactional
    @Modifying
    @Query("UPDATE Product SET stockQuantity = stockQuantity - :quantity WHERE id = :productId AND stockQuantity >= :quantity")
    int updateStock(@Param("quantity") int quantity, 
                   @Param("productId") Long productId);
    
    // Update product price
    @Transactional
    @Modifying
    @Query("UPDATE Product SET price = :newPrice WHERE category = :category")
    int updatePriceByCategory(@Param("newPrice") Double newPrice, 
                             @Param("category") String category);
    
    // Mark product as discontinued
    @Transactional
    @Modifying
    @Query("UPDATE Product SET isActive = false WHERE expiryDate < CURRENT_DATE")
    int markExpiredProductsInactive();
}
```

---

## üÜö Comparison Tables

### @Query vs Built-in Methods
| Feature | Custom @Query | Built-in Methods |
|---------|---------------|------------------|
| **Flexibility** | üî• High | üìù Limited |
| **Performance** | ‚ö° Optimized | üêå May fetch then update |
| **Bulk Operations** | ‚úÖ Supported | ‚ùå One by one |
| **Complex Conditions** | ‚úÖ Any condition | üìù Method name based |
| **Learning Curve** | üìö JPQL knowledge needed | üéØ Easy |

### JPQL vs Native SQL
| Aspect | JPQL | Native SQL |
|--------|------|------------|
| **Database Independence** | ‚úÖ Yes | ‚ùå Database specific |
| **Entity Mapping** | ‚úÖ Direct | üîß Manual mapping needed |
| **Performance** | üìà Good | üöÄ Best |
| **Complex Joins** | üìù Limited | üî• Full power |
| **Syntax** | `UPDATE User SET...` | `UPDATE users SET...` |

---

## üéØ Interview Questions

### Q1: Update Query mein @Modifying annotation kyun zaruri hai? ü§î
**Answer:** Bhai, Spring Data JPA by default assume karta hai ki @Query annotation sirf SELECT operations ke liye hai. Jab hum UPDATE/DELETE operations karte hain, toh @Modifying annotation Spring ko batata hai ki ye query database mein modification kar rahi hai, na ki sirf data fetch kar rahi hai.

```java
// Without @Modifying - Spring expects List<Entity> return type
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
List<User> updateUser(boolean active, Long id); // ‚ùå Wrong

// With @Modifying - Returns affected row count
@Modifying
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
int updateUser(boolean active, Long id); // ‚úÖ Correct
```

### Q2: @Transactional annotation ka kya role hai update queries mein? üîÑ
**Answer:** Yaad rakho bhai, database mein koi bhi modification operation (INSERT, UPDATE, DELETE) transaction ke andar hona chahiye. @Transactional annotation ensure karta hai ki:
- Operation atomically execute ho
- Agar koi error aaye toh rollback ho jaye
- Database consistency maintain rahe

```java
@Transactional
@Modifying
@Query("UPDATE User SET salary = salary * 1.1 WHERE department = 'IT'")
int giveSalaryHike(); // All IT employees get hike together or none
```

### Q3: Bulk update aur individual entity update mein kya difference hai? ‚ö°
**Answer:** 

**Individual Entity Update (JPA way):**
```java
// This will generate SELECT + UPDATE for each entity
public void updateUsers(List<Long> userIds) {
    for(Long id : userIds) {
        User user = userRepository.findById(id).orElse(null);
        if(user != null) {
            user.setActive(true);
            userRepository.save(user); // N+1 problem!
        }
    }
}
```

**Bulk Update (Efficient way):**
```java
@Modifying
@Query("UPDATE User SET active = true WHERE id IN :userIds")
int bulkUpdateUsers(@Param("userIds") List<Long> userIds);
// Single query for all records! üöÄ
```

---

## ‚ö†Ô∏è Common Mistakes

### 1. Forgetting @Transactional ‚ùå
```java
// ‚ùå WRONG - Will throw TransactionRequiredException
@Modifying
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
int updateUser(boolean active, Long id);

// ‚úÖ CORRECT
@Transactional
@Modifying  
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
int updateUser(boolean active, Long id);
```

### 2. Wrong Return Type ‚ùå
```java
// ‚ùå WRONG - Update queries return affected row count
@Transactional
@Modifying
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
User updateUser(boolean active, Long id);

// ‚úÖ CORRECT
@Transactional
@Modifying
@Query("UPDATE User SET active = ?1 WHERE id = ?2")
int updateUser(boolean active, Long id);
```

### 3. Entity vs Table Name Confusion ‚ùå
```java
// ‚ùå WRONG - Using table name instead of entity name
@Query("UPDATE users SET active = ?1 WHERE id = ?2") // 'users' is table name

// ‚úÖ CORRECT - Use entity name in JPQL
@Query("UPDATE User SET active = ?1 WHERE id = ?2") // 'User' is entity name
```

### 4. Not Handling Zero Updates ‚ùå
```java
// ‚ùå WRONG - Not checking if any record was actually updated
public void updateUserStatus(Long id, boolean status) {
    userRepository.updateUserActive(status, id);
    // What if no user found with that ID? ü§î
}

// ‚úÖ CORRECT - Check return value
public boolean updateUserStatus(Long id, boolean status) {
    int updatedCount = userRepository.updateUserActive(status, id);
    return updatedCount > 0;
}
```

---

## üèÜ Best Practices

### 1. Use Named Parameters üìù
```java
// ‚úÖ BEST PRACTICE - Easy to read and maintain
@Query("UPDATE User SET name = :name, email = :email WHERE id = :userId")
int updateUserInfo(@Param("name") String name, 
                  @Param("email") String email, 
                  @Param("userId") Long userId);

// üìù ACCEPTABLE but less readable with many parameters
@Query("UPDATE User SET name = ?1, email = ?2 WHERE id = ?3")
int updateUserInfo(String name, String email, Long userId);
```

### 2. Always Return Affected Row Count üìä
```java
// ‚úÖ BEST PRACTICE
@Transactional
@Modifying
@Query("UPDATE User SET lastLogin = CURRENT_TIMESTAMP WHERE id = :userId")
int updateLastLogin(@Param("userId") Long userId);

// Service layer mein use karo
public boolean markUserLogin(Long userId) {
    int updated = userRepository.updateLastLogin(userId);
    return updated > 0; // true if user exists and updated
}
```

### 3. Use Batch Updates for Multiple Records üöÄ
```java
// ‚úÖ EFFICIENT - Single query for multiple records
@Transactional
@Modifying
@Query("UPDATE User SET active = :status WHERE department = :dept")
int updateDepartmentStatus(@Param("status") boolean active, 
                          @Param("dept") String department);

// ‚ùå INEFFICIENT - Multiple database calls
public void updateDepartmentUsers(String department, boolean status) {
    List<User> users = userRepository.findByDepartment(department);
    for(User user : users) {
        user.setActive(status);
        userRepository.save(user); // N+1 problem!
    }
}
```

### 4. Add Proper Error Handling üõ°Ô∏è
```java
@Service
public class UserService {
    
    public ResponseEntity<String> updateUserStatus(Long userId, boolean status) {
        try {
            int updated = userRepository.updateUserActive(status, userId);
            
            if (updated > 0) {
                return ResponseEntity.ok("‚úÖ User updated successfully");
            } else {
                return ResponseEntity.notFound()
                    .header("Message", "‚ùå User not found with ID: " + userId)
                    .build();
            }
        } catch (Exception e) {
            log.error("Error updating user: ", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body("üî• Server error occurred");
        }
    }
}
```

### 5. Configuration Best Practices ‚öôÔ∏è
```properties
# application.properties
# Show SQL queries in logs (for debugging)
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true

# Hibernate specific settings
spring.jpa.properties.hibernate.jdbc.batch_size=25
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true
```

---

## üìã Summary/Quick Recap

### Key Takeaways üéØ
1. **Triple Annotation Rule:** `@Transactional + @Modifying + @Query` = Update Success! üî•
2. **Return Type:** Always `int` for update operations (affected row count)
3. **Entity Names:** Use entity class names in JPQL, not table names
4. **Bulk Operations:** More efficient than individual updates
5. **Error Handling:** Always check if records were actually updated

### Memory Tricks üß†
- **TMQ Rule:** **T**ransactional **M**odifying **Q**uery - Teen annotation chahiye! 
- **Return Count:** Update query = affected **COUNT** return karta hai
- **Entity First:** JPQL mein entity name use karo, table name nahi

### When to Use What ü§î

| Scenario | Use This Approach |
|----------|-------------------|
| **Single field update** | Custom @Query with @Modifying |
| **Multiple fields** | Custom @Query or entity.save() |
| **Bulk updates** | Always custom @Query |
| **Complex conditions** | Custom @Query with JPQL |
| **Simple CRUD** | Built-in JPA methods |

### Interview Preparation Checklist ‚úÖ
- [ ] Understand @Transactional importance
- [ ] Know difference between JPQL entity names vs SQL table names  
- [ ] Practice bulk update scenarios
- [ ] Remember common error messages
- [ ] Know performance implications

---

## üîó Quick Reference Links

### Spring Data JPA Annotations
- `@Query` - Custom JPQL/SQL queries
- `@Modifying` - For UPDATE/DELETE operations  
- `@Transactional` - Transaction management
- `@Param` - Named parameter binding

### Common Error Messages to Remember üö®
```
TransactionRequiredException: Executing an update/delete query
-> Solution: Add @Transactional

InvalidDataAccessApiUsageException: @Modifying annotation missing
-> Solution: Add @Modifying for UPDATE/DELETE

QuerySyntaxException: User is not mapped
-> Solution: Use correct entity name in JPQL
```

**Yaad rakhne ka mantra:** "Transaction Modify Query" - Teen dost hamesha saath! ü§ù

---

*Happy Coding, Bhai! üöÄ Interview mein confidence ke saath answer dena!* ‚ú®
