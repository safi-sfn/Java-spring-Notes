# JPA Delete Queries - Complete Study Notes üóëÔ∏èüíæ

> **Bhai log, delete operations samjhna hai? Chalo step by step sikhte hain!** üöÄ

---

## 1. Introduction with Confusion Clearing ü§î

### Simple Explanation First üìù
**Bhai**, JPA delete queries matlab hai ki database se data ko hatana. Just like tum apne phone se photos delete karte ho, waise hi database table se records delete karte hain.

### Real-life Analogy üè†
Imagine karo tumhara room hai (Database Table), aur usme bohot saare books hain (Records). Ab tumhe:
- Ek specific book hatani hai ‚Üí **Delete by ID**
- Ek author ki saari books hatani hain ‚Üí **Delete by Field** 
- Saari books hatani hain ‚Üí **Delete All**
- Purane books hatane hain ‚Üí **Custom Delete Query**

### Technical Definition üîß
JPA Delete Queries provide ways to remove entity objects from the database using JPQL, native SQL, or derived query methods in Spring Data JPA repositories.

---

## 2. Key Terms/Concepts üìö

| Term | Meaning | Example |
|------|---------|---------|
| **@Query** | Custom query define karne ke liye | `@Query("DELETE FROM User u WHERE u.age < 18")` |
| **@Modifying** | Insert/Update/Delete operations ke liye | Must use with delete queries |
| **@Transactional** | Transaction management ke liye | Rollback support |
| **JPQL** | Java Persistence Query Language | Entity-based queries |
| **Native SQL** | Direct database SQL queries | Table-based queries |
| **Derived Methods** | Method name se query generate hoti hai | `deleteByEmail(String email)` |

### Visual Representation üé®
```
üèóÔ∏è JPA Delete Methods
‚îú‚îÄ‚îÄ üì¶ Built-in Methods
‚îÇ   ‚îú‚îÄ‚îÄ deleteById(ID id)
‚îÇ   ‚îú‚îÄ‚îÄ delete(Entity entity)
‚îÇ   ‚îú‚îÄ‚îÄ deleteAll()
‚îÇ   ‚îî‚îÄ‚îÄ deleteAllInBatch()
‚îú‚îÄ‚îÄ üõ†Ô∏è Custom @Query Methods  
‚îÇ   ‚îú‚îÄ‚îÄ JPQL Queries
‚îÇ   ‚îî‚îÄ‚îÄ Native SQL Queries
‚îî‚îÄ‚îÄ üîç Derived Query Methods
    ‚îú‚îÄ‚îÄ deleteByFieldName()
    ‚îî‚îÄ‚îÄ removeByFieldName()
```

---

## 3. Detailed Examples üíª

### Example 1: Built-in Delete Methods ‚úÖ

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // Inherited methods - no need to write
    // deleteById(Long id)
    // delete(User user)  
    // deleteAll()
    // deleteAllInBatch()
}

// Service class usage
@Service
public class UserService {
    @Autowired
    private UserRepository userRepo;
    
    // Delete by ID
    public void deleteUser(Long userId) {
        userRepo.deleteById(userId);  // üéØ Single record delete
    }
    
    // Delete entity object
    public void deleteUserEntity(User user) {
        userRepo.delete(user);  // üì¶ Entity-based delete
    }
    
    // Delete all records
    public void deleteAllUsers() {
        userRepo.deleteAll();  // ‚ö†Ô∏è Dangerous - sab delete!
    }
}
```

**Output:**
```
Hibernate: delete from user_table where id=?
```

### Example 2: Custom Delete with @Query (JPQL) üî•

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Transactional
    @Modifying  
    @Query("DELETE FROM User u WHERE u.email = :email")
    int deleteByEmail(String email);
    
    @Transactional
    @Modifying
    @Query("DELETE FROM User u WHERE u.age < :age")  
    int deleteUsersYoungerThan(int age);
    
    @Transactional
    @Modifying
    @Query("DELETE FROM User u WHERE u.active = false")
    int deleteInactiveUsers();
}
```

**Expected Output:**
```java
// Usage in service
@Service
public class UserService {
    
    public String deleteByEmail(String email) {
        int deletedCount = userRepo.deleteByEmail(email);
        return deletedCount + " users deleted successfully!";
    }
}

// Console output:
// Hibernate: delete from user_table u1_0 where u1_0.email=?
```

### Example 3: Native SQL Delete Query üóÑÔ∏è

```java
@Repository  
public interface UserRepository extends JpaRepository<User, Long> {
    
    @Transactional
    @Modifying
    @Query(value = "DELETE FROM user_table WHERE active = :active", 
           nativeQuery = true)
    int deleteByActiveStatus(boolean active);
    
    @Transactional
    @Modifying  
    @Query(value = "DELETE FROM user_table WHERE created_date < ?1",
           nativeQuery = true)
    int deleteOldRecords(LocalDateTime date);
}
```

### Example 4: Derived Query Methods üöÄ

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Method name se query generate hoti hai
    int deleteByEmail(String email);              // ‚úÖ delete keyword
    int removeByAge(int age);                     // ‚úÖ remove keyword  
    int deleteByAgeGreaterThan(int age);         // ‚úÖ Condition-based
    int deleteByEmailAndActive(String email, boolean active); // ‚úÖ Multiple conditions
    
    List<User> deleteByActiveTrue();             // ‚úÖ Returns deleted entities
}
```

**Step-by-step Explanation:**
1. **deleteBy** keyword se start karo
2. **Field name** add karo (camelCase mein)  
3. **Condition** add karo (optional): GreaterThan, LessThan, etc.
4. **Parameters** method mein pass karo

---

## 4. Rules/Guidelines üìã

### ‚úÖ DO - Correct Approaches

**Rule 1: Always use @Transactional with delete operations**
```java
@Transactional  // ‚úÖ Transaction management
@Modifying      // ‚úÖ Modification operation  
@Query("DELETE FROM User u WHERE u.id = :id")
int customDelete(Long id);
```

**Rule 2: Use @Modifying annotation for custom delete queries**
```java
@Modifying  // ‚úÖ Must have for INSERT/UPDATE/DELETE
@Query("DELETE FROM User u WHERE u.email = :email")  
int deleteUser(String email);
```

**Rule 3: Return int/long for affected row count**
```java
int deleteByEmail(String email);     // ‚úÖ Returns count
long removeByAge(int age);           // ‚úÖ Returns count  
List<User> deleteByActive(boolean active); // ‚úÖ Returns deleted entities
```

### ‚ùå DON'T - Common Mistakes  

**Rule 1: Never forget @Modifying annotation**
```java
// ‚ùå Wrong - Missing @Modifying
@Query("DELETE FROM User u WHERE u.id = :id")  
int deleteUser(Long id);

// Error: org.springframework.dao.InvalidDataAccessApiUsageException: 
// @Query annotation does not support non-select operations; use @Modifying
```

**Rule 2: Don't use SELECT syntax in DELETE queries**  
```java  
// ‚ùå Wrong - This is SELECT syntax
@Query("SELECT u FROM User u WHERE u.id = :id")
int deleteUser(Long id);

// ‚úÖ Correct - This is DELETE syntax  
@Query("DELETE FROM User u WHERE u.id = :id")
int deleteUser(Long id);
```

**Rule 3: Don't mix entity and table names**
```java
// ‚ùå Wrong - Mixed syntax
@Query("DELETE FROM user_table u WHERE u.email = :email")  // Native table name in JPQL
int deleteByEmail(String email);

// ‚úÖ Correct - JPQL uses entity names
@Query("DELETE FROM User u WHERE u.email = :email")
int deleteByEmail(String email);

// ‚úÖ Correct - Native query uses table names
@Query(value = "DELETE FROM user_table WHERE email = :email", nativeQuery = true)  
int deleteByEmailNative(String email);
```

---

## 5. Real-world Applications üåç

### Banking System Example üè¶
```java
@Entity
@Table(name = "bank_account")
public class BankAccount {
    @Id
    private Long accountNumber;
    private String customerName;
    private BigDecimal balance;
    private boolean isActive;
    private LocalDateTime lastTransaction;
}

@Repository
public interface BankAccountRepository extends JpaRepository<BankAccount, Long> {
    
    // Inactive accounts delete karna
    @Transactional
    @Modifying
    @Query("DELETE FROM BankAccount ba WHERE ba.isActive = false")
    int deleteInactiveAccounts();
    
    // Zero balance accounts delete karna  
    int deleteByBalance(BigDecimal balance);
    
    // Purane transactions delete karna
    @Transactional  
    @Modifying
    @Query("DELETE FROM BankAccount ba WHERE ba.lastTransaction < :date")
    int deleteOldAccounts(LocalDateTime date);
}
```

### E-commerce Product Management üõí
```java
@Entity
public class Product {
    @Id
    private Long productId;
    private String productName;
    private BigDecimal price;
    private int stock;
    private String category;
    private boolean discontinued;
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Out of stock products delete
    int deleteByStock(int stock);  // stock = 0
    
    // Discontinued products delete  
    int deleteByDiscontinuedTrue();
    
    // Category wise delete
    @Transactional
    @Modifying  
    @Query("DELETE FROM Product p WHERE p.category = :category")
    int deleteByCategory(String category);
    
    // Price range delete
    int deleteByPriceLessThan(BigDecimal minPrice);
}
```

---

## 6. Comparison Tables üìä

### JPQL vs Native SQL Delete Queries

| Aspect | JPQL | Native SQL |
|--------|------|------------|
| **Syntax** | `DELETE FROM User u WHERE...` | `DELETE FROM user_table WHERE...` |  
| **Entity/Table** | Uses Entity names | Uses actual table names |
| **Database Independent** | ‚úÖ Yes | ‚ùå No |
| **Performance** | Good | Better |
| **Complex Queries** | Limited | Full SQL power |
| **JPA Features** | ‚úÖ Supports relationships | ‚ùå Raw SQL only |

```java
// JPQL Example
@Query("DELETE FROM User u WHERE u.email = :email")
int jpqlDelete(String email);

// Native SQL Example  
@Query(value = "DELETE FROM user_table WHERE email = :email", nativeQuery = true)
int nativeDelete(String email);
```

### Built-in vs Custom Delete Methods

| Method Type | When to Use | Performance | Return Type |
|-------------|-------------|-------------|-------------|
| `deleteById()` | Single record by ID | Fast | `void` |
| `delete(entity)` | When you have entity object | Medium | `void` |
| `deleteAll()` | All records (careful!) | Slow | `void` |  
| Custom `@Query` | Complex conditions | Fast | `int/long` |
| Derived methods | Simple field-based | Fast | `int/List<Entity>` |

---

## 7. Interview Questions üé§

### Q1: What annotations are required for custom delete queries?
**Answer:** Three annotations are mandatory: @Query for defining the query, @Modifying for modification operations (INSERT, UPDATE, DELETE), and @Transactional for transaction management.

```java
@Transactional  // Transaction management
@Modifying      // Modification operation
@Query("DELETE FROM User u WHERE u.email = :email")
int deleteByEmail(String email);
```

### Q2: What's the difference between deleteById() and delete()?
**Answer:**
```java
// deleteById() - Only needs ID
userRepo.deleteById(1L);  // Just pass ID

// delete() - Needs complete entity object
User user = userRepo.findById(1L).get();
userRepo.delete(user);    // Pass entire entity
```

### Q3: How to return deleted entities instead of count?
**Answer:**
```java
// Return count (default)
int deleteByEmail(String email);

// Return deleted entities  
List<User> deleteByActive(boolean active);

// Usage
List<User> deletedUsers = userRepo.deleteByActive(false);
System.out.println("Deleted users: " + deletedUsers);
```

### Q4: What happens if @Transactional is missing?
**Answer:**
```java
// ‚ùå Without @Transactional - May cause issues
@Modifying
@Query("DELETE FROM User u WHERE u.email = :email")  
int deleteByEmail(String email);

// Error can occur: TransactionRequiredException: 
// Executing an update/delete query
```

### Q5: How to delete by multiple conditions?
**Answer:**
```java
// Method 1: Derived query
int deleteByEmailAndAgeGreaterThan(String email, int age);

// Method 2: Custom JPQL
@Query("DELETE FROM User u WHERE u.email = :email AND u.age > :age")
int customDeleteByEmailAndAge(String email, int age);

// Method 3: Native SQL
@Query(value = "DELETE FROM user_table WHERE email = ? AND age > ?", 
       nativeQuery = true)
int nativeDeleteByEmailAndAge(String email, int age);
```

---

## 8. Common Mistakes üö®

### Mistake 1: Forgetting @Transactional
```java
// ‚ùå Wrong
@Modifying  
@Query("DELETE FROM User u WHERE u.id = :id")
int deleteUser(Long id);

// Error: javax.persistence.TransactionRequiredException: 
// Executing an update/delete query

// ‚úÖ Correct  
@Transactional
@Modifying
@Query("DELETE FROM User u WHERE u.id = :id")
int deleteUser(Long id);
```

### Mistake 2: Wrong Entity Name in JPQL
```java
// ‚ùå Wrong - Using table name instead of entity name
@Query("DELETE FROM user_table u WHERE u.email = :email")
int deleteByEmail(String email);

// Error: org.hibernate.hql.internal.ast.QuerySyntaxException: 
// user_table is not mapped

// ‚úÖ Correct - Use entity name  
@Query("DELETE FROM User u WHERE u.email = :email") 
int deleteByEmail(String email);
```

### Mistake 3: Missing @Modifying Annotation
```java
// ‚ùå Wrong
@Transactional
@Query("DELETE FROM User u WHERE u.email = :email")
int deleteByEmail(String email);

// Error: InvalidDataAccessApiUsageException: 
// @Query annotation does not support non-select operations

// ‚úÖ Correct
@Transactional  
@Modifying
@Query("DELETE FROM User u WHERE u.email = :email")
int deleteByEmail(String email);
```

### Mistake 4: Incorrect Method Naming for Derived Queries
```java
// ‚ùå Wrong - Invalid keywords
int eraseByEmail(String email);        // 'erase' not supported
int destroyByEmail(String email);      // 'destroy' not supported

// ‚úÖ Correct - Supported keywords only
int deleteByEmail(String email);      // 'delete' supported  
int removeByEmail(String email);      // 'remove' supported
```

---

## 9. Best Practices üèÜ

### Practice 1: Always Use Transactions
```java
// ‚úÖ Good - Explicit transaction
@Transactional
@Modifying
@Query("DELETE FROM User u WHERE u.active = false")
int deleteInactiveUsers();

// ‚úÖ Better - Service level transaction  
@Service
@Transactional  // Class level
public class UserService {
    
    public int cleanupInactiveUsers() {
        return userRepo.deleteInactiveUsers();
    }
}
```

### Practice 2: Return Meaningful Data
```java
// ‚úÖ Good - Return count for monitoring
@Service
public class UserService {
    
    public String deleteInactiveUsers() {
        int count = userRepo.deleteByActiveFalse();
        return String.format("Successfully deleted %d inactive users", count);
    }
}
```

### Practice 3: Add Logging for Delete Operations
```java
@Service  
@Slf4j  // Lombok annotation
public class UserService {
    
    public int deleteUserByEmail(String email) {
        log.info("Attempting to delete user with email: {}", email);
        int deletedCount = userRepo.deleteByEmail(email);
        log.info("Successfully deleted {} user(s) with email: {}", deletedCount, email);
        return deletedCount;
    }
}
```

### Practice 4: Use Batch Operations for Multiple Deletes
```java
// ‚úÖ Good - For multiple records
@Service
public class UserService {
    
    // For bulk delete - more efficient
    public void deleteUsersByIds(List<Long> userIds) {
        userRepo.deleteAllByIdInBatch(userIds);  // Batch operation
    }
    
    // For single delete  
    public void deleteUser(Long userId) {
        userRepo.deleteById(userId);
    }
}
```

### Practice 5: Validate Before Delete
```java
@Service
public class UserService {
    
    public String safeDeleteUser(Long userId) {
        // ‚úÖ Check if exists first
        if (!userRepo.existsById(userId)) {
            return "User not found with ID: " + userId;
        }
        
        // ‚úÖ Check business rules
        User user = userRepo.findById(userId).get();
        if (user.hasActiveOrders()) {
            return "Cannot delete user with active orders";  
        }
        
        userRepo.deleteById(userId);
        return "User deleted successfully";
    }
}
```

---

## 10. Summary/Quick Recap üìù

### Key Takeaways üéØ

1. **‡§§‡•Ä‡§® Essential Annotations**: `@Transactional`, `@Modifying`, `@Query`

2. **Delete Methods ‡§ï‡•á Types**:
   - Built-in: `deleteById()`, `delete()`, `deleteAll()`
   - Custom: `@Query` with JPQL/Native SQL  
   - Derived: `deleteByFieldName()`

3. **JPQL vs Native SQL**:
   - JPQL ‚Üí Entity names use karo
   - Native SQL ‚Üí Table names use karo

4. **Return Types**:
   - `int/long` ‚Üí Deleted records count
   - `List<Entity>` ‚Üí Deleted entities list
   - `void` ‚Üí No return value

### Memory Tricks üß†

- **"TMQ"** = **T**ransactional + **M**odifying + **Q**uery (‡§§‡•Ä‡§®‡•ã ‡§ö‡§æ‡§π‡§ø‡§è!)
- **"JPQL = Java, Native = Database"** (Entity vs Table names)
- **"Delete/Remove = Supported, Erase/Destroy = Not Supported"**

### When to Use What? ü§î

| Scenario | Best Choice | Why? |
|----------|-------------|------|
| Single record by ID | `deleteById()` | Simple & fast |
| Simple field condition | Derived methods | Auto-generated |  
| Complex conditions | `@Query` with JPQL | Readable & flexible |
| Database-specific | Native SQL | Full SQL power |
| Bulk operations | `deleteAllInBatch()` | Performance |

### Final Mantra üïâÔ∏è
> **"Transaction laga, Modifying kar, Query likh - Delete ho jayega!"**

---

## üéâ Congratulations Bhai!
Ab tum JPA Delete Queries mein expert ho gaye! Interview mein confidence se jawab de sakte ho! 

**Remember**: Practice makes perfect, so hands-on coding karte raho! üí™

---

*Happy Coding! üöÄ*
