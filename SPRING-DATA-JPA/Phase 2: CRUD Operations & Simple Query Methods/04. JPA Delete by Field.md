# 🚀 Spring Data JPA - Delete by Field Complete Guide

*Bhai, Spring Data JPA mein delete operations samjhne ka time aa gaya! Yahan par hum different fields ke basis par data delete karne ke tarike seekhenge* 💪

---

## 📖 1. Introduction - Confusion Clear Karte Hain! 

### Simple Explanation (Dost ki tarah) 🤝
**Bhai, simple words mein:** JPA Repository mein hum sirf ID se hi delete nahi kar sakte, balki kisi bhi field ke basis par delete kar sakte hain! Jaise email, name, status, etc.

### Real-life Analogy 🌟
**Samjho aise:** 
- WhatsApp group mein admin sirf phone number se member remove nahi karta
- Wo name se bhi remove kar sakta hai, last seen se bhi, ya fir inactive members ko bulk mein bhi!
- Wahi concept hai yahan - **flexible delete operations!** 📱

### Technical Definition 📋
Spring Data JPA allows us to delete records by field using query method deleteById() and custom query methods with delete or remove keywords for deleting records based on the property name of the JPA Entity class

---

## 🎯 2. Key Terms/Concepts

### Important Terminology 📝

| Term | Hindi Explanation | English Definition |
|------|-------------------|-------------------|
| **deleteById()** | ID ke basis par delete | Built-in method to delete by primary key |
| **Custom Delete Methods** | Apne banaye gaye delete methods | User-defined methods with delete/remove keywords |
| **@Transactional** | Transaction ka annotation | Ensures database consistency during delete |
| **Query Methods** | Method names se query banta hai | Spring creates queries from method names |

### Visual Representation 🎨
```
🏢 Database Table
├── 🆔 ID (Primary Key)
├── 📧 Email
├── 👤 Name  
├── ✅ Active Status
└── 📅 Created Date

❌ Delete Options:
├── By ID ➡️ deleteById(id)
├── By Email ➡️ deleteByEmail(email)  
├── By Status ➡️ deleteByActive(status)
└── By Any Field ➡️ deleteBy[FieldName](value)
```

---

## 💻 3. Detailed Examples

### Example 1: Basic Setup - Entity Class 🏗️

```java
package com.springjava.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name = "user_tbl")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    private boolean active;
    private String city;
    private Integer age;
    
    // Lombok @Data annotation generates:
    // - Constructors
    // - Getters/Setters  
    // - toString()
    // - equals()/hashCode()
}
```

**Expected Output:** Database mein `user_tbl` table ban jayega with columns: id, name, email, active, city, age

### Example 2: Repository Interface - Delete Methods 🗂️

```java
package com.springjava.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.transaction.annotation.Transactional;
import com.springjava.entity.User;

public interface UserRepository extends JpaRepository<User, Long> {
    
    // ✅ Built-in method - ID se delete
    // Ye already available hai JpaRepository mein!
    
    // ✅ Custom Query Methods - Field se delete
    @Transactional
    int deleteUserByEmail(String email);
    
    @Transactional  
    int removeUserByActive(boolean active);
    
    @Transactional
    int deleteUserByCity(String city);
    
    @Transactional
    int deleteUserByAgeGreaterThan(Integer age);
    
    // ✅ JPQL Query se delete
    @Transactional
    @Modifying
    @Query("DELETE FROM User u WHERE u.name = :name")
    int deleteUserByNameCustom(String name);
    
    // ✅ Native SQL Query se delete
    @Transactional
    @Modifying
    @Query(value = "DELETE FROM user_tbl WHERE age BETWEEN :minAge AND :maxAge", 
           nativeQuery = true)
    int deleteUsersByAgeRange(Integer minAge, Integer maxAge);
}
```

### Example 3: Service Implementation 🛠️

```java
package com.springjava.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.springjava.entity.User;
import com.springjava.repository.UserRepository;
import java.util.List;

@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // ✅ ID se delete - Basic method
    public void deleteById(Long id) {
        if (userRepository.existsById(id)) {
            userRepository.deleteById(id);
            System.out.println("✅ User deleted with ID: " + id);
        } else {
            System.out.println("❌ User not found with ID: " + id);
        }
    }
    
    // ✅ Email se delete
    public int deleteByEmail(String email) {
        int deletedCount = userRepository.deleteUserByEmail(email);
        System.out.println("✅ " + deletedCount + " users deleted with email: " + email);
        return deletedCount;
    }
    
    // ✅ Status se delete (bulk delete)
    public int deleteInactiveUsers() {
        int deletedCount = userRepository.removeUserByActive(false);
        System.out.println("✅ " + deletedCount + " inactive users deleted");
        return deletedCount;
    }
    
    // ✅ City se delete
    public int deleteUsersByCity(String city) {
        int deletedCount = userRepository.deleteUserByCity(city);
        System.out.println("✅ " + deletedCount + " users deleted from city: " + city);
        return deletedCount;
    }
    
    // ✅ Age criteria se delete  
    public int deleteOldUsers(Integer minAge) {
        int deletedCount = userRepository.deleteUserByAgeGreaterThan(minAge);
        System.out.println("✅ " + deletedCount + " users deleted above age: " + minAge);
        return deletedCount;
    }
    
    // ✅ Batch save for testing
    public void saveUsers(List<User> users) {
        userRepository.saveAll(users);
        System.out.println("✅ " + users.size() + " users saved successfully");
    }
}
```

### Example 4: REST Controller 🌐

```java
package com.springjava.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.springjava.entity.User;
import com.springjava.service.UserService;

import java.util.*;

@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // ✅ Bulk insert for testing
    @PostMapping("/bulk-save")
    public ResponseEntity<?> bulkSave(@RequestBody List<User> users) {
        Map<String, Object> response = new HashMap<>();
        try {
            userService.saveUsers(users);
            response.put("status", "success");
            response.put("message", users.size() + " users saved successfully! 🎉");
            response.put("count", users.size());
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("status", "error");
            response.put("message", "Error saving users: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    // ✅ Delete by ID
    @DeleteMapping("/delete-by-id/{id}")
    public ResponseEntity<?> deleteById(@PathVariable Long id) {
        Map<String, Object> response = new HashMap<>();
        try {
            userService.deleteById(id);
            response.put("status", "success");
            response.put("message", "User deleted successfully! 🗑️");
            response.put("deletedId", id);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("status", "error");
            response.put("message", "Error deleting user: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    // ✅ Delete by Email
    @DeleteMapping("/delete-by-email/{email}")
    public ResponseEntity<?> deleteByEmail(@PathVariable String email) {
        Map<String, Object> response = new HashMap<>();
        try {
            int count = userService.deleteByEmail(email);
            response.put("status", "success");
            response.put("message", count + " user(s) deleted by email! 📧");
            response.put("deletedCount", count);
            response.put("email", email);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("status", "error");
            response.put("message", "Error deleting by email: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    // ✅ Delete inactive users
    @DeleteMapping("/delete-inactive")
    public ResponseEntity<?> deleteInactiveUsers() {
        Map<String, Object> response = new HashMap<>();
        try {
            int count = userService.deleteInactiveUsers();
            response.put("status", "success");
            response.put("message", count + " inactive users deleted! 🚫");
            response.put("deletedCount", count);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("status", "error");
            response.put("message", "Error deleting inactive users: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    // ✅ Delete by city
    @DeleteMapping("/delete-by-city/{city}")
    public ResponseEntity<?> deleteByCity(@PathVariable String city) {
        Map<String, Object> response = new HashMap<>();
        try {
            int count = userService.deleteUsersByCity(city);
            response.put("status", "success");
            response.put("message", count + " users deleted from " + city + "! 🏙️");
            response.put("deletedCount", count);
            response.put("city", city);
            return ResponseEntity.ok(response);
        } catch (Exception e) {
            response.put("status", "error");
            response.put("message", "Error deleting by city: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
}
```

---

## ✅❌ 4. Rules/Guidelines

### Rule 1: Method Naming Convention ✅
**✅ Correct:**
```java
@Transactional
int deleteUserByEmail(String email);  // delete + Entity + By + FieldName

@Transactional  
int removeUserByActive(boolean active); // remove + Entity + By + FieldName

@Transactional
int deleteByName(String name); // delete + By + FieldName (Entity name optional)
```

**❌ Incorrect:**
```java
// ❌ Missing @Transactional annotation
int deleteUserByEmail(String email);  

// ❌ Wrong naming pattern
int deleteWithEmail(String email);

// ❌ Wrong return type for delete operations
User deleteByEmail(String email);
```

### Rule 2: Return Types for Delete Operations ✅
**✅ Correct:**
```java
@Transactional
int deleteUserByEmail(String email);     // Returns count of deleted records

@Transactional  
long deleteUserByActive(boolean active); // Returns count as long

@Transactional
void deleteById(Long id);                // Void for single delete operations
```

**❌ Incorrect:**
```java
// ❌ Entity return type for delete operations
@Transactional
User deleteUserByEmail(String email);

// ❌ List return type  
@Transactional
List<User> deleteUserByActive(boolean active);
```

**Error Message Example:**
```
InvalidJpaQueryMethodException: Cannot use custom delete query with return type other than void, int, or long
```

### Rule 3: @Transactional is Mandatory ✅
**✅ Correct:**
```java
@Transactional
int deleteUserByEmail(String email);
```

**❌ Incorrect:**
```java
int deleteUserByEmail(String email); // Missing @Transactional
```

**Error Message:**
```
TransactionRequiredException: No transaction is in progress. 
Delete operations require an active transaction.
```

### Rule 4: Parameter Matching ✅
**✅ Correct:**
```java
@Transactional
int deleteUserByEmailAndActive(String email, boolean active);
// Parameters must match method name sequence

@Transactional
int deleteUserByAgeGreaterThan(Integer age);
// Use proper comparison keywords
```

**❌ Incorrect:**
```java
// ❌ Parameter mismatch
@Transactional
int deleteUserByEmail(String username); // Method says 'email' but parameter is 'username'

// ❌ Wrong parameter type
@Transactional  
int deleteUserByActive(String active); // Should be boolean, not String
```

---

## 🌍 5. Real-world Applications

### Banking System Example 🏦
```java
@Entity
public class BankAccount {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long accountId;
    
    private String accountNumber;
    private String customerName;
    private Double balance;
    private boolean isActive;
    private String branchCode;
    private LocalDateTime lastTransactionDate;
}

@Repository
public interface BankAccountRepository extends JpaRepository<BankAccount, Long> {
    
    // ✅ Delete inactive accounts
    @Transactional
    int deleteBankAccountByIsActive(boolean isActive);
    
    // ✅ Delete zero balance accounts  
    @Transactional
    int deleteBankAccountByBalance(Double balance);
    
    // ✅ Delete old unused accounts
    @Transactional
    @Query("DELETE FROM BankAccount ba WHERE ba.lastTransactionDate < :cutoffDate")
    int deleteOldUnusedAccounts(@Param("cutoffDate") LocalDateTime cutoffDate);
    
    // ✅ Delete accounts by branch (branch closure scenario)
    @Transactional
    int deleteBankAccountByBranchCode(String branchCode);
}
```

### E-commerce System Example 🛒
```java
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long productId;
    
    private String productName;
    private String category;
    private Double price;
    private Integer stockQuantity;
    private boolean isDiscontinued;
    private String sellerId;
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // ✅ Delete discontinued products
    @Transactional
    int deleteProductByIsDiscontinued(boolean isDiscontinued);
    
    // ✅ Delete out-of-stock products
    @Transactional  
    int deleteProductByStockQuantity(Integer stockQuantity);
    
    // ✅ Delete products by seller (seller account closure)
    @Transactional
    int deleteProductBySellerId(String sellerId);
    
    // ✅ Delete products by category (category removal)
    @Transactional
    int deleteProductByCategory(String category);
}
```

### Social Media System Example 📱
```java
@Entity
public class UserPost {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long postId;
    
    private String userId;
    private String content;
    private LocalDateTime createdDate;
    private boolean isReported;
    private boolean isDeleted;
    private String postType; // "TEXT", "IMAGE", "VIDEO"
}

@Repository  
public interface UserPostRepository extends JpaRepository<UserPost, Long> {
    
    // ✅ Delete reported posts (moderation)
    @Transactional
    int deleteUserPostByIsReported(boolean isReported);
    
    // ✅ Delete user's all posts (account deletion)
    @Transactional
    int deleteUserPostByUserId(String userId);
    
    // ✅ Delete old posts (cleanup)
    @Transactional
    @Query("DELETE FROM UserPost up WHERE up.createdDate < :cutoffDate")
    int deleteOldPosts(@Param("cutoffDate") LocalDateTime cutoffDate);
    
    // ✅ Delete specific post type
    @Transactional
    int deleteUserPostByPostType(String postType);
}
```

---

## 📊 6. Comparison Tables

### Delete Methods Comparison

| Method Type | Syntax | Use Case | Return Type | Performance |
|-------------|--------|----------|-------------|-------------|
| **deleteById()** | `deleteById(id)` | Single record by ID | `void` | ⚡ Fastest |
| **Custom Query** | `deleteBy[Field]()` | By any field | `int/long` | 🐌 Moderate |
| **@Query JPQL** | `@Query("DELETE...")` | Complex conditions | `int/long` | 🚀 Fast |
| **@Query Native** | `@Query(nativeQuery=true)` | Database-specific | `int/long` | 🚀 Fastest |

### Method Naming Patterns

| Pattern | Example | Description |
|---------|---------|-------------|
| `deleteBy[Field]` | `deleteByEmail(String email)` | Single field condition |
| `deleteBy[Field]And[Field]` | `deleteByEmailAndActive(String email, boolean active)` | Multiple AND conditions |
| `deleteBy[Field]Or[Field]` | `deleteByEmailOrName(String email, String name)` | Multiple OR conditions |
| `deleteBy[Field][Operator]` | `deleteByAgeGreaterThan(Integer age)` | With comparison operators |

### Supported Operators in Method Names

| Operator | Example | SQL Equivalent |
|----------|---------|----------------|
| `GreaterThan` | `deleteByAgeGreaterThan(25)` | `WHERE age > 25` |
| `LessThan` | `deleteByAgeLessThan(18)` | `WHERE age < 18` |
| `Between` | `deleteByAgeBetween(18, 65)` | `WHERE age BETWEEN 18 AND 65` |
| `In` | `deleteByStatusIn(List<String> statuses)` | `WHERE status IN (...)` |
| `NotIn` | `deleteByStatusNotIn(List<String> statuses)` | `WHERE status NOT IN (...)` |
| `IsNull` | `deleteByEmailIsNull()` | `WHERE email IS NULL` |
| `IsNotNull` | `deleteByEmailIsNotNull()` | `WHERE email IS NOT NULL` |
| `StartingWith` | `deleteByNameStartingWith("A")` | `WHERE name LIKE 'A%'` |
| `EndingWith` | `deleteByNameEndingWith("son")` | `WHERE name LIKE '%son'` |
| `Containing` | `deleteByNameContaining("john")` | `WHERE name LIKE '%john%'` |

---

## ❓ 7. Interview Questions

### Q1: What's the difference between deleteById() and custom delete methods? 🤔

**Answer:**
```java
// Built-in method - Fast & Direct
public void deleteById(Long id) {
    userRepository.deleteById(id);  // Direct delete by primary key
}

// Custom method - Flexible but Slower  
@Transactional
public int deleteByEmail(String email) {
    return userRepository.deleteUserByEmail(email);  // First finds, then deletes
}
```

**Key Differences:**
- `deleteById()` directly deletes using primary key (fastest)
- Custom methods first execute SELECT query, then DELETE (slower)
- Custom methods can return count of deleted records
- Custom methods require `@Transactional` annotation

### Q2: Why do we need @Transactional annotation for custom delete methods? 🤔

**Answer:**
```java
// ❌ Without @Transactional - Will throw exception
public int deleteByEmail(String email) {
    return userRepository.deleteUserByEmail(email);  
    // TransactionRequiredException: No transaction is in progress
}

// ✅ With @Transactional - Works perfectly
@Transactional
public int deleteByEmail(String email) {
    return userRepository.deleteUserByEmail(email);  // Works fine!
}
```

**Reason:** Delete operations modify database state and need transaction management for:
- **ACID Properties:** Ensuring data consistency
- **Rollback Support:** If error occurs, changes can be reverted
- **Isolation:** Other transactions don't interfere

### Q3: How to delete records with complex conditions? 🤔

**Answer:**
```java
// Method 1: Using JPQL Query
@Transactional
@Modifying
@Query("DELETE FROM User u WHERE u.age > :age AND u.active = :active")
int deleteInactiveOldUsers(@Param("age") Integer age, @Param("active") boolean active);

// Method 2: Using Native Query
@Transactional  
@Modifying
@Query(value = "DELETE FROM user_tbl WHERE created_date < :date AND login_count = 0", 
       nativeQuery = true)
int deleteUnusedOldAccounts(@Param("date") LocalDateTime date);

// Method 3: Method Name (Limited complexity)
@Transactional
int deleteUserByAgeGreaterThanAndActiveAndLastLoginDateBefore(
    Integer age, boolean active, LocalDateTime lastLogin);
```

### Q4: What happens if we try to delete a record that doesn't exist? 🤔

**Answer:**
```java
// deleteById() - No exception, silently ignores
@Test
public void testDeleteNonExistentRecord() {
    userRepository.deleteById(999L);  // No exception thrown
    System.out.println("Delete completed - no error even if record doesn't exist");
}

// Custom delete methods - Returns 0 count
@Test
public void testCustomDeleteNonExistent() {
    int count = userRepository.deleteUserByEmail("nonexistent@email.com");
    System.out.println("Deleted count: " + count);  // Output: Deleted count: 0
}

// Safe delete with check
public boolean safeDeleteById(Long id) {
    if (userRepository.existsById(id)) {
        userRepository.deleteById(id);
        return true;
    }
    return false;
}
```

### Q5: How to perform bulk delete operations efficiently? 🤔

**Answer:**
```java
// ✅ Efficient Bulk Delete using JPQL
@Transactional
@Modifying
@Query("DELETE FROM User u WHERE u.active = false")
int deleteAllInactiveUsers();

// ✅ Batch Delete with Criteria
@Transactional
@Modifying  
@Query("DELETE FROM User u WHERE u.lastLoginDate < :cutoffDate")
int deleteUnusedAccounts(@Param("cutoffDate") LocalDateTime cutoffDate);

// ❌ Inefficient - Don't do this for large datasets
public void inefficientBulkDelete() {
    List<User> inactiveUsers = userRepository.findByActive(false);
    for (User user : inactiveUsers) {
        userRepository.delete(user);  // Multiple DB calls - Very slow!
    }
}

// ✅ Efficient Alternative
@Transactional
public int efficientBulkDelete() {
    return userRepository.deleteUserByActive(false);  // Single DB call
}
```

---

## ⚠️ 8. Common Mistakes

### Mistake 1: Forgetting @Transactional ❌
```java
// ❌ Wrong - Will throw TransactionRequiredException
public interface UserRepository extends JpaRepository<User, Long> {
    int deleteUserByEmail(String email);  // Missing @Transactional
}

// ✅ Correct
public interface UserRepository extends JpaRepository<User, Long> {
    @Transactional
    int deleteUserByEmail(String email);
}
```

### Mistake 2: Wrong Return Type ❌
```java
// ❌ Wrong - Delete methods shouldn't return entities
@Transactional
User deleteUserByEmail(String email);

// ❌ Wrong - List return type not allowed
@Transactional
List<User> deleteUserByActive(boolean active);

// ✅ Correct - Return count or void
@Transactional
int deleteUserByEmail(String email);

@Transactional
void deleteById(Long id);
```

### Mistake 3: Parameter Name Mismatch ❌
```java
// ❌ Wrong - Parameter name doesn't match method
@Transactional
int deleteUserByEmail(String username);  // Should be 'email', not 'username'

// ✅ Correct - Parameter matches method name
@Transactional
int deleteUserByEmail(String email);
```

### Mistake 4: Not Handling Cascade Operations ❌
```java
@Entity
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // ❌ Wrong - No cascade delete defined
    @OneToMany(mappedBy = "user")
    private List<UserPost> posts;
}

// ✅ Correct - Define cascade behavior
@OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
private List<UserPost> posts;
```

### Mistake 5: Not Checking Dependencies Before Delete ❌
```java
// ❌ Wrong - Delete without checking dependencies
@Transactional
public void deleteUser(Long userId) {
    userRepository.deleteById(userId);  // May cause foreign key constraint violations
}

// ✅ Correct - Check and handle dependencies
@Transactional
public boolean safeDeleteUser(Long userId) {
    try {
        // Check if user has dependent records
        if (userPostRepository.countByUserId(userId) > 0) {
            // Handle dependent records first
            userPostRepository.deleteUserPostByUserId(userId);
        }
        
        userRepository.deleteById(userId);
        return true;
    } catch (DataIntegrityViolationException e) {
        logger.error("Cannot delete user due to dependencies: " + e.getMessage());
        return false;
    }
}
```

---

## 🏆 9. Best Practices

### Practice 1: Always Use @Transactional for Custom Deletes ✅
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // ✅ Always annotate custom delete methods
    @Transactional
    int deleteUserByEmail(String email);
    
    @Transactional
    int deleteUserByActiveAndLastLoginDateBefore(boolean active, LocalDateTime date);
}
```

### Practice 2: Meaningful Method Names ✅
```java
// ✅ Good - Clear and descriptive
@Transactional
int deleteInactiveUsers();

@Transactional  
int deleteExpiredSessions();

@Transactional
int deleteUnverifiedAccountsOlderThan(LocalDateTime cutoffDate);

// ❌ Bad - Unclear purpose
@Transactional
int deleteUsers();

@Transactional
int deleteStuff();
```

### Practice 3: Return Types for Better Feedback ✅
```java
@Service
public class UserService {
    
    // ✅ Return count for bulk operations
    @Transactional
    public int cleanupInactiveUsers() {
        int deletedCount = userRepository.deleteUserByActive(false);
        logger.info("Cleaned up {} inactive users", deletedCount);
        return deletedCount;
    }
    
    // ✅ Return boolean for single operations
    public boolean deleteUserById(Long id) {
        if (userRepository.existsById(id)) {
            userRepository.deleteById(id);
            logger.info("User deleted successfully with ID: {}", id);
            return true;
        }
        logger.warn("User not found with ID: {}", id);
        return false;
    }
}
```

### Practice 4: Error Handling and Logging ✅
```java
@Service
public class UserService {
    
    private static final Logger logger = LoggerFactory.getLogger(UserService.class);
    
    @Transactional
    public DeleteResult deleteUsersByStatus(String status) {
        try {
            int deletedCount = userRepository.deleteUserByStatus(status);
            
            if (deletedCount > 0) {
                logger.info("Successfully deleted {} users with status: {}", deletedCount, status);
                return new DeleteResult(true, deletedCount, "Users deleted successfully");
            } else {
                logger.info("No users found with status: {}", status);
                return new DeleteResult(true, 0, "No users found to delete");
            }
            
        } catch (DataIntegrityViolationException e) {
            logger.error("Foreign key constraint violation while deleting users: {}", e.getMessage());
            return new DeleteResult(false, 0, "Cannot delete users due to dependencies");
            
        } catch (Exception e) {
            logger.error("Unexpected error while deleting users: {}", e.getMessage(), e);
            return new DeleteResult(false, 0, "Internal error occurred");
        }
    }
}

// Helper class for better response handling
public class DeleteResult {
    private boolean success;
    private int deletedCount;
    private String message;
    
    // Constructor, getters, setters...
}
```

### Practice 5: Batch Processing for Large Datasets ✅
```java
@Service
public class UserCleanupService {
    
    @Autowired
    private UserRepository userRepository;
    
    // ✅ Process large datasets in batches
    @Transactional
    public int cleanupLargeDataset(LocalDateTime cutoffDate) {
        int totalDeleted = 0;
        int batchSize = 1000;
        
        while (true) {
            // Process in batches to avoid memory issues
            int deletedInBatch = userRepository
