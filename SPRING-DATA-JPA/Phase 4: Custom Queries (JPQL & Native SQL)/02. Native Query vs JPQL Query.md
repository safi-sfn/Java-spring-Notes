# Native Query vs JPQL Query - Complete Guide ğŸš€

## ğŸ¤” Introduction - Confusion Clear Karte Hain!

### Simple Explanation (Dost ki tarah) ğŸ‘«
Bhai, socho tum database se data chahiye. Ab tum ye kaise kar sakte ho:
1. **Native Query** - Direct SQL likhna (jaise database se seedha baat karna) ğŸ’¬
2. **JPQL Query** - Java entities ke through baat karna (translator ke through) ğŸ”„

### Real-Life Analogy ğŸ 
**Native Query** = Ghar ke cook se direct Hindi mein bolna "Dal banao, 2 chamach namak daalo"
**JPQL Query** = English-speaking guest ke through cook ko bolwana "Please make lentils with proper seasoning"

### Technical Definition ğŸ“š
- **Native Query**: Raw SQL queries jo direct database tables aur columns pe kaam karte hain
- **JPQL (Java Persistence Query Language)**: Object-oriented query language jo JPA entities pe kaam karta hai

---

## ğŸ”‘ Key Terms/Concepts

| Term | Technical Definition |
|------|---------------------|
| **Native Query** | Raw SQL queries using database-specific syntax |
| **JPQL** | Object-oriented query language for JPA entities |
| **Entity** | Java class mapped to database table |
| **Portability** | Code working across different databases |
| **Runtime Validation** | Query validation during execution |

### Visual Representation ğŸ“Š
```
Database Table          JPA Entity
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ user_id     â”‚  â†â†’    â”‚ userId      â”‚
â”‚ user_name   â”‚  â†â†’    â”‚ userName    â”‚
â”‚ email       â”‚  â†â†’    â”‚ email       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â†‘                      â†‘
Native Query          JPQL Query
```

---

## ğŸ’¡ Detailed Examples

### 1ï¸âƒ£ Native Query Example

```java
// Repository mein Native Query
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // âœ… Native Query - Direct SQL
    @Query(value = "SELECT * FROM orders WHERE order_status = :status", 
           nativeQuery = true)
    List<Order> findByStatusNative(@Param("status") String status);
    
    // âœ… Complex Native Query with JOIN
    @Query(value = """
        SELECT o.*, c.customer_name 
        FROM orders o 
        JOIN customers c ON o.customer_id = c.id 
        WHERE o.order_date >= :startDate 
        ORDER BY o.order_total DESC 
        LIMIT :limit
        """, nativeQuery = true)
    List<Object[]> findTopOrdersWithCustomer(
        @Param("startDate") LocalDate startDate,
        @Param("limit") int limit);
}
```

**Expected Output:**
```
Query executed: SELECT * FROM orders WHERE order_status = 'PENDING'
Results: [Order(id=1, status=PENDING), Order(id=3, status=PENDING)]
```

### 2ï¸âƒ£ JPQL Query Example

```java
// Repository mein JPQL Query
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // âœ… JPQL Query - Entity-based
    @Query("SELECT o FROM Order o WHERE o.status = :status")
    List<Order> findByStatusJPQL(@Param("status") OrderStatus status);
    
    // âœ… Complex JPQL with JOIN
    @Query("""
        SELECT o, c.customerName 
        FROM Order o 
        JOIN o.customer c 
        WHERE o.orderDate >= :startDate 
        ORDER BY o.orderTotal DESC
        """)
    List<Object[]> findOrdersWithCustomer(@Param("startDate") LocalDate startDate);
}
```

**Expected Output:**
```
Generated SQL: SELECT o.order_id, o.order_status FROM orders o WHERE o.order_status = ?
Results: [Order(id=1, status=PENDING), Order(id=3, status=PENDING)]
```

---

## ğŸ“‹ Rules/Guidelines

### Native Query Rules ğŸ“

#### Rule 1: Always use nativeQuery = true âœ…
```java
âœ… CORRECT
@Query(value = "SELECT * FROM users", nativeQuery = true)
List<User> getAllUsers();

âŒ WRONG - Missing nativeQuery flag
@Query(value = "SELECT * FROM users")  
List<User> getAllUsers();
```
**Error:** `org.hibernate.QueryException: Not all named parameters have been set`

#### Rule 2: Use database-specific syntax âœ…
```java
âœ… CORRECT - MySQL specific
@Query(value = "SELECT * FROM orders LIMIT :limit", nativeQuery = true)
List<Order> findTopOrders(@Param("limit") int limit);

âœ… CORRECT - Oracle specific  
@Query(value = "SELECT * FROM orders WHERE ROWNUM <= :limit", nativeQuery = true)
List<Order> findTopOrdersOracle(@Param("limit") int limit);
```

#### Rule 3: Explicit result mapping for DTOs âœ…
```java
âœ… CORRECT - With result mapping
@SqlResultSetMapping(
    name = "OrderSummaryMapping",
    classes = @ConstructorResult(
        targetClass = OrderSummary.class,
        columns = {
            @ColumnResult(name = "order_id", type = Long.class),
            @ColumnResult(name = "total", type = BigDecimal.class)
        }
    )
)
```

### JPQL Query Rules ğŸ“

#### Rule 1: Use entity names, not table names âœ…
```java
âœ… CORRECT - Entity name 'Order'
@Query("SELECT o FROM Order o WHERE o.status = :status")

âŒ WRONG - Table name 'orders'
@Query("SELECT o FROM orders o WHERE o.status = :status")
```
**Error:** `QuerySyntaxException: orders is not mapped`

#### Rule 2: Use entity attributes, not column names âœ…
```java
âœ… CORRECT - Entity attribute 'orderTotal'
@Query("SELECT o FROM Order o WHERE o.orderTotal > :amount")

âŒ WRONG - Column name 'order_total'
@Query("SELECT o FROM Order o WHERE o.order_total > :amount")
```
**Error:** `IllegalArgumentException: Unable to locate appropriate property: order_total`

#### Rule 3: No database-specific functions âœ…
```java
âœ… CORRECT - JPQL functions
@Query("SELECT o FROM Order o WHERE SIZE(o.items) > :count")

âŒ WRONG - Database-specific function
@Query("SELECT o FROM Order o WHERE COUNT(items) > :count")
```

---

## ğŸŒ Real-world Applications

### 1ï¸âƒ£ Banking System Example ğŸ¦

#### Native Query - Complex Financial Report
```java
@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    
    // Monthly balance calculation with database-specific optimizations
    @Query(value = """
        WITH monthly_summary AS (
            SELECT 
                account_id,
                MONTH(transaction_date) as month,
                SUM(CASE WHEN type = 'CREDIT' THEN amount ELSE -amount END) as net_amount,
                ROW_NUMBER() OVER (PARTITION BY account_id ORDER BY transaction_date DESC) as rn
            FROM transactions 
            WHERE transaction_date BETWEEN :startDate AND :endDate
            GROUP BY account_id, MONTH(transaction_date)
        )
        SELECT account_id, net_amount 
        FROM monthly_summary 
        WHERE rn = 1
        """, nativeQuery = true)
    List<Object[]> getMonthlyBalanceSummary(
        @Param("startDate") LocalDate startDate, 
        @Param("endDate") LocalDate endDate
    );
}
```

#### JPQL - Simple Account Operations
```java
@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    // Simple balance check - database independent
    @Query("SELECT a FROM Account a WHERE a.balance >= :minBalance AND a.status = 'ACTIVE'")
    List<Account> findActiveAccountsWithMinBalance(@Param("minBalance") BigDecimal minBalance);
    
    // Account holder details with join
    @Query("SELECT a, ah.fullName FROM Account a JOIN a.accountHolder ah WHERE a.accountType = :type")
    List<Object[]> findAccountsWithHolderName(@Param("type") AccountType type);
}
```

### 2ï¸âƒ£ E-commerce Platform Example ğŸ›’

#### Native Query - Performance Optimized Product Search
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Query(value = """
        SELECT p.*, 
               AVG(r.rating) as avg_rating,
               COUNT(r.id) as review_count,
               MATCH(p.name, p.description) AGAINST (:searchTerm IN NATURAL LANGUAGE MODE) as relevance
        FROM products p
        LEFT JOIN reviews r ON p.id = r.product_id
        WHERE MATCH(p.name, p.description) AGAINST (:searchTerm IN NATURAL LANGUAGE MODE)
        GROUP BY p.id
        HAVING avg_rating >= :minRating
        ORDER BY relevance DESC, avg_rating DESC
        LIMIT :limit
        """, nativeQuery = true)
    List<Object[]> searchProductsWithRating(
        @Param("searchTerm") String searchTerm,
        @Param("minRating") Double minRating,
        @Param("limit") int limit
    );
}
```

#### JPQL - Simple Product Queries
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Query("SELECT p FROM Product p WHERE p.category.name = :categoryName AND p.active = true")
    List<Product> findActiveProductsByCategory(@Param("categoryName") String categoryName);
    
    @Query("SELECT p FROM Product p JOIN p.reviews r GROUP BY p HAVING AVG(r.rating) >= :rating")
    List<Product> findProductsWithHighRating(@Param("rating") Double rating);
}
```

---

## âš–ï¸ Comparison Tables

### Feature Comparison

| Feature | Native Query ğŸ”§ | JPQL Query ğŸ¯ |
|---------|------------------|----------------|
| **Syntax** | Raw SQL (`SELECT * FROM orders`) | Entity-based (`SELECT o FROM Order o`) |
| **Portability** | âŒ Database-specific | âœ… Database-independent |
| **Validation Time** | â° Runtime | âœ… Application startup |
| **Result Mapping** | ğŸ”§ Manual mapping required | âœ… Automatic entity mapping |
| **Advanced SQL** | âœ… Full SQL support | âŒ Limited JPQL features |
| **Performance** | âœ… Direct database execution | âš ï¸ Translation overhead |
| **Learning Curve** | ğŸ“š SQL knowledge needed | ğŸ“ JPA knowledge needed |

### Use Case Scenarios

| Scenario | Native Query ğŸ”§ | JPQL Query ğŸ¯ | Winner ğŸ† |
|----------|------------------|----------------|-----------|
| Simple CRUD operations | âš ï¸ Overkill | âœ… Perfect fit | JPQL |
| Complex reporting with aggregations | âœ… Full control | âŒ Limited | Native |
| Multi-database deployment | âŒ Needs modification | âœ… Works everywhere | JPQL |
| Database-specific optimizations | âœ… Best performance | âŒ Generic queries | Native |
| Stored procedure calls | âœ… Direct support | âŒ Not supported | Native |
| Entity relationship navigation | âš ï¸ Manual joins | âœ… Object navigation | JPQL |

### Performance Comparison

| Query Type | Execution Speed | Memory Usage | Complexity |
|------------|----------------|---------------|------------|
| **Native Query** | ğŸš€ Fastest | ğŸ’¾ Low | ğŸ§  High |
| **JPQL Query** | âš¡ Fast (with overhead) | ğŸ’¾ Medium | ğŸ§  Medium |

---

## ğŸ¯ Interview Questions

### Q1: Native Query aur JPQL mein main difference kya hai?

**Answer:**
```java
// Native Query - Direct SQL
@Query(value = "SELECT * FROM users WHERE age > ?1", nativeQuery = true)
List<User> findUsersByAgeNative(int age);

// JPQL - Entity-based  
@Query("SELECT u FROM User u WHERE u.age > :age")
List<User> findUsersByAgeJPQL(@Param("age") int age);
```

**Key Differences:**
- Native Query database-specific hai, JPQL portable hai
- Native Query runtime pe validate hota hai, JPQL startup pe
- Native Query mein manual result mapping, JPQL automatic

### Q2: Kab Native Query use karna chahiye?

**Answer:**
```java
// When you need database-specific features
@Query(value = """
    SELECT u.*, 
           TIMESTAMPDIFF(YEAR, u.birth_date, CURDATE()) as calculated_age
    FROM users u 
    WHERE u.city = :city 
    ORDER BY calculated_age DESC 
    LIMIT :limit
    """, nativeQuery = true)
List<Object[]> findUsersWithCalculatedAge(String city, int limit);
```

**Use Cases:**
- Complex aggregations aur window functions
- Database-specific functions (TIMESTAMPDIFF, etc.)
- Performance-critical queries
- Stored procedures

### Q3: JPQL mein JOIN kaise karte hain?

**Answer:**
```java
// Entity relationship ke through
@Query("""
    SELECT o, c.name, p.productName 
    FROM Order o 
    JOIN o.customer c 
    JOIN o.orderItems oi 
    JOIN oi.product p 
    WHERE c.city = :city
    """)
List<Object[]> findOrdersWithCustomerAndProducts(@Param("city") String city);
```

### Q4: Native Query mein SQL Injection kaise prevent karte hain?

**Answer:**
```java
// âŒ WRONG - Vulnerable to SQL Injection
@Query(value = "SELECT * FROM users WHERE name = '" + name + "'", nativeQuery = true)

// âœ… CORRECT - Using parameters
@Query(value = "SELECT * FROM users WHERE name = :name", nativeQuery = true)
List<User> findByNameSafe(@Param("name") String name);

// âœ… CORRECT - Using positional parameters
@Query(value = "SELECT * FROM users WHERE name = ?1", nativeQuery = true)
List<User> findByNameSafe(String name);
```

### Q5: JPQL mein pagination kaise implement karte hain?

**Answer:**
```java
@Query("SELECT p FROM Product p WHERE p.category = :category ORDER BY p.price")
Page<Product> findByCategoryOrderByPrice(
    @Param("category") String category, 
    Pageable pageable
);

// Usage
Pageable pageable = PageRequest.of(0, 10, Sort.by("price").descending());
Page<Product> products = repository.findByCategoryOrderByPrice("Electronics", pageable);
```

---

## ğŸš« Common Mistakes

### Mistake 1: Native Query mein entity name use karna

```java
âŒ WRONG
@Query(value = "SELECT o FROM Order o WHERE o.status = :status", nativeQuery = true)

âœ… CORRECT  
@Query(value = "SELECT * FROM orders WHERE order_status = :status", nativeQuery = true)
```

**Why Wrong:** Native query mein table names aur column names use karte hain, entity names nahi!

### Mistake 2: JPQL mein database-specific functions

```java
âŒ WRONG
@Query("SELECT u FROM User u WHERE DATEDIFF(CURDATE(), u.birthDate) > 365")

âœ… CORRECT
@Query("SELECT u FROM User u WHERE u.birthDate < :oneYearAgo")
// Parameter mein date calculate karke pass karo
```

**Why Wrong:** JPQL database-independent hona chahiye!

### Mistake 3: Result mapping bhoolna

```java
âŒ WRONG - Return type mismatch
@Query(value = "SELECT user_name, email FROM users", nativeQuery = true)
List<User> findUserDetails(); // User entity expect kar raha hai but partial data aa rahi hai

âœ… CORRECT - Proper DTO mapping
@Query(value = "SELECT user_name as userName, email FROM users", nativeQuery = true)
List<UserDetailsDTO> findUserDetails();
```

### Mistake 4: Parameter binding galat

```java
âŒ WRONG
@Query("SELECT u FROM User u WHERE u.age > age") // Parameter missing

âœ… CORRECT
@Query("SELECT u FROM User u WHERE u.age > :age")
List<User> findUsersByAge(@Param("age") int age);
```

---

## âœ¨ Best Practices

### Native Query Best Practices ğŸ”§

#### 1ï¸âƒ£ Always Use Parameters
```java
// âœ… Safe from SQL injection
@Query(value = """
    SELECT u.* FROM users u 
    WHERE u.city = :city 
    AND u.age BETWEEN :minAge AND :maxAge
    """, nativeQuery = true)
List<User> findUsersByCityAndAgeRange(
    @Param("city") String city,
    @Param("minAge") int minAge, 
    @Param("maxAge") int maxAge
);
```

#### 2ï¸âƒ£ Proper Result Mapping for DTOs
```java
// âœ… Clean DTO mapping
public interface UserSummary {
    Long getId();
    String getName();
    String getEmail();
    Integer getOrderCount();
}

@Query(value = """
    SELECT u.id, u.name, u.email, COUNT(o.id) as orderCount
    FROM users u 
    LEFT JOIN orders o ON u.id = o.user_id
    GROUP BY u.id, u.name, u.email
    """, nativeQuery = true)
List<UserSummary> getUserSummaries();
```

#### 3ï¸âƒ£ Database-specific Optimizations
```java
// âœ… Use database strengths
@Query(value = """
    SELECT /*+ INDEX(orders, idx_order_date) */ 
    o.* FROM orders o 
    WHERE o.order_date >= :startDate
    AND o.status IN ('PENDING', 'PROCESSING')
    """, nativeQuery = true)
List<Order> findRecentPendingOrders(@Param("startDate") LocalDate startDate);
```

### JPQL Best Practices ğŸ¯

#### 1ï¸âƒ£ Use Entity Relationships
```java
// âœ… Leverage JPA relationships
@Query("""
    SELECT o FROM Order o 
    JOIN FETCH o.customer 
    JOIN FETCH o.orderItems oi 
    JOIN FETCH oi.product 
    WHERE o.status = :status
    """)
List<Order> findOrdersWithDetailsJPQL(@Param("status") OrderStatus status);
```

#### 2ï¸âƒ£ Efficient Pagination
```java
// âœ… Use Spring Data pagination
@Query("SELECT p FROM Product p WHERE p.category.name = :category")
Page<Product> findByCategory(@Param("category") String category, Pageable pageable);

// Usage with sorting
Pageable pageable = PageRequest.of(0, 20, Sort.by("price").descending());
```

#### 3ï¸âƒ£ Constructor Expressions for DTOs
```java
// âœ… Direct DTO mapping in JPQL
@Query("""
    SELECT new com.example.dto.OrderSummaryDTO(
        o.id, 
        o.orderDate, 
        c.name, 
        SUM(oi.price * oi.quantity)
    )
    FROM Order o 
    JOIN o.customer c 
    JOIN o.orderItems oi 
    GROUP BY o.id, o.orderDate, c.name
    """)
List<OrderSummaryDTO> getOrderSummaries();
```

### Documentation Best Practices ğŸ“

```java
/**
 * Fetches orders with complex business logic
 * 
 * Uses native query for performance optimization with database-specific features:
 * - Window functions for ranking
 * - Full-text search capabilities
 * - Database hints for query optimization
 * 
 * @param searchTerm Full-text search term
 * @param limit Maximum number of results
 * @return List of orders with calculated relevance scores
 */
@Query(value = """
    SELECT o.*, 
           ROW_NUMBER() OVER (ORDER BY o.order_total DESC) as rank,
           MATCH(p.name) AGAINST (:searchTerm) as relevance
    FROM orders o
    JOIN order_items oi ON o.id = oi.order_id
    JOIN products p ON oi.product_id = p.id
    WHERE MATCH(p.name) AGAINST (:searchTerm)
    LIMIT :limit
    """, nativeQuery = true)
List<Object[]> searchOrdersWithRanking(String searchTerm, int limit);
```

---

## ğŸ¯ Summary/Quick Recap

### Key Takeaways ğŸ”‘

#### Native Query - Yaad Rakhne Ka Mantra ğŸ§ 
- **"Direct SQL, Direct Control"** - Database ke saath seedhi baat
- **"Power with Responsibility"** - Zyada power, zyada complexity
- **"When JPQL is not enough"** - Complex queries ke liye use karo

#### JPQL Query - Yaad Rakhne Ka Mantra ğŸ§   
- **"Entity First, Table Last"** - Hamesha entity names use karo
- **"Portable and Safe"** - Har database mein chalta hai
- **"Simple and Clean"** - Basic operations ke liye perfect

### When to Use What? ğŸ¤”

```
ğŸ“Š Complex Reports + Performance = Native Query
ğŸ”„ Simple CRUD + Portability = JPQL Query
ğŸš€ Database-specific features = Native Query  
ğŸŒ Multi-database support = JPQL Query
```

### Memory Tricks ğŸ’¡

1. **Native = Natural SQL** (Raw aur direct)
2. **JPQL = Java + SQL** (Object-oriented thinking)
3. **Native for Speed, JPQL for Need** ğŸƒâ€â™‚ï¸
4. **Complex = Native, Simple = JPQL** 

### Final Decision Matrix ğŸ¯

| Your Requirement | Choose This |
|------------------|-------------|
| ğŸ”¥ Maximum Performance | Native Query |
| ğŸŒ Database Independence | JPQL Query |
| ğŸ“Š Complex Reporting | Native Query |
| ğŸ¯ Simple Entity Operations | JPQL Query |
| ğŸ› ï¸ Database-specific Features | Native Query |
| âš¡ Quick Development | JPQL Query |

---

## ğŸ‰ Bonus Tips for Interviews!

### Tricky Questions Ke Answers ğŸ¯

**Q: Performance mein kaun better hai?**
**A:** "Sir, Native Query generally faster hai kyunki direct SQL execute hota hai. JPQL mein translation overhead hota hai, but modern JPA implementations mein ye difference negligible hai for simple queries."

**Q: Production mein kya use karna chahiye?**
**A:** "Sir, depends on use case. Standard operations ke liye JPQL (maintainability), complex reporting ke liye Native Query (performance). Best practice hai ki 80% JPQL, 20% Native Query use karo."

**Q: Migration mein problem aayegi?**
**A:** "Native Query database-specific hai, so migration time pe rewrite karna padega. JPQL queries as-is chalti hain new database pe. That's why JPQL is preferred for long-term projects."

---

### ğŸ¯ Pro Tips for Success!

1. **Practice Both**: Dono queries practice karo, interview mein dono puchte hain
2. **Real Examples**: Banking, E-commerce examples ready rakho  
3. **Performance Understanding**: Kab kaun use karna hai, clearly samjho
4. **Code Quality**: Clean, readable code likho interview mein

**Yaad rakho bhai:** Native Query aur JPQL dono important hain. Situation according use karo, dogmatic mat bano! ğŸš€

---

*Happy Coding! May your queries be fast and your data be consistent! ğŸ¯âœ¨*
