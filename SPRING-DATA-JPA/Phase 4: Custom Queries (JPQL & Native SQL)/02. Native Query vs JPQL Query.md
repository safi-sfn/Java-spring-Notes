# Native Query vs JPQL Query - Complete Guide 🚀

## 🤔 Introduction - Confusion Clear Karte Hain!

### Simple Explanation (Dost ki tarah) 👫
Bhai, socho tum database se data chahiye. Ab tum ye kaise kar sakte ho:
1. **Native Query** - Direct SQL likhna (jaise database se seedha baat karna) 💬
2. **JPQL Query** - Java entities ke through baat karna (translator ke through) 🔄

### Real-Life Analogy 🏠
**Native Query** = Ghar ke cook se direct Hindi mein bolna "Dal banao, 2 chamach namak daalo"
**JPQL Query** = English-speaking guest ke through cook ko bolwana "Please make lentils with proper seasoning"

### Technical Definition 📚
- **Native Query**: Raw SQL queries jo direct database tables aur columns pe kaam karte hain
- **JPQL (Java Persistence Query Language)**: Object-oriented query language jo JPA entities pe kaam karta hai

---

## 🔑 Key Terms/Concepts

| Term | Technical Definition |
|------|---------------------|
| **Native Query** | Raw SQL queries using database-specific syntax |
| **JPQL** | Object-oriented query language for JPA entities |
| **Entity** | Java class mapped to database table |
| **Portability** | Code working across different databases |
| **Runtime Validation** | Query validation during execution |

### Visual Representation 📊
```
Database Table          JPA Entity
┌─────────────┐        ┌─────────────┐
│ user_id     │  ←→    │ userId      │
│ user_name   │  ←→    │ userName    │
│ email       │  ←→    │ email       │
└─────────────┘        └─────────────┘
     ↑                      ↑
Native Query          JPQL Query
```

---

## 💡 Detailed Examples

### 1️⃣ Native Query Example

```java
// Repository mein Native Query
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // ✅ Native Query - Direct SQL
    @Query(value = "SELECT * FROM orders WHERE order_status = :status", 
           nativeQuery = true)
    List<Order> findByStatusNative(@Param("status") String status);
    
    // ✅ Complex Native Query with JOIN
    @Query(value = """
        SELECT o.*, c.customer_name 
        FROM orders o 
        JOIN customers c ON o.customer_id = c.id 
        WHERE o.order_date >= :startDate 
        ORDER BY o.order_total DESC 
        LIMIT :limit
        """, nativeQuery = true)
    List<Object[]> findTopOrdersWithCustomer(
        @Param("startDate") LocalDate startDate,
        @Param("limit") int limit);
}
```

**Expected Output:**
```
Query executed: SELECT * FROM orders WHERE order_status = 'PENDING'
Results: [Order(id=1, status=PENDING), Order(id=3, status=PENDING)]
```

### 2️⃣ JPQL Query Example

```java
// Repository mein JPQL Query
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // ✅ JPQL Query - Entity-based
    @Query("SELECT o FROM Order o WHERE o.status = :status")
    List<Order> findByStatusJPQL(@Param("status") OrderStatus status);
    
    // ✅ Complex JPQL with JOIN
    @Query("""
        SELECT o, c.customerName 
        FROM Order o 
        JOIN o.customer c 
        WHERE o.orderDate >= :startDate 
        ORDER BY o.orderTotal DESC
        """)
    List<Object[]> findOrdersWithCustomer(@Param("startDate") LocalDate startDate);
}
```

**Expected Output:**
```
Generated SQL: SELECT o.order_id, o.order_status FROM orders o WHERE o.order_status = ?
Results: [Order(id=1, status=PENDING), Order(id=3, status=PENDING)]
```

---

## 📋 Rules/Guidelines

### Native Query Rules 📏

#### Rule 1: Always use nativeQuery = true ✅
```java
✅ CORRECT
@Query(value = "SELECT * FROM users", nativeQuery = true)
List<User> getAllUsers();

❌ WRONG - Missing nativeQuery flag
@Query(value = "SELECT * FROM users")  
List<User> getAllUsers();
```
**Error:** `org.hibernate.QueryException: Not all named parameters have been set`

#### Rule 2: Use database-specific syntax ✅
```java
✅ CORRECT - MySQL specific
@Query(value = "SELECT * FROM orders LIMIT :limit", nativeQuery = true)
List<Order> findTopOrders(@Param("limit") int limit);

✅ CORRECT - Oracle specific  
@Query(value = "SELECT * FROM orders WHERE ROWNUM <= :limit", nativeQuery = true)
List<Order> findTopOrdersOracle(@Param("limit") int limit);
```

#### Rule 3: Explicit result mapping for DTOs ✅
```java
✅ CORRECT - With result mapping
@SqlResultSetMapping(
    name = "OrderSummaryMapping",
    classes = @ConstructorResult(
        targetClass = OrderSummary.class,
        columns = {
            @ColumnResult(name = "order_id", type = Long.class),
            @ColumnResult(name = "total", type = BigDecimal.class)
        }
    )
)
```

### JPQL Query Rules 📏

#### Rule 1: Use entity names, not table names ✅
```java
✅ CORRECT - Entity name 'Order'
@Query("SELECT o FROM Order o WHERE o.status = :status")

❌ WRONG - Table name 'orders'
@Query("SELECT o FROM orders o WHERE o.status = :status")
```
**Error:** `QuerySyntaxException: orders is not mapped`

#### Rule 2: Use entity attributes, not column names ✅
```java
✅ CORRECT - Entity attribute 'orderTotal'
@Query("SELECT o FROM Order o WHERE o.orderTotal > :amount")

❌ WRONG - Column name 'order_total'
@Query("SELECT o FROM Order o WHERE o.order_total > :amount")
```
**Error:** `IllegalArgumentException: Unable to locate appropriate property: order_total`

#### Rule 3: No database-specific functions ✅
```java
✅ CORRECT - JPQL functions
@Query("SELECT o FROM Order o WHERE SIZE(o.items) > :count")

❌ WRONG - Database-specific function
@Query("SELECT o FROM Order o WHERE COUNT(items) > :count")
```

---

## 🌍 Real-world Applications

### 1️⃣ Banking System Example 🏦

#### Native Query - Complex Financial Report
```java
@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    
    // Monthly balance calculation with database-specific optimizations
    @Query(value = """
        WITH monthly_summary AS (
            SELECT 
                account_id,
                MONTH(transaction_date) as month,
                SUM(CASE WHEN type = 'CREDIT' THEN amount ELSE -amount END) as net_amount,
                ROW_NUMBER() OVER (PARTITION BY account_id ORDER BY transaction_date DESC) as rn
            FROM transactions 
            WHERE transaction_date BETWEEN :startDate AND :endDate
            GROUP BY account_id, MONTH(transaction_date)
        )
        SELECT account_id, net_amount 
        FROM monthly_summary 
        WHERE rn = 1
        """, nativeQuery = true)
    List<Object[]> getMonthlyBalanceSummary(
        @Param("startDate") LocalDate startDate, 
        @Param("endDate") LocalDate endDate
    );
}
```

#### JPQL - Simple Account Operations
```java
@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    // Simple balance check - database independent
    @Query("SELECT a FROM Account a WHERE a.balance >= :minBalance AND a.status = 'ACTIVE'")
    List<Account> findActiveAccountsWithMinBalance(@Param("minBalance") BigDecimal minBalance);
    
    // Account holder details with join
    @Query("SELECT a, ah.fullName FROM Account a JOIN a.accountHolder ah WHERE a.accountType = :type")
    List<Object[]> findAccountsWithHolderName(@Param("type") AccountType type);
}
```

### 2️⃣ E-commerce Platform Example 🛒

#### Native Query - Performance Optimized Product Search
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Query(value = """
        SELECT p.*, 
               AVG(r.rating) as avg_rating,
               COUNT(r.id) as review_count,
               MATCH(p.name, p.description) AGAINST (:searchTerm IN NATURAL LANGUAGE MODE) as relevance
        FROM products p
        LEFT JOIN reviews r ON p.id = r.product_id
        WHERE MATCH(p.name, p.description) AGAINST (:searchTerm IN NATURAL LANGUAGE MODE)
        GROUP BY p.id
        HAVING avg_rating >= :minRating
        ORDER BY relevance DESC, avg_rating DESC
        LIMIT :limit
        """, nativeQuery = true)
    List<Object[]> searchProductsWithRating(
        @Param("searchTerm") String searchTerm,
        @Param("minRating") Double minRating,
        @Param("limit") int limit
    );
}
```

#### JPQL - Simple Product Queries
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    @Query("SELECT p FROM Product p WHERE p.category.name = :categoryName AND p.active = true")
    List<Product> findActiveProductsByCategory(@Param("categoryName") String categoryName);
    
    @Query("SELECT p FROM Product p JOIN p.reviews r GROUP BY p HAVING AVG(r.rating) >= :rating")
    List<Product> findProductsWithHighRating(@Param("rating") Double rating);
}
```

---

## ⚖️ Comparison Tables

### Feature Comparison

| Feature | Native Query 🔧 | JPQL Query 🎯 |
|---------|------------------|----------------|
| **Syntax** | Raw SQL (`SELECT * FROM orders`) | Entity-based (`SELECT o FROM Order o`) |
| **Portability** | ❌ Database-specific | ✅ Database-independent |
| **Validation Time** | ⏰ Runtime | ✅ Application startup |
| **Result Mapping** | 🔧 Manual mapping required | ✅ Automatic entity mapping |
| **Advanced SQL** | ✅ Full SQL support | ❌ Limited JPQL features |
| **Performance** | ✅ Direct database execution | ⚠️ Translation overhead |
| **Learning Curve** | 📚 SQL knowledge needed | 🎓 JPA knowledge needed |

### Use Case Scenarios

| Scenario | Native Query 🔧 | JPQL Query 🎯 | Winner 🏆 |
|----------|------------------|----------------|-----------|
| Simple CRUD operations | ⚠️ Overkill | ✅ Perfect fit | JPQL |
| Complex reporting with aggregations | ✅ Full control | ❌ Limited | Native |
| Multi-database deployment | ❌ Needs modification | ✅ Works everywhere | JPQL |
| Database-specific optimizations | ✅ Best performance | ❌ Generic queries | Native |
| Stored procedure calls | ✅ Direct support | ❌ Not supported | Native |
| Entity relationship navigation | ⚠️ Manual joins | ✅ Object navigation | JPQL |

### Performance Comparison

| Query Type | Execution Speed | Memory Usage | Complexity |
|------------|----------------|---------------|------------|
| **Native Query** | 🚀 Fastest | 💾 Low | 🧠 High |
| **JPQL Query** | ⚡ Fast (with overhead) | 💾 Medium | 🧠 Medium |

---

## 🎯 Interview Questions

### Q1: Native Query aur JPQL mein main difference kya hai?

**Answer:**
```java
// Native Query - Direct SQL
@Query(value = "SELECT * FROM users WHERE age > ?1", nativeQuery = true)
List<User> findUsersByAgeNative(int age);

// JPQL - Entity-based  
@Query("SELECT u FROM User u WHERE u.age > :age")
List<User> findUsersByAgeJPQL(@Param("age") int age);
```

**Key Differences:**
- Native Query database-specific hai, JPQL portable hai
- Native Query runtime pe validate hota hai, JPQL startup pe
- Native Query mein manual result mapping, JPQL automatic

### Q2: Kab Native Query use karna chahiye?

**Answer:**
```java
// When you need database-specific features
@Query(value = """
    SELECT u.*, 
           TIMESTAMPDIFF(YEAR, u.birth_date, CURDATE()) as calculated_age
    FROM users u 
    WHERE u.city = :city 
    ORDER BY calculated_age DESC 
    LIMIT :limit
    """, nativeQuery = true)
List<Object[]> findUsersWithCalculatedAge(String city, int limit);
```

**Use Cases:**
- Complex aggregations aur window functions
- Database-specific functions (TIMESTAMPDIFF, etc.)
- Performance-critical queries
- Stored procedures

### Q3: JPQL mein JOIN kaise karte hain?

**Answer:**
```java
// Entity relationship ke through
@Query("""
    SELECT o, c.name, p.productName 
    FROM Order o 
    JOIN o.customer c 
    JOIN o.orderItems oi 
    JOIN oi.product p 
    WHERE c.city = :city
    """)
List<Object[]> findOrdersWithCustomerAndProducts(@Param("city") String city);
```

### Q4: Native Query mein SQL Injection kaise prevent karte hain?

**Answer:**
```java
// ❌ WRONG - Vulnerable to SQL Injection
@Query(value = "SELECT * FROM users WHERE name = '" + name + "'", nativeQuery = true)

// ✅ CORRECT - Using parameters
@Query(value = "SELECT * FROM users WHERE name = :name", nativeQuery = true)
List<User> findByNameSafe(@Param("name") String name);

// ✅ CORRECT - Using positional parameters
@Query(value = "SELECT * FROM users WHERE name = ?1", nativeQuery = true)
List<User> findByNameSafe(String name);
```

### Q5: JPQL mein pagination kaise implement karte hain?

**Answer:**
```java
@Query("SELECT p FROM Product p WHERE p.category = :category ORDER BY p.price")
Page<Product> findByCategoryOrderByPrice(
    @Param("category") String category, 
    Pageable pageable
);

// Usage
Pageable pageable = PageRequest.of(0, 10, Sort.by("price").descending());
Page<Product> products = repository.findByCategoryOrderByPrice("Electronics", pageable);
```

---

## 🚫 Common Mistakes

### Mistake 1: Native Query mein entity name use karna

```java
❌ WRONG
@Query(value = "SELECT o FROM Order o WHERE o.status = :status", nativeQuery = true)

✅ CORRECT  
@Query(value = "SELECT * FROM orders WHERE order_status = :status", nativeQuery = true)
```

**Why Wrong:** Native query mein table names aur column names use karte hain, entity names nahi!

### Mistake 2: JPQL mein database-specific functions

```java
❌ WRONG
@Query("SELECT u FROM User u WHERE DATEDIFF(CURDATE(), u.birthDate) > 365")

✅ CORRECT
@Query("SELECT u FROM User u WHERE u.birthDate < :oneYearAgo")
// Parameter mein date calculate karke pass karo
```

**Why Wrong:** JPQL database-independent hona chahiye!

### Mistake 3: Result mapping bhoolna

```java
❌ WRONG - Return type mismatch
@Query(value = "SELECT user_name, email FROM users", nativeQuery = true)
List<User> findUserDetails(); // User entity expect kar raha hai but partial data aa rahi hai

✅ CORRECT - Proper DTO mapping
@Query(value = "SELECT user_name as userName, email FROM users", nativeQuery = true)
List<UserDetailsDTO> findUserDetails();
```

### Mistake 4: Parameter binding galat

```java
❌ WRONG
@Query("SELECT u FROM User u WHERE u.age > age") // Parameter missing

✅ CORRECT
@Query("SELECT u FROM User u WHERE u.age > :age")
List<User> findUsersByAge(@Param("age") int age);
```

---

## ✨ Best Practices

### Native Query Best Practices 🔧

#### 1️⃣ Always Use Parameters
```java
// ✅ Safe from SQL injection
@Query(value = """
    SELECT u.* FROM users u 
    WHERE u.city = :city 
    AND u.age BETWEEN :minAge AND :maxAge
    """, nativeQuery = true)
List<User> findUsersByCityAndAgeRange(
    @Param("city") String city,
    @Param("minAge") int minAge, 
    @Param("maxAge") int maxAge
);
```

#### 2️⃣ Proper Result Mapping for DTOs
```java
// ✅ Clean DTO mapping
public interface UserSummary {
    Long getId();
    String getName();
    String getEmail();
    Integer getOrderCount();
}

@Query(value = """
    SELECT u.id, u.name, u.email, COUNT(o.id) as orderCount
    FROM users u 
    LEFT JOIN orders o ON u.id = o.user_id
    GROUP BY u.id, u.name, u.email
    """, nativeQuery = true)
List<UserSummary> getUserSummaries();
```

#### 3️⃣ Database-specific Optimizations
```java
// ✅ Use database strengths
@Query(value = """
    SELECT /*+ INDEX(orders, idx_order_date) */ 
    o.* FROM orders o 
    WHERE o.order_date >= :startDate
    AND o.status IN ('PENDING', 'PROCESSING')
    """, nativeQuery = true)
List<Order> findRecentPendingOrders(@Param("startDate") LocalDate startDate);
```

### JPQL Best Practices 🎯

#### 1️⃣ Use Entity Relationships
```java
// ✅ Leverage JPA relationships
@Query("""
    SELECT o FROM Order o 
    JOIN FETCH o.customer 
    JOIN FETCH o.orderItems oi 
    JOIN FETCH oi.product 
    WHERE o.status = :status
    """)
List<Order> findOrdersWithDetailsJPQL(@Param("status") OrderStatus status);
```

#### 2️⃣ Efficient Pagination
```java
// ✅ Use Spring Data pagination
@Query("SELECT p FROM Product p WHERE p.category.name = :category")
Page<Product> findByCategory(@Param("category") String category, Pageable pageable);

// Usage with sorting
Pageable pageable = PageRequest.of(0, 20, Sort.by("price").descending());
```

#### 3️⃣ Constructor Expressions for DTOs
```java
// ✅ Direct DTO mapping in JPQL
@Query("""
    SELECT new com.example.dto.OrderSummaryDTO(
        o.id, 
        o.orderDate, 
        c.name, 
        SUM(oi.price * oi.quantity)
    )
    FROM Order o 
    JOIN o.customer c 
    JOIN o.orderItems oi 
    GROUP BY o.id, o.orderDate, c.name
    """)
List<OrderSummaryDTO> getOrderSummaries();
```

### Documentation Best Practices 📝

```java
/**
 * Fetches orders with complex business logic
 * 
 * Uses native query for performance optimization with database-specific features:
 * - Window functions for ranking
 * - Full-text search capabilities
 * - Database hints for query optimization
 * 
 * @param searchTerm Full-text search term
 * @param limit Maximum number of results
 * @return List of orders with calculated relevance scores
 */
@Query(value = """
    SELECT o.*, 
           ROW_NUMBER() OVER (ORDER BY o.order_total DESC) as rank,
           MATCH(p.name) AGAINST (:searchTerm) as relevance
    FROM orders o
    JOIN order_items oi ON o.id = oi.order_id
    JOIN products p ON oi.product_id = p.id
    WHERE MATCH(p.name) AGAINST (:searchTerm)
    LIMIT :limit
    """, nativeQuery = true)
List<Object[]> searchOrdersWithRanking(String searchTerm, int limit);
```

---

## 🎯 Summary/Quick Recap

### Key Takeaways 🔑

#### Native Query - Yaad Rakhne Ka Mantra 🧠
- **"Direct SQL, Direct Control"** - Database ke saath seedhi baat
- **"Power with Responsibility"** - Zyada power, zyada complexity
- **"When JPQL is not enough"** - Complex queries ke liye use karo

#### JPQL Query - Yaad Rakhne Ka Mantra 🧠  
- **"Entity First, Table Last"** - Hamesha entity names use karo
- **"Portable and Safe"** - Har database mein chalta hai
- **"Simple and Clean"** - Basic operations ke liye perfect

### When to Use What? 🤔

```
📊 Complex Reports + Performance = Native Query
🔄 Simple CRUD + Portability = JPQL Query
🚀 Database-specific features = Native Query  
🌐 Multi-database support = JPQL Query
```

### Memory Tricks 💡

1. **Native = Natural SQL** (Raw aur direct)
2. **JPQL = Java + SQL** (Object-oriented thinking)
3. **Native for Speed, JPQL for Need** 🏃‍♂️
4. **Complex = Native, Simple = JPQL** 

### Final Decision Matrix 🎯

| Your Requirement | Choose This |
|------------------|-------------|
| 🔥 Maximum Performance | Native Query |
| 🌍 Database Independence | JPQL Query |
| 📊 Complex Reporting | Native Query |
| 🎯 Simple Entity Operations | JPQL Query |
| 🛠️ Database-specific Features | Native Query |
| ⚡ Quick Development | JPQL Query |

---

## 🎉 Bonus Tips for Interviews!

### Tricky Questions Ke Answers 🎯

**Q: Performance mein kaun better hai?**
**A:** "Sir, Native Query generally faster hai kyunki direct SQL execute hota hai. JPQL mein translation overhead hota hai, but modern JPA implementations mein ye difference negligible hai for simple queries."

**Q: Production mein kya use karna chahiye?**
**A:** "Sir, depends on use case. Standard operations ke liye JPQL (maintainability), complex reporting ke liye Native Query (performance). Best practice hai ki 80% JPQL, 20% Native Query use karo."

**Q: Migration mein problem aayegi?**
**A:** "Native Query database-specific hai, so migration time pe rewrite karna padega. JPQL queries as-is chalti hain new database pe. That's why JPQL is preferred for long-term projects."

---

### 🎯 Pro Tips for Success!

1. **Practice Both**: Dono queries practice karo, interview mein dono puchte hain
2. **Real Examples**: Banking, E-commerce examples ready rakho  
3. **Performance Understanding**: Kab kaun use karna hai, clearly samjho
4. **Code Quality**: Clean, readable code likho interview mein

**Yaad rakho bhai:** Native Query aur JPQL dono important hain. Situation according use karo, dogmatic mat bano! 🚀

---

*Happy Coding! May your queries be fast and your data be consistent! 🎯✨*
