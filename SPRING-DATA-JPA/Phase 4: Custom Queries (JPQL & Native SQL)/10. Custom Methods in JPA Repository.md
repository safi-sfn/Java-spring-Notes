# 🚀 Spring Data JPA Custom Methods - Complete Study Notes

> **Bhai log, ye topic bohot important hai Spring Boot mein! JPA Repository mein custom methods add karna sikho** 💪

---

## 📖 1. Introduction - Confusion Ko Clear Karte Hain

### 🤔 Simple Explanation First
Yaar, JPA Repository ka basic concept ye hai - tumhe database ke saath interact karne ke liye khud se SQL queries nahi likhni padti. Spring Data JPA tumhare liye automatic queries banata hai!

### 🏠 Real-life Analogy
**Library Example:** 
- Tumhare paas ek library hai (Database)
- Librarian (JPA Repository) tumhare liye books dhundh deta hai
- Tumhe sirf book ka naam batana hai (Method name), librarian khud samjh jaata hai kya dhundhna hai! 📚

### 🔧 Technical Definition
**Spring Data JPA Repository** ek interface hai jo database operations ke liye pre-defined methods provide karta hai. **Custom methods** wo methods hain jo hum apni specific requirements ke liye banate hain using method naming conventions.

---

## 🎯 2. Key Terms/Concepts

| Term  | Technical Definition |
|------|---------------------|
| **JpaRepository** | Base interface jo CRUD operations provide karta hai |
| **Query Method** | Method names se automatic queries generate karna |
| **Entity** | Java class jo database table ko represent karta hai |
| **Repository** | Data access layer interface |
| **@Entity** | JPA annotation for marking entity classes |
| **findBy** | Query method prefix for SELECT operations |

### 🎨 Visual Representation
```
📦 Spring Data JPA Architecture
│
├── 🎯 Controller Layer (API endpoints)
│   └── Handles HTTP requests/responses
│
├── 🔧 Service Layer (Business logic)  
│   └── Processes data and business rules
│
├── 🗃️ Repository Layer (Data access)
│   └── Custom methods + JPA methods
│
└── 🗄️ Database Layer (H2/MySQL/PostgreSQL)
    └── Actual data storage
```

---

## 💻 3. Detailed Examples

### 📝 Complete Working Code Examples

#### **Step 1: Creating JPA Entity**
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Data                    // 🎯 Lombok: Auto generates getters, setters, toString
@Entity                  // 🎯 JPA: Marks this class as database table
@Table(name = "employees") // 🎯 Optional: Custom table name
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "emp_name", nullable = false)
    private String name;
    
    @Column(unique = true)  // 🎯 Email should be unique
    private String email;
    
    @Column(name = "mobile_number")
    private String mobileNo;
    
    private String department;
    private Double salary;
    
    // 🎯 Constructor for testing
    public Employee(String name, String email, String mobileNo) {
        this.name = name;
        this.email = email;
        this.mobileNo = mobileNo;
    }
}
```

#### **Step 2: Repository Interface with Custom Methods**
```java
package com.springjava.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.List;
import java.util.Optional;

public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // 🎯 METHOD 1: Find by single property
    List<Employee> findByName(String name);
    
    // 🎯 METHOD 2: Find by email (returns single object)
    Optional<Employee> findByEmail(String email);
    
    // 🎯 METHOD 3: Find by mobile number
    Employee findByMobileNo(String mobileNo);
    
    // 🎯 METHOD 4: Find by multiple properties (AND condition)
    List<Employee> findByNameAndDepartment(String name, String department);
    
    // 🎯 METHOD 5: Find by property with condition
    List<Employee> findBySalaryGreaterThan(Double salary);
    
    // 🎯 METHOD 6: Find with LIKE operation
    List<Employee> findByNameContaining(String namePart);
    
    // 🎯 METHOD 7: Find with ORDER BY
    List<Employee> findByDepartmentOrderBySalaryDesc(String department);
    
    // 🎯 METHOD 8: Count employees by department
    long countByDepartment(String department);
    
    // 🎯 METHOD 9: Check existence
    boolean existsByEmail(String email);
    
    // 🎯 METHOD 10: Custom JPQL Query
    @Query("SELECT e FROM Employee e WHERE e.salary BETWEEN :minSal AND :maxSal")
    List<Employee> findBySalaryRange(@Param("minSal") Double minSal, 
                                   @Param("maxSal") Double maxSal);
    
    // 🎯 METHOD 11: Native SQL Query
    @Query(value = "SELECT * FROM employees WHERE department = ?1 AND salary > ?2", 
           nativeQuery = true)
    List<Employee> findHighSalaryEmployeesByDept(String department, Double salary);
}
```

#### **Step 3: Service Implementation**
```java
package com.springjava.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;
import java.util.Optional;

@Service
public class EmployeeServiceImpl implements EmployeeService {
    
    @Autowired
    private EmployeeRepository empRepo;
    
    @Override
    public Employee saveEmployee(Employee employee) {
        // 🎯 Business logic: Check if email already exists
        if (empRepo.existsByEmail(employee.getEmail())) {
            throw new RuntimeException("Email already exists: " + employee.getEmail());
        }
        return empRepo.save(employee);
    }
    
    @Override
    public List<Employee> findByName(String name) {
        return empRepo.findByName(name);
    }
    
    @Override
    public Employee findByEmail(String email) {
        Optional<Employee> employee = empRepo.findByEmail(email);
        return employee.orElseThrow(() -> 
            new RuntimeException("Employee not found with email: " + email));
    }
    
    @Override
    public List<Employee> getHighSalaryEmployees(Double minSalary) {
        return empRepo.findBySalaryGreaterThan(minSalary);
    }
    
    @Override
    public List<Employee> searchEmployees(String searchTerm) {
        return empRepo.findByNameContaining(searchTerm);
    }
}
```

### 📊 Expected Outputs

```java
// 🎯 Testing the methods
public class RepositoryTest {
    
    @Autowired
    private EmployeeRepository empRepo;
    
    @Test
    public void testCustomMethods() {
        // 1. Save employees
        empRepo.save(new Employee("Rahul Sharma", "rahul@gmail.com", "9876543210"));
        empRepo.save(new Employee("Priya Singh", "priya@gmail.com", "9876543211"));
        
        // 2. Find by name
        List<Employee> employees = empRepo.findByName("Rahul Sharma");
        // Output: [Employee(id=1, name=Rahul Sharma, email=rahul@gmail.com)]
        
        // 3. Find by email  
        Optional<Employee> emp = empRepo.findByEmail("priya@gmail.com");
        // Output: Optional[Employee(id=2, name=Priya Singh, email=priya@gmail.com)]
        
        // 4. Count by department
        long count = empRepo.countByDepartment("IT");
        // Output: 5 (if 5 employees in IT department)
        
        // 5. Check existence
        boolean exists = empRepo.existsByEmail("rahul@gmail.com");
        // Output: true
    }
}
```

---

## 📋 4. Rules/Guidelines

### ✅ Correct Methods

**1. Method Naming Convention** ✅
```java
// ✅ CORRECT: Follow proper naming pattern
List<Employee> findByName(String name);
List<Employee> findByNameAndEmail(String name, String email);
List<Employee> findBySalaryGreaterThan(Double salary);
```

**2. Return Types** ✅
```java
// ✅ CORRECT: Use appropriate return types
List<Employee> findByDepartment(String dept);      // For multiple results
Employee findByEmail(String email);               // For single result (can be null)
Optional<Employee> findByMobileNo(String mobile); // For single result (safe)
```

**3. Parameter Matching** ✅
```java
// ✅ CORRECT: Parameters match property names
List<Employee> findByNameAndDepartment(String name, String department);
//                    ↑ matches 'name'     ↑ matches 'department' field
```

### ❌ Incorrect Methods

**1. Wrong Naming Convention** ❌
```java
// ❌ WRONG: Incorrect method names
List<Employee> getByName(String name);          // Should be 'findBy'
List<Employee> findName(String name);           // Missing 'By'
List<Employee> findByWrongProperty(String x);   // Property doesn't exist

// Error: No property 'wrongProperty' found for type 'Employee'
```

**2. Parameter Mismatch** ❌
```java
// ❌ WRONG: Parameter count/type mismatch
List<Employee> findByNameAndEmail(String name);  // Missing email parameter
List<Employee> findBySalary(String salary);      // Wrong type (should be Double)

// Error: Invalid number of arguments; expected 2 but found 1
```

**3. Invalid Return Types** ❌
```java
// ❌ WRONG: Invalid return types for operations
String findByEmail(String email);               // Should return Employee
int countByDepartment(String dept);            // Should return long

// Error: Invalid return type for query method
```

---

## 🌍 5. Real-world Applications

### 🏦 Banking System Example
```java
@Entity
public class Account {
    @Id
    private String accountNumber;
    private String customerName;
    private Double balance;
    private String accountType;
    private String branch;
}

@Repository
public interface AccountRepository extends JpaRepository<Account, String> {
    
    // 🏦 Find accounts by customer
    List<Account> findByCustomerName(String customerName);
    
    // 💰 Find high balance accounts
    List<Account> findByBalanceGreaterThanEqual(Double minBalance);
    
    // 🏢 Find accounts by branch and type
    List<Account> findByBranchAndAccountType(String branch, String accountType);
    
    // 💳 Find low balance accounts for alerts
    List<Account> findByBalanceLessThan(Double threshold);
    
    // 📊 Count accounts by type
    long countByAccountType(String accountType);
}
```

### 🛒 E-commerce System Example
```java
@Entity
public class Product {
    @Id
    private Long productId;
    private String productName;
    private String category;
    private Double price;
    private Integer stock;
    private String brand;
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // 🔍 Search products by name
    List<Product> findByProductNameContainingIgnoreCase(String searchTerm);
    
    // 💸 Find products in price range
    List<Product> findByPriceBetween(Double minPrice, Double maxPrice);
    
    // 📦 Find out of stock products
    List<Product> findByStockLessThan(Integer threshold);
    
    // 🏷️ Find products by category and brand
    List<Product> findByCategoryAndBrandOrderByPriceAsc(String category, String brand);
    
    // ⭐ Find premium products (high price)
    List<Product> findByPriceGreaterThanOrderByPriceDesc(Double priceThreshold);
}
```

---

## 📊 6. Comparison Tables

### Query Method vs JPQL vs Native SQL

| Feature | Query Method | JPQL | Native SQL |
|---------|-------------|------|------------|
| **Ease of Use** | ⭐⭐⭐⭐⭐ Very Easy | ⭐⭐⭐ Moderate | ⭐⭐ Complex |
| **Flexibility** | ⭐⭐ Limited | ⭐⭐⭐⭐ High | ⭐⭐⭐⭐⭐ Highest |
| **Database Independence** | ⭐⭐⭐⭐⭐ Full | ⭐⭐⭐⭐⭐ Full | ⭐ Database Specific |
| **Complex Queries** | ⭐ Very Limited | ⭐⭐⭐⭐ Good | ⭐⭐⭐⭐⭐ Best |
| **Maintenance** | ⭐⭐⭐⭐⭐ Easy | ⭐⭐⭐ Moderate | ⭐⭐ Difficult |

### Method Naming Keywords

| Keyword | Purpose | Example | Generated SQL |
|---------|---------|---------|---------------|
| `findBy` | SELECT query | `findByName(String name)` | `SELECT * FROM employee WHERE name = ?` |
| `countBy` | COUNT query | `countByDepartment(String dept)` | `SELECT COUNT(*) FROM employee WHERE department = ?` |
| `deleteBy` | DELETE query | `deleteByEmail(String email)` | `DELETE FROM employee WHERE email = ?` |
| `existsBy` | EXISTS check | `existsByMobileNo(String mobile)` | `SELECT COUNT(*) > 0 FROM employee WHERE mobile_no = ?` |

### Conditional Keywords

| Keyword | Meaning | Example |
|---------|---------|---------|
| `And` | AND condition | `findByNameAndEmail` |
| `Or` | OR condition | `findByNameOrEmail` |
| `Between` | BETWEEN values | `findBySalaryBetween` |
| `LessThan` | < condition | `findBySalaryLessThan` |
| `GreaterThan` | > condition | `findBySalaryGreaterThan` |
| `Like` | LIKE pattern | `findByNameLike` |
| `Containing` | LIKE %value% | `findByNameContaining` |
| `StartingWith` | LIKE value% | `findByNameStartingWith` |
| `EndingWith` | LIKE %value | `findByNameEndingWith` |
| `IgnoreCase` | Case insensitive | `findByNameIgnoreCase` |
| `OrderBy` | ORDER BY clause | `findByDepartmentOrderByName` |

---

## 🎤 7. Interview Questions

### **Q1: What is the difference between JpaRepository and CrudRepository?**
**Answer:**
```java
// CrudRepository - Basic CRUD operations
public interface CrudRepository<T, ID> {
    <S extends T> S save(S entity);
    Optional<T> findById(ID id);
    boolean existsById(ID id);
    Iterable<T> findAll();
    long count();
    void deleteById(ID id);
}

// JpaRepository - Extends CrudRepository + PagingAndSortingRepository
public interface JpaRepository<T, ID> extends PagingAndSortingRepository<T, ID>, CrudRepository<T, ID> {
    List<T> findAll();                    // Returns List instead of Iterable
    List<T> findAllById(Iterable<ID> ids);
    void flush();                         // Flush pending changes
    <S extends T> S saveAndFlush(S entity);
    void deleteInBatch(Iterable<T> entities);
}
```

### **Q2: How do query methods work internally?**
**Answer:**
```java
// When you write:
List<Employee> findByNameAndDepartment(String name, String department);

// Spring Data JPA creates a proxy that generates:
// SELECT e FROM Employee e WHERE e.name = ?1 AND e.department = ?2

// Implementation steps:
// 1. Parse method name
// 2. Extract property names (name, department)  
// 3. Extract conditions (And)
// 4. Generate JPQL query
// 5. Create Query object
// 6. Set parameters
// 7. Execute query
```

### **Q3: What happens if query method name is wrong?**
**Answer:**
```java
// ❌ Wrong property name
List<Employee> findByWrongProperty(String value);

// Error at startup:
// org.springframework.data.mapping.PropertyReferenceException: 
// No property wrongProperty found for type Employee!

// ✅ Correct approach
List<Employee> findByName(String name);  // 'name' property exists in Employee
```

### **Q4: How to handle null values in query methods?**
**Answer:**
```java
// ❌ Problem: Can return null
Employee findByEmail(String email);  // Returns null if not found

// ✅ Better: Use Optional
Optional<Employee> findByEmail(String email);  // Safe null handling

// Usage:
Optional<Employee> emp = repository.findByEmail("test@gmail.com");
if (emp.isPresent()) {
    // Employee found
    Employee employee = emp.get();
} else {
    // Employee not found
    throw new RuntimeException("Employee not found");
}
```

### **Q5: What is @Query annotation and when to use it?**
**Answer:**
```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // ✅ Use @Query for complex queries
    @Query("SELECT e FROM Employee e WHERE e.salary > :minSal AND e.department = :dept")
    List<Employee> findHighSalaryEmployees(@Param("minSal") Double minSal, 
                                         @Param("dept") String department);
    
    // ✅ Use @Query for calculations
    @Query("SELECT AVG(e.salary) FROM Employee e WHERE e.department = ?1")
    Double getAverageSalaryByDepartment(String department);
    
    // ✅ Use native queries for database-specific features
    @Query(value = "SELECT * FROM employees WHERE YEAR(created_date) = ?1", nativeQuery = true)
    List<Employee> findEmployeesByYear(int year);
}

// Use @Query when:
// 1. Query method name becomes too long
// 2. Need complex JOIN operations
// 3. Need aggregate functions (COUNT, SUM, AVG)
// 4. Need native SQL features
```

---

## ⚠️ 8. Common Mistakes

### **Mistake 1: Incorrect Method Naming**
```java
// ❌ WRONG
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    Employee getByEmail(String email);        // Should be 'findBy'
    Employee findEmail(String email);         // Missing 'By'
    Employee findByEmailAddress(String email); // Property name is 'email', not 'emailAddress'
}

// ✅ CORRECT
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    Employee findByEmail(String email);       // Follows correct naming convention
}
```

### **Mistake 2: Parameter Count Mismatch**
```java
// ❌ WRONG
List<Employee> findByNameAndDepartment(String name); // Missing department parameter

// Error: Invalid number of arguments for method findByNameAndDepartment

// ✅ CORRECT  
List<Employee> findByNameAndDepartment(String name, String department);
```

### **Mistake 3: Wrong Return Types**
```java
// ❌ WRONG
String findByEmail(String email);           // Should return Employee/Optional<Employee>
int countByDepartment(String department);   // Should return long

// ✅ CORRECT
Optional<Employee> findByEmail(String email);
long countByDepartment(String department);
```

### **Mistake 4: Not Handling Null Values**
```java
// ❌ WRONG - Can throw NullPointerException
Employee emp = repository.findByEmail("nonexistent@email.com");
String name = emp.getName(); // NPE if employee not found

// ✅ CORRECT - Safe handling
Optional<Employee> empOpt = repository.findByEmail("test@email.com");
if (empOpt.isPresent()) {
    String name = empOpt.get().getName();
}
```

### **Mistake 5: Forgetting @Repository Annotation**
```java
// ❌ WRONG - Missing @Repository (though not always required)
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    List<Employee> findByName(String name);
}

// ✅ BETTER - Explicit @Repository annotation
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    List<Employee> findByName(String name);
}
```

---

## 💎 9. Best Practices

### **1. Use Optional for Single Results** 🛡️
```java
// ✅ BEST PRACTICE: Null-safe approach
Optional<Employee> findByEmail(String email);

// Usage:
Employee employee = employeeRepository.findByEmail(email)
    .orElseThrow(() -> new EntityNotFoundException("Employee not found"));
```

### **2. Keep Method Names Readable** 📖
```java
// ❌ Avoid: Too long method names
List<Employee> findByNameAndDepartmentAndSalaryGreaterThanAndEmailContaining(
    String name, String dept, Double salary, String emailPart);

// ✅ BETTER: Use @Query for complex scenarios
@Query("SELECT e FROM Employee e WHERE e.name = :name AND e.department = :dept " +
       "AND e.salary > :salary AND e.email LIKE %:emailPart%")
List<Employee> findComplexEmployeeQuery(@Param("name") String name,
                                      @Param("dept") String department,
                                      @Param("salary") Double salary,
                                      @Param("emailPart") String emailPart);
```

### **3. Use Proper Naming Conventions** 🎯
```java
// ✅ GOOD: Clear, descriptive names
List<Employee> findByDepartment(String department);
List<Employee> findBySalaryGreaterThan(Double minSalary);
boolean existsByEmail(String email);
long countByActiveStatus(boolean active);
```

### **4. Handle Large Result Sets** 📊
```java
// ✅ Use Pageable for large datasets
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Page;

Page<Employee> findByDepartment(String department, Pageable pageable);

// Usage:
Pageable pageable = PageRequest.of(0, 20); // Page 0, Size 20
Page<Employee> employees = repository.findByDepartment("IT", pageable);
```

### **5. Add Validation in Service Layer** ✅
```java
@Service
public class EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    public Employee createEmployee(Employee employee) {
        // ✅ Validation before saving
        if (employee.getName() == null || employee.getName().trim().isEmpty()) {
            throw new IllegalArgumentException("Name cannot be empty");
        }
        
        if (employeeRepository.existsByEmail(employee.getEmail())) {
            throw new DuplicateEmailException("Email already exists");
        }
        
        return employeeRepository.save(employee);
    }
}
```

### **6. Use Proper Exception Handling** 🛡️
```java
@RestController
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    @GetMapping("/employee/{email}")
    public ResponseEntity<Employee> getEmployee(@PathVariable String email) {
        try {
            Employee employee = employeeService.findByEmail(email);
            return ResponseEntity.ok(employee);
        } catch (EntityNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (Exception e) {
            return ResponseEntity.status(500).build();
        }
    }
}
```

---

## 📝 10. Summary/Quick Recap

### 🎯 Key Takeaways

#### **Method Naming Pattern** 🔤
```
findBy + PropertyName + Condition + OrderBy + PropertyName
│       │              │           │         │
│       │              │           │         └── Sort field
│       │              │           └── Optional sorting
│       │              └── Optional condition (GreaterThan, Like, etc.)
│       └── Entity property name (exact match)
└── Query type (find, count, delete, exists)
```

#### **Common Patterns** 📋
```java
// Basic patterns har developer ko yaad hona chahiye:
findBy{PropertyName}                    // Equal condition
findBy{Property}And{Property}           // Multiple conditions
findBy{Property}GreaterThan             // Comparison
findBy{Property}Containing              // Like search  
findBy{Property}OrderBy{Property}Asc    // With sorting
countBy{Property}                       // Count records
existsBy{Property}                      // Check existence
deleteBy{Property}                      // Delete records
```

#### **Memory Tricks** 🧠
1. **"Find Buy Property"** - findBy + property name
2. **"And/Or for Multiple"** - Use And/Or for multiple conditions  
3. **"Greater/Less for Numbers"** - Use comparison keywords for numeric fields
4. **"Containing for Search"** - Use Containing for text search
5. **"Optional for Safety"** - Use Optional<> for single results

#### **When to Use What** 🤔

| Use Case | Solution | Example |
|----------|----------|---------|
| Simple property search | Query method | `findByName(String name)` |
| Multiple conditions | Query method with And/Or | `findByNameAndDepartment()` |
| Complex queries | @Query with JPQL | `@Query("SELECT ... JOIN ...")` |
| Database-specific features | @Query with native SQL | `@Query(value="...", nativeQuery=true)` |
| Large datasets | Pageable | `findByDepartment(String, Pageable)` |

### 🚨 **Final Tips for Success**

**✅ DO:**
- Follow proper method naming conventions
- Use Optional for single results  
- Add proper validation in service layer
- Handle exceptions gracefully
- Use @Query for complex scenarios
- Test your repository methods

**❌ DON'T:**
- Ignore null value handling
- Create very long method names  
- Mix business logic in repository
- Forget to handle exceptions
- Use repository directly in controller
- Skip parameter validation

### 🎉 **Congratulations Bhai!**
Ab tumhe Spring Data JPA custom methods ke baare mein sab kuch pata hai! Practice karte raho aur interviews mein confidence se answer do! 💪

---

**Happy Coding! 🚀**

*Made with ❤️ for Java developers by Java developers*
