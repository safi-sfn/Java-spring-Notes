# üöÄ Spring Data JPA Native Queries - Complete Guide 

**Bhai, agar tumhe SQL pasand hai aur JPA Repository mein complex queries likhni hain, toh ye topic tumhare liye perfect hai!** üí™

---

## ü§î Introduction - Confusion Clear Karte Hain

### Simple Explanation First üìù
Yaar, **Native Query** matlab plain SQL query jo directly database pe run hoti hai. Jab JPA Repository mein @Query annotation use karte hain aur `nativeQuery = true` set karte hain, tab hum raw SQL likh sakte hain!

### Real-Life Analogy üè†
Socho tumhe kisi se baat karni hai:
- **JPQL** = Hindi/English mein baat karna (JPA samjh jaata hai aur translate karta hai)
- **Native Query** = Directly unki local language mein baat karna (Database ki actual language - SQL)

### Technical Definition üíª
Native Query is a plain SQL query that is executed directly against the database without any JPA abstraction layer. It uses actual table names and column names instead of entity names and properties.

---

## üìö Key Terms/Concepts

| Term | Hindi Meaning | Technical Definition |
|------|---------------|---------------------|
| **Native Query** | ‡§Æ‡•Ç‡§≤ ‡§ï‡•ç‡§µ‡•á‡§∞‡•Ä | Direct SQL query without JPA abstraction |
| **@Query** | ‡§ï‡•ç‡§µ‡•á‡§∞‡•Ä ‡§è‡§®‡•ã‡§ü‡•á‡§∂‡§® | Annotation to define custom queries |
| **nativeQuery = true** | ‡§Æ‡•Ç‡§≤ ‡§ï‡•ç‡§µ‡•á‡§∞‡•Ä ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø | Parameter to enable native SQL |
| **Positional Parameter** | ‡§∏‡•ç‡§•‡§ø‡§§‡§ø‡§ó‡§§ ‡§™‡•à‡§∞‡§æ‡§Æ‡•Ä‡§ü‡§∞ | Parameters using ?1, ?2 format |
| **Named Parameter** | ‡§®‡§æ‡§Æ‡§ø‡§§ ‡§™‡•à‡§∞‡§æ‡§Æ‡•Ä‡§ü‡§∞ | Parameters using :paramName format |
| **JPQL** | JPA ‡§ï‡•ç‡§µ‡•á‡§∞‡•Ä ‡§≠‡§æ‡§∑‡§æ | Object-oriented query language |

---

## üí° JPQL vs Native Query - Samjho Bhai!

### JPQL (Java Persistence Query Language)
```java
// Entity class name aur properties use karte hain
@Query("SELECT e FROM Employee e WHERE e.email = ?1")
List<Employee> findByEmail(String email);
```

### Native Query 
```java
// Table name aur column names use karte hain
@Query(value = "SELECT * FROM employee WHERE email = ?1", nativeQuery = true)
List<Employee> findByEmail(String email);
```

### Comparison Table üìä

| Aspect | JPQL | Native Query |
|--------|------|--------------|
| **Syntax** | Object-oriented | Pure SQL |
| **Table Names** | Entity class names | Actual database table names |
| **Column Names** | Entity properties | Actual database columns |
| **Database Specific** | ‚ùå Portable | ‚úÖ Database specific |
| **Complex Queries** | ‚ùå Limited | ‚úÖ Full SQL power |
| **Performance** | üêå Slower | üöÄ Faster |
| **Maintenance** | ‚úÖ Easy | ‚ùå Database dependent |

---

## üî• Complete Working Example

### Step 1: Entity Class üèóÔ∏è
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name = "employee") // Table name specify kar sakte hain
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "emp_name") // Column name different ho sakta hai
    private String name;
    
    private String email;
    
    @Column(name = "mobile_no")
    private String mobileNo;
    
    private String department;
    private Double salary;
}
```

### Step 2: Repository with Native Queries üóÉÔ∏è
```java
package com.springjava.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.List;

public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // 1. Simple SELECT query
    @Query(value = "SELECT * FROM employee", nativeQuery = true)
    List<Employee> findAllEmployees();
    
    // 2. Positional Parameter (?1, ?2)
    @Query(value = "SELECT * FROM employee WHERE email = ?1", nativeQuery = true)
    Employee findByEmail(String email);
    
    // 3. Named Parameter (:paramName)
    @Query(value = "SELECT * FROM employee WHERE mobile_no = :mobileNo", nativeQuery = true)
    Employee findByMobileNo(@Param("mobileNo") String mobileNo);
    
    // 4. Multiple parameters - Mixed approach
    @Query(value = "SELECT * FROM employee WHERE department = ?1 AND salary > :minSalary", 
           nativeQuery = true)
    List<Employee> findByDepartmentAndSalary(String department, @Param("minSalary") Double minSalary);
    
    // 5. Complex JOIN query
    @Query(value = """
        SELECT e.*, d.dept_name 
        FROM employee e 
        JOIN department d ON e.department = d.dept_code 
        WHERE e.salary BETWEEN :minSal AND :maxSal
        """, nativeQuery = true)
    List<Object[]> findEmployeesWithDepartmentBySalaryRange(
        @Param("minSal") Double minSalary, 
        @Param("maxSal") Double maxSalary);
    
    // 6. Aggregate functions
    @Query(value = "SELECT department, COUNT(*), AVG(salary) FROM employee GROUP BY department", 
           nativeQuery = true)
    List<Object[]> getDepartmentStats();
    
    // 7. Custom result mapping
    @Query(value = "SELECT emp_name as name, email, mobile_no as phone FROM employee WHERE department = ?1", 
           nativeQuery = true)
    List<EmployeeDTO> findEmployeeDTOByDepartment(String department);
}
```

### Step 3: Service Implementation üõ†Ô∏è
```java
package com.springjava.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    public List<Employee> getAllEmployees() {
        return employeeRepository.findAllEmployees();
    }
    
    public Employee getEmployeeByEmail(String email) {
        Employee emp = employeeRepository.findByEmail(email);
        if (emp == null) {
            throw new RuntimeException("Employee nahi mila bhai: " + email);
        }
        return emp;
    }
    
    public List<Employee> getHighSalaryEmployees(String department, Double minSalary) {
        return employeeRepository.findByDepartmentAndSalary(department, minSalary);
    }
}
```

### Step 4: REST Controller üéÆ
```java
package com.springjava.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/api/employees")
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    @GetMapping("/all")
    public ResponseEntity<List<Employee>> getAllEmployees() {
        List<Employee> employees = employeeService.getAllEmployees();
        return ResponseEntity.ok(employees);
    }
    
    @GetMapping("/by-email/{email}")
    public ResponseEntity<Employee> getByEmail(@PathVariable String email) {
        try {
            Employee employee = employeeService.getEmployeeByEmail(email);
            return ResponseEntity.ok(employee);
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }
    
    @GetMapping("/high-salary")
    public ResponseEntity<List<Employee>> getHighSalaryEmployees(
            @RequestParam String department,
            @RequestParam Double minSalary) {
        List<Employee> employees = employeeService.getHighSalaryEmployees(department, minSalary);
        return ResponseEntity.ok(employees);
    }
}
```

---

## ‚ö° Parameter Binding - Dono Tarike Seekho!

### 1. Positional Parameters (? style) üéØ
```java
// Single parameter
@Query(value = "SELECT * FROM employee WHERE email = ?1", nativeQuery = true)
Employee findByEmail(String email);

// Multiple parameters - Order important hai!
@Query(value = "SELECT * FROM employee WHERE department = ?1 AND salary > ?2", nativeQuery = true)
List<Employee> findByDeptAndSalary(String dept, Double salary);

// ‚úÖ Correct usage
Employee emp = repo.findByDeptAndSalary("IT", 50000.0);

// ‚ùå Wrong - Order change mat karo!
Employee emp = repo.findByDeptAndSalary(50000.0, "IT"); // Error aayega!
```

### 2. Named Parameters (: style) üè∑Ô∏è
```java
// Single named parameter
@Query(value = "SELECT * FROM employee WHERE mobile_no = :phoneNumber", nativeQuery = true)
Employee findByPhone(@Param("phoneNumber") String mobile);

// Multiple named parameters - Order doesn't matter!
@Query(value = "SELECT * FROM employee WHERE department = :dept AND salary > :minSal", 
       nativeQuery = true)
List<Employee> findByDeptAndSalary(@Param("dept") String department, 
                                   @Param("minSal") Double salary);

// ‚úÖ Correct usage - Any order
List<Employee> emps = repo.findByDeptAndSalary("IT", 50000.0);
List<Employee> emps2 = repo.findByDeptAndSalary(salary = 50000.0, department = "IT");
```

### 3. Mixed Parameters (Recommended for complex queries) üé≠
```java
@Query(value = """
    SELECT * FROM employee 
    WHERE department = ?1 
    AND salary BETWEEN :minSal AND :maxSal 
    AND email LIKE %?2%
    """, nativeQuery = true)
List<Employee> complexSearch(String dept, String emailPattern, 
                           @Param("minSal") Double min, @Param("maxSal") Double max);
```

---

## üìã Rules/Guidelines - Yaad Rakhne Wale!

### Rule 1: nativeQuery = true Always Set Karo ‚úÖ
```java
// ‚úÖ Correct
@Query(value = "SELECT * FROM employee", nativeQuery = true)
List<Employee> findAll();

// ‚ùå Wrong - ye JPQL ban jaayega!
@Query(value = "SELECT * FROM employee")
List<Employee> findAll();
// Error: org.hibernate.hql.internal.ast.QuerySyntaxException
```

### Rule 2: Table Names aur Column Names Exact Match Hone Chahiye ‚úÖ
```java
// Database mein table name: employee
// Database mein column name: mobile_no

// ‚úÖ Correct
@Query(value = "SELECT * FROM employee WHERE mobile_no = ?1", nativeQuery = true)
Employee findByMobile(String mobile);

// ‚ùå Wrong - Entity property name use nahi karna!
@Query(value = "SELECT * FROM employee WHERE mobileNo = ?1", nativeQuery = true)
Employee findByMobile(String mobile);
// Error: SQLSyntaxErrorException: Column "mobileNo" not found
```

### Rule 3: @Param Annotation Named Parameters ke Saath Mandatory ‚úÖ
```java
// ‚úÖ Correct
@Query(value = "SELECT * FROM employee WHERE email = :userEmail", nativeQuery = true)
Employee findByEmail(@Param("userEmail") String email);

// ‚ùå Wrong - @Param missing!
@Query(value = "SELECT * FROM employee WHERE email = :userEmail", nativeQuery = true)
Employee findByEmail(String email);
// Error: NamedParameterValidatingStatementInspector
```

### Rule 4: Return Type Properly Define Karo ‚úÖ
```java
// ‚úÖ Correct - Entity return
@Query(value = "SELECT * FROM employee WHERE id = ?1", nativeQuery = true)
Employee findById(Long id);

// ‚úÖ Correct - Specific columns ke liye Object[]
@Query(value = "SELECT emp_name, email FROM employee", nativeQuery = true)
List<Object[]> getNameAndEmail();

// ‚úÖ Correct - Count queries ke liye Integer/Long
@Query(value = "SELECT COUNT(*) FROM employee", nativeQuery = true)
Long countEmployees();

// ‚ùå Wrong - Partial columns ke liye Entity
@Query(value = "SELECT emp_name, email FROM employee", nativeQuery = true)
List<Employee> getPartialData(); // Only name aur email populate honge, baaki null!
```

### Rule 5: Complex Queries ke Liye Text Blocks Use Karo ‚úÖ
```java
// ‚úÖ Correct - Readable hai!
@Query(value = """
    SELECT e.emp_name, e.email, d.dept_name, e.salary
    FROM employee e
    JOIN department d ON e.department = d.dept_code
    WHERE e.salary > :minSalary
    ORDER BY e.salary DESC
    """, nativeQuery = true)
List<Object[]> getEmployeeDetails(@Param("minSalary") Double minSalary);

// ‚ùå Avoid - Single line mein difficult hai!
@Query(value = "SELECT e.emp_name, e.email, d.dept_name, e.salary FROM employee e JOIN department d ON e.department = d.dept_code WHERE e.salary > :minSalary ORDER BY e.salary DESC", nativeQuery = true)
List<Object[]> getEmployeeDetails(@Param("minSalary") Double minSalary);
```

---

## üåç Real-World Applications

### 1. Banking System Example üè¶
```java
@Entity
public class BankTransaction {
    @Id
    private String transactionId;
    private String accountNumber;
    private Double amount;
    private String transactionType; // CREDIT, DEBIT
    private LocalDateTime transactionDate;
}

@Repository
public interface TransactionRepository extends JpaRepository<BankTransaction, String> {
    
    // Monthly statement
    @Query(value = """
        SELECT * FROM bank_transaction 
        WHERE account_number = :accNum 
        AND transaction_date BETWEEN :startDate AND :endDate 
        ORDER BY transaction_date DESC
        """, nativeQuery = true)
    List<BankTransaction> getMonthlyStatement(
        @Param("accNum") String accountNumber,
        @Param("startDate") LocalDateTime start,
        @Param("endDate") LocalDateTime end);
    
    // Account balance calculation
    @Query(value = """
        SELECT 
            SUM(CASE WHEN transaction_type = 'CREDIT' THEN amount ELSE 0 END) - 
            SUM(CASE WHEN transaction_type = 'DEBIT' THEN amount ELSE 0 END) as balance
        FROM bank_transaction 
        WHERE account_number = ?1
        """, nativeQuery = true)
    Double getCurrentBalance(String accountNumber);
    
    // Fraud detection - High amount transactions
    @Query(value = """
        SELECT * FROM bank_transaction 
        WHERE amount > :threshold 
        AND transaction_date > NOW() - INTERVAL 24 HOUR
        ORDER BY amount DESC
        """, nativeQuery = true)
    List<BankTransaction> getHighAmountTransactions(@Param("threshold") Double threshold);
}
```

### 2. E-commerce Analytics üõí
```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // Top selling products
    @Query(value = """
        SELECT p.product_name, SUM(oi.quantity) as total_sold, SUM(oi.price * oi.quantity) as revenue
        FROM order_item oi
        JOIN product p ON oi.product_id = p.id
        JOIN orders o ON oi.order_id = o.id
        WHERE o.order_date >= :startDate
        GROUP BY p.product_name
        ORDER BY total_sold DESC
        LIMIT 10
        """, nativeQuery = true)
    List<Object[]> getTopSellingProducts(@Param("startDate") LocalDate startDate);
    
    // Customer purchase behavior
    @Query(value = """
        SELECT 
            c.customer_name,
            COUNT(o.id) as total_orders,
            SUM(o.total_amount) as total_spent,
            AVG(o.total_amount) as avg_order_value
        FROM customer c
        LEFT JOIN orders o ON c.id = o.customer_id
        WHERE o.order_date >= :fromDate
        GROUP BY c.id, c.customer_name
        HAVING total_spent > :minSpent
        ORDER BY total_spent DESC
        """, nativeQuery = true)
    List<Object[]> getCustomerAnalytics(@Param("fromDate") LocalDate fromDate, 
                                       @Param("minSpent") Double minSpent);
}
```

### 3. HR Management System üë•
```java
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // Department wise salary statistics
    @Query(value = """
        SELECT 
            department,
            COUNT(*) as emp_count,
            MIN(salary) as min_salary,
            MAX(salary) as max_salary,
            AVG(salary) as avg_salary,
            SUM(salary) as total_salary_cost
        FROM employee 
        WHERE is_active = 1
        GROUP BY department
        ORDER BY avg_salary DESC
        """, nativeQuery = true)
    List<Object[]> getDepartmentSalaryStats();
    
    // Employees due for appraisal
    @Query(value = """
        SELECT * FROM employee 
        WHERE DATEDIFF(NOW(), last_appraisal_date) >= 365 
        AND is_active = 1
        ORDER BY last_appraisal_date ASC
        """, nativeQuery = true)
    List<Employee> getEmployeesDueForAppraisal();
    
    // Experience based employee distribution
    @Query(value = """
        SELECT 
            CASE 
                WHEN DATEDIFF(NOW(), joining_date) < 365 THEN 'Fresher'
                WHEN DATEDIFF(NOW(), joining_date) BETWEEN 365 AND 1825 THEN 'Experienced'
                ELSE 'Senior'
            END as experience_level,
            COUNT(*) as count
        FROM employee 
        WHERE is_active = 1
        GROUP BY experience_level
        """, nativeQuery = true)
    List<Object[]> getExperienceDistribution();
}
```

---

## üìä Comparison Table - JPQL vs Native Query

| Feature | JPQL | Native Query | Winner | Reason |
|---------|------|--------------|--------|---------|
| **Learning Curve** | Easy | Medium | JPQL | Java developers ke liye familiar |
| **Database Portability** | ‚úÖ High | ‚ùå Low | JPQL | Database change karne pe code same |
| **Performance** | Good | Excellent | Native | Direct SQL execution |
| **Complex Queries** | Limited | Full Power | Native | Joins, subqueries, functions sab |
| **Stored Procedures** | ‚ùå No | ‚úÖ Yes | Native | Business logic database mein |
| **Database Features** | Generic | Specific | Native | Window functions, JSON queries etc. |
| **Maintenance** | Easy | Difficult | JPQL | Schema changes handle automatically |
| **Testing** | Easy | Difficult | JPQL | Database independent testing |

---

## üéØ Interview Questions & Answers

### Q1: Native Query kya hai aur kab use karte hain?
**Answer:**
```java
// Native Query example
@Query(value = "SELECT * FROM employee WHERE salary > ?1", nativeQuery = true)
List<Employee> findHighSalaryEmployees(Double salary);

// Use Cases:
// 1. Complex joins with multiple tables
// 2. Database-specific functions (JSON_EXTRACT, REGEXP, etc.)
// 3. Performance optimization for specific queries
// 4. Legacy database integration
// 5. Stored procedure calls
```

### Q2: Positional aur Named parameters mein difference?
**Answer:**
```java
// Positional Parameters - Order matters
@Query(value = "SELECT * FROM employee WHERE name = ?1 AND email = ?2", nativeQuery = true)
Employee findByNameAndEmail(String name, String email);

// Named Parameters - Order doesn't matter
@Query(value = "SELECT * FROM employee WHERE name = :empName AND email = :empEmail", 
       nativeQuery = true)
Employee findByNameAndEmail(@Param("empName") String name, 
                           @Param("empEmail") String email);

// Named parameters zyada readable aur maintainable hain!
```

### Q3: Native Query mein Object[] kab use karte hain?
**Answer:**
```java
// Jab specific columns chahiye, complete entity nahi
@Query(value = "SELECT emp_name, salary, department FROM employee", nativeQuery = true)
List<Object[]> getEmployeeSummary();

// Usage:
List<Object[]> results = repository.getEmployeeSummary();
for (Object[] row : results) {
    String name = (String) row[0];
    Double salary = (Double) row[1];
    String dept = (String) row[2];
}

// Better approach - DTO use karo
@Query(value = "SELECT emp_name as name, salary, department as dept FROM employee", 
       nativeQuery = true)
List<EmployeeSummaryDTO> getEmployeeSummaryDTO();
```

### Q4: Native Query mein error handling kaise kare?
**Answer:**
```java
@Service
public class EmployeeService {
    
    public Employee findByEmail(String email) {
        try {
            return employeeRepository.findByEmail(email);
        } catch (DataAccessException e) {
            // SQL errors
            log.error("Database error while finding employee: {}", e.getMessage());
            throw new ServiceException("Employee search failed", e);
        } catch (Exception e) {
            // Other errors
            log.error("Unexpected error: {}", e.getMessage());
            throw new ServiceException("Service unavailable", e);
        }
    }
}
```

### Q5: Native Query mein pagination kaise implement kare?
**Answer:**
```java
// Method 1: Manual LIMIT OFFSET
@Query(value = "SELECT * FROM employee ORDER BY id LIMIT :limit OFFSET :offset", 
       nativeQuery = true)
List<Employee> findEmployeesWithPagination(@Param("limit") int limit, 
                                          @Param("offset") int offset);

// Method 2: Spring Pageable use karo (Recommended)
@Query(value = "SELECT * FROM employee", 
       countQuery = "SELECT COUNT(*) FROM employee",
       nativeQuery = true)
Page<Employee> findAllEmployees(Pageable pageable);

// Usage:
Pageable pageable = PageRequest.of(0, 10, Sort.by("salary").descending());
Page<Employee> employees = repository.findAllEmployees(pageable);
```

---

## ‚ùå Common Mistakes - Inse Bacho!

### Mistake 1: Entity Property Names Use Karna
```java
// ‚ùå Wrong - Entity property name use kiya
@Query(value = "SELECT * FROM employee WHERE mobileNo = ?1", nativeQuery = true)
Employee findByMobile(String mobile);
// Error: Unknown column 'mobileNo'

// ‚úÖ Correct - Database column name use karo
@Query(value = "SELECT * FROM employee WHERE mobile_no = ?1", nativeQuery = true)
Employee findByMobile(String mobile);
```

### Mistake 2: @Param Annotation Bhoolna
```java
// ‚ùå Wrong - @Param missing
@Query(value = "SELECT * FROM employee WHERE email = :emailId", nativeQuery = true)
Employee findByEmail(String email);

// ‚úÖ Correct
@Query(value = "SELECT * FROM employee WHERE email = :emailId", nativeQuery = true)
Employee findByEmail(@Param("emailId") String email);
```

### Mistake 3: Return Type Mismatch
```java
// ‚ùå Wrong - Partial columns ke liye Entity return
@Query(value = "SELECT emp_name FROM employee", nativeQuery = true)
List<Employee> getNames(); // Sirf name populate hoga, baaki null!

// ‚úÖ Correct - Proper return type
@Query(value = "SELECT emp_name FROM employee", nativeQuery = true)
List<String> getNames();
```

### Mistake 4: SQL Injection Vulnerability
```java
// ‚ùå Wrong - String concatenation
public List<Employee> searchEmployees(String searchTerm) {
    String sql = "SELECT * FROM employee WHERE name LIKE '%" + searchTerm + "%'";
    // SQL Injection possible!
}

// ‚úÖ Correct - Parameters use karo
@Query(value = "SELECT * FROM employee WHERE name LIKE CONCAT('%', :searchTerm, '%')", 
       nativeQuery = true)
List<Employee> searchEmployees(@Param("searchTerm") String searchTerm);
```

### Mistake 5: Exception Handling Nahi Karna
```java
// ‚ùå Wrong - No error handling
public Employee getEmployee(String email) {
    return employeeRepository.findByEmail(email); // Null return ho sakta hai!
}

// ‚úÖ Correct - Proper handling
public Employee getEmployee(String email) {
    Employee emp = employeeRepository.findByEmail(email);
    if (emp == null) {
        throw new EntityNotFoundException("Employee not found: " + email);
    }
    return emp;
}
```

---

## üèÜ Best Practices

### 1. Readable Query Formatting üìñ
```java
// ‚úÖ Good - Multi-line with proper indentation
@Query(value = """
    SELECT 
        e.emp_name,
        e.email,
        d.dept_name,
        e.salary
    FROM employee e
    JOIN department d ON e.department = d.dept_code
    WHERE e.salary > :minSalary
    ORDER BY e.salary DESC
    """, nativeQuery = true)
List<Object[]> getEmployeeDetails(@Param("minSalary") Double minSalary);
```

### 2. Performance Optimization ‚ö°
```java
// Index-friendly queries
@Query(value = """
    SELECT * FROM employee 
    WHERE email = :email 
    AND is_active = 1
    """, nativeQuery = true)
Employee findActiveEmployeeByEmail(@Param("email") String email);

// Use EXPLAIN PLAN for query optimization
// MySQL: EXPLAIN SELECT * FROM employee WHERE email = 'test@example.com';
```

### 3. Error Handling Strategy üõ°Ô∏è
```java
@Service
public class EmployeeService {
    
    @Transactional(readOnly = true)
    public List<Employee> searchEmployees(String searchCriteria) {
        try {
            return employeeRepository.searchEmployees(searchCriteria);
        } catch (DataAccessException e) {
            log.error("Database error during employee search: {}", e.getMessage());
            throw new ServiceException("Search operation failed", e);
        }
    }
}
```

### 4. Documentation aur Comments üìù
```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    /**
     * Find employees by department with salary above threshold
     * 
     * @param department Department code (IT, HR, FIN, etc.)
     * @param minSalary Minimum salary threshold
     * @return List of employees matching criteria
     * 
     * Performance Note: Uses index on (department, salary) for optimal performance
     * Database Note: Works with MySQL 5.7+ and PostgreSQL 10+
     */
    @Query(value = """
        SELECT * FROM employee 
        WHERE department = :dept 
        AND salary >= :minSal 
        AND is_active = 1
        ORDER BY salary DESC
        """, nativeQuery = true)
    List<Employee> findByDepartmentAndMinSalary(
        @Param("dept") String department, 
        @Param("minSal") Double minSalary);
}
```

### 5. Testing Strategy üß™
```java
@DataJpaTest
class EmployeeRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    @Test
    void testFindByEmail() {
        // Given
        Employee employee = new Employee();
        employee.setName("Test User");
        employee.setEmail("test@example.com");
        entityManager.persistAndFlush(employee);
        
        // When
        Employee found = employeeRepository.findByEmail("test@example.com");
        
        // Then
        assertThat(found).isNotNull();
        assertThat(found.getName()).isEqualTo("Test User");
    }
    
    @Test
    void testFindByEmailNotFound() {
        // When
        Employee found = employeeRepository.findByEmail("nonexistent@example.com");
        
        // Then
        assertThat(found).isNull();
    }
}
```

---

## üìù Summary/Quick Recap

### üéØ Key Takeaways - Yaad Rakhne Ke Points

1. **Native Query = Direct SQL** üéØ
   - `nativeQuery = true` lagana mandatory hai
   - Database table aur column names use karte hain

2. **Parameter Binding** üè∑Ô∏è
   - Positional: `?1, ?2` (order matters)
   - Named: `:paramName` (readable, order doesn't matter)

3. **Performance Winner** üöÄ
   - Native queries faster hain JPQL se
   - Complex operations ke liye perfect

4. **Common Pitfalls** ‚ö†Ô∏è
   - Entity properties use mat karo
   - @Param annotation bhoolna nahi
   - SQL injection se baco

5. **Best Use Cases** üí°
   - Complex joins aur aggregations
   - Database-specific functions
   - Performance critical queries
   - Legacy database integration

### üß† Memory Tricks

**"Native Query = SQL Direct, JPQL = ORM Indirect"** üé≠

**Parameter Types:**
- **?** = **Question** = Position important hai
- **:** = **Colon** = Name important hai

**Return Types:**
- Complete columns = Entity
- Partial columns = Object[] ya DTO
- Single value = Primitive type

# ====================================================================================================


# üèÜ Spring Data JPA Native Query - Complete Study Notes üöÄ

---

## üéØ 1. Introduction with Confusion Clearing

### Simple Explanation First üí°
**Bhai, simple words mein samjho** - Native Query matlab plain SQL query hai jo database mein directly run hoti hai! 

Native Query = Raw SQL queries jinhe hum direct database par execute karte hain, bina koi ORM magic ke! ü™Ñ

### Real-Life Analogy üåü
**Real life example:** 
- **JPQL** = Ordering food in restaurant (waiter translates your English to kitchen Hindi)
- **Native Query** = Going directly to kitchen and speaking in chef's language üë®‚Äçüç≥

### Technical Definition üìö
Native query is a plain SQL query of the database. We can create a native query in JPA Repository by using @Query annotation with its attribute nativeQuery set to be true in the method of the JPA Repository of the Spring Data JPA.

---

## üîß 2. Key Terms/Concepts

| Term | English Meaning | Hindi Meaning | Example |
|------|----------------|---------------|---------|
| **Native Query** | Raw SQL Query | Seedha Database Query | `SELECT * FROM employee` |
| **@Query** | Annotation for custom queries | Custom query banane ka annotation | `@Query(value="...", nativeQuery=true)` |
| **nativeQuery=true** | Enable native SQL | SQL mode ON karta hai | Required for raw SQL |
| **Positional Parameter** | ?1, ?2 style parameters | Position ke hisab se parameter | `WHERE id = ?1` |
| **Named Parameter** | :name style parameters | Naam ke hisab se parameter | `WHERE name = :empName` |

### Visual Representation üìä
```
üèóÔ∏è Spring Data JPA Architecture
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Controller    ‚îÇ ‚Üê REST API endpoints
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Service      ‚îÇ ‚Üê Business Logic
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Repository    ‚îÇ ‚Üê @Query + Native SQL
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Database      ‚îÇ ‚Üê Raw SQL execution
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üíª 3. Detailed Examples

### Basic Setup - Maven Dependencies
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

### Entity Class Example üèóÔ∏è
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Data
@Entity
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    private String mobileNo;
    private Double salary;
    private String department;
}
```

### Repository with Native Queries üéØ
```java
package com.springjava.repository;

import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // Basic Native Query
    @Query(value = "SELECT * FROM employee", nativeQuery = true)
    List<Employee> findAllEmployees();
    
    // Positional Parameter (?1, ?2)
    @Query(value = "SELECT * FROM employee WHERE email = ?1", nativeQuery = true)
    Employee findByEmail(String email);
    
    @Query(value = "SELECT * FROM employee WHERE department = ?1 AND salary > ?2", 
           nativeQuery = true)
    List<Employee> findByDeptAndSalary(String department, Double salary);
    
    // Named Parameter (:paramName)
    @Query(value = "SELECT * FROM employee WHERE mobile_no = :mobNo", nativeQuery = true)
    Employee findByMobileNo(@Param("mobNo") String mobileNo);
    
    @Query(value = "SELECT * FROM employee WHERE name LIKE :namePattern", 
           nativeQuery = true)
    List<Employee> findByNameContaining(@Param("namePattern") String namePattern);
    
    // Complex Queries
    @Query(value = """
           SELECT e.*, d.department_name 
           FROM employee e 
           JOIN department d ON e.department_id = d.id 
           WHERE e.salary BETWEEN :minSal AND :maxSal
           ORDER BY e.salary DESC
           """, nativeQuery = true)
    List<Object[]> findEmployeesWithDepartment(@Param("minSal") Double minSal, 
                                               @Param("maxSal") Double maxSal);
    
    // Aggregate Functions
    @Query(value = "SELECT COUNT(*) FROM employee WHERE department = ?1", nativeQuery = true)
    Long countByDepartment(String department);
    
    @Query(value = "SELECT AVG(salary) FROM employee WHERE department = :dept", 
           nativeQuery = true)
    Double avgSalaryByDept(@Param("dept") String department);
}
```

**Expected Output Examples:**
```json
// findAllEmployees() output:
[
    {
        "id": 1,
        "name": "Rahul Sharma",
        "email": "rahul@gmail.com",
        "mobileNo": "9876543210",
        "salary": 50000.0,
        "department": "IT"
    },
    {
        "id": 2,
        "name": "Priya Singh",
        "email": "priya@gmail.com", 
        "mobileNo": "8765432109",
        "salary": 45000.0,
        "department": "HR"
    }
]
```

---

## ‚ö° 4. Rules/Guidelines

### ‚úÖ Correct Native Query Rules

**Rule 1:** Always set `nativeQuery = true` ‚úÖ
```java
@Query(value = "SELECT * FROM employee WHERE id = ?1", nativeQuery = true)
Employee findById(Long id);
```

**Rule 2:** Use table names, not entity names ‚úÖ
```java
// ‚úÖ Correct - table name
@Query(value = "SELECT * FROM employee", nativeQuery = true)

// ‚ùå Wrong - entity name
@Query(value = "SELECT * FROM Employee", nativeQuery = true) 
```

**Rule 3:** Use column names, not property names ‚úÖ
```java
// ‚úÖ Correct - column name
@Query(value = "SELECT * FROM employee WHERE mobile_no = ?1", nativeQuery = true)

// ‚ùå Wrong - property name  
@Query(value = "SELECT * FROM employee WHERE mobileNo = ?1", nativeQuery = true)
```

**Rule 4:** Parameter binding sahi tareeke se karo ‚úÖ
```java
// ‚úÖ Positional Parameter
@Query(value = "SELECT * FROM employee WHERE email = ?1 AND department = ?2", 
       nativeQuery = true)
List<Employee> findByEmailAndDept(String email, String dept);

// ‚úÖ Named Parameter
@Query(value = "SELECT * FROM employee WHERE email = :email AND department = :dept", 
       nativeQuery = true)  
List<Employee> findByEmailAndDept(@Param("email") String email, 
                                  @Param("dept") String dept);
```

### ‚ùå Common Error Examples

**Error 1:** Forgetting nativeQuery = true
```java
// ‚ùå This will throw error
@Query(value = "SELECT * FROM employee WHERE id = ?1")
Employee findById(Long id);

// Error Message:
// org.hibernate.hql.internal.ast.QuerySyntaxException: 
// employee is not mapped [SELECT * FROM employee WHERE id = ?1]
```

**Rule 5:** Complex queries ke liye proper formatting ‚úÖ
```java
@Query(value = """
       SELECT e.name, e.salary, d.dept_name
       FROM employee e
       INNER JOIN department d ON e.dept_id = d.id
       WHERE e.salary > :minSalary
       ORDER BY e.salary DESC
       LIMIT :limitCount
       """, nativeQuery = true)
List<Object[]> getTopEarners(@Param("minSalary") Double minSalary,
                             @Param("limitCount") int limit);
```

---

## üåç 5. Real-world Applications

### Banking System Example üè¶
```java
@Repository  
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    // Monthly statement
    @Query(value = """
           SELECT * FROM account_transactions 
           WHERE account_id = ?1 
           AND transaction_date BETWEEN ?2 AND ?3
           ORDER BY transaction_date DESC
           """, nativeQuery = true)
    List<Transaction> getMonthlyStatement(Long accountId, 
                                        LocalDate startDate, 
                                        LocalDate endDate);
    
    // Top 5 customers by balance
    @Query(value = """
           SELECT c.customer_name, a.balance 
           FROM accounts a 
           JOIN customers c ON a.customer_id = c.id 
           ORDER BY a.balance DESC 
           LIMIT 5
           """, nativeQuery = true)
    List<Object[]> getTopCustomersByBalance();
    
    // Loan defaulters
    @Query(value = """
           SELECT c.customer_name, l.loan_amount, l.due_date
           FROM loans l
           JOIN customers c ON l.customer_id = c.id
           WHERE l.due_date < CURRENT_DATE 
           AND l.status = 'PENDING'
           """, nativeQuery = true)
    List<Object[]> getLoanDefaulters();
}
```

### E-commerce System Example üõí
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Best selling products
    @Query(value = """
           SELECT p.product_name, SUM(oi.quantity) as total_sold
           FROM order_items oi
           JOIN products p ON oi.product_id = p.id
           WHERE oi.created_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
           GROUP BY p.id, p.product_name
           ORDER BY total_sold DESC
           LIMIT 10
           """, nativeQuery = true)
    List<Object[]> getBestSellingProducts();
    
    // Products with low stock
    @Query(value = """
           SELECT product_name, stock_quantity 
           FROM products 
           WHERE stock_quantity <= :threshold
           AND is_active = true
           """, nativeQuery = true)
    List<Object[]> getLowStockProducts(@Param("threshold") Integer threshold);
}
```

---

## ‚öñÔ∏è 6. Comparison Tables

### JPQL vs Native Query Comparison

| Feature | JPQL | Native Query |
|---------|------|--------------|
| **Syntax** | Entity-based | Table-based |
| **Example** | `SELECT e FROM Employee e` | `SELECT * FROM employee` |
| **Database Independence** | ‚úÖ Yes | ‚ùå No |
| **Complex Queries** | ‚ö†Ô∏è Limited | ‚úÖ Full Power |
| **Performance** | ‚ö†Ô∏è Good | ‚úÖ Excellent |
| **Learning Curve** | üìà Easy | üìà Moderate |
| **Type Safety** | ‚úÖ Yes | ‚ùå Limited |

### Parameter Binding Comparison

| Type | Syntax | Example | Use Case |
|------|--------|---------|----------|
| **Positional** | `?1, ?2, ?3` | `WHERE name = ?1 AND age = ?2` | Simple queries |
| **Named** | `:paramName` | `WHERE name = :empName` | Complex queries, Readability |

### Return Type Options

| Return Type | Use Case | Example |
|-------------|----------|---------|
| `Entity` | Single table select | `Employee findById(Long id)` |
| `List<Entity>` | Multiple entities | `List<Employee> findAll()` |
| `Object[]` | Join queries | `List<Object[]> getEmployeeWithDept()` |
| `Primitive` | Aggregate functions | `Long countEmployees()` |
| `Optional<Entity>` | Null-safe single result | `Optional<Employee> findByEmail(String email)` |

---

## üé§ 7. Interview Questions

### Q1: JPQL aur Native Query mein kya difference hai?
**Answer with Code Example:**

```java
// JPQL - Entity based
@Query("SELECT e FROM Employee e WHERE e.department = :dept")
List<Employee> findByDepartmentJPQL(@Param("dept") String department);

// Native Query - Table based  
@Query(value = "SELECT * FROM employee WHERE department = :dept", nativeQuery = true)
List<Employee> findByDepartmentNative(@Param("dept") String department);
```

**Key Points:**
- JPQL uses entity names (`Employee`), Native uses table names (`employee`)
- JPQL is database independent, Native is database specific
- Native queries give more control for complex operations

### Q2: Native Query mein parameter binding ke kitne tarike hain?

**Answer:**
```java
// 1. Positional Parameters (?1, ?2, ...)
@Query(value = "SELECT * FROM employee WHERE name = ?1 AND salary > ?2", 
       nativeQuery = true)
List<Employee> findByNameAndSalary(String name, Double salary);

// 2. Named Parameters (:paramName)
@Query(value = "SELECT * FROM employee WHERE name = :empName AND salary > :minSal", 
       nativeQuery = true)  
List<Employee> findByNameAndSalary(@Param("empName") String name, 
                                   @Param("minSal") Double salary);
```

### Q3: Complex join query kaise likhte hain Native Query mein?

**Answer:**
```java
@Query(value = """
       SELECT 
           e.name as employee_name,
           e.salary,
           d.dept_name,
           p.project_name
       FROM employee e
       LEFT JOIN department d ON e.dept_id = d.id
       LEFT JOIN employee_projects ep ON e.id = ep.emp_id  
       LEFT JOIN projects p ON ep.project_id = p.id
       WHERE e.salary BETWEEN :minSal AND :maxSal
       ORDER BY e.salary DESC, d.dept_name ASC
       """, nativeQuery = true)
List<Object[]> getEmployeeProjectDetails(@Param("minSal") Double minSalary,
                                         @Param("maxSal") Double maxSalary);
```

### Q4: Aggregate functions Native Query mein kaise use karte hain?

**Answer:**
```java
// Count
@Query(value = "SELECT COUNT(*) FROM employee WHERE department = ?1", 
       nativeQuery = true)
Long countByDepartment(String department);

// Average  
@Query(value = "SELECT AVG(salary) FROM employee WHERE department = ?1", 
       nativeQuery = true)
Double avgSalaryByDept(String department);

// Group By with multiple aggregates
@Query(value = """
       SELECT 
           department,
           COUNT(*) as emp_count,
           AVG(salary) as avg_salary,
           MAX(salary) as max_salary,
           MIN(salary) as min_salary
       FROM employee 
       GROUP BY department
       HAVING COUNT(*) > :minCount
       """, nativeQuery = true)
List<Object[]> getDepartmentStatistics(@Param("minCount") Long minCount);
```

---

## ‚ö†Ô∏è 8. Common Mistakes

### Mistake 1: Entity name use karna table name ke bajay ‚ùå
```java
// ‚ùå Wrong - Entity name used
@Query(value = "SELECT * FROM Employee WHERE name = ?1", nativeQuery = true)

// ‚úÖ Correct - Table name used  
@Query(value = "SELECT * FROM employee WHERE name = ?1", nativeQuery = true)

// Why it's wrong: Native queries directly hit database, 
// database doesn't know about Java entity names
```

### Mistake 2: Property name use karna column name ke bajay ‚ùå
```java
// ‚ùå Wrong - Java property name
@Query(value = "SELECT * FROM employee WHERE mobileNo = ?1", nativeQuery = true)

// ‚úÖ Correct - Database column name
@Query(value = "SELECT * FROM employee WHERE mobile_no = ?1", nativeQuery = true)

// Error Message you'll get:
// SQLSyntaxErrorException: Unknown column 'mobileNo' in 'where clause'
```

### Mistake 3: nativeQuery = true bhool jana ‚ùå
```java
// ‚ùå Wrong - Missing nativeQuery flag
@Query(value = "SELECT * FROM employee WHERE id = ?1")
Employee findById(Long id);

// ‚úÖ Correct
@Query(value = "SELECT * FROM employee WHERE id = ?1", nativeQuery = true)  
Employee findById(Long id);

// Error: QuerySyntaxException - Hibernate tries to parse as JPQL
```

### Mistake 4: Wrong parameter binding ‚ùå
```java
// ‚ùå Wrong - Parameter count mismatch
@Query(value = "SELECT * FROM employee WHERE name = ?1 AND department = ?2", 
       nativeQuery = true)
List<Employee> findByName(String name); // Only 1 parameter provided, 2 expected

// ‚úÖ Correct  
@Query(value = "SELECT * FROM employee WHERE name = ?1 AND department = ?2", 
       nativeQuery = true)
List<Employee> findByNameAndDept(String name, String department);
```

### Mistake 5: Return type galat choose karna ‚ùå
```java
// ‚ùå Wrong - Single Employee expected but query returns multiple
@Query(value = "SELECT * FROM employee WHERE department = ?1", nativeQuery = true)
Employee findByDepartment(String dept); // Can return multiple employees

// ‚úÖ Correct
@Query(value = "SELECT * FROM employee WHERE department = ?1", nativeQuery = true)
List<Employee> findByDepartment(String dept);
```

---

## üèÖ 9. Best Practices

### Practice 1: Use Multi-line Strings for Complex Queries ‚úÖ
```java
// ‚úÖ Readable format using text blocks (Java 15+)
@Query(value = """
       SELECT 
           e.id,
           e.name,
           e.email,
           d.dept_name,
           COUNT(p.id) as project_count
       FROM employee e
       LEFT JOIN department d ON e.dept_id = d.id
       LEFT JOIN employee_projects ep ON e.id = ep.emp_id
       LEFT JOIN projects p ON ep.project_id = p.id
       WHERE e.is_active = true
       GROUP BY e.id, e.name, e.email, d.dept_name
       HAVING project_count >= :minProjects
       ORDER BY project_count DESC, e.name ASC
       """, nativeQuery = true)
List<Object[]> getActiveEmployeesWithProjects(@Param("minProjects") Long minProjects);
```

### Practice 2: Use Named Parameters for Better Readability ‚úÖ
```java
// ‚úÖ Good - Named parameters
@Query(value = """
       SELECT * FROM employee 
       WHERE salary BETWEEN :minSalary AND :maxSalary
       AND department = :department
       AND joining_date >= :fromDate
       """, nativeQuery = true)
List<Employee> searchEmployees(@Param("minSalary") Double minSalary,
                               @Param("maxSalary") Double maxSalary,
                               @Param("department") String department,
                               @Param("fromDate") LocalDate fromDate);
```

### Practice 3: Error Handling aur Validation ‚úÖ
```java
// Service layer mein proper error handling
@Service
public class EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    public List<Employee> searchEmployees(String department, Double minSalary) {
        // Validation
        if (department == null || department.trim().isEmpty()) {
            throw new IllegalArgumentException("Department cannot be null or empty");
        }
        
        if (minSalary < 0) {
            throw new IllegalArgumentException("Minimum salary cannot be negative");  
        }
        
        try {
            return employeeRepository.findByDeptAndSalary(department, minSalary);
        } catch (Exception e) {
            log.error("Error while searching employees: {}", e.getMessage());
            throw new ServiceException("Failed to search employees", e);
        }
    }
}
```

### Practice 4: Proper Result Mapping for Object[] Returns ‚úÖ
```java
// Repository method
@Query(value = """
       SELECT e.name, e.salary, d.dept_name, COUNT(p.id) as project_count
       FROM employee e
       JOIN department d ON e.dept_id = d.id
       LEFT JOIN employee_projects ep ON e.id = ep.emp_id
       LEFT JOIN projects p ON ep.project_id = p.id
       GROUP BY e.id, e.name, e.salary, d.dept_name
       """, nativeQuery = true)
List<Object[]> getEmployeeStatistics();

// Service method with proper mapping
public List<EmployeeStatisticsDTO> getEmployeeStatistics() {
    List<Object[]> results = employeeRepository.getEmployeeStatistics();
    
    return results.stream()
            .map(result -> EmployeeStatisticsDTO.builder()
                    .name((String) result[0])
                    .salary(((Number) result[1]).doubleValue())
                    .departmentName((String) result[2])
                    .projectCount(((Number) result[3]).longValue())
                    .build())
            .collect(Collectors.toList());
}
```

### Practice 5: Database-specific Features Use Karo ‚úÖ
```java
// MySQL specific features
@Query(value = """
       SELECT *
       FROM employee
       WHERE MATCH(name, email) AGAINST(?1 IN BOOLEAN MODE)
       ORDER BY salary DESC
       LIMIT ?2
       """, nativeQuery = true)
List<Employee> fullTextSearch(String searchTerm, int limit);

// PostgreSQL specific features  
@Query(value = """
       SELECT e.*, 
              RANK() OVER (PARTITION BY e.department ORDER BY e.salary DESC) as salary_rank
       FROM employee e
       WHERE e.is_active = true
       """, nativeQuery = true)
List<Object[]> getEmployeeSalaryRanks();
```

---

## üìù 10. Summary/Quick Recap

### Key Takeaways üéØ

**Yaad rakhne ka mantra:**
1. **Native = Raw SQL** üîß
2. **nativeQuery = true** is mandatory ‚úÖ  
3. **Table names**, not entity names üèóÔ∏è
4. **Column names**, not property names üìã
5. **Two parameter types**: Positional (?1) aur Named (:param) üéØ

### When to Use What? ü§î

| Scenario | Recommendation | Reason |
|----------|----------------|---------|
| **Simple CRUD** | JPQL ya Method Names | Database independent |
| **Complex Joins** | Native Query | Full SQL power |
| **Aggregate Functions** | Native Query | Better performance |
| **Database-specific Features** | Native Query | Only option |
| **Reporting Queries** | Native Query | Optimized SQL |

### Memory Tricks üß†

**NATIVE Acronym:**
- **N** = **N**eed nativeQuery = true
- **A** = **A**lways use table names  
- **T** = **T**able columns, not properties
- **I** = **I**ndex parameters correctly (?1, ?2)
- **V** = **V**alidate parameter count
- **E** = **E**rror handling zaroori hai

### Quick Syntax Cheat Sheet üìã

```java
// Basic Pattern
@Query(value = "SELECT * FROM table_name WHERE column = ?1", nativeQuery = true)
ReturnType methodName(ParameterType param);

// Named Parameter Pattern  
@Query(value = "SELECT * FROM table_name WHERE column = :paramName", nativeQuery = true)
ReturnType methodName(@Param("paramName") ParameterType param);

// Complex Query Pattern
@Query(value = """
       SELECT t1.col1, t2.col2
       FROM table1 t1
       JOIN table2 t2 ON t1.id = t2.foreign_id
       WHERE t1.condition = :value
       ORDER BY t1.sort_column
       """, nativeQuery = true)
List<Object[]> complexQuery(@Param("value") String value);
```

---

## üî• Final Pro Tips

1. **Testing**: Always test native queries with actual database data
2. **Performance**: Use EXPLAIN PLAN to optimize complex queries  
3. **Security**: Never use string concatenation for dynamic queries (SQL Injection risk)
4. **Documentation**: Comment complex native queries properly
5. **Version Control**: Keep query history for rollbacks

**Happy Coding, Bhai! üöÄ** 

Remember: **"Practice makes perfect, Native Query makes performance!"** ‚ö°

---

*Yeh notes save kar lena aur interview se pehle ek baar zaroor revise karna! All the best! üéØ*
|
