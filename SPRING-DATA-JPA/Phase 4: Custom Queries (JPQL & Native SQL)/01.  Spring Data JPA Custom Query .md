# 📚 Spring Data JPA Custom Query - Complete Study Notes

## 🎯 Introduction with Confusion Clearing

### Simple Explanation First 
Bhai, **Custom Query** ka matlab hai apna khud ka SQL query likhna database operations ke liye! 😎

### Real-life Analogy 🏠
Imagine karo tumhe ek library mein specific books dhundni hain:
- **Default JPA Methods**: Library staff se puchna "Mujhe Java ki books do" (pre-defined queries)
- **Custom Query**: Staff se kehna "Mujhe Java ki woh books do jo 2023 ke baad publish hui hain aur 500 pages se zyada hain" (your custom requirements)

### Technical Definition 📖
Custom Query in JPA Repository means creating your own JPQL or native SQL queries using @Query annotation to perform specific database operations that are not available through default JPA methods.

---

## 🔑 Key Terms/Concepts

| Term | Technical Definition |
|------|----------------------|
| **@Query** | Annotation to define custom queries |
| **JPQL** |  Jakarta Persistence Query Language |
| **Named Parameter** | Parameters starting with `:` |
| **Positional Parameter** | Parameters with `?1, ?2` |
| **Entity** | Java class representing database table |

### Visual Representation 🎨
```
┌─────────────────┐    @Query     ┌──────────────────┐
│   Repository    │  ◄─────────── │  Custom Method   │
│                 │               │                  │
└─────────────────┘               └──────────────────┘
         │                                 │
         ▼                                 ▼
┌─────────────────┐               ┌──────────────────┐
│    Database     │               │   JPQL/SQL       │
│                 │               │   Query String   │
└─────────────────┘               └──────────────────┘
```

---

## 💻 Detailed Examples

### 1. Basic Custom Query Setup

#### Step 1: Entity Class 🏗️
```java
package com.example.entity;

import javax.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "employee_name")
    private String name;
    
    @Column(name = "email", unique = true)
    private String email;
    
    @Column(name = "mobile_number")
    private String mobileNo;
    
    @Column(name = "salary")
    private Double salary;
    
    @Column(name = "department")
    private String department;
}
```

#### Step 2: Repository with Custom Queries 🗃️
```java
package com.example.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import java.util.List;

public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // ✅ JPQL Query - Entity based
    @Query("SELECT e FROM Employee e")
    List<Employee> getAllEmployees();
    
    // ✅ Positional Parameter (?1, ?2)
    @Query("SELECT e FROM Employee e WHERE e.email = ?1")
    Employee findByEmail(String email);
    
    // ✅ Named Parameter (:paramName)
    @Query("SELECT e FROM Employee e WHERE e.mobileNo = :mobNo")
    Employee findByMobileNumber(@Param("mobNo") String mobileNumber);
    
    // ✅ Multiple conditions
    @Query("SELECT e FROM Employee e WHERE e.salary > :minSalary AND e.department = :dept")
    List<Employee> findByDepartmentAndMinSalary(
        @Param("minSalary") Double minSalary, 
        @Param("dept") String department
    );
    
    // ✅ Native SQL Query
    @Query(value = "SELECT * FROM employees WHERE salary BETWEEN ?1 AND ?2", 
           nativeQuery = true)
    List<Employee> findBySalaryRange(Double minSalary, Double maxSalary);
    
    // ✅ Count Query
    @Query("SELECT COUNT(e) FROM Employee e WHERE e.department = :dept")
    Long countByDepartment(@Param("dept") String department);
    
    // ✅ Update Query
    @Modifying
    @Query("UPDATE Employee e SET e.salary = :newSalary WHERE e.id = :empId")
    int updateEmployeeSalary(@Param("empId") Long id, @Param("newSalary") Double salary);
}
```

### Expected Output 📋
```json
// GET /api/employees/department/IT?minSalary=50000
{
    "status": 1,
    "data": [
        {
            "id": 1,
            "name": "Rahul Sharma",
            "email": "rahul@company.com",
            "mobileNo": "9876543210",
            "salary": 75000.0,
            "department": "IT"
        }
    ]
}
```

---

## 📏 Rules/Guidelines

### Rule 1: @Query Annotation Usage ✅
```java
// ✅ Correct - JPQL Query
@Query("SELECT e FROM Employee e WHERE e.name = ?1")
Employee findByName(String name);

// ❌ Wrong - Missing @Query annotation
Employee findByName(String name); // This won't work for custom logic
```

### Rule 2: Parameter Binding ✅
```java
// ✅ Correct - Positional Parameter
@Query("SELECT e FROM Employee e WHERE e.email = ?1 AND e.department = ?2")
List<Employee> findByEmailAndDept(String email, String dept);

// ✅ Correct - Named Parameter  
@Query("SELECT e FROM Employee e WHERE e.email = :email AND e.department = :dept")
List<Employee> findByEmailAndDept(@Param("email") String email, @Param("dept") String dept);

// ❌ Wrong - Mixed parameters (Don't mix positional and named)
@Query("SELECT e FROM Employee e WHERE e.email = ?1 AND e.department = :dept")
List<Employee> findByEmailAndDept(String email, @Param("dept") String dept);
```

### Rule 3: Native Query Usage ✅
```java
// ✅ Correct - Native SQL with nativeQuery = true
@Query(value = "SELECT * FROM employees WHERE created_date > ?1", nativeQuery = true)
List<Employee> findRecentEmployees(Date date);

// ❌ Wrong - Native SQL without nativeQuery flag
@Query("SELECT * FROM employees WHERE created_date > ?1")
List<Employee> findRecentEmployees(Date date); // Will throw exception
```

### Rule 4: Update/Delete Queries ✅
```java
// ✅ Correct - @Modifying for update queries
@Modifying
@Transactional
@Query("UPDATE Employee e SET e.salary = e.salary * 1.1 WHERE e.department = :dept")
int giveDepartmentRaise(@Param("dept") String department);

// ❌ Wrong - Missing @Modifying annotation
@Query("UPDATE Employee e SET e.salary = e.salary * 1.1 WHERE e.department = :dept")
int giveDepartmentRaise(@Param("dept") String department); // Will throw exception
```

**Common Error Message:**
```
org.springframework.dao.InvalidDataAccessApiUsageException: 
Modifying queries can only use void or int/Integer as return type!
```

---

## 🌍 Real-world Applications

### 1. Banking System 🏦
```java
@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    // Find accounts with low balance
    @Query("SELECT a FROM Account a WHERE a.balance < :minBalance")
    List<Account> findLowBalanceAccounts(@Param("minBalance") Double minBalance);
    
    // Transfer money between accounts
    @Modifying
    @Transactional
    @Query("UPDATE Account a SET a.balance = a.balance - :amount WHERE a.accountNumber = :fromAccount")
    int debitAmount(@Param("fromAccount") String accountNumber, @Param("amount") Double amount);
    
    // Monthly statement
    @Query(value = "SELECT * FROM accounts WHERE last_transaction_date BETWEEN ?1 AND ?2", 
           nativeQuery = true)
    List<Account> getMonthlyStatement(Date startDate, Date endDate);
}
```

### 2. E-commerce System 🛒
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Search products by name (case-insensitive)
    @Query("SELECT p FROM Product p WHERE UPPER(p.name) LIKE UPPER(CONCAT('%', :keyword, '%'))")
    List<Product> searchProductsByName(@Param("keyword") String keyword);
    
    // Find trending products
    @Query(value = "SELECT p.* FROM products p JOIN orders o ON p.id = o.product_id " +
           "WHERE o.order_date >= DATE_SUB(NOW(), INTERVAL 30 DAY) " +
           "GROUP BY p.id ORDER BY COUNT(o.id) DESC LIMIT ?1", 
           nativeQuery = true)
    List<Product> findTrendingProducts(int limit);
    
    // Price range filter
    @Query("SELECT p FROM Product p WHERE p.price BETWEEN :minPrice AND :maxPrice " +
           "AND p.category = :category ORDER BY p.price ASC")
    List<Product> findByPriceRangeAndCategory(@Param("minPrice") Double minPrice,
                                             @Param("maxPrice") Double maxPrice,
                                             @Param("category") String category);
}
```

---

## 📊 Comparison Tables

### JPQL vs Native SQL

| Feature | JPQL | Native SQL |
|---------|------|------------|
| **Database Independence** | ✅ Yes | ❌ No |
| **Entity-based** | ✅ Yes | ❌ No |
| **Complex Joins** | ⚠️ Limited | ✅ Full Support |
| **Database Functions** | ⚠️ Limited | ✅ All Functions |
| **Type Safety** | ✅ Yes | ❌ No |
| **Performance** | ⚠️ Good | ✅ Better |

### Parameter Binding Comparison

| Type | Syntax | Advantage | Disadvantage |
|------|--------|-----------|--------------|
| **Positional** | `?1, ?2` | Simple, Quick | Order dependent |
| **Named** | `:paramName` | Readable, Order independent | More verbose |

```java
// Positional - Simple but order matters
@Query("SELECT e FROM Employee e WHERE e.salary > ?1 AND e.department = ?2")
List<Employee> findBySalaryAndDept(Double salary, String dept);

// Named - More readable and maintainable  
@Query("SELECT e FROM Employee e WHERE e.salary > :minSalary AND e.department = :dept")
List<Employee> findBySalaryAndDept(@Param("minSalary") Double salary, @Param("dept") String dept);
```

---

## 🎤 Interview Questions

### Q1: What is the difference between @Query and derived query methods?
**Answer:**
```java
// Derived Query Method - Spring generates query automatically
List<Employee> findByDepartmentAndSalaryGreaterThan(String department, Double salary);

// @Query - You write the query manually
@Query("SELECT e FROM Employee e WHERE e.department = :dept AND e.salary > :salary")
List<Employee> findByDeptAndMinSalary(@Param("dept") String department, @Param("salary") Double salary);
```

**Key Differences:**
- Derived methods: Limited flexibility, Spring generates query
- @Query: Full control, can write complex queries

### Q2: How do you handle dynamic queries?
**Answer:**
```java
// Using @Query with conditional logic
@Query("SELECT e FROM Employee e WHERE " +
       "(:name IS NULL OR e.name LIKE %:name%) AND " +
       "(:dept IS NULL OR e.department = :dept) AND " +
       "(:minSalary IS NULL OR e.salary >= :minSalary)")
List<Employee> findWithFilters(@Param("name") String name,
                              @Param("dept") String department,
                              @Param("minSalary") Double minSalary);
```

### Q3: What happens if you don't use @Transactional with @Modifying?
**Answer:**
```java
// ❌ This will throw TransactionRequiredException
@Modifying
@Query("UPDATE Employee e SET e.salary = :salary WHERE e.id = :id")
int updateSalary(@Param("id") Long id, @Param("salary") Double salary);

// ✅ Correct approach
@Modifying
@Transactional
@Query("UPDATE Employee e SET e.salary = :salary WHERE e.id = :id")
int updateSalary(@Param("id") Long id, @Param("salary") Double salary);
```

**Error Message:**
```
javax.persistence.TransactionRequiredException: 
Executing an update/delete query
```

---

## ⚠️ Common Mistakes

### Mistake 1: Entity Name vs Table Name
```java
// ❌ Wrong - Using table name in JPQL
@Query("SELECT * FROM employees WHERE email = ?1") // This is SQL, not JPQL
Employee findByEmail(String email);

// ✅ Correct - Using entity name in JPQL
@Query("SELECT e FROM Employee e WHERE e.email = ?1") // Employee is entity name
Employee findByEmail(String email);
```

### Mistake 2: Return Type Mismatch
```java
// ❌ Wrong - Return type doesn't match query result
@Query("SELECT COUNT(e) FROM Employee e")
List<Employee> countEmployees(); // COUNT returns Long, not List<Employee>

// ✅ Correct - Proper return type
@Query("SELECT COUNT(e) FROM Employee e") 
Long countEmployees();
```

### Mistake 3: Parameter Annotation Missing
```java
// ❌ Wrong - Missing @Param for named parameters
@Query("SELECT e FROM Employee e WHERE e.department = :dept")
List<Employee> findByDepartment(String department); // Parameter name mismatch

// ✅ Correct - Proper @Param annotation
@Query("SELECT e FROM Employee e WHERE e.department = :dept")
List<Employee> findByDepartment(@Param("dept") String department);
```

---

## ✨ Best Practices

### 1. Query Optimization 🚀
```java
// ✅ Use specific columns instead of SELECT *
@Query("SELECT e.name, e.email FROM Employee e WHERE e.department = :dept")
List<Object[]> findEmployeeNameAndEmail(@Param("dept") String department);

// ✅ Use FETCH JOIN for lazy associations
@Query("SELECT e FROM Employee e JOIN FETCH e.department WHERE e.id = :id")
Employee findEmployeeWithDepartment(@Param("id") Long id);
```

### 2. Error Handling 🛡️
```java
@Service
public class EmployeeService {
    
    public Employee findByEmail(String email) {
        try {
            Employee emp = employeeRepository.findByEmail(email);
            if (emp == null) {
                throw new EntityNotFoundException("Employee not found with email: " + email);
            }
            return emp;
        } catch (Exception e) {
            log.error("Error finding employee by email: {}", email, e);
            throw new ServiceException("Failed to find employee", e);
        }
    }
}
```

### 3. Pagination Support 📄
```java
// ✅ Use Pageable for large result sets
@Query("SELECT e FROM Employee e WHERE e.department = :dept")
Page<Employee> findByDepartment(@Param("dept") String department, Pageable pageable);

// Usage in Controller
@GetMapping("/employees")
public Page<Employee> getEmployees(@RequestParam String department,
                                  @PageableDefault(size = 10) Pageable pageable) {
    return employeeService.findByDepartment(department, pageable);
}
```

### 4. Documentation Tips 📝
```java
/**
 * Finds employees by department with salary greater than specified amount
 * @param department - Department name (case-sensitive)  
 * @param minSalary - Minimum salary threshold
 * @return List of employees matching criteria
 * @throws DataAccessException if database error occurs
 */
@Query("SELECT e FROM Employee e WHERE e.department = :dept AND e.salary > :minSalary")
List<Employee> findHighPaidEmployeesByDept(@Param("dept") String department, 
                                          @Param("minSalary") Double minSalary);
```

---

## 📝 Summary/Quick Recap

### Key Takeaways 🎯
1. **@Query annotation** se custom queries likhte hain
2. **JPQL** uses entity names, **Native SQL** uses table names
3. **Parameters** do tarike se bind karte hain: Positional (`?1`) aur Named (`:param`)
4. **@Modifying + @Transactional** update/delete queries ke liye zaroori hai
5. **Return type** query result ke hisaab se hona chahiye

### Memory Tricks 🧠
- **JPQL**: "Java mein Entity ka naam use karo"
- **Native**: "Database ka actual table naam use karo" 
- **@Modifying**: "Modify kar rahe ho to @Modifying lagana mat bhoolna"
- **Parameters**: "Position se pareshaan ho to Named use karo"

### When to Use What? 🤔

| Use Case | Recommended Approach |
|----------|---------------------|
| Simple CRUD | Default JPA methods |
| Complex business logic | JPQL with @Query |
| Database-specific features | Native SQL |
| Dynamic conditions | Criteria API or Specifications |
| Bulk operations | @Modifying queries |

---

## 🎉 Final Pro Tips

**Yaad rakhne ka mantra:**
- **JPQL** = Java objects ke saath kaam karo
- **Native SQL** = Database tables ke saath kaam karo  
- **@Param** = Named parameters ke saath dost bano
- **@Modifying** = Update/Delete ke saath essential hai

**Interview mein ye puchte hain:**
1. JPQL vs Native SQL difference
2. Parameter binding types
3. @Modifying annotation ka use
4. Custom query performance optimization

**Common mistake - inse bacho!**
- Table name JPQL mein use karna
- @Param annotation bhoolna
- Wrong return type specify karna
- @Transactional miss karna updates mein

Happy Coding, Bhai! 🚀💻
