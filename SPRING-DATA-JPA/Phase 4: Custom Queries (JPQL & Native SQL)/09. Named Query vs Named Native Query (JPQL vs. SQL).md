# Named Query vs Named Native Query - Complete Guide üöÄ

---

## 1. Introduction with Confusion Clearing ü§î

### Simple Explanation First üë∂
**Bhai, ye concept samjho -** JPA mein do tarah ke named queries hain:
- **@NamedQuery** - JPQL (Java language) mein likhte hain
- **@NamedNativeQuery** - Pure SQL mein likhte hain

### Real-life Analogy üè†
**Imagine karo** tum ek restaurant mein ho:
- **@NamedQuery** = Menu card se order dena (standardized, har restaurant mein same)
- **@NamedNativeQuery** = Chef se directly specific dish mangna (restaurant-specific)

### Technical Definition üìö
Named Query and Named Native Query annotations allow us to define queries directly in the JPA Entity class and execute them by name, but they differ in syntax, use cases, and database interaction.

---

## 2. Key Terms/Concepts üîë

### Important Terminology üìñ

| Term | Hindi Meaning | Technical Meaning |
|------|---------------|-------------------|
| **JPQL** | Java Persistence Query Language | Java ka apna query language |
| **Native SQL** | Database ka original SQL | Pure SQL jo database samajhta hai |
| **Entity Mapping** | Object-Table connection | Java object aur database table ka rishta |
| **Runtime Validation** | Execution time check | Query chalate time validate hota hai |
| **Startup Validation** | Application start time check | App start hote hi validate hota hai |

### Visual Representation üé®
```
@NamedQuery
     ‚Üì
   JPQL ‚Üí JPA ‚Üí SQL ‚Üí Database
     ‚úÖ Portable   ‚úÖ Safe

@NamedNativeQuery
     ‚Üì
   SQL ‚Üí Database (Direct)
     ‚úÖ Fast   ‚ö†Ô∏è Database-specific
```

---

## 3. Detailed Examples üíª

### @NamedQuery Example - Complete Code üéØ

```java
// Entity Class
@Entity
@Table(name = "orders")
@NamedQuery(
    name = "Order.findByStatus",
    query = "SELECT o FROM Order o WHERE o.status = :status"
)
@NamedQuery(
    name = "Order.findByCustomerId", 
    query = "SELECT o FROM Order o WHERE o.customerId = :customerId ORDER BY o.orderDate DESC"
)
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "customer_id")
    private Long customerId;
    
    private String status;
    
    @Column(name = "order_date")
    private LocalDateTime orderDate;
    
    private BigDecimal amount;
    
    // Constructors, getters, setters...
}

// Service Class - Execution
@Service
@Transactional
public class OrderService {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    public List<Order> findOrdersByStatus(String status) {
        TypedQuery<Order> query = entityManager
            .createNamedQuery("Order.findByStatus", Order.class);
        query.setParameter("status", status);
        return query.getResultList();
    }
    
    public List<Order> findOrdersByCustomerId(Long customerId) {
        TypedQuery<Order> query = entityManager
            .createNamedQuery("Order.findByCustomerId", Order.class);
        query.setParameter("customerId", customerId);
        return query.getResultList();
    }
}
```

**Expected Output:**
```
// When status = "PENDING"
[Order{id=1, customerId=101, status='PENDING', amount=1500.00}]
[Order{id=3, customerId=102, status='PENDING', amount=2300.50}]
```

### @NamedNativeQuery Example - Complete Code üéØ

```java
// Entity Class
@Entity
@Table(name = "orders")
@NamedNativeQuery(
    name = "Order.findTop5ExpensiveOrders",
    query = "SELECT * FROM orders ORDER BY amount DESC LIMIT 5",
    resultClass = Order.class
)
@NamedNativeQuery(
    name = "Order.getOrderStatistics",
    query = """
        SELECT 
            status,
            COUNT(*) as total_count,
            AVG(amount) as avg_amount,
            MAX(amount) as max_amount
        FROM orders 
        GROUP BY status
        ORDER BY total_count DESC
    """,
    resultSetMapping = "OrderStatisticsMapping"
)
@SqlResultSetMapping(
    name = "OrderStatisticsMapping",
    classes = @ConstructorResult(
        targetClass = OrderStatistics.class,
        columns = {
            @ColumnResult(name = "status"),
            @ColumnResult(name = "total_count", type = Long.class),
            @ColumnResult(name = "avg_amount", type = BigDecimal.class),
            @ColumnResult(name = "max_amount", type = BigDecimal.class)
        }
    )
)
public class Order {
    // Same as above...
}

// DTO for Statistics
public class OrderStatistics {
    private String status;
    private Long totalCount;
    private BigDecimal avgAmount;
    private BigDecimal maxAmount;
    
    public OrderStatistics(String status, Long totalCount, 
                          BigDecimal avgAmount, BigDecimal maxAmount) {
        this.status = status;
        this.totalCount = totalCount;
        this.avgAmount = avgAmount;
        this.maxAmount = maxAmount;
    }
    // Getters and setters...
}

// Service Class - Execution
@Service
@Transactional
public class OrderService {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    public List<Order> findTop5ExpensiveOrders() {
        Query query = entityManager
            .createNamedQuery("Order.findTop5ExpensiveOrders");
        return query.getResultList();
    }
    
    public List<OrderStatistics> getOrderStatistics() {
        Query query = entityManager
            .createNamedQuery("Order.getOrderStatistics");
        return query.getResultList();
    }
}
```

**Expected Output:**
```
// Top 5 Expensive Orders
[Order{amount=5000.00}, Order{amount=4500.00}, Order{amount=3200.00}...]

// Order Statistics
[OrderStatistics{status='COMPLETED', totalCount=150, avgAmount=2500.00}]
[OrderStatistics{status='PENDING', totalCount=45, avgAmount=1800.00}]
```

---

## 4. Rules/Guidelines üìã

### @NamedQuery Rules ‚úÖ‚ùå

#### Rule 1: JPQL Syntax Only ‚úÖ
```java
// ‚úÖ Correct - Entity names aur properties use karo
@NamedQuery(
    name = "User.findByEmail",
    query = "SELECT u FROM User u WHERE u.email = :email"
)

// ‚ùå Wrong - Table names use nahi karte
@NamedQuery(
    name = "User.findByEmail", 
    query = "SELECT * FROM users WHERE email = :email" // SQL syntax
)
```
**Error Message:**
```
org.hibernate.hql.internal.ast.QuerySyntaxException: 
users is not mapped [SELECT * FROM users WHERE email = :email]
```

#### Rule 2: Parameter Binding Required ‚úÖ
```java
// ‚úÖ Correct - Parameters use karo
@NamedQuery(
    name = "Product.findByPrice",
    query = "SELECT p FROM Product p WHERE p.price > :minPrice"
)

// ‚ùå Wrong - Direct values se SQL injection risk
@NamedQuery(
    name = "Product.findByPrice",
    query = "SELECT p FROM Product p WHERE p.price > 1000" // Hardcoded
)
```

#### Rule 3: Entity Class Names ‚úÖ
```java
// ‚úÖ Correct - Entity class name use karo
@NamedQuery(
    name = "Order.findAll",
    query = "SELECT o FROM Order o" // Order is entity class name
)

// ‚ùå Wrong - Table name use nahi karte
@NamedQuery(
    name = "Order.findAll", 
    query = "SELECT o FROM orders o" // orders is table name
)
```

### @NamedNativeQuery Rules ‚úÖ‚ùå

#### Rule 1: Pure SQL Syntax ‚úÖ
```java
// ‚úÖ Correct - Table names aur column names use karo
@NamedNativeQuery(
    name = "User.findActiveUsers",
    query = "SELECT * FROM users WHERE is_active = true",
    resultClass = User.class
)

// ‚ùå Wrong - Entity properties nahi, column names chahiye
@NamedNativeQuery(
    name = "User.findActiveUsers",
    query = "SELECT u FROM User u WHERE u.isActive = true" // JPQL syntax
)
```

#### Rule 2: Result Mapping Required ‚úÖ
```java
// ‚úÖ Correct - resultClass specify karo
@NamedNativeQuery(
    name = "Order.getOrderCount",
    query = "SELECT COUNT(*) as count FROM orders",
    resultClass = Long.class
)

// ‚úÖ Correct - Complex mapping ke liye
@NamedNativeQuery(
    name = "Order.getCustomReport",
    query = "SELECT customer_name, total_amount FROM order_summary",
    resultSetMapping = "CustomReportMapping"
)
```

#### Rule 3: Database-Specific Features ‚úÖ
```java
// ‚úÖ MySQL specific
@NamedNativeQuery(
    name = "Order.findRecent",
    query = "SELECT * FROM orders ORDER BY created_date DESC LIMIT 10"
)

// ‚úÖ PostgreSQL specific  
@NamedNativeQuery(
    name = "Order.findRecent",
    query = "SELECT * FROM orders ORDER BY created_date DESC LIMIT 10 OFFSET 0"
)

// ‚úÖ Oracle specific
@NamedNativeQuery(
    name = "Order.findRecent", 
    query = "SELECT * FROM (SELECT * FROM orders ORDER BY created_date DESC) WHERE ROWNUM <= 10"
)
```

---

## 5. Real-world Applications üåç

### Banking System Example üè¶

```java
// Account Entity
@Entity
@Table(name = "accounts")
@NamedQuery(
    name = "Account.findByCustomerId",
    query = "SELECT a FROM Account a WHERE a.customerId = :customerId AND a.status = 'ACTIVE'"
)
@NamedNativeQuery(
    name = "Account.getMonthlyStatement",
    query = """
        SELECT 
            a.account_number,
            a.balance,
            COUNT(t.id) as transaction_count,
            SUM(CASE WHEN t.type = 'CREDIT' THEN t.amount ELSE 0 END) as total_credits,
            SUM(CASE WHEN t.type = 'DEBIT' THEN t.amount ELSE 0 END) as total_debits
        FROM accounts a
        LEFT JOIN transactions t ON a.id = t.account_id 
        WHERE a.customer_id = :customerId 
        AND t.transaction_date >= :fromDate 
        AND t.transaction_date <= :toDate
        GROUP BY a.account_number, a.balance
    """,
    resultSetMapping = "MonthlyStatementMapping"
)
public class Account {
    @Id
    private Long id;
    
    @Column(name = "account_number")
    private String accountNumber;
    
    @Column(name = "customer_id") 
    private Long customerId;
    
    private BigDecimal balance;
    private String status;
    
    // Constructors, getters, setters...
}

@Service
public class BankingService {
    
    public List<Account> getActiveAccounts(Long customerId) {
        // Simple query - @NamedQuery perfect hai
        return entityManager
            .createNamedQuery("Account.findByCustomerId", Account.class)
            .setParameter("customerId", customerId)
            .getResultList();
    }
    
    public List<MonthlyStatement> getMonthlyStatement(Long customerId, 
                                                     LocalDate fromDate, 
                                                     LocalDate toDate) {
        // Complex aggregation - @NamedNativeQuery better hai
        return entityManager
            .createNamedQuery("Account.getMonthlyStatement")
            .setParameter("customerId", customerId)
            .setParameter("fromDate", fromDate)
            .setParameter("toDate", toDate)
            .getResultList();
    }
}
```

### E-commerce System Example üõí

```java
// Product Entity
@Entity
@NamedQuery(
    name = "Product.findByCategoryAndPriceRange",
    query = """
        SELECT p FROM Product p 
        WHERE p.category.id = :categoryId 
        AND p.price BETWEEN :minPrice AND :maxPrice 
        AND p.active = true
        ORDER BY p.rating DESC
    """
)
@NamedNativeQuery(
    name = "Product.getTrendingProducts",
    query = """
        SELECT p.*, 
               COALESCE(sales.total_sales, 0) as total_sales,
               COALESCE(reviews.avg_rating, 0) as avg_rating
        FROM products p
        LEFT JOIN (
            SELECT product_id, COUNT(*) as total_sales 
            FROM order_items 
            WHERE created_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
            GROUP BY product_id
        ) sales ON p.id = sales.product_id
        LEFT JOIN (
            SELECT product_id, AVG(rating) as avg_rating
            FROM reviews 
            GROUP BY product_id
        ) reviews ON p.id = reviews.product_id
        WHERE p.active = true
        ORDER BY (total_sales * 0.7 + avg_rating * 0.3) DESC
        LIMIT 20
    """,
    resultSetMapping = "TrendingProductMapping"
)
public class Product {
    // Entity definition...
}
```

---

## 6. Comparison Tables üìä

### Feature Comparison üÜö

| Feature | @NamedQuery üéØ | @NamedNativeQuery ‚ö° |
|---------|----------------|---------------------|
| **Query Language** | JPQL (Java-like) | Pure SQL |
| **Database Portability** | ‚úÖ Multi-database support | ‚ùå Database-specific |
| **Validation Time** | ‚úÖ Application startup | ‚ö†Ô∏è Runtime execution |
| **Performance** | ‚ö†Ô∏è JPQL translation overhead | ‚úÖ Direct SQL execution |
| **Complex Queries** | ‚ùå Limited capabilities | ‚úÖ Full SQL power |
| **Result Mapping** | ‚úÖ Automatic entity mapping | ‚ö†Ô∏è Manual mapping required |
| **Learning Curve** | ‚úÖ Easy for Java developers | ‚ö†Ô∏è Requires SQL knowledge |
| **Maintenance** | ‚úÖ Type-safe, refactoring-friendly | ‚ö†Ô∏è String-based, error-prone |

### When to Use What? ü§î

| Scenario | Recommended Approach | Reason |
|----------|---------------------|---------|
| **Simple CRUD Operations** | @NamedQuery | JPQL is sufficient, portable |
| **Complex Reports** | @NamedNativeQuery | SQL aggregations, joins needed |
| **Multi-database App** | @NamedQuery | Portability important |
| **Performance Critical** | @NamedNativeQuery | Direct SQL execution |
| **Database-specific Features** | @NamedNativeQuery | LIMIT, window functions etc. |
| **Entity Relationships** | @NamedQuery | JPQL handles relationships well |
| **Legacy SQL Integration** | @NamedNativeQuery | Reuse existing SQL queries |

### Performance Comparison ‚ö°

| Query Type | Execution Time | Memory Usage | Complexity |
|------------|----------------|--------------|------------|
| **Simple Select (@NamedQuery)** | ~10ms | Low | Simple |
| **Simple Select (@NamedNativeQuery)** | ~8ms | Low | Simple |
| **Complex Join (@NamedQuery)** | ~25ms | Medium | Limited |
| **Complex Join (@NamedNativeQuery)** | ~15ms | Medium | Full Control |
| **Aggregation (@NamedQuery)** | Not Possible | - | Limited |
| **Aggregation (@NamedNativeQuery)** | ~12ms | Low | Optimized |

---

## 7. Interview Questions üé§

### Q1: What's the main difference between @NamedQuery and @NamedNativeQuery?

**Answer:**
```java
// @NamedQuery - JPQL based
@NamedQuery(
    name = "User.findByStatus",
    query = "SELECT u FROM User u WHERE u.status = :status" // Entity-based
)

// @NamedNativeQuery - SQL based  
@NamedNativeQuery(
    name = "User.findByStatusNative",
    query = "SELECT * FROM users WHERE status = :status", // Table-based
    resultClass = User.class
)
```

**Key Points:**
- @NamedQuery uses JPQL (entity attributes)
- @NamedNativeQuery uses pure SQL (table columns)
- JPQL is database-independent, SQL is database-specific

### Q2: When would you choose @NamedNativeQuery over @NamedQuery?

**Answer:**
```java
// Scenario 1: Database-specific features
@NamedNativeQuery(
    name = "Product.findTopSelling",
    query = "SELECT * FROM products ORDER BY sales_count DESC LIMIT 10" // LIMIT not in JPQL
)

// Scenario 2: Complex aggregations
@NamedNativeQuery(
    name = "Sales.getMonthlyReport",
    query = """
        SELECT 
            DATE_FORMAT(order_date, '%Y-%m') as month,
            SUM(amount) as total_sales,
            COUNT(DISTINCT customer_id) as unique_customers,
            AVG(amount) as avg_order_value
        FROM orders 
        WHERE order_date >= DATE_SUB(NOW(), INTERVAL 12 MONTH)
        GROUP BY DATE_FORMAT(order_date, '%Y-%m')
        ORDER BY month DESC
    """
)

// Scenario 3: Performance optimization
@NamedNativeQuery(
    name = "Order.findWithCustomIndex",
    query = "SELECT /*+ USE_INDEX(orders, idx_customer_date) */ * FROM orders WHERE customer_id = :customerId"
)
```

### Q3: How do you handle result mapping in @NamedNativeQuery?

**Answer:**
```java
// Method 1: Simple entity mapping
@NamedNativeQuery(
    name = "User.findActiveUsers",
    query = "SELECT * FROM users WHERE active = true",
    resultClass = User.class // Direct entity mapping
)

// Method 2: Custom DTO mapping
@NamedNativeQuery(
    name = "Order.getOrderSummary",
    query = """
        SELECT 
            customer_name as customerName,
            COUNT(*) as orderCount,
            SUM(amount) as totalAmount
        FROM orders o
        JOIN customers c ON o.customer_id = c.id
        GROUP BY customer_name
    """,
    resultSetMapping = "OrderSummaryMapping"
)

@SqlResultSetMapping(
    name = "OrderSummaryMapping",
    classes = @ConstructorResult(
        targetClass = OrderSummary.class,
        columns = {
            @ColumnResult(name = "customerName"),
            @ColumnResult(name = "orderCount", type = Long.class),
            @ColumnResult(name = "totalAmount", type = BigDecimal.class)
        }
    )
)

// DTO Class
public class OrderSummary {
    private String customerName;
    private Long orderCount;
    private BigDecimal totalAmount;
    
    public OrderSummary(String customerName, Long orderCount, BigDecimal totalAmount) {
        this.customerName = customerName;
        this.orderCount = orderCount;
        this.totalAmount = totalAmount;
    }
}
```

### Q4: What are the validation differences between both approaches?

**Answer:**
```java
// @NamedQuery - Validated at startup
@NamedQuery(
    name = "User.findByEmail",
    query = "SELECT u FROM User u WHERE u.emailAddress = :email" // Wrong property name
)
// Error at application startup:
// org.hibernate.QueryException: could not resolve property: emailAddress

// @NamedNativeQuery - Validated at runtime
@NamedNativeQuery(
    name = "User.findByEmailNative", 
    query = "SELECT * FROM users WHERE email_address = :email" // Wrong column name
)
// Error during query execution:
// SQLException: Unknown column 'email_address' in 'where clause'
```

---

## 8. Common Mistakes üö´

### Mistake 1: Mixing JPQL and SQL Syntax ‚ùå

```java
// ‚ùå Wrong - JPQL mein SQL syntax use kar rahe
@NamedQuery(
    name = "User.findAll",
    query = "SELECT * FROM users" // SQL syntax in JPQL
)

// ‚úÖ Correct - Pure JPQL
@NamedQuery(
    name = "User.findAll", 
    query = "SELECT u FROM User u" // JPQL syntax
)

// ‚ùå Wrong - Native query mein JPQL syntax
@NamedNativeQuery(
    name = "User.findByName",
    query = "SELECT u FROM User u WHERE u.name = :name" // JPQL syntax in native
)

// ‚úÖ Correct - Pure SQL
@NamedNativeQuery(
    name = "User.findByName",
    query = "SELECT * FROM users WHERE name = :name",
    resultClass = User.class
)
```

**Why it's wrong:** JPA confused ho jata hai ki konsa parser use karna hai!

### Mistake 2: Forgetting Result Mapping ‚ùå

```java
// ‚ùå Wrong - Native query without result mapping
@NamedNativeQuery(
    name = "User.getUserStats",
    query = "SELECT COUNT(*) as total, AVG(age) as avg_age FROM users"
    // Missing resultClass or resultSetMapping
)

// ‚úÖ Correct - With proper mapping
@NamedNativeQuery(
    name = "User.getUserStats", 
    query = "SELECT COUNT(*) as total, AVG(age) as avgAge FROM users",
    resultSetMapping = "UserStatsMapping"
)
@SqlResultSetMapping(
    name = "UserStatsMapping",
    classes = @ConstructorResult(
        targetClass = UserStats.class,
        columns = {
            @ColumnResult(name = "total", type = Long.class),
            @ColumnResult(name = "avgAge", type = Double.class)
        }
    )
)
```

### Mistake 3: Parameter Security Issues ‚ùå

```java
// ‚ùå Wrong - String concatenation (SQL Injection risk)
public List<User> findUsersByStatus(String status) {
    String query = "SELECT u FROM User u WHERE u.status = '" + status + "'";
    return entityManager.createQuery(query, User.class).getResultList();
}

// ‚úÖ Correct - Parameter binding
@NamedQuery(
    name = "User.findByStatus",
    query = "SELECT u FROM User u WHERE u.status = :status"
)

public List<User> findUsersByStatus(String status) {
    return entityManager
        .createNamedQuery("User.findByStatus", User.class)
        .setParameter("status", status)
        .getResultList();
}
```

### Mistake 4: Database-Specific Code in @NamedQuery ‚ùå

```java
// ‚ùå Wrong - Database-specific function in JPQL
@NamedQuery(
    name = "Order.findRecent",
    query = "SELECT o FROM Order o ORDER BY o.date DESC LIMIT 10" // LIMIT not supported
)

// ‚úÖ Correct - Use native query for database-specific features
@NamedNativeQuery(
    name = "Order.findRecent",
    query = "SELECT * FROM orders ORDER BY order_date DESC LIMIT 10",
    resultClass = Order.class
)

// ‚úÖ Alternative - Use JPQL with maxResults
public List<Order> findRecentOrders() {
    return entityManager
        .createQuery("SELECT o FROM Order o ORDER BY o.date DESC", Order.class)
        .setMaxResults(10)
        .getResultList();
}
```

---

## 9. Best Practices üåü

### For @NamedQuery üìù

#### 1. Naming Conventions ‚úÖ
```java
// ‚úÖ Good naming - Entity.operation pattern
@NamedQuery(name = "User.findByEmail", ...)
@NamedQuery(name = "Order.findByCustomerAndStatus", ...)
@NamedQuery(name = "Product.countByCategory", ...)

// ‚ùå Bad naming - Unclear purpose
@NamedQuery(name = "query1", ...)
@NamedQuery(name = "getUserStuff", ...)
```

#### 2. Parameter Validation ‚úÖ
```java
@NamedQuery(
    name = "User.findByEmailAndActive",
    query = """
        SELECT u FROM User u 
        WHERE (:email IS NULL OR u.email = :email)
        AND (:active IS NULL OR u.active = :active)
    """
)

public List<User> findUsers(String email, Boolean active) {
    return entityManager
        .createNamedQuery("User.findByEmailAndActive", User.class)
        .setParameter("email", email)
        .setParameter("active", active)
        .getResultList();
}
```

#### 3. Query Organization ‚úÖ
```java
@Entity
@NamedQueries({
    @NamedQuery(
        name = "User.findByEmail",
        query = "SELECT u FROM User u WHERE u.email = :email"
    ),
    @NamedQuery(
        name = "User.findActiveUsers",
        query = "SELECT u FROM User u WHERE u.active = true ORDER BY u.createdDate DESC"
    ),
    @NamedQuery(
        name = "User.countByStatus", 
        query = "SELECT COUNT(u) FROM User u WHERE u.status = :status"
    )
})
public class User {
    // Entity definition
}
```

### For @NamedNativeQuery ‚ö°

#### 1. SQL Optimization ‚úÖ
```java
@NamedNativeQuery(
    name = "Order.findCustomerOrders",
    query = """
        SELECT /*+ USE_INDEX(orders, idx_customer_date) */ 
               o.id, o.order_date, o.amount, o.status
        FROM orders o
        WHERE o.customer_id = :customerId
        AND o.order_date >= :fromDate
        ORDER BY o.order_date DESC
    """,
    resultSetMapping = "CustomerOrderMapping"
)
```

#### 2. Parameter Safety ‚úÖ
```java
// ‚úÖ Good - Always use parameters
@NamedNativeQuery(
    name = "Product.searchProducts",
    query = """
        SELECT * FROM products 
        WHERE name LIKE CONCAT('%', :searchTerm, '%')
        AND price BETWEEN :minPrice AND :maxPrice
        AND category_id = :categoryId
    """
)

// ‚ùå Bad - Never concatenate strings
// query = "SELECT * FROM products WHERE name LIKE '%" + searchTerm + "%'"
```

#### 3. Result Set Mapping Best Practices ‚úÖ
```java
// Complex mapping with proper types
@SqlResultSetMapping(
    name = "DetailedOrderMapping",
    entities = {
        @EntityResult(
            entityClass = Order.class,
            fields = {
                @FieldResult(name = "id", column = "order_id"),
                @FieldResult(name = "amount", column = "order_amount"),
                @FieldResult(name = "customer", column = "customer_id")
            }
        )
    },
    columns = {
        @ColumnResult(name = "customer_name", type = String.class),
        @ColumnResult(name = "total_items", type = Integer.class),
        @ColumnResult(name = "order_rank", type = Integer.class)
    }
)
```

### General Best Practices üéØ

#### 1. Documentation ‚úÖ
```java
/**
 * Finds all orders for a customer within date range
 * Performance: Uses composite index on (customer_id, order_date)
 * 
 * @param customerId Customer ID to search
 * @param fromDate Start date (inclusive)
 * @param toDate End date (inclusive)
 * @return List of orders sorted by date descending
 */
@NamedQuery(
    name = "Order.findByCustomerAndDateRange",
    query = """
        SELECT o FROM Order o 
        WHERE o.customerId = :customerId
        AND o.orderDate BETWEEN :fromDate AND :toDate
        ORDER BY o.orderDate DESC
    """
)
```

#### 2. Testing Strategy ‚úÖ
```java
@TestMethodOrder(OrderAnnotation.class)
class NamedQueryTest {
    
    @Test
    @Order(1)
    void testNamedQueryValidation() {
        // Test that all named queries are valid
        entityManagerFactory.createEntityManager()
            .createNamedQuery("User.findByEmail")
            .setParameter("email", "test@example.com");
    }
    
    @Test
    @Order(2) 
    void testQueryResults() {
        List<User> users = userService.findByEmail("john@example.com");
        assertThat(users).isNotEmpty();
        assertThat(users.get(0).getEmail()).isEqualTo("john@example.com");
    }
    
    @Test
    @Order(3)
    void testPerformance() {
        StopWatch stopWatch = new StopWatch();
        stopWatch.start();
        
        List<Order> orders = orderService.findRecentOrders();
        
        stopWatch.stop();
        assertThat(stopWatch.getTotalTimeMillis()).isLessThan(100);
    }
}
```

---

## 10. Summary/Quick Recap üéØ

### Key Takeaways üîë

| Aspect | @NamedQuery üéØ | @NamedNativeQuery ‚ö° |
|--------|----------------|---------------------|
| **Best For** | Simple queries, portability | Complex queries, performance |
| **Language** | JPQL (Java-like) | Pure SQL |
| **Validation** | Startup time ‚úÖ | Runtime ‚ö†Ô∏è |
| **Performance** | Good for simple queries | Excellent for complex queries |
| **Maintenance** | Easy refactoring | Manual SQL maintenance |

### Memory Tricks üß†

**Yaad rakhne ka mantra:**
- **@NamedQuery = Java Query** üéØ
  - **J**PQL language
  - **J**ava entity names
  - **J**ust for simple queries
  
- **@NamedNativeQuery = Native Power** ‚ö°
  - **N**ative SQL
  - **N**o entity names (table names)
  - **N**eeded for complex operations

### When to Use What - Quick Decision Tree üå≥

```
Need database-specific features? 
‚îú‚îÄ YES ‚Üí @NamedNativeQuery
‚îî‚îÄ NO ‚Üí Continue...

Complex aggregations/joins needed?
‚îú‚îÄ YES ‚Üí @NamedNativeQuery  
‚îî‚îÄ NO ‚Üí Continue...

Multi-database support required?
‚îú‚îÄ YES ‚Üí @NamedQuery
‚îî‚îÄ NO ‚Üí Continue...

Performance is critical?
‚îú‚îÄ YES ‚Üí @NamedNativeQuery
‚îî‚îÄ NO ‚Üí @NamedQuery (simpler)
```

### Code Templates for Quick Reference üìã

#### @NamedQuery Template
```java
@NamedQuery(
    name = "EntityName.operationDescription",
    query = "SELECT e FROM EntityName e WHERE e.property = :parameter"
)
```

#### @NamedNativeQuery Template  
```java
@NamedNativeQuery(
    name = "EntityName.operationDescription",
    query = "SELECT * FROM table_name WHERE column_name = :parameter",
    resultClass = EntityName.class
)
```

#### Complex Native Query Template
```java
@NamedNativeQuery(
    name = "EntityName.complexOperation",
    query = """
        SELECT col1, col2, aggregation_func(col3) as result
        FROM table1 t1
        JOIN table2 t2 ON t1.id = t2.foreign_key
        WHERE t1.condition = :param
        GROUP BY col1, col2
        ORDER BY result DESC
    """,
    resultSetMapping = "CustomMapping"
)

@SqlResultSetMapping(
    name = "CustomMapping",
    classes = @ConstructorResult(
        targetClass = CustomDTO.class,
        columns = {
            @ColumnResult(name = "col1"),
            @ColumnResult(name = "col2"),
            @ColumnResult(name = "result", type = Long.class)
        }
    )
)
```

---

## Bonus Section: Advanced Tips üöÄ

### 1. Dynamic Named Queries ‚öôÔ∏è

```java
// Repository method with dynamic conditions
@Repository
public class OrderRepository {
    
    public List<Order> findOrders(OrderSearchCriteria criteria) {
        StringBuilder jpql = new StringBuilder("SELECT o FROM Order o WHERE 1=1");
        Map<String, Object> parameters = new HashMap<>();
        
        if (criteria.getStatus() != null) {
            jpql.append(" AND o.status = :status");
            parameters.put("status", criteria.getStatus());
        }
        
        if (criteria.getFromDate() != null) {
            jpql.append(" AND o.orderDate >= :fromDate");
            parameters.put("fromDate", criteria.getFromDate());
        }
        
        if (criteria.getCustomerId() != null) {
            jpql.append(" AND o.customerId = :customerId");
            parameters.put("customerId", criteria.getCustomerId());
        }
        
        TypedQuery<Order> query = entityManager.createQuery(jpql.toString(), Order.class);
        parameters.forEach(query::setParameter);
        
        return query.getResultList();
    }
}
```

### 2. Named Query with Pagination üìÑ

```java
@NamedQuery(
    name = "Product.findByCategory",
    query = "SELECT p FROM Product p WHERE p.category.id = :categoryId ORDER BY p.name ASC"
)

@Service
public class ProductService {
    
    public Page<Product> findProductsByCategory(Long categoryId, Pageable pageable) {
        // Count query for total elements
        Long total = entityManager
            .createQuery("SELECT COUNT(p) FROM Product p WHERE p.category.id = :categoryId", Long.class)
            .setParameter("categoryId", categoryId)
            .getSingleResult();
        
        // Data query with pagination
        List<Product> products = entityManager
            .createNamedQuery("Product.findByCategory", Product.class)
            .setParameter("categoryId", categoryId)
            .setFirstResult((int) pageable.getOffset())
            .setMaxResults(pageable.getPageSize())
            .getResultList();
        
        return new PageImpl<>(products, pageable, total);
    }
}
```

### 3. Native Query with Custom Result Processor üîÑ

```java
@NamedNativeQuery(
    name = "Sales.getDashboardStats",
    query = """
        SELECT 
            DATE(order_date) as order_date,
            COUNT(*) as total_orders,
            SUM(amount) as total_revenue,
            AVG(amount) as avg_order_value,
            COUNT(DISTINCT customer_id) as unique_customers
        FROM orders 
        WHERE order_date >= DATE_SUB(NOW(), INTERVAL 30 DAY)
        GROUP BY DATE(order_date)
        ORDER BY order_date DESC
    """
)

@Service
public class DashboardService {
    
    public DashboardStats getDashboardStats() {
        List<Object[]> results = entityManager
            .createNamedQuery("Sales.getDashboardStats")
            .getResultList();
        
        List<DailyStats> dailyStats = results.stream()
            .map(row -> DailyStats.builder()
                .date((Date) row[0])
                .totalOrders(((Number) row[1]).intValue())
                .totalRevenue((BigDecimal) row[2])
                .avgOrderValue((BigDecimal) row[3])
                .uniqueCustomers(((Number) row[4]).intValue())
                .build())
            .collect(Collectors.toList());
        
        return DashboardStats.builder()
            .dailyStats(dailyStats)
            .totalDays(dailyStats.size())
            .overallRevenue(dailyStats.stream()
                .map(DailyStats::getTotalRevenue)
                .reduce(BigDecimal.ZERO, BigDecimal::add))
            .build();
    }
}
```

### 4. Error Handling Best Practices ‚ö†Ô∏è

```java
@Service
@Transactional
public class QueryService {
    
    public List<Order> findOrdersSafely(String status) {
        try {
            return entityManager
                .createNamedQuery("Order.findByStatus", Order.class)
                .setParameter("status", status)
                .getResultList();
                
        } catch (IllegalArgumentException e) {
            log.error("Named query not found: Order.findByStatus", e);
            throw new ServiceException("Query configuration error", e);
            
        } catch (QueryTimeoutException e) {
            log.error("Query timeout for status: {}", status, e);
            throw new ServiceException("Query took too long to execute", e);
            
        } catch (PersistenceException e) {
            log.error("Database error while finding orders by status: {}", status, e);
            throw new ServiceException("Database error occurred", e);
        }
    }
    
    public List<Object[]> executeNativeQuerySafely(String queryName, Map<String, Object> parameters) {
        try {
            Query query = entityManager.createNamedQuery(queryName);
            
            // Set parameters safely
            parameters.forEach((key, value) -> {
                if (value != null) {
                    query.setParameter(key, value);
                }
            });
            
            return query.getResultList();
            
        } catch (IllegalArgumentException e) {
            log.error("Invalid query name or parameter: {}", queryName, e);
            return Collections.emptyList();
            
        } catch (SQLException e) {
            log.error("SQL error in native query: {}", queryName, e);
            throw new DataAccessException("Native query execution failed", e);
        }
    }
}
```

---

## Final Thoughts üí≠

### Developer's Mindset üß†

**Bhai, remember:**
1. **Start Simple** - @NamedQuery se shuru karo
2. **Upgrade When Needed** - Complex requirements aane par @NamedNativeQuery use karo
3. **Test Everything** - Dono approaches ko thoroughly test karo
4. **Document Well** - Future developers ko samjhane ke liye comments likho

### Common Real-world Scenarios üåç

```java
// 80% cases - Simple business queries
@NamedQuery(name = "User.findActiveUsers", ...)
@NamedQuery(name = "Order.findByCustomer", ...)

// 15% cases - Performance critical or complex
@NamedNativeQuery(name = "Report.getMonthlySales", ...)
@NamedNativeQuery(name = "Analytics.getTopProducts", ...)

// 5% cases - Database-specific features
@NamedNativeQuery(name = "Search.fullTextSearch", ...)
@NamedNativeQuery(name = "Batch.bulkUpdate", ...)
```

### Last Advice üéØ

**Yaad rakho bhai:**
- **@NamedQuery** = ‡§Ü‡§∏‡§æ‡§® ‡§î‡§∞ safe, ‡§≤‡•á‡§ï‡§ø‡§® limited
- **@NamedNativeQuery** = Powerful ‡§î‡§∞ fast, ‡§≤‡•á‡§ï‡§ø‡§® database-dependent
- **Choose wisely** based on your requirements!
- **Always test** with real data volumes
- **Monitor performance** in production

**Happy Coding! üöÄ**

---

*Made with ‚ù§Ô∏è for Java developers who want to master JPA queries!*
