# @NamedNativeQuery in JPA - Complete Study Notes ğŸš€

---

## ğŸ¯ Introduction - Confusion Clear Karte Hain!

### Simple Words Mein Samjho Bhai! ğŸ‘¨â€ğŸ«

**@NamedNativeQuery** ka matlab hai - "Apna custom SQL query likhna aur usse naam dena!" 

### Real-Life Analogy ğŸª
Imagine karo ki tum ek restaurant mein ho:
- **JPQL** = Menu card mein jo dishes hain (limited options)
- **@NamedNativeQuery** = Chef se direct bolna "Yaar, mere liye kuch special banao!" (unlimited possibilities)

### Technical Definition ğŸ“š
The @NamedNativeQuery annotation in JPA allows us to specify native SQL queries directly in the JPA Entity class and execute them by name. This annotation is used when we need to execute complex SQL queries that cannot be easily expressed using the JPQL.

---

## ğŸ”‘ Key Terms/Concepts

| Term | Explanation |
|------|-------------|
| **@NamedNativeQuery** | Native SQL query with a unique name ğŸ·ï¸ |
| **Native SQL** | Raw database-specific SQL queries |
| **ResultClass** | Entity ya DTO class for mapping results |
| **EntityManager** | JPA interface to interact with database |
| **@SqlResultSetMapping** | Maps query results to custom DTOs |

### Visual Representation ğŸ“Š
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Entity Class  â”‚â”€â”€â”€â–¶â”‚ @NamedNativeQuery â”‚â”€â”€â”€â–¶â”‚   Database      â”‚
â”‚   (Orders.java) â”‚    â”‚   (SQL Query)     â”‚    â”‚   (orders table)â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» Detailed Examples

### Basic Syntax ğŸ”§

```java
@NamedNativeQuery(
    name = "queryName",           // Unique identifier
    query = "SQL query here",     // Raw SQL
    resultClass = EntityName.class // Mapping class
)
```

### Complete Working Example - Orders Entity ğŸ›ï¸

```java
@Entity
@Data
@NamedNativeQuery(
    name = "findOrdersByStatus",
    query = "SELECT * FROM orders WHERE status = :status",
    resultClass = Orders.class
)
public class Orders {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String product;
    private double price;
    private String status;
}
```

### Executing the Query ğŸƒâ€â™‚ï¸

```java
@Service
public class OrderServiceImpl implements OrderService {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<Orders> getOrdersByStatus(String status) {
        Query query = entityManager.createNamedQuery("findOrdersByStatus");
        query.setParameter("status", status);
        return query.getResultList();
    }
}
```

**Expected Output:** âœ…
```
Hibernate: SELECT * FROM orders WHERE status = ?
[Orders(id=1, product=Laptop, price=2000.0, status=PENDING)]
```

### Multiple Named Queries Example ğŸ”„

```java
@Entity
@Data
@NamedNativeQuery(
    name = "findOrdersByStatus",
    query = "SELECT * FROM orders WHERE status = :status",
    resultClass = Orders.class
)
@NamedNativeQuery(
    name = "findOrdersByPriceRange",
    query = "SELECT * FROM orders WHERE price BETWEEN :minPrice AND :maxPrice",
    resultClass = Orders.class
)
public class Orders {
    // Entity fields...
}
```

### DTO Mapping Example ğŸ“¦

```java
// DTO Class
@Data
@AllArgsConstructor
public class OrderDTO {
    private String product;
    private double price;
}

// Entity with DTO Mapping
@Entity
@Data
@SqlResultSetMapping(
    name = "OrderDTOResult",
    classes = @ConstructorResult(
        targetClass = OrderDTO.class,
        columns = {
            @ColumnResult(name = "product", type = String.class),
            @ColumnResult(name = "price", type = Double.class)
        }
    )
)
@NamedNativeQuery(
    name = "findOrderDTOsByStatus",
    query = "SELECT product, price FROM orders WHERE status = :status",
    resultSetMapping = "OrderDTOResult"
)
public class Orders {
    // Entity fields...
}
```

---

## ğŸ“‹ Rules/Guidelines

### âœ… Do's (Ye Karo Bhai!)

1. **âœ… Always use parameter placeholders**
   ```java
   // Correct âœ…
   query = "SELECT * FROM orders WHERE status = :status"
   
   // Wrong âŒ
   query = "SELECT * FROM orders WHERE status = 'PENDING'"
   ```

2. **âœ… Use unique names for queries**
   ```java
   @NamedNativeQuery(name = "findOrdersByStatus", ...) // âœ… Clear name
   @NamedNativeQuery(name = "query1", ...)            // âŒ Confusing name
   ```

3. **âœ… Specify resultClass properly**
   ```java
   resultClass = Orders.class // âœ… Correct mapping
   ```

### âŒ Don'ts (Inse Bacho!)

1. **âŒ Never use string concatenation for queries**
   ```java
   // Wrong âŒ - SQL Injection risk!
   String sql = "SELECT * FROM orders WHERE status = '" + status + "'";
   ```

2. **âŒ Don't forget @PersistenceContext**
   ```java
   // Wrong âŒ
   EntityManager em; // Null pointer exception!
   
   // Correct âœ…
   @PersistenceContext
   EntityManager entityManager;
   ```

### Error Examples with Solutions ğŸš¨

**Common Error 1:**
```
Error: org.hibernate.QueryException: No data type for node
```
**Solution:** Specify proper resultClass or resultSetMapping

**Common Error 2:**
```
Error: javax.persistence.NoResultException
```
**Solution:** Use `getResultList()` instead of `getSingleResult()`

---

## ğŸŒ Real-world Applications

### 1. Banking System Example ğŸ¦

```java
@Entity
@NamedNativeQuery(
    name = "findHighValueTransactions",
    query = "SELECT t.* FROM transactions t " +
            "WHERE t.amount > :amount AND t.transaction_date >= :startDate",
    resultClass = Transaction.class
)
public class Transaction {
    @Id
    private Long id;
    private BigDecimal amount;
    private LocalDateTime transactionDate;
    private String accountNumber;
}
```

### 2. E-commerce Inventory System ğŸ›’

```java
@Entity
@NamedNativeQuery(
    name = "findLowStockProducts",
    query = "SELECT p.* FROM products p " +
            "WHERE p.stock_quantity < p.minimum_threshold " +
            "ORDER BY p.stock_quantity ASC",
    resultClass = Product.class
)
public class Product {
    @Id
    private Long id;
    private String name;
    private int stockQuantity;
    private int minimumThreshold;
}
```

### 3. Student Management System ğŸ“

```java
@Entity
@NamedNativeQuery(
    name = "findTopStudentsByGrade",
    query = "SELECT s.* FROM students s " +
            "JOIN grades g ON s.id = g.student_id " +
            "WHERE g.percentage >= :minPercentage " +
            "ORDER BY g.percentage DESC LIMIT :limit",
    resultClass = Student.class
)
public class Student {
    @Id
    private Long id;
    private String name;
    private String email;
    private String course;
}
```

---

## âš–ï¸ Comparison Tables

### @NamedNativeQuery vs JPQL

| Feature | @NamedNativeQuery | JPQL |
|---------|-------------------|------|
| **SQL Type** | Native SQL ğŸ”¥ | Object-oriented queries ğŸ¯ |
| **Database Specific** | Yes (MySQL, PostgreSQL specific) | No (Database independent) |
| **Complex Joins** | Excellent support âœ… | Limited support âš ï¸ |
| **Performance** | Can be optimized ğŸš€ | Good but limited â­ |
| **Maintenance** | Database dependent âš ï¸ | Easy to maintain âœ… |
| **Learning Curve** | Need SQL knowledge ğŸ“š | Need JPQL knowledge ğŸ“– |

### @NamedNativeQuery vs @Query

| Aspect | @NamedNativeQuery | @Query (nativeQuery=true) |
|--------|-------------------|---------------------------|
| **Location** | Entity class ğŸ  | Repository interface ğŸ¢ |
| **Reusability** | High (can be used anywhere) âœ… | Limited to specific repository âš ï¸ |
| **Organization** | Centralized in entity ğŸ“ | Scattered in repositories ğŸ“‚ |
| **IDE Support** | Limited autocomplete âš ï¸ | Better IDE support âœ… |

---

## ğŸ¯ Interview Questions

### Q1: @NamedNativeQuery ka use kab karna chahiye?
**Answer:** 
```java
// Jab JPQL se complex query nahi ban sakti
@NamedNativeQuery(
    name = "complexReportQuery",
    query = "SELECT o.product, SUM(o.price) as total_sales, " +
            "COUNT(*) as order_count, " +
            "AVG(o.price) as avg_price " +
            "FROM orders o " +
            "WHERE o.created_date BETWEEN :startDate AND :endDate " +
            "GROUP BY o.product " +
            "HAVING COUNT(*) > 5 " +
            "ORDER BY total_sales DESC",
    resultSetMapping = "SalesReportMapping"
)
```

### Q2: Multiple parameters kaise pass karte hain?
**Answer:**
```java
@Service
public class OrderService {
    public List<Orders> getOrdersByMultipleFilters(
            String status, double minPrice, double maxPrice) {
        
        Query query = entityManager.createNamedQuery("findOrdersByFilters");
        query.setParameter("status", status);
        query.setParameter("minPrice", minPrice);
        query.setParameter("maxPrice", maxPrice);
        return query.getResultList();
    }
}
```

### Q3: DTO mapping kaise karte hain bina constructor ke?
**Answer:**
```java
@SqlResultSetMapping(
    name = "OrderSummaryMapping",
    columns = {
        @ColumnResult(name = "product", type = String.class),
        @ColumnResult(name = "total_orders", type = Long.class),
        @ColumnResult(name = "total_revenue", type = Double.class)
    }
)
```

---

## âš ï¸ Common Mistakes

### Mistake 1: Parameter naming mismatch ğŸ·ï¸
```java
// Wrong âŒ
@NamedNativeQuery(
    query = "SELECT * FROM orders WHERE status = :orderStatus"
)
// But setting parameter as:
query.setParameter("status", "PENDING"); // Wrong parameter name!

// Correct âœ…
query.setParameter("orderStatus", "PENDING");
```

### Mistake 2: Forgetting resultClass ğŸ“¦
```java
// Wrong âŒ - No resultClass specified
@NamedNativeQuery(
    name = "findOrders",
    query = "SELECT * FROM orders"
    // Missing resultClass!
)

// Correct âœ…
@NamedNativeQuery(
    name = "findOrders",
    query = "SELECT * FROM orders",
    resultClass = Orders.class
)
```

### Mistake 3: Case sensitivity in column names ğŸ“
```java
// Database column: product_name
// Entity field: productName

// Wrong âŒ
query = "SELECT product_name FROM orders" // Won't map properly

// Correct âœ…  
query = "SELECT product_name as productName FROM orders"
// OR use @Column annotation in entity
```

---

## ğŸŒŸ Best Practices

### 1. Query Organization ğŸ“
```java
// Good practice - Group related queries
@Entity
@NamedNativeQueries({
    @NamedNativeQuery(
        name = "Orders.findByStatus",
        query = "SELECT * FROM orders WHERE status = :status"
    ),
    @NamedNativeQuery(
        name = "Orders.findByDateRange", 
        query = "SELECT * FROM orders WHERE created_date BETWEEN :start AND :end"
    )
})
public class Orders {
    // Entity implementation
}
```

### 2. Parameter Validation ğŸ›¡ï¸
```java
@Service
public class OrderService {
    public List<Orders> getOrdersByStatus(String status) {
        // Validate input
        if (status == null || status.trim().isEmpty()) {
            throw new IllegalArgumentException("Status cannot be null or empty");
        }
        
        Query query = entityManager.createNamedQuery("findOrdersByStatus");
        query.setParameter("status", status.toUpperCase());
        return query.getResultList();
    }
}
```

### 3. Performance Optimization ğŸš€
```java
// Use pagination for large results
@Override
public Page<Orders> getOrdersByStatusPaged(String status, Pageable pageable) {
    Query query = entityManager.createNamedQuery("findOrdersByStatus");
    query.setParameter("status", status);
    query.setFirstResult((int) pageable.getOffset());
    query.setMaxResults(pageable.getPageSize());
    
    List<Orders> orders = query.getResultList();
    
    // Count query for total elements
    Query countQuery = entityManager.createNamedQuery("countOrdersByStatus");
    countQuery.setParameter("status", status);
    Long total = (Long) countQuery.getSingleResult();
    
    return new PageImpl<>(orders, pageable, total);
}
```

### 4. Error Handling ğŸ¯
```java
@Override
public List<Orders> getOrdersByStatus(String status) {
    try {
        Query query = entityManager.createNamedQuery("findOrdersByStatus");
        query.setParameter("status", status);
        return query.getResultList();
    } catch (IllegalArgumentException e) {
        log.error("Invalid query name or parameter: {}", e.getMessage());
        throw new ServiceException("Invalid query configuration", e);
    } catch (Exception e) {
        log.error("Database error while fetching orders: {}", e.getMessage());
        throw new ServiceException("Failed to fetch orders", e);
    }
}
```

---

## ğŸ“š Summary/Quick Recap

### Key Takeaways ğŸ¯
1. **@NamedNativeQuery** = Raw SQL queries with unique names ğŸ·ï¸
2. **Use when JPQL limitations** = Complex joins, database-specific functions ğŸ’ª
3. **Always use parameters** = Prevent SQL injection (:parameter) ğŸ›¡ï¸
4. **ResultClass/ResultSetMapping** = Map results to entities/DTOs ğŸ“¦
5. **EntityManager.createNamedQuery()** = Execute queries by name ğŸš€

### Memory Tricks ğŸ§ 
- **"Name it, Claim it, Frame it"** - Name the query, Use EntityManager, Map results
- **"Parameters are Paramounts"** - Always use :parameter, never concatenate
- **"Entity Manager is the Manager"** - It manages all your named queries

### When to Use What? ğŸ¤”

| Scenario | Use This | Why? |
|----------|----------|------|
| Simple CRUD operations | JPA Repository methods | Easiest and cleanest âœ¨ |
| Complex queries but portable | JPQL | Database independent ğŸŒ |
| Database-specific optimizations | @NamedNativeQuery | Full SQL power ğŸ’ª |
| Ad-hoc queries in repository | @Query(nativeQuery=true) | Quick and localized ğŸ¯ |

### Yaad Rakhne Ka Mantra ğŸµ
```
"Native query native power,
Entity mein define karo har hour,
Parameters se safe rakho,
ResultClass se map karo!"
```

---

### ğŸ”¥ Pro Tips for Interview

1. **Mention SQL Injection prevention** - Always talk about parameterized queries
2. **Compare with JPQL** - Show you know both approaches
3. **Talk about performance** - Native queries can be optimized better
4. **Entity vs Repository approach** - Know the difference between @NamedNativeQuery and @Query

### Common Interview Questions Ready Answers ğŸ’¡
- **"Why @NamedNativeQuery over JPQL?"** â†’ "Complex queries, database-specific functions, performance optimization"
- **"How to prevent SQL injection?"** â†’ "Always use :parameter, never string concatenation"
- **"DTO mapping in native queries?"** â†’ "Use @SqlResultSetMapping with @ConstructorResult"

---

**Happy Coding, Bhai! ğŸš€ Ab tum @NamedNativeQuery ke expert ho gaye! ğŸ’ª**
