# @NamedNativeQuery in JPA - Complete Study Notes 🚀

---

## 🎯 Introduction - Confusion Clear Karte Hain!

### Simple Words Mein Samjho Bhai! 👨‍🏫

**@NamedNativeQuery** ka matlab hai - "Apna custom SQL query likhna aur usse naam dena!" 

### Real-Life Analogy 🏪
Imagine karo ki tum ek restaurant mein ho:
- **JPQL** = Menu card mein jo dishes hain (limited options)
- **@NamedNativeQuery** = Chef se direct bolna "Yaar, mere liye kuch special banao!" (unlimited possibilities)

### Technical Definition 📚
The @NamedNativeQuery annotation in JPA allows us to specify native SQL queries directly in the JPA Entity class and execute them by name. This annotation is used when we need to execute complex SQL queries that cannot be easily expressed using the JPQL.

---

## 🔑 Key Terms/Concepts

| Term | Explanation |
|------|-------------|
| **@NamedNativeQuery** | Native SQL query with a unique name 🏷️ |
| **Native SQL** | Raw database-specific SQL queries |
| **ResultClass** | Entity ya DTO class for mapping results |
| **EntityManager** | JPA interface to interact with database |
| **@SqlResultSetMapping** | Maps query results to custom DTOs |

### Visual Representation 📊
```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   Entity Class  │───▶│ @NamedNativeQuery │───▶│   Database      │
│   (Orders.java) │    │   (SQL Query)     │    │   (orders table)│
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

---

## 💻 Detailed Examples

### Basic Syntax 🔧

```java
@NamedNativeQuery(
    name = "queryName",           // Unique identifier
    query = "SQL query here",     // Raw SQL
    resultClass = EntityName.class // Mapping class
)
```

### Complete Working Example - Orders Entity 🛍️

```java
@Entity
@Data
@NamedNativeQuery(
    name = "findOrdersByStatus",
    query = "SELECT * FROM orders WHERE status = :status",
    resultClass = Orders.class
)
public class Orders {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String product;
    private double price;
    private String status;
}
```

### Executing the Query 🏃‍♂️

```java
@Service
public class OrderServiceImpl implements OrderService {
    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<Orders> getOrdersByStatus(String status) {
        Query query = entityManager.createNamedQuery("findOrdersByStatus");
        query.setParameter("status", status);
        return query.getResultList();
    }
}
```

**Expected Output:** ✅
```
Hibernate: SELECT * FROM orders WHERE status = ?
[Orders(id=1, product=Laptop, price=2000.0, status=PENDING)]
```

### Multiple Named Queries Example 🔄

```java
@Entity
@Data
@NamedNativeQuery(
    name = "findOrdersByStatus",
    query = "SELECT * FROM orders WHERE status = :status",
    resultClass = Orders.class
)
@NamedNativeQuery(
    name = "findOrdersByPriceRange",
    query = "SELECT * FROM orders WHERE price BETWEEN :minPrice AND :maxPrice",
    resultClass = Orders.class
)
public class Orders {
    // Entity fields...
}
```

### DTO Mapping Example 📦

```java
// DTO Class
@Data
@AllArgsConstructor
public class OrderDTO {
    private String product;
    private double price;
}

// Entity with DTO Mapping
@Entity
@Data
@SqlResultSetMapping(
    name = "OrderDTOResult",
    classes = @ConstructorResult(
        targetClass = OrderDTO.class,
        columns = {
            @ColumnResult(name = "product", type = String.class),
            @ColumnResult(name = "price", type = Double.class)
        }
    )
)
@NamedNativeQuery(
    name = "findOrderDTOsByStatus",
    query = "SELECT product, price FROM orders WHERE status = :status",
    resultSetMapping = "OrderDTOResult"
)
public class Orders {
    // Entity fields...
}
```

---

## 📋 Rules/Guidelines

### ✅ Do's (Ye Karo Bhai!)

1. **✅ Always use parameter placeholders**
   ```java
   // Correct ✅
   query = "SELECT * FROM orders WHERE status = :status"
   
   // Wrong ❌
   query = "SELECT * FROM orders WHERE status = 'PENDING'"
   ```

2. **✅ Use unique names for queries**
   ```java
   @NamedNativeQuery(name = "findOrdersByStatus", ...) // ✅ Clear name
   @NamedNativeQuery(name = "query1", ...)            // ❌ Confusing name
   ```

3. **✅ Specify resultClass properly**
   ```java
   resultClass = Orders.class // ✅ Correct mapping
   ```

### ❌ Don'ts (Inse Bacho!)

1. **❌ Never use string concatenation for queries**
   ```java
   // Wrong ❌ - SQL Injection risk!
   String sql = "SELECT * FROM orders WHERE status = '" + status + "'";
   ```

2. **❌ Don't forget @PersistenceContext**
   ```java
   // Wrong ❌
   EntityManager em; // Null pointer exception!
   
   // Correct ✅
   @PersistenceContext
   EntityManager entityManager;
   ```

### Error Examples with Solutions 🚨

**Common Error 1:**
```
Error: org.hibernate.QueryException: No data type for node
```
**Solution:** Specify proper resultClass or resultSetMapping

**Common Error 2:**
```
Error: javax.persistence.NoResultException
```
**Solution:** Use `getResultList()` instead of `getSingleResult()`

---

## 🌍 Real-world Applications

### 1. Banking System Example 🏦

```java
@Entity
@NamedNativeQuery(
    name = "findHighValueTransactions",
    query = "SELECT t.* FROM transactions t " +
            "WHERE t.amount > :amount AND t.transaction_date >= :startDate",
    resultClass = Transaction.class
)
public class Transaction {
    @Id
    private Long id;
    private BigDecimal amount;
    private LocalDateTime transactionDate;
    private String accountNumber;
}
```

### 2. E-commerce Inventory System 🛒

```java
@Entity
@NamedNativeQuery(
    name = "findLowStockProducts",
    query = "SELECT p.* FROM products p " +
            "WHERE p.stock_quantity < p.minimum_threshold " +
            "ORDER BY p.stock_quantity ASC",
    resultClass = Product.class
)
public class Product {
    @Id
    private Long id;
    private String name;
    private int stockQuantity;
    private int minimumThreshold;
}
```

### 3. Student Management System 🎓

```java
@Entity
@NamedNativeQuery(
    name = "findTopStudentsByGrade",
    query = "SELECT s.* FROM students s " +
            "JOIN grades g ON s.id = g.student_id " +
            "WHERE g.percentage >= :minPercentage " +
            "ORDER BY g.percentage DESC LIMIT :limit",
    resultClass = Student.class
)
public class Student {
    @Id
    private Long id;
    private String name;
    private String email;
    private String course;
}
```

---

## ⚖️ Comparison Tables

### @NamedNativeQuery vs JPQL

| Feature | @NamedNativeQuery | JPQL |
|---------|-------------------|------|
| **SQL Type** | Native SQL 🔥 | Object-oriented queries 🎯 |
| **Database Specific** | Yes (MySQL, PostgreSQL specific) | No (Database independent) |
| **Complex Joins** | Excellent support ✅ | Limited support ⚠️ |
| **Performance** | Can be optimized 🚀 | Good but limited ⭐ |
| **Maintenance** | Database dependent ⚠️ | Easy to maintain ✅ |
| **Learning Curve** | Need SQL knowledge 📚 | Need JPQL knowledge 📖 |

### @NamedNativeQuery vs @Query

| Aspect | @NamedNativeQuery | @Query (nativeQuery=true) |
|--------|-------------------|---------------------------|
| **Location** | Entity class 🏠 | Repository interface 🏢 |
| **Reusability** | High (can be used anywhere) ✅ | Limited to specific repository ⚠️ |
| **Organization** | Centralized in entity 📁 | Scattered in repositories 📂 |
| **IDE Support** | Limited autocomplete ⚠️ | Better IDE support ✅ |

---

## 🎯 Interview Questions

### Q1: @NamedNativeQuery ka use kab karna chahiye?
**Answer:** 
```java
// Jab JPQL se complex query nahi ban sakti
@NamedNativeQuery(
    name = "complexReportQuery",
    query = "SELECT o.product, SUM(o.price) as total_sales, " +
            "COUNT(*) as order_count, " +
            "AVG(o.price) as avg_price " +
            "FROM orders o " +
            "WHERE o.created_date BETWEEN :startDate AND :endDate " +
            "GROUP BY o.product " +
            "HAVING COUNT(*) > 5 " +
            "ORDER BY total_sales DESC",
    resultSetMapping = "SalesReportMapping"
)
```

### Q2: Multiple parameters kaise pass karte hain?
**Answer:**
```java
@Service
public class OrderService {
    public List<Orders> getOrdersByMultipleFilters(
            String status, double minPrice, double maxPrice) {
        
        Query query = entityManager.createNamedQuery("findOrdersByFilters");
        query.setParameter("status", status);
        query.setParameter("minPrice", minPrice);
        query.setParameter("maxPrice", maxPrice);
        return query.getResultList();
    }
}
```

### Q3: DTO mapping kaise karte hain bina constructor ke?
**Answer:**
```java
@SqlResultSetMapping(
    name = "OrderSummaryMapping",
    columns = {
        @ColumnResult(name = "product", type = String.class),
        @ColumnResult(name = "total_orders", type = Long.class),
        @ColumnResult(name = "total_revenue", type = Double.class)
    }
)
```

---

## ⚠️ Common Mistakes

### Mistake 1: Parameter naming mismatch 🏷️
```java
// Wrong ❌
@NamedNativeQuery(
    query = "SELECT * FROM orders WHERE status = :orderStatus"
)
// But setting parameter as:
query.setParameter("status", "PENDING"); // Wrong parameter name!

// Correct ✅
query.setParameter("orderStatus", "PENDING");
```

### Mistake 2: Forgetting resultClass 📦
```java
// Wrong ❌ - No resultClass specified
@NamedNativeQuery(
    name = "findOrders",
    query = "SELECT * FROM orders"
    // Missing resultClass!
)

// Correct ✅
@NamedNativeQuery(
    name = "findOrders",
    query = "SELECT * FROM orders",
    resultClass = Orders.class
)
```

### Mistake 3: Case sensitivity in column names 📝
```java
// Database column: product_name
// Entity field: productName

// Wrong ❌
query = "SELECT product_name FROM orders" // Won't map properly

// Correct ✅  
query = "SELECT product_name as productName FROM orders"
// OR use @Column annotation in entity
```

---

## 🌟 Best Practices

### 1. Query Organization 📁
```java
// Good practice - Group related queries
@Entity
@NamedNativeQueries({
    @NamedNativeQuery(
        name = "Orders.findByStatus",
        query = "SELECT * FROM orders WHERE status = :status"
    ),
    @NamedNativeQuery(
        name = "Orders.findByDateRange", 
        query = "SELECT * FROM orders WHERE created_date BETWEEN :start AND :end"
    )
})
public class Orders {
    // Entity implementation
}
```

### 2. Parameter Validation 🛡️
```java
@Service
public class OrderService {
    public List<Orders> getOrdersByStatus(String status) {
        // Validate input
        if (status == null || status.trim().isEmpty()) {
            throw new IllegalArgumentException("Status cannot be null or empty");
        }
        
        Query query = entityManager.createNamedQuery("findOrdersByStatus");
        query.setParameter("status", status.toUpperCase());
        return query.getResultList();
    }
}
```

### 3. Performance Optimization 🚀
```java
// Use pagination for large results
@Override
public Page<Orders> getOrdersByStatusPaged(String status, Pageable pageable) {
    Query query = entityManager.createNamedQuery("findOrdersByStatus");
    query.setParameter("status", status);
    query.setFirstResult((int) pageable.getOffset());
    query.setMaxResults(pageable.getPageSize());
    
    List<Orders> orders = query.getResultList();
    
    // Count query for total elements
    Query countQuery = entityManager.createNamedQuery("countOrdersByStatus");
    countQuery.setParameter("status", status);
    Long total = (Long) countQuery.getSingleResult();
    
    return new PageImpl<>(orders, pageable, total);
}
```

### 4. Error Handling 🎯
```java
@Override
public List<Orders> getOrdersByStatus(String status) {
    try {
        Query query = entityManager.createNamedQuery("findOrdersByStatus");
        query.setParameter("status", status);
        return query.getResultList();
    } catch (IllegalArgumentException e) {
        log.error("Invalid query name or parameter: {}", e.getMessage());
        throw new ServiceException("Invalid query configuration", e);
    } catch (Exception e) {
        log.error("Database error while fetching orders: {}", e.getMessage());
        throw new ServiceException("Failed to fetch orders", e);
    }
}
```

---

## 📚 Summary/Quick Recap

### Key Takeaways 🎯
1. **@NamedNativeQuery** = Raw SQL queries with unique names 🏷️
2. **Use when JPQL limitations** = Complex joins, database-specific functions 💪
3. **Always use parameters** = Prevent SQL injection (:parameter) 🛡️
4. **ResultClass/ResultSetMapping** = Map results to entities/DTOs 📦
5. **EntityManager.createNamedQuery()** = Execute queries by name 🚀

### Memory Tricks 🧠
- **"Name it, Claim it, Frame it"** - Name the query, Use EntityManager, Map results
- **"Parameters are Paramounts"** - Always use :parameter, never concatenate
- **"Entity Manager is the Manager"** - It manages all your named queries

### When to Use What? 🤔

| Scenario | Use This | Why? |
|----------|----------|------|
| Simple CRUD operations | JPA Repository methods | Easiest and cleanest ✨ |
| Complex queries but portable | JPQL | Database independent 🌐 |
| Database-specific optimizations | @NamedNativeQuery | Full SQL power 💪 |
| Ad-hoc queries in repository | @Query(nativeQuery=true) | Quick and localized 🎯 |

### Yaad Rakhne Ka Mantra 🎵
```
"Native query native power,
Entity mein define karo har hour,
Parameters se safe rakho,
ResultClass se map karo!"
```

---

### 🔥 Pro Tips for Interview

1. **Mention SQL Injection prevention** - Always talk about parameterized queries
2. **Compare with JPQL** - Show you know both approaches
3. **Talk about performance** - Native queries can be optimized better
4. **Entity vs Repository approach** - Know the difference between @NamedNativeQuery and @Query

### Common Interview Questions Ready Answers 💡
- **"Why @NamedNativeQuery over JPQL?"** → "Complex queries, database-specific functions, performance optimization"
- **"How to prevent SQL injection?"** → "Always use :parameter, never string concatenation"
- **"DTO mapping in native queries?"** → "Use @SqlResultSetMapping with @ConstructorResult"

---

**Happy Coding, Bhai! 🚀 Ab tum @NamedNativeQuery ke expert ho gaye! 💪**
