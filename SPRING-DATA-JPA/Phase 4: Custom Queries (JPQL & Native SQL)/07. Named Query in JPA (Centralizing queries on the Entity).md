# Named Query in JPA Spring Boot - Complete Study Notes 📚

## 🎯 Introduction with Confusion Clearing

### Simple Explanation First 🤔
Bhai, **Named Query** ko simple words mein samjho - ye ek tarika hai apne database queries ko pre-define karne ka! Matlab tumne ek baar query likh di, usko ek naam de diya, aur phir bas naam se call kar sakte ho! 

### Real-life Analogy 🏠
Soch ke dekho, tumhare ghar mein ek recipe book hai. Usme "Maggi Recipe" naam se ek recipe likhi hai. Har baar maggi banane ke liye tumhe poori recipe nahi likhni padti - bas "Maggi Recipe" bolo aur kaam ho gaya! Same concept hai Named Query ka! 

### Technical Definition 💻
**Named Query (@NamedQuery)** ek JPA annotation hai jo tumhe JPQL queries ko Entity class level par define karne ki facility deta hai with a unique name. Ye queries reusable hoti hain aur better maintainability provide karti hain.

---

## 🔑 Key Terms/Concepts

| Term | Hindi Meaning | Description |
|------|---------------|-------------|
| **@NamedQuery** | नामित प्रश्न | JPA annotation for defining queries with names |
| **JPQL** | Java Persistence Query Language | Java ka special query language |
| **EntityManager** | इकाई प्रबंधक | JPA ka main interface for database operations |
| **@PersistenceContext** | संदर्भ अन्तक्षेप | EntityManager inject karne ke liye |
| **Parameter Binding** | मापदंड बंधन | Query parameters set karna |

### Visual Representation 📊
```
Entity Class
    ↓
@NamedQuery(name="queryName", query="JPQL")
    ↓
Service/Repository
    ↓
EntityManager.createNamedQuery("queryName")
    ↓
Database Result
```

---

## 💡 Detailed Examples

### 1. Basic Named Query Example 

```java
// Entity Class - Orders.java
@Entity
@Data
@NamedQuery(
    name = "findOrdersByStatus",  // Unique naam 
    query = "SELECT o FROM Orders o WHERE status = :status"  // JPQL query
)
public class Orders {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String product;
    private double price;
    private String status;
}
```

**Expected Output:** Ye query specific status wale orders return karegi

### 2. Service Implementation - EntityManager se

```java
@Service
public class OrderServiceImpl implements OrderService {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public List<Orders> getOrdersByStatus(String status) {
        // Named query ko naam se call karo
        Query query = entityManager.createNamedQuery("findOrdersByStatus");
        
        // Parameter set karo
        query.setParameter("status", status);
        
        // Results return karo
        return query.getResultList();
    }
}
```

### 3. Repository Implementation

```java
public interface OrderRepository extends JpaRepository<Orders, Long> {
    
    @Query(name = "findOrdersByStatus")  // Named query link karo
    List<Orders> findOrdersByStatus(String status);
}
```

**Step-by-step Explanation:**
1. **Entity par @NamedQuery define kiya** - Query ko naam diya
2. **Service mein EntityManager use kiya** - Query execute karne ke liye
3. **Repository method banaya** - Easy access ke liye

---

## 📋 Rules/Guidelines

### Rule 1: Unique Names Required ✅
```java
// ✅ Correct - Unique names
@NamedQuery(name = "findOrdersByStatus", query = "...")
@NamedQuery(name = "findOrdersByPrice", query = "...")

// ❌ Wrong - Duplicate names
@NamedQuery(name = "findOrders", query = "...")
@NamedQuery(name = "findOrders", query = "...")  // Error!
```

### Rule 2: Parameter Binding is Mandatory ✅
```java
// ✅ Correct - Parameter binding
query.setParameter("status", "PENDING");

// ❌ Wrong - Direct string concatenation
query = "SELECT o FROM Orders o WHERE status = 'PENDING'";  // SQL Injection risk!
```

### Rule 3: JPQL Syntax Must Be Correct ✅
```java
// ✅ Correct JPQL
"SELECT o FROM Orders o WHERE o.status = :status"

// ❌ Wrong - SQL syntax in JPQL
"SELECT * FROM orders WHERE status = :status"  // Wrong table name!
```

**Error Example:**
```
QuerySyntaxException: unexpected token: * near line 1, column 8
[SELECT * FROM Orders o WHERE status = :status]
```

---

## 🌟 Real-world Applications

### 1. Banking System Example 🏦

```java
@Entity
@NamedQuery(
    name = "findAccountsByBalance",
    query = "SELECT a FROM Account a WHERE a.balance >= :minBalance"
)
@NamedQuery(
    name = "findTransactionsByDateRange", 
    query = "SELECT t FROM Transaction t WHERE t.date BETWEEN :startDate AND :endDate"
)
public class Account {
    @Id private Long accountNumber;
    private String customerName;
    private Double balance;
    private String accountType;
}
```

### 2. E-commerce System 🛒

```java
@Entity
@NamedQuery(
    name = "findProductsByCategory",
    query = "SELECT p FROM Product p WHERE p.category = :category"
)
@NamedQuery(
    name = "findTopSellingProducts",
    query = "SELECT p FROM Product p ORDER BY p.salesCount DESC"
)
public class Product {
    @Id private Long id;
    private String name;
    private String category;
    private Double price;
    private Integer salesCount;
}
```

### 3. Educational System 📚

```java
@Entity
@NamedQuery(
    name = "findStudentsByGrade",
    query = "SELECT s FROM Student s WHERE s.grade >= :minGrade"
)
public class Student {
    @Id private Long rollNumber;
    private String name;
    private String course;
    private Double grade;
}
```

---

## 🆚 Comparison Tables

### Named Query vs Regular Repository Methods

| Feature | Named Query | Repository Methods |
|---------|-------------|-------------------|
| **Definition Location** | Entity Class | Repository Interface |
| **Reusability** | ✅ High | ❌ Medium |
| **Complex Queries** | ✅ Excellent | ❌ Limited |
| **Maintainability** | ✅ Better | ❌ Scattered |
| **Type Safety** | ❌ Runtime Check | ✅ Compile Time |
| **IDE Support** | ❌ Limited | ✅ Full Support |

### EntityManager vs Repository Approach

| Aspect | EntityManager | Repository |
|--------|---------------|------------|
| **Code Length** | 🔴 More Code | 🟢 Less Code |
| **Flexibility** | 🟢 High | 🔴 Medium |
| **Parameter Handling** | 🔴 Manual | 🟢 Automatic |
| **Error Handling** | 🔴 Manual | 🟢 Spring Managed |

---

## 🎤 Interview Questions

### Q1: What is Named Query in JPA and why use it?
**Answer:** 
Bhai, Named Query ek pre-defined JPQL query hai jo Entity level par define hoti hai. Iska main fayda ye hai:

```java
@NamedQuery(
    name = "User.findByEmail",
    query = "SELECT u FROM User u WHERE u.email = :email"
)
```

**Benefits:**
- **Reusability** - Ek baar define, multiple places use
- **Performance** - Query pre-compiled hoti hai
- **Maintainability** - Centralized query management

### Q2: How to handle multiple parameters in Named Query?

**Answer:**
```java
@NamedQuery(
    name = "findOrdersByPriceRange",
    query = "SELECT o FROM Orders o WHERE o.price BETWEEN :minPrice AND :maxPrice"
)

// Usage
Query query = entityManager.createNamedQuery("findOrdersByPriceRange");
query.setParameter("minPrice", 1000.0);
query.setParameter("maxPrice", 5000.0);
return query.getResultList();
```

### Q3: How to return DTO from Named Query?

**Answer:**
Constructor expression ka use karo:

```java
@NamedQuery(
    name = "findOrderDTOs",
    query = "SELECT NEW com.example.OrderDTO(o.product, o.price) FROM Orders o"
)

// DTO Class
public class OrderDTO {
    private String product;
    private Double price;
    
    public OrderDTO(String product, Double price) {
        this.product = product;
        this.price = price;
    }
}
```

### Q4: What happens if Named Query name is duplicate?

**Answer:**
```java
// This will throw exception
@NamedQuery(name = "findAll", query = "SELECT o FROM Orders o")
@NamedQuery(name = "findAll", query = "SELECT u FROM Users u")  // ERROR!
```

**Exception:**
```
org.hibernate.DuplicateMappingException: Duplicate query mapping: findAll
```

---

## ⚠️ Common Mistakes

### Mistake 1: SQL Syntax in JPQL ❌
```java
// ❌ Wrong - SQL syntax
@NamedQuery(
    name = "findOrders",
    query = "SELECT * FROM orders WHERE status = 'PENDING'"
)

// ✅ Correct - JPQL syntax  
@NamedQuery(
    name = "findOrders", 
    query = "SELECT o FROM Orders o WHERE o.status = 'PENDING'"
)
```

### Mistake 2: Forgetting Parameter Binding ❌
```java
// ❌ Wrong - Hard coded values
@NamedQuery(
    name = "findPendingOrders",
    query = "SELECT o FROM Orders o WHERE o.status = 'PENDING'"
)

// ✅ Correct - Parameter binding
@NamedQuery(
    name = "findOrdersByStatus",
    query = "SELECT o FROM Orders o WHERE o.status = :status"
)
```

### Mistake 3: Wrong Table/Entity Names ❌
```java
// ❌ Wrong - Database table name used
query = "SELECT o FROM orders o"  // 'orders' is table name

// ✅ Correct - Entity class name used
query = "SELECT o FROM Orders o"  // 'Orders' is entity name
```

### Mistake 4: Missing Constructor in DTO ❌
```java
// ❌ Wrong - No constructor
public class OrderDTO {
    private String product;
    private Double price;
    // Missing constructor!
}

// ✅ Correct - Constructor present
public class OrderDTO {
    private String product;
    private Double price;
    
    public OrderDTO(String product, Double price) {  // Constructor required!
        this.product = product;
        this.price = price;
    }
}
```

---

## 🏆 Best Practices

### 1. Naming Conventions 📝
```java
// ✅ Good naming
@NamedQuery(name = "User.findByEmail", query = "...")
@NamedQuery(name = "Order.findByStatus", query = "...")
@NamedQuery(name = "Product.findByCategory", query = "...")

// ❌ Bad naming  
@NamedQuery(name = "q1", query = "...")
@NamedQuery(name = "getUserQuery", query = "...")
```

### 2. Parameter Validation 🔒
```java
@Override
public List<Orders> getOrdersByStatus(String status) {
    // ✅ Parameter validation
    if (status == null || status.trim().isEmpty()) {
        throw new IllegalArgumentException("Status cannot be null or empty");
    }
    
    Query query = entityManager.createNamedQuery("findOrdersByStatus");
    query.setParameter("status", status);
    return query.getResultList();
}
```

### 3. Exception Handling 🛡️
```java
@Override
public List<Orders> getOrdersByPriceRange(double minPrice, double maxPrice) {
    try {
        Query query = entityManager.createNamedQuery("findOrdersByPriceRange");
        query.setParameter("minPrice", minPrice);
        query.setParameter("maxPrice", maxPrice);
        return query.getResultList();
    } catch (Exception e) {
        log.error("Error executing named query: {}", e.getMessage());
        throw new DataAccessException("Failed to fetch orders", e);
    }
}
```

### 4. Documentation 📖
```java
/**
 * Named Query to find orders by status
 * @param status Order status (PENDING, COMPLETED, CANCELLED)
 * @return List of orders with specified status
 */
@NamedQuery(
    name = "findOrdersByStatus",
    query = "SELECT o FROM Orders o WHERE o.status = :status"
)
```

### 5. Performance Optimization 🚀
```java
// ✅ Use indexed columns in WHERE clause
@NamedQuery(
    name = "findOrdersByIndexedStatus", 
    query = "SELECT o FROM Orders o WHERE o.status = :status"  // status should be indexed
)

// ✅ Limit results for large datasets
@NamedQuery(
    name = "findRecentOrders",
    query = "SELECT o FROM Orders o ORDER BY o.createdDate DESC"
)

// Usage with pagination
query.setFirstResult(0);
query.setMaxResults(10);
```

---

## 📝 Summary/Quick Recap

### Key Takeaways 🎯
1. **Named Query = Pre-defined JPQL with unique name**
2. **Entity level par define karte hain** 
3. **EntityManager ya Repository se execute karte hain**
4. **Parameter binding always use karo**
5. **Constructor expression se DTO return kar sakte hain**

### Memory Tricks 🧠
- **Name + Query = Named Query** (Simple!)
- **Entity par define, Service mein execute**
- **Parameters always bind (SQL injection se bacho)**
- **JPQL syntax use karo, SQL nahi**

### When to Use What 🤔

| Use Named Query When | Use Repository Methods When |
|---------------------|----------------------------|
| 🔴 Complex JPQL queries | 🟢 Simple CRUD operations |
| 🔴 Query reusability needed | 🟢 Quick development |
| 🔴 Custom business logic | 🟢 Standard operations |
| 🔴 Performance optimization | 🟢 Type safety important |

---

## 🚀 Advanced Examples

### Multiple Named Queries in Single Entity
```java
@Entity
@NamedQueries({
    @NamedQuery(
        name = "Orders.findByStatus",
        query = "SELECT o FROM Orders o WHERE o.status = :status"
    ),
    @NamedQuery(
        name = "Orders.findByPriceRange", 
        query = "SELECT o FROM Orders o WHERE o.price BETWEEN :minPrice AND :maxPrice"
    ),
    @NamedQuery(
        name = "Orders.findExpensiveOrders",
        query = "SELECT o FROM Orders o WHERE o.price > 1000 ORDER BY o.price DESC"
    )
})
public class Orders {
    // Entity fields...
}
```

### Complex Query with Joins
```java
@NamedQuery(
    name = "Orders.findWithCustomerDetails",
    query = "SELECT o FROM Orders o JOIN FETCH o.customer c WHERE o.status = :status"
)
```

### Count Query Example
```java
@NamedQuery(
    name = "Orders.countByStatus",
    query = "SELECT COUNT(o) FROM Orders o WHERE o.status = :status"
)

// Usage
public Long countOrdersByStatus(String status) {
    Query query = entityManager.createNamedQuery("Orders.countByStatus");
    query.setParameter("status", status);
    return (Long) query.getSingleResult();
}
```

---

## 🎭 Pro Tips

### Tip 1: Query Validation at Startup
```java
// Spring Boot automatically validates Named Queries at startup
// If query is wrong, application won't start - good for catching errors early!
```

### Tip 2: Use Query Hints for Performance
```java
@NamedQuery(
    name = "Orders.findWithHints",
    query = "SELECT o FROM Orders o WHERE o.status = :status",
    hints = {
        @QueryHint(name = "org.hibernate.cacheable", value = "true"),
        @QueryHint(name = "org.hibernate.readOnly", value = "true")
    }
)
```

### Tip 3: Native SQL Alternative
```java
@NamedNativeQuery(
    name = "Orders.findByNativeQuery",
    query = "SELECT * FROM orders WHERE status = :status",
    resultClass = Orders.class
)
```

---

## 🎉 Conclusion

Bhai, Named Query ek powerful feature hai JPA ka! Ye tumhare queries ko organized rakhta hai aur performance bhi improve karta hai. Remember:

- **Simple से start karo** - Basic queries se
- **Best practices follow karo** - Naming conventions, parameter binding
- **Error handling add karo** - Production ready code ke liye  
- **Performance optimize karo** - Indexing aur hints use karo

**Final mantra:** Named Query = Reusable + Maintainable + Performance Optimized! 🚀

Happy Coding, Bhai! 💻✨
