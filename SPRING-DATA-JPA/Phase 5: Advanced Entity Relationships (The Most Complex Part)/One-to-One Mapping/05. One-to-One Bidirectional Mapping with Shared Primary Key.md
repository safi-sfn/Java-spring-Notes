# 🚀 Spring Data JPA: One-to-One Bidirectional Mapping with Shared Primary Key

## 🌟 Introduction - Confusion Clear Karte Hain Bhai! 

### Simple Explanation First 🤔
Yaar, shared primary key wala one-to-one mapping matlab ye hai ki dono tables mein same primary key use karte hain. Bidirectional means dono side se navigate kar sakte ho!

### Real-Life Analogy 🏠
Samjho yaar, **Employee aur Address** ka relation hai:
- Ek employee sirf ek address pe rehta hai 🏡
- Ek address pe sirf ek employee rehta hai 👤
- Dono tables ka same ID hoga (shared primary key) 🔑
- Employee se Address ja sakte ho, Address se Employee ja sakte ho (bidirectional) 🔄

### Technical Definition 📚
One-to-one bidirectional mapping with shared primary key means both entities share the same primary key value and can navigate the relationship from either side.

---

## 📋 Key Terms/Concepts

| Term | Meaning | Use Case |
|------|---------|----------|
| `@OneToOne` | One-to-one relationship annotation | Entity relationship mapping |
| `@PrimaryKeyJoinColumn` | Join using primary key | Shared primary key mapping |
| `mappedBy` | Non-owning side indicator | Bidirectional mapping |
| `CascadeType.ALL` | All operations cascade | Auto save/update/delete |

### Visual Representation 🎨
```
┌─────────────┐    ┌─────────────┐
│  Employee   │◄──►│   Address   │
├─────────────┤    ├─────────────┤
│ id (PK)     │    │ id (PK)     │
│ name        │    │ street      │
│ email       │    │ city        │
│ mobile      │    │ state       │
│ designation │    │ employee_id │
└─────────────┘    └─────────────┘
     SAME ID VALUES (Shared PK)
```

---

## 💻 Complete Working Example

### 1. Maven Dependencies
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

### 2. Entity Classes

#### Employee Entity (Parent/Owning Side) 👨‍💼
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    private String emailId;
    private String mobNo;
    private String design;
    
    // ✅ Bidirectional mapping - mappedBy indicates non-owning side
    @OneToOne(mappedBy = "employee", cascade = CascadeType.ALL)
    private Address address;
}
```

#### Address Entity (Child/Non-owning Side) 🏠
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Address {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String street;
    private String city;
    private String state;
    
    // ✅ Owner side with @PrimaryKeyJoinColumn
    @OneToOne
    @PrimaryKeyJoinColumn
    private Employee employee;
}
```

### 3. Repository Interfaces
```java
// EmployeeRepository.java
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
}

// AddressRepository.java  
@Repository
public interface AddressRepository extends JpaRepository<Address, Integer> {
}
```

### 4. Service Layer
```java
@Service
public class EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    public Employee saveEmployee(Employee employee) {
        return employeeRepository.save(employee);
    }
    
    public List<Employee> getAllEmployees() {
        return employeeRepository.findAll();
    }
    
    public Optional<Employee> getEmployeeById(Integer id) {
        return employeeRepository.findById(id);
    }
}
```

### 5. Model Class (DTO)
```java
@Data
public class EmployeeModel {
    private Integer id;
    private String name;
    private String emailId;
    private String mobNo;
    private String design;
    private String street;
    private String city;
    private String state;
}
```

### 6. REST Controller
```java
@RestController
@RequestMapping("/api")
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    @PostMapping("/save")
    public ResponseEntity<?> saveEmployee(@RequestBody EmployeeModel model) {
        
        // Create Address object
        Address address = new Address();
        address.setStreet(model.getStreet());
        address.setCity(model.getCity());
        address.setState(model.getState());
        
        // Create Employee object
        Employee employee = new Employee();
        employee.setName(model.getName());
        employee.setEmailId(model.getEmailId());
        employee.setMobNo(model.getMobNo());
        employee.setDesign(model.getDesign());
        employee.setAddress(address);
        
        // Set bidirectional relationship
        address.setEmployee(employee);
        
        Employee savedEmployee = employeeService.saveEmployee(employee);
        
        return ResponseEntity.ok()
            .body(Map.of("status", 1, "message", "Employee saved successfully!"));
    }
    
    @GetMapping("/employees")
    public ResponseEntity<List<EmployeeModel>> getAllEmployees() {
        List<Employee> employees = employeeService.getAllEmployees();
        List<EmployeeModel> models = employees.stream()
            .map(this::convertToModel)
            .collect(Collectors.toList());
        
        return ResponseEntity.ok(models);
    }
    
    private EmployeeModel convertToModel(Employee emp) {
        EmployeeModel model = new EmployeeModel();
        model.setId(emp.getId());
        model.setName(emp.getName());
        model.setEmailId(emp.getEmailId());
        model.setMobNo(emp.getMobNo());
        model.setDesign(emp.getDesign());
        
        // Accessing address through bidirectional mapping
        if (emp.getAddress() != null) {
            model.setStreet(emp.getAddress().getStreet());
            model.setCity(emp.getAddress().getCity());
            model.setState(emp.getAddress().getState());
        }
        
        return model;
    }
}
```

### Expected Output 📤
#### POST Request: `/api/save`
```json
{
    "name": "Rahul Sharma",
    "emailId": "rahul@gmail.com", 
    "mobNo": "9876543210",
    "design": "Software Developer",
    "street": "123 Main Street",
    "city": "Delhi",
    "state": "Delhi"
}
```

#### Response:
```json
{
    "status": 1,
    "message": "Employee saved successfully!"
}
```

#### GET Request: `/api/employees`
```json
[
    {
        "id": 1,
        "name": "Rahul Sharma",
        "emailId": "rahul@gmail.com",
        "mobNo": "9876543210", 
        "design": "Software Developer",
        "street": "123 Main Street",
        "city": "Delhi",
        "state": "Delhi"
    }
]
```

---

## ⚖️ Rules & Guidelines

### ✅ DO's:

1. **Always use `@PrimaryKeyJoinColumn` on owning side**
   ```java
   @OneToOne
   @PrimaryKeyJoinColumn  // ✅ Correct
   private Employee employee;
   ```

2. **Use `mappedBy` on non-owning side**
   ```java
   @OneToOne(mappedBy = "employee")  // ✅ Correct
   private Address address;
   ```

3. **Set cascade operations for automatic operations**
   ```java
   @OneToOne(mappedBy = "employee", cascade = CascadeType.ALL)  // ✅ Correct
   private Address address;
   ```

4. **Always set both sides in bidirectional relationship**
   ```java
   // ✅ Correct approach
   employee.setAddress(address);
   address.setEmployee(employee);  // Set both sides!
   ```

### ❌ DON'Ts:

1. **Don't use `@JoinColumn` with shared primary key**
   ```java
   @OneToOne
   @JoinColumn(name = "employee_id")  // ❌ Wrong for shared PK
   private Employee employee;
   ```

2. **Don't forget to set both sides**
   ```java
   employee.setAddress(address);
   // address.setEmployee(employee);  // ❌ Missing this!
   ```

3. **Don't use `mappedBy` on owning side**
   ```java
   @OneToOne(mappedBy = "address")  // ❌ Wrong side
   @PrimaryKeyJoinColumn
   private Employee employee;
   ```

---

## 🌍 Real-World Applications

### 1. Banking System 🏦
```java
// Account and AccountDetails share same ID
@Entity
public class Account {
    @Id
    @GeneratedValue
    private Long accountNumber;
    
    @OneToOne(mappedBy = "account", cascade = CascadeType.ALL)
    private AccountDetails details;
}

@Entity  
public class AccountDetails {
    @Id
    private Long accountNumber;
    
    private String branch;
    private String ifscCode;
    
    @OneToOne
    @PrimaryKeyJoinColumn
    private Account account;
}
```

### 2. User Profile System 👤
```java
@Entity
public class User {
    @Id
    @GeneratedValue
    private Long userId;
    
    @OneToOne(mappedBy = "user", cascade = CascadeType.ALL)
    private UserProfile profile;
}

@Entity
public class UserProfile {
    @Id  
    private Long userId;
    
    private String bio;
    private String profilePicture;
    
    @OneToOne
    @PrimaryKeyJoinColumn
    private User user;
}
```

---

## 📊 Comparison Table

| Feature | Foreign Key Approach | Shared Primary Key |
|---------|---------------------|-------------------|
| **Performance** | Good | Better ⭐ |
| **Storage** | More space needed | Less space needed ⭐ |
| **Complexity** | Simple | Moderate |
| **Flexibility** | High | Lower |
| **Use Case** | Optional relationships | Mandatory relationships ⭐ |
| **Lazy Loading** | Works well | Works better ⭐ |

---

## 🎯 Interview Questions & Answers

### Q1: What is the difference between shared primary key and foreign key approach?
**Answer:**
```java
// Shared Primary Key - Same ID values
Employee(id=1) ↔ Address(id=1)  // Both have ID = 1

// Foreign Key - Different ID values  
Employee(id=1) ↔ Address(id=5, employee_id=1)  // Different IDs
```

### Q2: Why use `@PrimaryKeyJoinColumn`?
**Answer:** 
`@PrimaryKeyJoinColumn` tells Hibernate to use the primary key of the referenced entity as the foreign key. This creates a shared primary key relationship.

### Q3: Which side should be the owning side?
**Answer:**
```java
// ✅ Child entity (Address) should be owning side
@Entity
public class Address {
    @OneToOne
    @PrimaryKeyJoinColumn  // Owning side
    private Employee employee;
}

// ✅ Parent entity (Employee) is non-owning side  
@Entity
public class Employee {
    @OneToOne(mappedBy = "employee")  // Non-owning side
    private Address address;
}
```

### Q4: How to handle cascade operations?
**Answer:**
```java
@OneToOne(mappedBy = "employee", 
          cascade = {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REMOVE})
private Address address;
```

---

## 🚫 Common Mistakes

### Mistake 1: Wrong Annotation Usage
```java
// ❌ Wrong
@Entity
public class Address {
    @OneToOne
    @JoinColumn(name = "employee_id")  // Wrong for shared PK
    private Employee employee;
}

// ✅ Correct  
@Entity
public class Address {
    @OneToOne
    @PrimaryKeyJoinColumn  // Correct for shared PK
    private Employee employee;
}
```

### Mistake 2: Not Setting Both Sides
```java
// ❌ Wrong - Only one side set
employee.setAddress(address);
employeeRepository.save(employee);  // Address won't be saved properly!

// ✅ Correct - Both sides set
employee.setAddress(address);
address.setEmployee(employee);  // Set both sides!
employeeRepository.save(employee);
```

### Mistake 3: Wrong Primary Key Generation
```java
// ❌ Wrong - Both entities generating their own IDs
@Entity
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // Wrong!
    private Integer id;
}

// ✅ Correct - Child uses parent's ID
@Entity  
public class Address {
    @Id
    private Integer id;  // Will use Employee's ID
    
    @OneToOne
    @PrimaryKeyJoinColumn
    @JoinColumn(name = "id")
    private Employee employee;
}
```

**Error Message You'll See:**
```
org.hibernate.id.IdentifierGenerationException: 
attempted to assign id from null one-to-one property
```

---

## 🏆 Best Practices

### 1. Use Helper Methods 🛠️
```java
@Entity
public class Employee {
    @OneToOne(mappedBy = "employee", cascade = CascadeType.ALL)
    private Address address;
    
    // ✅ Helper method to maintain bidirectional relationship
    public void setAddress(Address address) {
        this.address = address;
        if (address != null) {
            address.setEmployee(this);  // Auto-set both sides
        }
    }
}
```

### 2. Use DTOs for API Layer 📡
```java
// ✅ Separate DTO from Entity
@Data
public class EmployeeDTO {
    private String name;
    private String email;
    private AddressDTO address;  // Nested DTO
}

@Data  
public class AddressDTO {
    private String street;
    private String city;
    private String state;
}
```

### 3. Handle Lazy Loading Properly 🐌
```java
// ✅ Use @Transactional for lazy loading
@Transactional
public EmployeeDTO getEmployeeWithAddress(Integer id) {
    Employee employee = employeeRepository.findById(id)
        .orElseThrow(() -> new EntityNotFoundException("Employee not found"));
    
    // Address will be loaded lazily within transaction
    return convertToDTO(employee);
}
```

### 4. Add Validation ✅
```java
@Entity
public class Employee {
    @NotBlank(message = "Name cannot be blank")
    private String name;
    
    @Email(message = "Invalid email format")
    private String emailId;
    
    @Pattern(regexp = "\\d{10}", message = "Mobile number should be 10 digits")
    private String mobNo;
}
```

---

## 📝 Quick Recap & Memory Tricks

### 🧠 Memory Tricks:
1. **"Shared PK = Same ID"** - Dono tables mein same primary key value 🔑
2. **"@PrimaryKeyJoinColumn = Owner side"** - Ye annotation owning side pe lagta hai 👑  
3. **"mappedBy = Non-owner"** - Ye non-owning side pe lagta hai 🤝
4. **"Set Both Sides"** - Hamesha dono entities mein relationship set karo 🔄

### ⚡ When to Use Shared Primary Key:
- ✅ **Strong relationship** exists (Employee-Address)
- ✅ **Mandatory relationship** (Can't have employee without address)
- ✅ **Performance is critical** 
- ✅ **Storage optimization** needed

### 🚫 When NOT to Use:
- ❌ **Optional relationships**
- ❌ **Frequently changing relationships** 
- ❌ **Multiple relationships possible**
- ❌ **Different lifecycle management** needed

### 🎯 Key Takeaways:
1. Shared Primary Key approach saves storage space
2. Better performance than foreign key approach  
3. Both entities must have same lifecycle
4. Always set bidirectional relationships properly
5. Use `@PrimaryKeyJoinColumn` on owning side
6. Use `mappedBy` on non-owning side

---

### 💡 Pro Tip:
**"Yaad rakhne ka mantra: Shared PK matlab same ID, bidirectional matlab dono taraf se ja sakte ho, aur hamesha dono sides set karo!"** 🎉

**Happy Coding, Bhai! 🚀💻**
