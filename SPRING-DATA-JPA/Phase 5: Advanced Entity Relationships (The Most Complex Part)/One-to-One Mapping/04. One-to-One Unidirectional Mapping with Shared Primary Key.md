# ğŸ¯ Spring Data JPA: One-to-One Unidirectional Mapping with Shared Primary Key

---

## ğŸ¤” Introduction - Confusion Clear Karte Hain!

### Simple Words Mein Samjhao Bhai! 
Yaar, imagine kar ki tumhare paas **Employee** aur **Address** hai. Har employee ka sirf ek hi address hota hai, aur har address sirf ek hi employee ka hota hai. Lekin twist ye hai ki **dono tables same primary key use karte hain!** ğŸ˜

### ğŸ  Real-Life Analogy
```
Employee ID = 1  â†’  Address ID = 1
Employee ID = 2  â†’  Address ID = 2
Employee ID = 3  â†’  Address ID = 3
```

Jaise ki tumhara **Aadhaar number** aur **PAN card** - dono same person ke liye unique hain, bas different purposes ke liye use hote hain! 

### ğŸ“š Technical Definition
**One-to-One Unidirectional Mapping with Shared Primary Key** means:
- âœ… Two entities share the same primary key value
- âœ… Navigation is only from one side (Employee â†’ Address)
- âœ… Address table ka primary key, Employee table ke primary key ke equal hota hai
- âœ… No separate foreign key column needed

---

## ğŸ¨ Key Terms/Concepts

| Term | Hindi Meaning | Technical Definition |
|------|---------------|---------------------|
| **@OneToOne** | Ek-se-Ek relationship | Defines one-to-one association |
| **@PrimaryKeyJoinColumn** | Primary Key se join | Uses primary key as foreign key |
| **Unidirectional** | Ek-tarafaa | Navigation only from one entity |
| **CascadeType.ALL** | Saath-saath operations | All operations cascade to related entity |
| **Shared Primary Key** | Same primary key | Both tables use same key value |

### ğŸ¯ Visual Representation
```
EMPLOYEE TABLE           ADDRESS TABLE
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”
â”‚ ID  â”‚ NAME â”‚ EMAIL â”‚   â”‚ ID  â”‚STREETâ”‚ CITY â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤   â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤
â”‚  1  â”‚ Raj  â”‚raj@.. â”‚   â”‚  1  â”‚MG Rd â”‚Delhi â”‚
â”‚  2  â”‚ Sam  â”‚sam@.. â”‚   â”‚  2  â”‚FC Rd â”‚Pune  â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜
        â†‘                        â†‘
        â””â”€â”€â”€â”€ Same ID value â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’» Detailed Examples

### ğŸ—ï¸ Project Setup

**Maven Dependencies:**
```xml
<!-- pom.xml -->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

**Database Configuration:**
```properties
# application.properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update
spring.h2.console.enabled=true
```

### ğŸ¢ Entity Classes

**Employee Entity (Parent):**
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    private String emailId;
    private String mobNo;
    private String designation;
    
    // ğŸ”¥ Main magic yahan hai bhai!
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn  // Ye line bohot important hai!
    private Address address;
}
```

**Address Entity (Child):**
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Address {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String street;
    private String city;
    private String state;
    private String pincode;
    
    // ğŸš¨ Notice: No Employee reference - Unidirectional!
}
```

### ğŸ—„ï¸ Repository Layer
```java
package com.springjava.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.springjava.entity.Employee;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    // ğŸ¯ Spring Data JPA automatically provides CRUD methods
}
```

### âš™ï¸ Service Layer
```java
package com.springjava.service;

import java.util.List;
import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.springjava.entity.Employee;
import com.springjava.repository.EmployeeRepository;

@Service
public class EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    // ğŸ’¾ Save employee with address
    public Employee saveEmployee(Employee employee) {
        return employeeRepository.save(employee);
    }
    
    // ğŸ“‹ Get all employees
    public List<Employee> getAllEmployees() {
        return employeeRepository.findAll();
    }
    
    // ğŸ” Find by ID
    public Optional<Employee> getEmployeeById(Integer id) {
        return employeeRepository.findById(id);
    }
    
    // ğŸ—‘ï¸ Delete employee (address bhi delete ho jaayega cascade ki wajah se)
    public void deleteEmployee(Integer id) {
        employeeRepository.deleteById(id);
    }
}
```

### ğŸŒ Controller Layer
```java
package com.springjava.controller;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.springjava.entity.Employee;
import com.springjava.service.EmployeeService;

@RestController
@RequestMapping("/api/employees")
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    // ğŸ“ Create new employee with address
    @PostMapping
    public ResponseEntity<?> createEmployee(@RequestBody Employee employee) {
        try {
            Employee savedEmployee = employeeService.saveEmployee(employee);
            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Employee saved successfully bhai! ğŸ‰");
            response.put("data", savedEmployee);
            return new ResponseEntity<>(response, HttpStatus.CREATED);
        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", "Kuch gadbad hai bhai: " + e.getMessage());
            return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
        }
    }
    
    // ğŸ“‹ Get all employees
    @GetMapping
    public ResponseEntity<?> getAllEmployees() {
        List<Employee> employees = employeeService.getAllEmployees();
        Map<String, Object> response = new HashMap<>();
        
        if (!employees.isEmpty()) {
            response.put("status", "success");
            response.put("count", employees.size());
            response.put("data", employees);
            return new ResponseEntity<>(response, HttpStatus.OK);
        } else {
            response.put("status", "info");
            response.put("message", "Abhi koi employee nahi hai database mein! ğŸ˜…");
            return new ResponseEntity<>(response, HttpStatus.NO_CONTENT);
        }
    }
    
    // ğŸ” Get employee by ID
    @GetMapping("/{id}")
    public ResponseEntity<?> getEmployeeById(@PathVariable Integer id) {
        return employeeService.getEmployeeById(id)
            .map(employee -> {
                Map<String, Object> response = new HashMap<>();
                response.put("status", "success");
                response.put("data", employee);
                return new ResponseEntity<>(response, HttpStatus.OK);
            })
            .orElse(() -> {
                Map<String, Object> response = new HashMap<>();
                response.put("status", "error");
                response.put("message", "Employee nahi mila ID: " + id + " ke saath! ğŸ¤·â€â™‚ï¸");
                return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
            });
    }
}
```

### ğŸ“¤ Expected Output

**POST Request Body:**
```json
{
    "name": "Rajesh Kumar",
    "emailId": "rajesh@example.com",
    "mobNo": "9876543210",
    "designation": "Software Developer",
    "address": {
        "street": "123 MG Road",
        "city": "Delhi",
        "state": "Delhi",
        "pincode": "110001"
    }
}
```

**Response:**
```json
{
    "status": "success",
    "message": "Employee saved successfully bhai! ğŸ‰",
    "data": {
        "id": 1,
        "name": "Rajesh Kumar",
        "emailId": "rajesh@example.com",
        "mobNo": "9876543210",
        "designation": "Software Developer",
        "address": {
            "id": 1,
            "street": "123 MG Road",
            "city": "Delhi",
            "state": "Delhi",
            "pincode": "110001"
        }
    }
}
```

---

## ğŸ“‹ Rules/Guidelines

### âœ… DO's - Ye Karo

**1. âœ… Always use @PrimaryKeyJoinColumn**
```java
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn  // âœ… Correct
private Address address;
```

**2. âœ… Use appropriate Cascade Type**
```java
@OneToOne(cascade = CascadeType.ALL)  // âœ… For complete lifecycle management
// or
@OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})  // âœ… For selective operations
```

**3. âœ… Handle null checks in service layer**
```java
public Employee saveEmployee(Employee employee) {
    if (employee.getAddress() == null) {
        throw new IllegalArgumentException("Address cannot be null bhai!");
    }
    return employeeRepository.save(employee);
}
```

### âŒ DON'Ts - Ye Mat Karo

**1. âŒ Don't use @JoinColumn with @PrimaryKeyJoinColumn**
```java
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn
@JoinColumn(name = "address_id")  // âŒ Wrong! Don't use both
private Address address;
```
**Error Message:** `AnnotationException: @PrimaryKeyJoinColumn and @JoinColumn cannot be used together`

**2. âŒ Don't add Employee reference in Address (for unidirectional)**
```java
// âŒ Wrong in Address entity
@OneToOne(mappedBy = "address")
private Employee employee;  // âŒ This makes it bidirectional
```

**3. âŒ Don't forget cascade operations**
```java
@OneToOne  // âŒ Wrong! Address won't be saved automatically
@PrimaryKeyJoinColumn
private Address address;
```

---

## ğŸŒ Real-world Applications

### ğŸ¦ Banking System
```java
@Entity
public class Account {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long accountId;
    
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private AccountDetails details;  // Interest rates, limits, etc.
}

@Entity
public class AccountDetails {
    @Id
    private Long id;  // Same as Account ID
    private Double interestRate;
    private Double creditLimit;
}
```

### ğŸš— Vehicle Registration
```java
@Entity
public class Vehicle {
    @Id
    @GeneratedValue
    private Integer vehicleId;
    
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn  
    private RegistrationCard regCard;
}

@Entity  
public class RegistrationCard {
    @Id
    private Integer id;  // Same as Vehicle ID
    private String registrationNumber;
    private Date issueDate;
    private Date expiryDate;
}
```

### ğŸ‘¨â€ğŸ’¼ Employee Profile System
```java
@Entity
public class Employee {
    @Id
    @GeneratedValue
    private Long empId;
    
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private EmployeeProfile profile;  // Detailed profile info
}

@Entity
public class EmployeeProfile {
    @Id 
    private Long id;  // Same as Employee ID
    private String skills;
    private Integer experienceYears;
    private String certifications;
}
```

---

## ğŸ“Š Comparison Tables

### One-to-One Mapping Types Comparison

| Mapping Type | Foreign Key Location | Primary Key Shared | Navigation | Use Case |
|--------------|---------------------|-------------------|------------|----------|
| **@JoinColumn** | Parent table | âŒ No | Unidirectional | When child can exist independently |
| **@PrimaryKeyJoinColumn** | Child table inherits parent's PK | âœ… Yes | Unidirectional | When child cannot exist without parent |
| **mappedBy** | Child table | âŒ No | Bidirectional | When you need navigation from both sides |

### Cascade Types Comparison

| Cascade Type | Save | Update | Delete | Refresh | Hindi Meaning |
|--------------|------|--------|--------|---------|---------------|
| **PERSIST** | âœ… | âŒ | âŒ | âŒ | Sirf save karo |
| **MERGE** | âŒ | âœ… | âŒ | âŒ | Sirf update karo |
| **REMOVE** | âŒ | âŒ | âœ… | âŒ | Sirf delete karo |
| **REFRESH** | âŒ | âŒ | âŒ | âœ… | Database se reload karo |
| **ALL** | âœ… | âœ… | âœ… | âœ… | Sab operations karo |

---

## ğŸ¤ Interview Questions

### Q1: What's the difference between @JoinColumn and @PrimaryKeyJoinColumn?

**Answer:**
```java
// @JoinColumn - Creates separate foreign key column
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "address_id")  // Creates address_id column in employee table
private Address address;

// @PrimaryKeyJoinColumn - Uses same primary key value  
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn  // Address.id = Employee.id
private Address address;
```

**Real difference:**
- `@JoinColumn`: Employee table mein separate column `address_id` banta hai
- `@PrimaryKeyJoinColumn`: Address table ka ID same hota hai Employee ke ID jaisa

### Q2: Can we have bidirectional mapping with shared primary key?

**Answer:** Haan bhai, bilkul kar sakte hain!

```java
// Employee.java
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn
private Address address;

// Address.java  
@OneToOne(mappedBy = "address")
@MapsId  // Important annotation for bidirectional
private Employee employee;
```

### Q3: What happens when we delete Employee with CascadeType.ALL?

**Answer:**
```java
// When you delete employee
employeeService.deleteEmployee(1);

// This happens:
// 1. First Address with id=1 gets deleted
// 2. Then Employee with id=1 gets deleted  
// 3. Both records removed from database

// SQL executed:
// DELETE FROM ADDRESS WHERE ID = 1;
// DELETE FROM EMPLOYEE WHERE ID = 1;
```

### Q4: How to handle null address scenario?

**Answer:**
```java
@Service
public class EmployeeService {
    
    public Employee saveEmployee(Employee employee) {
        // âœ… Proper null handling
        if (employee.getAddress() == null) {
            throw new BusinessException("Address is mandatory bhai!");
        }
        
        // Validate address fields
        Address addr = employee.getAddress();
        if (addr.getCity() == null || addr.getCity().trim().isEmpty()) {
            throw new BusinessException("City cannot be empty!");
        }
        
        return employeeRepository.save(employee);
    }
}
```

---

## âš ï¸ Common Mistakes

### ğŸš« Mistake 1: Using both annotations together
```java
// âŒ Wrong
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn
@JoinColumn(name = "address_id")  // Don't use both!
private Address address;
```

**Why it's wrong:** Dono annotations different foreign key strategies define karte hain

**âœ… Correct approach:**
```java
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn  // Only use this for shared primary key
private Address address;
```

### ğŸš« Mistake 2: Forgetting cascade operations
```java
// âŒ Wrong
@OneToOne
@PrimaryKeyJoinColumn
private Address address;

Employee emp = new Employee();
emp.setAddress(new Address());  // Address won't be saved!
employeeRepository.save(emp);
```

**Error:** `TransientPropertyValueException: object references an unsaved transient instance`

**âœ… Correct approach:**
```java
@OneToOne(cascade = CascadeType.ALL)  // Add cascade
@PrimaryKeyJoinColumn
private Address address;
```

### ğŸš« Mistake 3: Manual ID setting in child entity
```java
// âŒ Wrong
Address address = new Address();
address.setId(100);  // Don't set ID manually!

Employee emp = new Employee();
emp.setAddress(address);
employeeRepository.save(emp);
```

**Why it's wrong:** Hibernate automatically sets child ID same as parent ID

**âœ… Correct approach:**
```java
Address address = new Address();
// Don't set ID, let Hibernate handle it

Employee emp = new Employee();  
emp.setAddress(address);
employeeRepository.save(emp);  // Hibernate will set address.id = emp.id
```

### ğŸš« Mistake 4: Incorrect entity navigation
```java
// âŒ Wrong - Trying to save Address directly
Address address = new Address();
address.setStreet("MG Road");
addressRepository.save(address);  // This will fail!
```

**Why it's wrong:** In unidirectional mapping, always save from parent entity

**âœ… Correct approach:**
```java
Employee emp = new Employee();
emp.setName("Rajesh");

Address address = new Address();
address.setStreet("MG Road");
emp.setAddress(address);  // Set in parent

employeeRepository.save(emp);  // Save parent, child gets saved automatically
```

---

## âœ¨ Best Practices

### ğŸ† Industry Standards

**1. Always use DTOs for API responses**
```java
@Data
public class EmployeeResponseDTO {
    private Integer id;
    private String name;
    private String email;
    private AddressDTO address;
    
    // Don't expose entity directly in APIs
}

@Data  
public class AddressDTO {
    private String street;
    private String city;
    private String state;
}
```

**2. Implement proper exception handling**
```java
@Service
public class EmployeeService {
    
    public Employee saveEmployee(Employee employee) {
        try {
            validateEmployee(employee);
            return employeeRepository.save(employee);
        } catch (DataIntegrityViolationException e) {
            throw new BusinessException("Database constraint violation: " + e.getMessage());
        } catch (Exception e) {
            throw new BusinessException("Error saving employee: " + e.getMessage());
        }
    }
    
    private void validateEmployee(Employee employee) {
        if (employee == null) {
            throw new IllegalArgumentException("Employee cannot be null");
        }
        if (employee.getAddress() == null) {
            throw new IllegalArgumentException("Address is mandatory");
        }
        // More validations...
    }
}
```

**3. Use repository custom methods wisely**
```java
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    
    // âœ… Good - Specific business queries
    @Query("SELECT e FROM Employee e WHERE e.address.city = :city")
    List<Employee> findEmployeesByCity(@Param("city") String city);
    
    // âœ… Good - Using method name conventions
    List<Employee> findByNameContainingIgnoreCase(String name);
    
    // âŒ Avoid - Complex queries in repository
    // Use service layer for complex business logic
}
```

### ğŸ§¹ Clean Code Principles

**1. Use meaningful variable names**
```java
// âŒ Bad
Employee e = new Employee();
Address a = new Address();

// âœ… Good  
Employee newEmployee = new Employee();
Address employeeAddress = new Address();
```

**2. Keep methods focused (Single Responsibility)**
```java
// âœ… Good - Each method has single purpose
public Employee createEmployeeWithAddress(EmployeeRequestDTO dto) {
    Employee employee = mapDtoToEntity(dto);
    validateEmployeeData(employee);
    return saveEmployee(employee);
}

private Employee mapDtoToEntity(EmployeeRequestDTO dto) { /* mapping logic */ }
private void validateEmployeeData(Employee employee) { /* validation logic */ }
private Employee saveEmployee(Employee employee) { /* save logic */ }
```

### ğŸ“š Documentation Tips

**1. Document entity relationships**
```java
/**
 * Employee entity with one-to-one unidirectional mapping to Address.
 * Uses shared primary key strategy where Address.id = Employee.id
 * 
 * @author Your Name
 * @version 1.0
 * @since 2024-01-01
 */
@Entity
@Table(name = "employees")
public class Employee {
    
    /**
     * Primary key that will be shared with Address entity
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    /**
     * One-to-one association with Address entity using shared primary key.
     * CascadeType.ALL ensures Address is created/updated/deleted with Employee.
     */
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private Address address;
}
```

**2. Add method documentation**
```java
/**
 * Saves employee along with address information using shared primary key strategy.
 * 
 * @param employee Employee entity with address information
 * @return Saved employee with generated ID
 * @throws BusinessException if employee validation fails
 * @throws DataAccessException if database operation fails
 */
public Employee saveEmployee(Employee employee) {
    // Implementation
}
```

---

## ğŸ“ Summary/Quick Recap

### ğŸ¯ Key Takeaways

1. **Shared Primary Key** = Same ID value in both tables
2. **@PrimaryKeyJoinColumn** = Magic annotation for shared PK
3. **Unidirectional** = Navigation sirf Employee se Address ki taraf
4. **CascadeType.ALL** = Parent ke saath child bhi handle hota hai
5. **No separate foreign key column** needed

### ğŸ§  Memory Tricks

**SHARED** acronym yaad rakho:
- **S**ame primary key values
- **H**ibernate handles ID generation  
- **A**lways use @PrimaryKeyJoinColumn
- **R**emember cascade operations
- **E**ntity navigation from parent only
- **D**on't set child ID manually

### ğŸ¤” When to Use What

| Scenario | Use This Approach |
|----------|------------------|
| **Child cannot exist without parent** | âœ… @PrimaryKeyJoinColumn |
| **Want to save database space** | âœ… Shared Primary Key |
| **Need only one-way navigation** | âœ… Unidirectional mapping |
| **Child can exist independently** | âŒ Use @JoinColumn instead |
| **Need navigation from both sides** | âŒ Use bidirectional mapping |

---

## ğŸ‰ Conclusion

Bhai, **One-to-One Unidirectional Mapping with Shared Primary Key** ek powerful technique hai Spring Data JPA mein! 

**Main benefits:**
- ğŸ’¾ Database space save hota hai (no extra foreign key column)
- ğŸš€ Performance better hai (fewer joins needed)  
- ğŸ”— Strong relationship ensure hota hai (same ID = guaranteed link)
- ğŸ›¡ï¸ Data integrity maintain rehti hai

**Remember the mantra:** 
> "Same ID, Same Entity, Strong Relationship!" ğŸ¯

Ab jaao aur practice karo! Happy coding! ğŸš€âœ¨

---

*Made with â¤ï¸ for Java developers by developers* 

**Next Topics:** 
- One-to-Many Bidirectional Mapping
- Many-to-Many with Custom Join Table  
- JPA Query Methods Advanced Techniques

---
