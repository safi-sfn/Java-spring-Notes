# 🎯 Spring Data JPA: One-to-One Unidirectional Mapping with Shared Primary Key

---

## 🤔 Introduction - Confusion Clear Karte Hain!

### Simple Words Mein Samjhao Bhai! 
Yaar, imagine kar ki tumhare paas **Employee** aur **Address** hai. Har employee ka sirf ek hi address hota hai, aur har address sirf ek hi employee ka hota hai. Lekin twist ye hai ki **dono tables same primary key use karte hain!** 😎

### 🏠 Real-Life Analogy
```
Employee ID = 1  →  Address ID = 1
Employee ID = 2  →  Address ID = 2
Employee ID = 3  →  Address ID = 3
```

Jaise ki tumhara **Aadhaar number** aur **PAN card** - dono same person ke liye unique hain, bas different purposes ke liye use hote hain! 

### 📚 Technical Definition
**One-to-One Unidirectional Mapping with Shared Primary Key** means:
- ✅ Two entities share the same primary key value
- ✅ Navigation is only from one side (Employee → Address)
- ✅ Address table ka primary key, Employee table ke primary key ke equal hota hai
- ✅ No separate foreign key column needed

---

## 🎨 Key Terms/Concepts

| Term | Hindi Meaning | Technical Definition |
|------|---------------|---------------------|
| **@OneToOne** | Ek-se-Ek relationship | Defines one-to-one association |
| **@PrimaryKeyJoinColumn** | Primary Key se join | Uses primary key as foreign key |
| **Unidirectional** | Ek-tarafaa | Navigation only from one entity |
| **CascadeType.ALL** | Saath-saath operations | All operations cascade to related entity |
| **Shared Primary Key** | Same primary key | Both tables use same key value |

### 🎯 Visual Representation
```
EMPLOYEE TABLE           ADDRESS TABLE
┌─────┬──────┬───────┐   ┌─────┬──────┬──────┐
│ ID  │ NAME │ EMAIL │   │ ID  │STREET│ CITY │
├─────┼──────┼───────┤   ├─────┼──────┼──────┤
│  1  │ Raj  │raj@.. │   │  1  │MG Rd │Delhi │
│  2  │ Sam  │sam@.. │   │  2  │FC Rd │Pune  │
└─────┴──────┴───────┘   └─────┴──────┴──────┘
        ↑                        ↑
        └──── Same ID value ─────┘
```

---

## 💻 Detailed Examples

### 🏗️ Project Setup

**Maven Dependencies:**
```xml
<!-- pom.xml -->
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId>
        <scope>runtime</scope>
    </dependency>
</dependencies>
```

**Database Configuration:**
```properties
# application.properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=update
spring.h2.console.enabled=true
```

### 🏢 Entity Classes

**Employee Entity (Parent):**
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    private String emailId;
    private String mobNo;
    private String designation;
    
    // 🔥 Main magic yahan hai bhai!
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn  // Ye line bohot important hai!
    private Address address;
}
```

**Address Entity (Child):**
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Address {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String street;
    private String city;
    private String state;
    private String pincode;
    
    // 🚨 Notice: No Employee reference - Unidirectional!
}
```

### 🗄️ Repository Layer
```java
package com.springjava.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import com.springjava.entity.Employee;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    // 🎯 Spring Data JPA automatically provides CRUD methods
}
```

### ⚙️ Service Layer
```java
package com.springjava.service;

import java.util.List;
import java.util.Optional;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.springjava.entity.Employee;
import com.springjava.repository.EmployeeRepository;

@Service
public class EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    // 💾 Save employee with address
    public Employee saveEmployee(Employee employee) {
        return employeeRepository.save(employee);
    }
    
    // 📋 Get all employees
    public List<Employee> getAllEmployees() {
        return employeeRepository.findAll();
    }
    
    // 🔍 Find by ID
    public Optional<Employee> getEmployeeById(Integer id) {
        return employeeRepository.findById(id);
    }
    
    // 🗑️ Delete employee (address bhi delete ho jaayega cascade ki wajah se)
    public void deleteEmployee(Integer id) {
        employeeRepository.deleteById(id);
    }
}
```

### 🌐 Controller Layer
```java
package com.springjava.controller;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.springjava.entity.Employee;
import com.springjava.service.EmployeeService;

@RestController
@RequestMapping("/api/employees")
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    // 📝 Create new employee with address
    @PostMapping
    public ResponseEntity<?> createEmployee(@RequestBody Employee employee) {
        try {
            Employee savedEmployee = employeeService.saveEmployee(employee);
            Map<String, Object> response = new HashMap<>();
            response.put("status", "success");
            response.put("message", "Employee saved successfully bhai! 🎉");
            response.put("data", savedEmployee);
            return new ResponseEntity<>(response, HttpStatus.CREATED);
        } catch (Exception e) {
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("status", "error");
            errorResponse.put("message", "Kuch gadbad hai bhai: " + e.getMessage());
            return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
        }
    }
    
    // 📋 Get all employees
    @GetMapping
    public ResponseEntity<?> getAllEmployees() {
        List<Employee> employees = employeeService.getAllEmployees();
        Map<String, Object> response = new HashMap<>();
        
        if (!employees.isEmpty()) {
            response.put("status", "success");
            response.put("count", employees.size());
            response.put("data", employees);
            return new ResponseEntity<>(response, HttpStatus.OK);
        } else {
            response.put("status", "info");
            response.put("message", "Abhi koi employee nahi hai database mein! 😅");
            return new ResponseEntity<>(response, HttpStatus.NO_CONTENT);
        }
    }
    
    // 🔍 Get employee by ID
    @GetMapping("/{id}")
    public ResponseEntity<?> getEmployeeById(@PathVariable Integer id) {
        return employeeService.getEmployeeById(id)
            .map(employee -> {
                Map<String, Object> response = new HashMap<>();
                response.put("status", "success");
                response.put("data", employee);
                return new ResponseEntity<>(response, HttpStatus.OK);
            })
            .orElse(() -> {
                Map<String, Object> response = new HashMap<>();
                response.put("status", "error");
                response.put("message", "Employee nahi mila ID: " + id + " ke saath! 🤷‍♂️");
                return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
            });
    }
}
```

### 📤 Expected Output

**POST Request Body:**
```json
{
    "name": "Rajesh Kumar",
    "emailId": "rajesh@example.com",
    "mobNo": "9876543210",
    "designation": "Software Developer",
    "address": {
        "street": "123 MG Road",
        "city": "Delhi",
        "state": "Delhi",
        "pincode": "110001"
    }
}
```

**Response:**
```json
{
    "status": "success",
    "message": "Employee saved successfully bhai! 🎉",
    "data": {
        "id": 1,
        "name": "Rajesh Kumar",
        "emailId": "rajesh@example.com",
        "mobNo": "9876543210",
        "designation": "Software Developer",
        "address": {
            "id": 1,
            "street": "123 MG Road",
            "city": "Delhi",
            "state": "Delhi",
            "pincode": "110001"
        }
    }
}
```

---

## 📋 Rules/Guidelines

### ✅ DO's - Ye Karo

**1. ✅ Always use @PrimaryKeyJoinColumn**
```java
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn  // ✅ Correct
private Address address;
```

**2. ✅ Use appropriate Cascade Type**
```java
@OneToOne(cascade = CascadeType.ALL)  // ✅ For complete lifecycle management
// or
@OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})  // ✅ For selective operations
```

**3. ✅ Handle null checks in service layer**
```java
public Employee saveEmployee(Employee employee) {
    if (employee.getAddress() == null) {
        throw new IllegalArgumentException("Address cannot be null bhai!");
    }
    return employeeRepository.save(employee);
}
```

### ❌ DON'Ts - Ye Mat Karo

**1. ❌ Don't use @JoinColumn with @PrimaryKeyJoinColumn**
```java
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn
@JoinColumn(name = "address_id")  // ❌ Wrong! Don't use both
private Address address;
```
**Error Message:** `AnnotationException: @PrimaryKeyJoinColumn and @JoinColumn cannot be used together`

**2. ❌ Don't add Employee reference in Address (for unidirectional)**
```java
// ❌ Wrong in Address entity
@OneToOne(mappedBy = "address")
private Employee employee;  // ❌ This makes it bidirectional
```

**3. ❌ Don't forget cascade operations**
```java
@OneToOne  // ❌ Wrong! Address won't be saved automatically
@PrimaryKeyJoinColumn
private Address address;
```

---

## 🌍 Real-world Applications

### 🏦 Banking System
```java
@Entity
public class Account {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long accountId;
    
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private AccountDetails details;  // Interest rates, limits, etc.
}

@Entity
public class AccountDetails {
    @Id
    private Long id;  // Same as Account ID
    private Double interestRate;
    private Double creditLimit;
}
```

### 🚗 Vehicle Registration
```java
@Entity
public class Vehicle {
    @Id
    @GeneratedValue
    private Integer vehicleId;
    
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn  
    private RegistrationCard regCard;
}

@Entity  
public class RegistrationCard {
    @Id
    private Integer id;  // Same as Vehicle ID
    private String registrationNumber;
    private Date issueDate;
    private Date expiryDate;
}
```

### 👨‍💼 Employee Profile System
```java
@Entity
public class Employee {
    @Id
    @GeneratedValue
    private Long empId;
    
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private EmployeeProfile profile;  // Detailed profile info
}

@Entity
public class EmployeeProfile {
    @Id 
    private Long id;  // Same as Employee ID
    private String skills;
    private Integer experienceYears;
    private String certifications;
}
```

---

## 📊 Comparison Tables

### One-to-One Mapping Types Comparison

| Mapping Type | Foreign Key Location | Primary Key Shared | Navigation | Use Case |
|--------------|---------------------|-------------------|------------|----------|
| **@JoinColumn** | Parent table | ❌ No | Unidirectional | When child can exist independently |
| **@PrimaryKeyJoinColumn** | Child table inherits parent's PK | ✅ Yes | Unidirectional | When child cannot exist without parent |
| **mappedBy** | Child table | ❌ No | Bidirectional | When you need navigation from both sides |

### Cascade Types Comparison

| Cascade Type | Save | Update | Delete | Refresh | Hindi Meaning |
|--------------|------|--------|--------|---------|---------------|
| **PERSIST** | ✅ | ❌ | ❌ | ❌ | Sirf save karo |
| **MERGE** | ❌ | ✅ | ❌ | ❌ | Sirf update karo |
| **REMOVE** | ❌ | ❌ | ✅ | ❌ | Sirf delete karo |
| **REFRESH** | ❌ | ❌ | ❌ | ✅ | Database se reload karo |
| **ALL** | ✅ | ✅ | ✅ | ✅ | Sab operations karo |

---

## 🎤 Interview Questions

### Q1: What's the difference between @JoinColumn and @PrimaryKeyJoinColumn?

**Answer:**
```java
// @JoinColumn - Creates separate foreign key column
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "address_id")  // Creates address_id column in employee table
private Address address;

// @PrimaryKeyJoinColumn - Uses same primary key value  
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn  // Address.id = Employee.id
private Address address;
```

**Real difference:**
- `@JoinColumn`: Employee table mein separate column `address_id` banta hai
- `@PrimaryKeyJoinColumn`: Address table ka ID same hota hai Employee ke ID jaisa

### Q2: Can we have bidirectional mapping with shared primary key?

**Answer:** Haan bhai, bilkul kar sakte hain!

```java
// Employee.java
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn
private Address address;

// Address.java  
@OneToOne(mappedBy = "address")
@MapsId  // Important annotation for bidirectional
private Employee employee;
```

### Q3: What happens when we delete Employee with CascadeType.ALL?

**Answer:**
```java
// When you delete employee
employeeService.deleteEmployee(1);

// This happens:
// 1. First Address with id=1 gets deleted
// 2. Then Employee with id=1 gets deleted  
// 3. Both records removed from database

// SQL executed:
// DELETE FROM ADDRESS WHERE ID = 1;
// DELETE FROM EMPLOYEE WHERE ID = 1;
```

### Q4: How to handle null address scenario?

**Answer:**
```java
@Service
public class EmployeeService {
    
    public Employee saveEmployee(Employee employee) {
        // ✅ Proper null handling
        if (employee.getAddress() == null) {
            throw new BusinessException("Address is mandatory bhai!");
        }
        
        // Validate address fields
        Address addr = employee.getAddress();
        if (addr.getCity() == null || addr.getCity().trim().isEmpty()) {
            throw new BusinessException("City cannot be empty!");
        }
        
        return employeeRepository.save(employee);
    }
}
```

---

## ⚠️ Common Mistakes

### 🚫 Mistake 1: Using both annotations together
```java
// ❌ Wrong
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn
@JoinColumn(name = "address_id")  // Don't use both!
private Address address;
```

**Why it's wrong:** Dono annotations different foreign key strategies define karte hain

**✅ Correct approach:**
```java
@OneToOne(cascade = CascadeType.ALL)
@PrimaryKeyJoinColumn  // Only use this for shared primary key
private Address address;
```

### 🚫 Mistake 2: Forgetting cascade operations
```java
// ❌ Wrong
@OneToOne
@PrimaryKeyJoinColumn
private Address address;

Employee emp = new Employee();
emp.setAddress(new Address());  // Address won't be saved!
employeeRepository.save(emp);
```

**Error:** `TransientPropertyValueException: object references an unsaved transient instance`

**✅ Correct approach:**
```java
@OneToOne(cascade = CascadeType.ALL)  // Add cascade
@PrimaryKeyJoinColumn
private Address address;
```

### 🚫 Mistake 3: Manual ID setting in child entity
```java
// ❌ Wrong
Address address = new Address();
address.setId(100);  // Don't set ID manually!

Employee emp = new Employee();
emp.setAddress(address);
employeeRepository.save(emp);
```

**Why it's wrong:** Hibernate automatically sets child ID same as parent ID

**✅ Correct approach:**
```java
Address address = new Address();
// Don't set ID, let Hibernate handle it

Employee emp = new Employee();  
emp.setAddress(address);
employeeRepository.save(emp);  // Hibernate will set address.id = emp.id
```

### 🚫 Mistake 4: Incorrect entity navigation
```java
// ❌ Wrong - Trying to save Address directly
Address address = new Address();
address.setStreet("MG Road");
addressRepository.save(address);  // This will fail!
```

**Why it's wrong:** In unidirectional mapping, always save from parent entity

**✅ Correct approach:**
```java
Employee emp = new Employee();
emp.setName("Rajesh");

Address address = new Address();
address.setStreet("MG Road");
emp.setAddress(address);  // Set in parent

employeeRepository.save(emp);  // Save parent, child gets saved automatically
```

---

## ✨ Best Practices

### 🏆 Industry Standards

**1. Always use DTOs for API responses**
```java
@Data
public class EmployeeResponseDTO {
    private Integer id;
    private String name;
    private String email;
    private AddressDTO address;
    
    // Don't expose entity directly in APIs
}

@Data  
public class AddressDTO {
    private String street;
    private String city;
    private String state;
}
```

**2. Implement proper exception handling**
```java
@Service
public class EmployeeService {
    
    public Employee saveEmployee(Employee employee) {
        try {
            validateEmployee(employee);
            return employeeRepository.save(employee);
        } catch (DataIntegrityViolationException e) {
            throw new BusinessException("Database constraint violation: " + e.getMessage());
        } catch (Exception e) {
            throw new BusinessException("Error saving employee: " + e.getMessage());
        }
    }
    
    private void validateEmployee(Employee employee) {
        if (employee == null) {
            throw new IllegalArgumentException("Employee cannot be null");
        }
        if (employee.getAddress() == null) {
            throw new IllegalArgumentException("Address is mandatory");
        }
        // More validations...
    }
}
```

**3. Use repository custom methods wisely**
```java
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    
    // ✅ Good - Specific business queries
    @Query("SELECT e FROM Employee e WHERE e.address.city = :city")
    List<Employee> findEmployeesByCity(@Param("city") String city);
    
    // ✅ Good - Using method name conventions
    List<Employee> findByNameContainingIgnoreCase(String name);
    
    // ❌ Avoid - Complex queries in repository
    // Use service layer for complex business logic
}
```

### 🧹 Clean Code Principles

**1. Use meaningful variable names**
```java
// ❌ Bad
Employee e = new Employee();
Address a = new Address();

// ✅ Good  
Employee newEmployee = new Employee();
Address employeeAddress = new Address();
```

**2. Keep methods focused (Single Responsibility)**
```java
// ✅ Good - Each method has single purpose
public Employee createEmployeeWithAddress(EmployeeRequestDTO dto) {
    Employee employee = mapDtoToEntity(dto);
    validateEmployeeData(employee);
    return saveEmployee(employee);
}

private Employee mapDtoToEntity(EmployeeRequestDTO dto) { /* mapping logic */ }
private void validateEmployeeData(Employee employee) { /* validation logic */ }
private Employee saveEmployee(Employee employee) { /* save logic */ }
```

### 📚 Documentation Tips

**1. Document entity relationships**
```java
/**
 * Employee entity with one-to-one unidirectional mapping to Address.
 * Uses shared primary key strategy where Address.id = Employee.id
 * 
 * @author Your Name
 * @version 1.0
 * @since 2024-01-01
 */
@Entity
@Table(name = "employees")
public class Employee {
    
    /**
     * Primary key that will be shared with Address entity
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    /**
     * One-to-one association with Address entity using shared primary key.
     * CascadeType.ALL ensures Address is created/updated/deleted with Employee.
     */
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private Address address;
}
```

**2. Add method documentation**
```java
/**
 * Saves employee along with address information using shared primary key strategy.
 * 
 * @param employee Employee entity with address information
 * @return Saved employee with generated ID
 * @throws BusinessException if employee validation fails
 * @throws DataAccessException if database operation fails
 */
public Employee saveEmployee(Employee employee) {
    // Implementation
}
```

---

## 📝 Summary/Quick Recap

### 🎯 Key Takeaways

1. **Shared Primary Key** = Same ID value in both tables
2. **@PrimaryKeyJoinColumn** = Magic annotation for shared PK
3. **Unidirectional** = Navigation sirf Employee se Address ki taraf
4. **CascadeType.ALL** = Parent ke saath child bhi handle hota hai
5. **No separate foreign key column** needed

### 🧠 Memory Tricks

**SHARED** acronym yaad rakho:
- **S**ame primary key values
- **H**ibernate handles ID generation  
- **A**lways use @PrimaryKeyJoinColumn
- **R**emember cascade operations
- **E**ntity navigation from parent only
- **D**on't set child ID manually

### 🤔 When to Use What

| Scenario | Use This Approach |
|----------|------------------|
| **Child cannot exist without parent** | ✅ @PrimaryKeyJoinColumn |
| **Want to save database space** | ✅ Shared Primary Key |
| **Need only one-way navigation** | ✅ Unidirectional mapping |
| **Child can exist independently** | ❌ Use @JoinColumn instead |
| **Need navigation from both sides** | ❌ Use bidirectional mapping |

---

## 🎉 Conclusion

Bhai, **One-to-One Unidirectional Mapping with Shared Primary Key** ek powerful technique hai Spring Data JPA mein! 

**Main benefits:**
- 💾 Database space save hota hai (no extra foreign key column)
- 🚀 Performance better hai (fewer joins needed)  
- 🔗 Strong relationship ensure hota hai (same ID = guaranteed link)
- 🛡️ Data integrity maintain rehti hai

**Remember the mantra:** 
> "Same ID, Same Entity, Strong Relationship!" 🎯

Ab jaao aur practice karo! Happy coding! 🚀✨

---

*Made with ❤️ for Java developers by developers* 

**Next Topics:** 
- One-to-Many Bidirectional Mapping
- Many-to-Many with Custom Join Table  
- JPA Query Methods Advanced Techniques

---
