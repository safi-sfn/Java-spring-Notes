# 🎯 JPA One-to-One Mapping - Complete Study Notes

*Bhai, ab samjhte hain ki JPA mein entities ka rishta kaise banate hain! 💪*

---

## 📚 1. Introduction - Confusion Clear Karte Hain! 

### 🤔 Simple Words Mein Samjho
Bhai, One-to-One mapping matlab ek entity ka doosre entity ke saath **unique relationship** hai. Jaise:
- Ek person ka sirf ek passport hota hai ✅
- Ek employee ka sirf ek address hota hai ✅
- Ek student ka sirf ek ID card hota hai ✅

### 🏠 Real-Life Analogy
Socho yaar, tumhara **Aadhaar Card** - sirf tumhara hai na? Kisi aur ka nahi. Bas yehi concept hai One-to-One mapping mein!

```
Person ←→ Aadhaar Card
Employee ←→ Address  
Student ←→ ID Card
```

### 🎓 Technical Definition
JPA mein One-to-One mapping ek **association** hai jo establish karta hai ki:
- Ek entity instance sirf ek doosre entity instance se related hai
- Database mein tables ke beech **unique relationship** banta hai
- `@OneToOne` annotation use karte hain

---

## 🔑 2. Key Terms/Concepts

| Term | Technical Definition |
|------|---------------------|
| **@OneToOne** | Primary annotation for 1:1 relationship |
| **@JoinColumn** | Specifies foreign key column |
| **mappedBy** | Indicates owning side of relationship |
| **CascadeType** | Operations to propagate to associated entity |
| **@PrimaryKeyJoinColumn** | Shares primary key between entities |
| **@MapsId** | Maps entity to primary key of associated entity |
| **@JoinTable** | Creates separate table for relationship |

### 🎭 Types of One-to-One Mapping

```ascii
One-to-One Mapping
        |
    ┌───────────────┬───────────────┐
    │               │               │
Unidirectional   Bidirectional   Join Table
    │               │               │
  Owner → Owned   Owner ↔ Owned   Table1 ← JoinTable → Table2
```

---

## 🛠️ 3. Detailed Examples

### 📝 Example 1: Foreign Key Column (Unidirectional)

**Employee.java** (Owner Entity)
```java
import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    private String emailId;
    private String mobNo;
    private String designation;
    
    // 🎯 One-to-One Mapping with Foreign Key
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "address_id", referencedColumnName = "id")
    private Address address;
}
```

**Address.java** (Owned Entity)
```java
import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Address {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String street;
    private String city;
    private String state;
    private String pincode;
}
```

**📊 Expected Database Structure:**
```sql
-- Employee Table
CREATE TABLE employee (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    email_id VARCHAR(255),
    mob_no VARCHAR(15),
    designation VARCHAR(100),
    address_id INT,  -- 🔗 Foreign Key
    FOREIGN KEY (address_id) REFERENCES address(id)
);

-- Address Table  
CREATE TABLE address (
    id INT AUTO_INCREMENT PRIMARY KEY,
    street VARCHAR(255),
    city VARCHAR(100),
    state VARCHAR(100),
    pincode VARCHAR(10)
);
```

**🏃‍♂️ Working Example:**
```java
// Repository usage
Employee emp = new Employee();
emp.setName("Rohit Sharma");
emp.setEmailId("rohit@example.com");

Address addr = new Address();
addr.setStreet("MG Road");
addr.setCity("Mumbai");
addr.setState("Maharashtra");

emp.setAddress(addr); // 🔗 Setting relationship

employeeRepository.save(emp); // Saves both entities!
```

### 📝 Example 2: Bidirectional Mapping

**Employee.java** (Owner Side)
```java
@Entity
@Data
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    private String emailId;
    
    // 🔗 Owner side of relationship
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "address_id")
    private Address address;
}
```

**Address.java** (Inverse Side)
```java
@Entity
@Data
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String street;
    private String city;
    
    // 🔙 Back reference using mappedBy
    @OneToOne(cascade = CascadeType.ALL, mappedBy = "address")
    private Employee employee;
}
```

### 📝 Example 3: Shared Primary Key

**Employee.java**
```java
@Entity
@Data
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    
    // 🎯 Shared Primary Key Mapping
    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    private Address address;
}
```

**Address.java**
```java
@Entity  
@Data
public class Address {
    @Id
    private Integer id; // 🔗 Same as Employee ID
    
    private String street;
    private String city;
    
    @OneToOne
    @PrimaryKeyJoinColumn
    private Employee employee;
}
```

### 📝 Example 4: Using @MapsId

**Employee.java**
```java
@Entity
@Data  
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    
    // 🎯 Maps ID annotation
    @OneToOne(cascade = CascadeType.ALL)
    @MapsId
    private Address address;
}
```

### 📝 Example 5: Join Table Approach

**Employee.java**
```java
@Entity
@Data
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    
    // 🎯 Join Table Mapping
    @OneToOne(cascade = CascadeType.ALL)
    @JoinTable(
        name = "emp_address",
        joinColumns = {@JoinColumn(name = "emp_id")},
        inverseJoinColumns = {@JoinColumn(name = "addr_id")}
    )
    private Address address;
}
```

**📊 Join Table Structure:**
```sql
CREATE TABLE emp_address (
    emp_id INT,
    addr_id INT,
    PRIMARY KEY (emp_id),
    FOREIGN KEY (emp_id) REFERENCES employee(id),
    FOREIGN KEY (addr_id) REFERENCES address(id)
);
```

---

## 📋 4. Rules/Guidelines

### ✅ DO's - Ye Karo Bhai!

1. **Always use @OneToOne annotation** ✅
   ```java
   @OneToOne(cascade = CascadeType.ALL)
   private Address address;
   ```

2. **Use proper CascadeType** ✅
   ```java
   @OneToOne(cascade = CascadeType.ALL) // All operations cascade
   @OneToOne(cascade = CascadeType.PERSIST) // Only persist cascades
   ```

3. **Define clear ownership** ✅
   ```java
   // Owner side
   @OneToOne
   @JoinColumn(name = "address_id")
   private Address address;
   
   // Inverse side  
   @OneToOne(mappedBy = "address")
   private Employee employee;
   ```

### ❌ DON'Ts - Ye Mat Karo!

1. **Don't forget mappedBy in bidirectional** ❌
   ```java
   // Wrong - No mappedBy
   @OneToOne
   private Employee employee;
   
   // Correct
   @OneToOne(mappedBy = "address")
   private Employee employee;
   ```

2. **Don't use @JoinColumn on both sides** ❌
   ```java
   // Wrong - JoinColumn on both sides
   @OneToOne
   @JoinColumn(name = "emp_id")
   private Employee employee;
   ```

3. **Don't mix mapping strategies** ❌
   ```java
   // Wrong - Mixing @PrimaryKeyJoinColumn with @JoinColumn
   @OneToOne
   @PrimaryKeyJoinColumn
   @JoinColumn(name = "emp_id")
   private Employee employee;
   ```

---

## 🏢 5. Real-world Applications

### 🏦 Banking System Example
```java
// Customer ←→ Account Details
@Entity
public class Customer {
    @Id
    private Long customerId;
    private String name;
    
    @OneToOne
    @JoinColumn(name = "account_details_id")
    private AccountDetails accountDetails;
}

@Entity  
public class AccountDetails {
    @Id
    private Long id;
    private String accountNumber;
    private Double balance;
    private String ifscCode;
}
```

### 🏥 Hospital Management
```java  
// Patient ←→ Medical Record
@Entity
public class Patient {
    @Id
    private Long patientId;
    private String name;
    
    @OneToOne(cascade = CascadeType.ALL)
    private MedicalRecord medicalRecord;
}

@Entity
public class MedicalRecord {
    @Id
    private Long recordId;
    private String bloodGroup;
    private String allergies;
    private String emergencyContact;
}
```

### 🎓 School Management
```java
// Student ←→ ID Card
@Entity
public class Student {
    @Id
    private Long studentId;
    private String name;
    
    @OneToOne
    @PrimaryKeyJoinColumn
    private IdCard idCard;
}

@Entity
public class IdCard {
    @Id
    private Long studentId; // Same as Student ID
    private String cardNumber;
    private Date issueDate;
    private Date expiryDate;
}
```

---

## 📊 6. Comparison Tables

### Mapping Strategy Comparison

| Strategy | Pros 👍 | Cons 👎 | Use Case |
|----------|---------|---------|----------|
| **Foreign Key** | Simple, Flexible | Extra column needed | General purpose |
| **Shared Primary Key** | No extra column | Tight coupling | When entities are closely related |
| **@MapsId** | Clean mapping | Complex setup | When you want to share IDs |
| **Join Table** | Flexible schema | Extra table overhead | Complex relationships |

### Annotation Comparison

| Annotation | Purpose | Example |
|------------|---------|---------|
| `@OneToOne` | Defines 1:1 relationship | `@OneToOne` |
| `@JoinColumn` | Specifies FK column | `@JoinColumn(name="addr_id")` |
| `mappedBy` | Defines inverse side | `mappedBy="address"` |
| `@PrimaryKeyJoinColumn` | Shares primary key | `@PrimaryKeyJoinColumn` |
| `@MapsId` | Maps to associated entity ID | `@MapsId` |
| `@JoinTable` | Creates join table | `@JoinTable(name="emp_addr")` |

---

## 💼 7. Interview Questions

### Q1: What is One-to-One mapping in JPA?
**Answer:** Bhai, One-to-One mapping JPA mein ek association hai where ek entity instance sirf ek doosre entity instance se related hota hai. For example:

```java
@Entity
public class Person {
    @OneToOne
    private Passport passport; // One person = One passport
}
```

### Q2: Difference between Unidirectional and Bidirectional mapping?

**Answer:**
```java
// Unidirectional - Sirf ek taraf se navigation
@Entity  
public class Employee {
    @OneToOne
    private Address address; // Employee → Address
}

// Bidirectional - Dono taraf se navigation
@Entity
public class Employee {
    @OneToOne
    @JoinColumn(name = "address_id")
    private Address address; // Employee → Address
}

@Entity
public class Address {
    @OneToOne(mappedBy = "address")  
    private Employee employee; // Address → Employee
}
```

### Q3: What is the purpose of mappedBy?
**Answer:** `mappedBy` inverse side of relationship define karta hai. Yeh batata hai ki:
- Relationship ka owner kaun hai
- Foreign key kahan store hoga
- Circular reference se bachne ke liye

```java
// Owner side
@OneToOne
@JoinColumn(name = "address_id")
private Address address;

// Inverse side
@OneToOne(mappedBy = "address") // 'address' is property name in Employee
private Employee employee;
```

### Q4: What are different ways to implement One-to-One mapping?

**Answer:** Teen main ways hain bhai:

1. **Foreign Key Column**
   ```java
   @OneToOne
   @JoinColumn(name = "address_id")
   private Address address;
   ```

2. **Shared Primary Key**
   ```java
   @OneToOne
   @PrimaryKeyJoinColumn
   private Address address;
   ```

3. **Join Table**
   ```java
   @OneToOne
   @JoinTable(name = "emp_address")
   private Address address;
   ```

### Q5: What is CascadeType in One-to-One mapping?

**Answer:** CascadeType defines karta hai ki operations parent entity se child entity mein propagate honge ya nahi:

```java
@OneToOne(cascade = CascadeType.ALL) // All operations cascade
@OneToOne(cascade = CascadeType.PERSIST) // Only save cascades
@OneToOne(cascade = CascadeType.REMOVE) // Only delete cascades
@OneToOne(cascade = CascadeType.MERGE) // Only update cascades
```

### Q6: Tricky Scenario - N+1 Problem

**Question:** How to avoid N+1 problem in One-to-One mapping?

**Answer:** Use **@BatchSize** or **JOIN FETCH**:

```java
// Solution 1: Using @BatchSize
@Entity
@BatchSize(size = 10)
public class Address {
    // entity code
}

// Solution 2: Using JOIN FETCH
@Query("SELECT e FROM Employee e JOIN FETCH e.address")
List<Employee> findAllWithAddress();

// Solution 3: Using EntityGraph
@EntityGraph(attributePaths = {"address"})
@Query("SELECT e FROM Employee e")
List<Employee> findAllWithAddressGraph();
```

---

## 🚫 8. Common Mistakes

### ❌ Mistake 1: Forgetting mappedBy in bidirectional
```java
// Wrong - Creates extra table
@Entity
public class Address {
    @OneToOne
    private Employee employee; // Missing mappedBy!
}

// Correct
@Entity  
public class Address {
    @OneToOne(mappedBy = "address")
    private Employee employee;
}
```

### ❌ Mistake 2: Using wrong cascade type
```java
// Wrong - Deletes address when employee is deleted
@OneToOne(cascade = CascadeType.ALL)
private Address address;

// Better - Only save operations cascade
@OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
private Address address;
```

### ❌ Mistake 3: Circular JSON serialization
```java
// Wrong - Causes infinite loop in JSON
@Entity
public class Employee {
    @OneToOne
    private Address address;
}

@Entity
public class Address {
    @OneToOne(mappedBy = "address")
    private Employee employee; // This causes circular reference!
}

// Solution - Use @JsonIgnore
@Entity
public class Address {
    @OneToOne(mappedBy = "address")
    @JsonIgnore // Prevents circular serialization
    private Employee employee;
}
```

### ❌ Mistake 4: Not handling null checks
```java
// Wrong - NullPointerException possible
public String getEmployeeCity(Long empId) {
    Employee emp = employeeRepository.findById(empId);
    return emp.getAddress().getCity(); // NPE if address is null!
}

// Correct - Proper null checking
public String getEmployeeCity(Long empId) {
    Employee emp = employeeRepository.findById(empId);
    if (emp != null && emp.getAddress() != null) {
        return emp.getAddress().getCity();
    }
    return "Address not found";
}
```

---

## ⭐ 9. Best Practices

### 🎯 Industry Standards

1. **Always use Lombok for cleaner code** 
   ```java
   @Entity
   @Data // Generates getters, setters, equals, hashCode
   @NoArgsConstructor // Default constructor
   @AllArgsConstructor // All-args constructor
   public class Employee {
       // entity fields
   }
   ```

2. **Use meaningful column names**
   ```java
   @JoinColumn(name = "employee_address_id") // Clear naming
   private Address address;
   ```

3. **Implement proper equals() and hashCode()**
   ```java
   @Entity
   public class Employee {
       @Override
       public boolean equals(Object o) {
           if (this == o) return true;
           if (!(o instanceof Employee)) return false;
           Employee employee = (Employee) o;
           return Objects.equals(id, employee.id);
       }
       
       @Override
       public int hashCode() {
           return Objects.hash(id);
       }
   }
   ```

### 🧹 Clean Code Principles

4. **Use Builder pattern for complex entities**
   ```java
   @Entity
   @Builder
   @Data
   public class Employee {
       // fields
       
       public static class EmployeeBuilder {
           public EmployeeBuilder withAddress(String street, String city) {
               Address addr = Address.builder()
                   .street(street)
                   .city(city)
                   .build();
               this.address = addr;
               return this;
           }
       }
   }
   
   // Usage
   Employee emp = Employee.builder()
       .name("Rohit")
       .emailId("rohit@example.com")
       .withAddress("MG Road", "Mumbai")
       .build();
   ```

5. **Use DTOs for API responses**
   ```java
   @Data
   public class EmployeeResponseDTO {
       private Long id;
       private String name;
       private AddressDTO address;
   }
   
   @Data
   public class AddressDTO {
       private String street;
       private String city;
       private String state;
   }
   ```

### 📝 Documentation Tips

6. **Document your relationships**
   ```java
   /**
    * Employee entity with one-to-one relationship to Address
    * 
    * @author Your Name
    * @version 1.0
    * @since 2024
    */
   @Entity
   @Table(name = "employees")
   public class Employee {
       
       /**
        * Address associated with this employee
        * Uses foreign key mapping with cascade operations
        */
       @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
       @JoinColumn(name = "address_id", referencedColumnName = "id")
       private Address address;
   }
   ```

7. **Use proper validation**
   ```java
   @Entity
   @Data
   public class Employee {
       
       @NotBlank(message = "Name cannot be blank")
       @Size(min = 2, max = 100, message = "Name must be between 2-100 characters")
       private String name;
       
       @Email(message = "Please provide valid email")
       private String emailId;
       
       @Valid // Validates nested object
       @OneToOne(cascade = CascadeType.ALL)
       private Address address;
   }
   ```

---

## 📚 10. Summary/Quick Recap

### 🎯 Key Takeaways

**Yaad Rakhne Ka Mantra:** 
- One-to-One = Ek-ka-Ek relationship 🔗
- @OneToOne annotation zaroori hai 📝
- mappedBy inverse side mein use karo 🔄
- CascadeType carefully choose karo ⚠️

### 🧠 Memory Tricks

| Concept | Memory Trick |
|---------|-------------|
| **@OneToOne** | "One Love, One Heart" - Bob Marley style! 💝 |
| **mappedBy** | "Mapped by" = "Kiske paas mapping hai?" 🗺️ |
| **@JoinColumn** | "Join" = "Jod" = "Connection banao" 🔗 |
| **CascadeType.ALL** | "ALL" = "Sab kuch" = "Sara operation pass kar do" 🚀 |

### 🤔 When to Use What?

```ascii
When to use One-to-One Mapping?
        |
    ┌───────────────────────┬───────────────────────┐
    │                       │                       │
Unique Relationship    Optional Relationship    Shared Identity
    │                       │                       │
Person-Passport        Employee-Address        User-Profile
Student-IDCard         Order-Receipt          Account-Details
```

### 📊 Quick Decision Matrix

| Scenario | Mapping Type | Code Example |
|----------|-------------|-------------|
| **Simple relationship** | Foreign Key | `@JoinColumn(name="addr_id")` |
| **Shared identity** | Primary Key | `@PrimaryKeyJoinColumn` |
| **Complex schema** | Join Table | `@JoinTable(name="emp_addr")` |
| **Both directions** | Bidirectional | `mappedBy="address"` |

### 🚀 Final Pro Tips

1. **Performance:** Use `FetchType.LAZY` for better performance
2. **Testing:** Always test bidirectional relationships 
3. **JSON:** Handle circular references with `@JsonIgnore`
4. **Validation:** Use `@Valid` for cascade validation
5. **Documentation:** Comment your mapping strategy

---

### 🎉 Congratulations Bhai!

Ab tum JPA One-to-One mapping ke expert ho gaye! 💪

**Next Steps:**
- Practice with real projects 🛠️
- Learn One-to-Many mapping 📈  
- Master Many-to-Many relationships 🕸️
- Explore Spring Data JPA queries 🔍

**Remember:** Practice makes perfect! Coding karte raho! 🚀

---

*"Code is like humor. When you have to explain it, it's bad." - Cory House*

**Happy Coding! 😊**
