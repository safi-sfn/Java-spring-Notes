# 🚀 Spring Boot JPA: One-to-One Mapping using Join Table 🔗

## 📝 Introduction - Confusion Clear Karte Hain Bhai! 

### 🤔 Simple Explanation Pehle
Yaar, imagine karo ki tumhara ek **Employee** hai aur uska ek **Address** hai. Normal case mein hum directly employee table mein address_id store kar dete hain. Lekin kya hoga agar employee ka address nahi hai? NULL values aayengi na! 😵

### 🏠 Real-life Analogy
Sochlo ki tum ek **company** ho aur tumhare paas employees hain. Kuch employees ka address complete hai, kuch ka nahi. Ab agar tum employee table mein hi address columns rakhoge to jo employees ka address nahi hai unke liye sare address fields NULL ho jayenge. Bohot messy lagega na database! 🗂️

Solution? **Join Table** banao! Ek separate table jo sirf relationship maintain kare. Jaise ki ek **mediator** ho between Employee aur Address. 👨‍💼

### 🎯 Technical Definition
**One-to-One mapping with Join Table** is a relationship where one entity is associated with exactly one instance of another entity, but instead of storing foreign key in either table, we create a separate join table to maintain this relationship. Ye approach NULL values se bachata hai aur database structure ko clean rakhta hai! 

---

## 📚 Key Terms/Concepts 

| Term | Meaning | Example |
|------|---------|---------|
| `@OneToOne` | One entity relates to exactly one other entity | Employee ↔ Address |
| `@JoinTable` | Creates separate table for relationship | `emp_address` table |
| `@JoinColumn` | Defines foreign key column in join table | `emp_id`, `addrs_id` |
| `joinColumns` | Column for owning entity | Employee ka column |
| `inverseJoinColumns` | Column for non-owning entity | Address ka column |
| `mappedBy` | Indicates non-owning side | `mappedBy = "address"` |

### 🎨 Visual Representation
```
EMPLOYEE Table           EMP_ADDRESS Table         ADDRESS Table
┌──────────────┐        ┌─────────────────┐       ┌──────────────┐
│ id (PK)      │◄───────┤ emp_id (FK)     │       │ id (PK)      │
│ name         │        │ addrs_id (FK)   ├──────►│ street       │
│ email        │        └─────────────────┘       │ city         │
│ mobile       │                                  │ state        │
│ designation  │                                  └──────────────┘
└──────────────┘
```

---

## 💻 Detailed Examples with Complete Code

### 🏗️ Project Structure
```
src/
├── main/
│   ├── java/
│   │   └── com/springjava/
│   │       ├── entity/
│   │       │   ├── Employee.java
│   │       │   └── Address.java
│   │       ├── repository/
│   │       │   ├── EmployeeRepository.java
│   │       │   └── AddressRepository.java
│   │       ├── service/
│   │       │   ├── EmployeeService.java
│   │       │   ├── EmployeeServiceImpl.java
│   │       │   ├── AddressService.java
│   │       │   └── AddressServiceImpl.java
│   │       ├── controller/
│   │       │   └── EmployeeController.java
│   │       └── model/
│   │           └── EmployeeModel.java
│   └── resources/
│       └── application.properties
```

### 🔧 Step 1: Maven Dependencies (pom.xml)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.6.3</version>
        <relativePath/>
    </parent>
    
    <groupId>com.springjava</groupId>
    <artifactId>demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    
    <dependencies>
        <!-- Spring Boot JPA Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <!-- Spring Boot Web Starter -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- Lombok - Boilerplate code ke liye -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
        
        <!-- H2 Database - In-memory database -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
    </dependencies>
</project>
```

### ⚙️ Step 2: Database Configuration (application.properties)
```properties
# H2 Database Configuration 🗃️
spring.datasource.url=jdbc:h2:mem:test
spring.datasource.username=sa
spring.datasource.password=
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=update
spring.h2.console.enabled=true
```

### 🏢 Step 3: Employee Entity (Owning Side)
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data  // Lombok ka magic - getters, setters, toString sab mil jayega! ✨
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    private String emailId;
    private String mobNo;
    private String design;
    
    // 🔗 Yahan magic happen hota hai!
    @OneToOne(cascade = CascadeType.ALL)
    @JoinTable(
        name = "emp_address",  // Join table ka naam
        joinColumns = {
            @JoinColumn(name = "emp_id", referencedColumnName = "id")
        },
        inverseJoinColumns = {
            @JoinColumn(name = "addrs_id", referencedColumnName = "id")
        }
    )
    private Address address;
}
```

### 🏠 Step 4: Address Entity (Non-owning Side)
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Address {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String street;
    private String city;
    private String state;
    
    // 🔄 Bidirectional relationship ka non-owning side
    @OneToOne(mappedBy = "address")
    private Employee employee;
}
```

### 📊 Step 5: Repository Layer
```java
// EmployeeRepository.java
package com.springjava.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import com.springjava.entity.Employee;

public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    // JpaRepository se sari basic CRUD operations mil jayengi! 🎉
}

// AddressRepository.java  
package com.springjava.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import com.springjava.entity.Address;

public interface AddressRepository extends JpaRepository<Address, Integer> {
}
```

### 🛠️ Step 6: Service Layer
```java
// EmployeeService.java - Interface
package com.springjava.service;

import java.util.List;
import com.springjava.entity.Employee;

public interface EmployeeService {
    void save(Employee emp);
    List<Employee> findAll();
}

// EmployeeServiceImpl.java - Implementation
package com.springjava.service;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.springjava.entity.Employee;
import com.springjava.repository.EmployeeRepository;

@Service
public class EmployeeServiceImpl implements EmployeeService {
    
    @Autowired
    EmployeeRepository employeeRepository;
    
    @Override
    public void save(Employee emp) {
        employeeRepository.save(emp);  // Save employee with address
    }
    
    @Override
    public List<Employee> findAll() {
        return employeeRepository.findAll();  // Get all employees with addresses
    }
}
```

### 📋 Step 7: Model Class (DTO)
```java
package com.springjava.model;

import lombok.Data;

@Data
public class EmployeeModel {
    private Integer id;
    private String name;
    private String emailId;
    private String mobNo;
    private String design;
    
    // Address fields bhi include kar rahe hain
    private String street;
    private String city;
    private String state;
}
```

### 🎮 Step 8: Controller (REST API)
```java
package com.springjava.controller;

import java.util.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.springjava.entity.Address;
import com.springjava.entity.Employee;
import com.springjava.model.EmployeeModel;
import com.springjava.service.EmployeeService;

@RestController
@RequestMapping("/api")
public class EmployeeController {
    
    @Autowired
    EmployeeService employeeService;
    
    // 💾 Employee save karne ka endpoint
    @PostMapping("/save")
    public ResponseEntity<?> saveEmp(@RequestBody EmployeeModel empModel) {
        Map<String, Object> response = new LinkedHashMap<>();
        
        // Address object banate hain
        Address address = new Address();
        address.setStreet(empModel.getStreet());
        address.setCity(empModel.getCity());
        address.setState(empModel.getState());
        
        // Employee object banate hain
        Employee emp = new Employee();
        emp.setName(empModel.getName());
        emp.setEmailId(empModel.getEmailId());
        emp.setMobNo(empModel.getMobNo());
        emp.setDesign(empModel.getDesign());
        emp.setAddress(address);  // Address set kar rahe hain
        
        // Database mein save karte hain
        employeeService.save(emp);
        
        response.put("status", 1);
        response.put("message", "Record saved successfully! 🎉");
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }
    
    // 📋 All employees get karne ka endpoint
    @GetMapping("/employees")
    public ResponseEntity<?> getEmployees() {
        Map<String, Object> response = new LinkedHashMap<>();
        List<Employee> employees = employeeService.findAll();
        List<EmployeeModel> employeeModels = new ArrayList<>();
        
        if (!employees.isEmpty()) {
            for (Employee emp : employees) {
                EmployeeModel model = new EmployeeModel();
                model.setId(emp.getId());
                model.setName(emp.getName());
                model.setEmailId(emp.getEmailId());
                model.setMobNo(emp.getMobNo());
                model.setDesign(emp.getDesign());
                
                // Address details add kar rahe hain
                if (emp.getAddress() != null) {
                    model.setStreet(emp.getAddress().getStreet());
                    model.setCity(emp.getAddress().getCity());
                    model.setState(emp.getAddress().getState());
                }
                
                employeeModels.add(model);
            }
            
            response.put("status", 1);
            response.put("data", employeeModels);
            return new ResponseEntity<>(response, HttpStatus.OK);
        } else {
            response.put("status", 0);
            response.put("message", "No data found! 😞");
            return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
        }
    }
}
```

### ▶️ Expected Output
```json
// POST /api/save response
{
    "status": 1,
    "message": "Record saved successfully! 🎉"
}

// GET /api/employees response  
{
    "status": 1,
    "data": [
        {
            "id": 1,
            "name": "Rahul Sharma",
            "emailId": "rahul@example.com",
            "mobNo": "9876543210",
            "design": "Software Engineer",
            "street": "123 MG Road",
            "city": "Bangalore",
            "state": "Karnataka"
        }
    ]
}
```

---

## ✅❌ Rules/Guidelines

### ✅ Rule 1: Always use @JoinTable on the owning side
```java
// ✅ Correct - Employee entity mein @JoinTable
@Entity
public class Employee {
    @OneToOne(cascade = CascadeType.ALL)
    @JoinTable(name = "emp_address", ...)
    private Address address;
}
```

```java
// ❌ Wrong - Both sides mein @JoinTable mat karo
@Entity  
public class Address {
    @OneToOne
    @JoinTable(name = "addr_emp", ...)  // ❌ Galat!
    private Employee employee;
}
```

### ✅ Rule 2: Use mappedBy on the non-owning side
```java
// ✅ Correct - Non-owning side mein mappedBy
@Entity
public class Address {
    @OneToOne(mappedBy = "address")
    private Employee employee;
}
```

### ✅ Rule 3: CascadeType carefully choose karo
```java
// ✅ Good for most cases
@OneToOne(cascade = CascadeType.ALL)

// ✅ Specific operations ke liye
@OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})

// ❌ Dangerous - accidentally delete ho sakta hai
@OneToOne(cascade = CascadeType.REMOVE)  // Use with caution!
```

### ✅ Rule 4: Join table naming convention follow karo
```java
// ✅ Good naming
@JoinTable(name = "emp_address")  // table1_table2 format
@JoinTable(name = "employee_address")  // Full names

// ❌ Bad naming  
@JoinTable(name = "emp_addr_rel")  // Too cryptic
@JoinTable(name = "EmpAddress")    // CamelCase avoid karo
```

---

## 🌍 Real-world Applications

### 🏦 Banking System Example
```java
@Entity
public class Customer {
    @Id
    private Long customerId;
    private String customerName;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinTable(
        name = "customer_kyc",
        joinColumns = @JoinColumn(name = "customer_id"),
        inverseJoinColumns = @JoinColumn(name = "kyc_id")
    )
    private KYCDetails kycDetails;
}

@Entity  
public class KYCDetails {
    @Id
    private Long kycId;
    private String panNumber;
    private String aadharNumber;
    private String kycStatus;
    
    @OneToOne(mappedBy = "kycDetails")
    private Customer customer;
}
```

### 🚗 Vehicle Registration System
```java
@Entity
public class Vehicle {
    @Id
    private String registrationNumber;
    private String make;
    private String model;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinTable(
        name = "vehicle_insurance",
        joinColumns = @JoinColumn(name = "reg_number", referencedColumnName = "registrationNumber"),
        inverseJoinColumns = @JoinColumn(name = "policy_id")
    )
    private Insurance insurance;
}
```

---

## 📊 Comparison Tables

### Join Table vs Foreign Key Approach

| Aspect | Join Table | Foreign Key |
|--------|------------|-------------|
| **NULL Values** | ✅ No NULL values | ❌ NULL values possible |
| **Database Design** | ✅ Cleaner structure | ❌ Mixed concerns |
| **Query Performance** | ❌ Extra join needed | ✅ Direct access |
| **Flexibility** | ✅ Easy to extend | ❌ Schema changes needed |
| **Storage** | ❌ Extra table overhead | ✅ Compact storage |
| **Use Case** | Optional relationships | Mandatory relationships |

### Different Cascade Types

| CascadeType | Description | Use Case |
|-------------|-------------|----------|
| `ALL` | All operations cascade | Parent-child tight coupling |
| `PERSIST` | Only save operations | New entities creation |
| `MERGE` | Only update operations | Existing entities updates |
| `REMOVE` | Only delete operations | ⚠️ Use carefully |
| `REFRESH` | Only refresh operations | Data synchronization |
| `DETACH` | Detachment operations | Memory management |

---

## 🎤 Interview Questions

### Q1: Why use Join Table instead of Foreign Key in One-to-One mapping?
**Answer:** Bhai, join table ka main benefit ye hai ki NULL values nahi aati. Agar employee ka address nahi hai to join table mein entry nahi hogi, but employee table clean rahega. Plus future mein agar relationship extend karna ho to easier ho jata hai.

```java
// Join Table approach - No NULL values
Employee: id=1, name="Rahul", email="rahul@test.com"
Address: id=1, street="MG Road", city="Bangalore"  
Join Table: emp_id=1, addr_id=1

// Foreign Key approach - NULL values possible
Employee: id=2, name="Priya", email="priya@test.com", address_id=NULL
```

### Q2: What's the difference between owning and non-owning side?
**Answer:** 
- **Owning side**: Jo side @JoinTable annotation rakhti hai, woh owning side hai. Database mein foreign key yahan se manage hoti hai.
- **Non-owning side**: Jo side mappedBy use karti hai, woh non-owning side hai. Ye sirf relationship ko read karne ke liye use hoti hai.

```java
// Owning side - Controls the relationship
@OneToOne(cascade = CascadeType.ALL)
@JoinTable(...)
private Address address;

// Non-owning side - Just for navigation
@OneToOne(mappedBy = "address")  
private Employee employee;
```

### Q3: Can we have @JoinTable on both sides?
**Answer:** ❌ **Bilkul nahi bhai!** Agar dono sides mein @JoinTable lagaoge to Hibernate confused ho jayega aur multiple join tables ban jayengi. Hamesha sirf owning side mein @JoinTable lagao.

### Q4: What happens if we don't use mappedBy?
**Answer:** Agar mappedBy nahi lagaoge to Hibernate samjhega ki ye two separate unidirectional relationships hain, aur database mein extra tables/columns ban jayengi. Performance impact hoga aur data inconsistency bhi ho sakti hai.

### Q5: How to handle lazy loading in Join Table mapping?
**Answer:** 
```java
// Lazy loading (default for @OneToOne)
@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
@JoinTable(...)
private Address address;

// Eager loading (load immediately)
@OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)  
@JoinTable(...)
private Address address;
```

---

## ❌ Common Mistakes

### ❌ Mistake 1: Using @JoinTable on both sides
```java
// ❌ Wrong - Dono sides mein @JoinTable
@Entity
public class Employee {
    @OneToOne
    @JoinTable(name = "emp_address", ...)
    private Address address;
}

@Entity
public class Address {
    @OneToOne
    @JoinTable(name = "addr_emp", ...)  // ❌ Galat!
    private Employee employee;
}
```

**Error Message:**
```
org.hibernate.MappingException: Foreign key (FK_xxx) must have same number of columns as the referenced primary key
```

**✅ Correct Approach:**
```java
// Employee - Owning side
@OneToOne(cascade = CascadeType.ALL)
@JoinTable(...)
private Address address;

// Address - Non-owning side  
@OneToOne(mappedBy = "address")
private Employee employee;
```

### ❌ Mistake 2: Wrong column names in @JoinColumn
```java
// ❌ Wrong - Column names don't match actual table columns
@JoinTable(
    name = "emp_address",
    joinColumns = @JoinColumn(name = "employee_id", referencedColumnName = "id"),  // ❌ 'id' column exists?
    inverseJoinColumns = @JoinColumn(name = "address_id", referencedColumnName = "pk")  // ❌ 'pk' column exists?
)
```

**✅ Correct:**
```java
@JoinTable(
    name = "emp_address",
    joinColumns = @JoinColumn(name = "emp_id", referencedColumnName = "id"),
    inverseJoinColumns = @JoinColumn(name = "addr_id", referencedColumnName = "id")
)
```

### ❌ Mistake 3: Missing Cascade configuration
```java
// ❌ Wrong - Address save nahi hoga automatically
@OneToOne
@JoinTable(...)
private Address address;

// Error when saving employee with new address
// Address entity must be persisted separately
```

**✅ Correct:**
```java
@OneToOne(cascade = CascadeType.ALL)  // ✅ Address bhi automatically save hoga
@JoinTable(...)
private Address address;
```

### ❌ Mistake 4: Infinite recursion in JSON serialization
```java
// ❌ Problem - Dono entities ek dusre ko reference kar rahe hain
public class Employee {
    private Address address;  // This will serialize Address
}

public class Address {
    private Employee employee;  // This will serialize Employee again!
}
```

**Error Message:**
```
com.fasterxml.jackson.databind.JsonMappingException: Infinite recursion (StackOverflowError)
```

**✅ Solutions:**
```java
// Solution 1: Use @JsonIgnore
@Entity
public class Address {
    @OneToOne(mappedBy = "address")
    @JsonIgnore  // Don't serialize this field
    private Employee employee;
}

// Solution 2: Use @JsonManagedReference and @JsonBackReference
@Entity
public class Employee {
    @OneToOne(cascade = CascadeType.ALL)
    @JoinTable(...)
    @JsonManagedReference
    private Address address;
}

@Entity
public class Address {
    @OneToOne(mappedBy = "address")
    @JsonBackReference
    private Employee employee;
}

// Solution 3: Use DTOs (Best practice)
public class EmployeeDTO {
    private Long id;
    private String name;
    private AddressDTO address;  // No circular reference
}
```

---

## 🏆 Best Practices

### 🎯 Practice 1: Always use DTOs for API responses
```java
// ✅ Good - Separate DTO classes
@RestController
public class EmployeeController {
    
    @GetMapping("/employees")
    public List<EmployeeDTO> getEmployees() {
        List<Employee> employees = employeeService.findAll();
        return employees.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }
    
    private EmployeeDTO convertToDTO(Employee employee) {
        EmployeeDTO dto = new EmployeeDTO();
        dto.setId(employee.getId());
        dto.setName(employee.getName());
        // Map only required fields
        return dto;
    }
}
```

### 🎯 Practice 2: Use proper naming conventions
```java
// ✅ Good naming
@JoinTable(
    name = "employee_address",  // Clear table name
    joinColumns = @JoinColumn(name = "employee_id"),  // Descriptive column names
    inverseJoinColumns = @JoinColumn(name = "address_id")
)
```

### 🎯 Practice 3: Handle null checks properly
```java
// ✅ Safe navigation
public String getEmployeeCity(Employee employee) {
    return Optional.ofNullable(employee)
            .map(Employee::getAddress)
            .map(Address::getCity)
            .orElse("City not available");
}
```

### 🎯 Practice 4: Use appropriate fetch strategies
```java
// ✅ For frequently accessed relationships
@OneToOne(fetch = FetchType.EAGER, cascade = CascadeType.ALL)

// ✅ For occasionally accessed relationships  
@OneToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
```

### 🎯 Practice 5: Implement equals() and hashCode() properly
```java
@Entity
public class Employee {
    @Id
    private Long id;
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof Employee)) return false;
        Employee employee = (Employee) o;
        return Objects.equals(id, employee.id);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}
```

---

## 📝 Summary/Quick Recap

### 🧠 Key Takeaways
1. **Join Table ka use**: NULL values avoid karne ke liye karo
2. **Owning Side**: @JoinTable sirf yahan lagao
3. **Non-owning Side**: mappedBy use karo
4. **Cascade Types**: Carefully choose karo based on business logic
5. **JSON Serialization**: Circular reference se bacho

### 🎪 Memory Tricks
- **"J-O-S"** - **J**oinTable **O**wning **S**ide mein lagao
- **"M-N-O"** - **M**appedBy **N**on-**O**wning side mein use karo
- **"C-A-L-L"** - **C**ascade **A**LL **L**agao **L**azily (carefully)

### 🤔 When to Use What?

| Scenario | Use Join Table | Use Foreign Key |
|----------|----------------|-----------------|
| Optional relationship | ✅ Yes | ❌ No |
| Mandatory relationship | ❌ No | ✅ Yes |
| Clean database design | ✅ Yes | ❌ No |
| Better performance | ❌ No | ✅ Yes |
| Future extensibility | ✅ Yes | ❌ No |

### 🔥 Pro Tips
- Hamesha DTOs use karo API responses mein
- Database indexes add karo join table columns mein
- Unit tests likhna mat bhulo relationships ke liye
- Production mein lazy loading carefully handle karo

---

## 🎯 Testing Commands

### Postman Testing
```bash
# Save Employee with Address
POST http://localhost:8080/api/save
Content-Type: application/json

{
    "name": "Rahul Sharma",
    "emailId": "rahul@example.com",
    "mobNo": "9876543210",
    "design": "Software Engineer",
    "street": "123 MG Road",
    "city": "Bangalore", 
    "state": "Karnataka"
}

# Get All Employees
GET http://localhost:8080/api/employees
```

### H2 Database Console
```
URL: http://localhost:8080/h2-console
JDBC URL: jdbc:h2:mem:test
Username: sa
Password: (leave empty)
```

### SQL Queries to Check Tables
```sql
-- Check tables created
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'PUBLIC';

-- Check employee data
SELECT * FROM EMPLOYEE;

-- Check address data  
SELECT * FROM ADDRESS;

-- Check join table data
SELECT * FROM EMP_ADDRESS;

-- Join query to see complete data
SELECT e.name, e.email_id, a.street, a.city, a.state 
FROM EMPLOYEE e 
JOIN EMP_ADDRESS ea ON e.id = ea.emp_id
JOIN ADDRESS a ON ea.addrs_id = a.id;
```

Yaar, ye complete guide hai One-to-One mapping with Join Table ke liye! Practice karo aur doubt ho to puchna. Happy coding! 🚀✨
