# 🎯 Spring Boot JPA One-to-One Unidirectional Mapping 
## Complete Study Guide 📚

---

## 🤔 **1. Introduction with Confusion Clearing**

### Simple Explanation First 🌟
Bhai, **One-to-One Unidirectional Mapping** matlab ek entity ka sirf ek hi dusre entity se relationship hai, lekin yeh relationship **ek taraf** se hi hai! 

### Real-life Analogy 🏠
Socho tumhara ek **Aadhaar Card** hai:
- **Tumhare paas** ek Aadhaar card hai (Employee has Address)
- **Aadhaar card** ko pata nahi ki yeh kiski hai (Address doesn't know about Employee)
- **Ek Employee** = **Ek Address** (One-to-One)
- **Sirf Employee** ko pata hai ki uska address kya hai (Unidirectional)

### Technical Definition 📖
> **One-to-One Unidirectional Mapping**: Ek entity class ka instance dusre entity class ke sirf ek hi instance se associated hota hai, aur yeh association sirf ek direction mein hoti hai using foreign key.

---

## 🔑 **2. Key Terms/Concepts**

| Term | Technical Definition |
|------|---------------------|
| **@OneToOne** | JPA annotation for one-to-one relationship |
| **@JoinColumn** | Foreign key column definition |
| **Unidirectional** | Only owning entity knows about relationship |
| **Owning Entity** |  Entity that contains foreign key |
| **Target Entity** |  Referenced entity (doesn't know about owner) |
| **CascadeType.ALL** | All operations cascade to related entity |

### Visual Representation 📊
```
Employee Table          Address Table
+----+------+--------+   +----+--------+------+-------+
| id | name |addrs_id|   | id | street | city | state |
+----+------+--------+   +----+--------+------+-------+
| 1  |Rahul | 101    |   |101 |CP      |Delhi |DL     |
| 2  |Priya | 102    |   |102 |Andheri |Mumbai|MH     |
+----+------+--------+   +----+--------+------+-------+
      ↓
  Foreign Key Reference (Unidirectional)
```

---

## 💡 **3. Detailed Examples**

### Complete Working Code 🔥

#### Address Entity (Target Entity)
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data  // Lombok - Auto generates getters/setters
public class Address {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String street;
    private String city; 
    private String state;
    
    // No reference to Employee - That's why UNIDIRECTIONAL! 🎯
}
```

#### Employee Entity (Owning Entity)
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    private String emailId;
    private String mobNo;
    private String design;
    
    // 🔥 This is where the magic happens!
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "addrs_id", referencedColumnName = "id")
    private Address address;
}
```

### Expected Outputs 📤

#### Database Tables Generated:
```sql
-- EMPLOYEE Table
CREATE TABLE EMPLOYEE (
    ID INTEGER PRIMARY KEY,
    NAME VARCHAR(255),
    EMAIL_ID VARCHAR(255),
    MOB_NO VARCHAR(255),
    DESIGN VARCHAR(255),
    ADDRS_ID INTEGER,  -- Foreign Key
    FOREIGN KEY (ADDRS_ID) REFERENCES ADDRESS(ID)
);

-- ADDRESS Table  
CREATE TABLE ADDRESS (
    ID INTEGER PRIMARY KEY,
    STREET VARCHAR(255),
    CITY VARCHAR(255),
    STATE VARCHAR(255)
);
```

### Step-by-step Explanation 🪜

1. **@Entity**: JPA ko batata hai ki yeh database table hai
2. **@Data**: Lombok automatically getters/setters banata hai
3. **@Id + @GeneratedValue**: Primary key auto-increment
4. **@OneToOne**: One-to-One relationship define karta hai
5. **@JoinColumn**: Foreign key column ka naam aur reference
6. **cascade = CascadeType.ALL**: Employee save/delete karo toh Address bhi ho jayega

---

## 📏 **4. Rules/Guidelines**

### Rule 1: @OneToOne Annotation ✅
```java
// ✅ Correct Way
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "addrs_id", referencedColumnName = "id")
private Address address;

// ❌ Wrong Way - No JoinColumn
@OneToOne(cascade = CascadeType.ALL)
private Address address;
```

### Rule 2: Proper Foreign Key Naming ✅
```java
// ✅ Correct - Clear naming
@JoinColumn(name = "addrs_id", referencedColumnName = "id")

// ❌ Wrong - Confusing naming  
@JoinColumn(name = "xyz", referencedColumnName = "id")
```

### Rule 3: Cascade Operations ✅
```java
// ✅ Correct - Use appropriate cascade
@OneToOne(cascade = CascadeType.ALL)  // For full control
@OneToOne(cascade = CascadeType.PERSIST) // Only for save operations

// ❌ Wrong - No cascade when needed
@OneToOne  // Address won't be saved automatically
```

### Rule 4: Unidirectional Nature ✅
```java
// ✅ Correct - Target entity has no back reference
public class Address {
    // No Employee reference - Perfect! 🎯
}

// ❌ Wrong - This makes it bidirectional
public class Address {
    @OneToOne(mappedBy = "address")
    private Employee employee; // This breaks unidirectional rule!
}
```

---

## 🌍 **5. Real-world Applications**

### Banking System Example 🏦
```java
@Entity
public class Account {
    @Id
    private Long accountNumber;
    private String accountType;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "kyc_id")
    private KYCDetails kycDetails;
}

@Entity  
public class KYCDetails {
    @Id
    private Long id;
    private String panNumber;
    private String aadhaarNumber;
    // No Account reference - Unidirectional!
}
```

### E-commerce Product System 🛒
```java
@Entity
public class Product {
    @Id
    private Long productId;
    private String name;
    private Double price;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "spec_id")
    private ProductSpecification specification;
}

@Entity
public class ProductSpecification {
    @Id
    private Long id;
    private String color;
    private String size;
    private String material;
    // No Product reference
}
```

### User Profile System 👤
```java
@Entity
public class User {
    @Id
    private Long userId;
    private String username;
    private String email;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id")
    private UserProfile profile;
}
```

---

## ⚖️ **6. Comparison Tables**

### Unidirectional vs Bidirectional 🔄

| Aspect | Unidirectional | Bidirectional |
|--------|---------------|---------------|
| **Navigation** | Only Owner → Target | Owner ⟷ Target |
| **Memory Usage** | Lower | Higher |
| **Complexity** | Simple | Complex |
| **Performance** | Better | Slower |
| **Use Case** | Simple references | Two-way navigation needed |

### Cascade Types Comparison 🌊

| CascadeType | When Used | Example |
|-------------|-----------|---------|
| **ALL** | Complete control over child | Employee controls Address completely |
| **PERSIST** | Only save operations | Save Employee → Save Address |
| **MERGE** | Only update operations | Update Employee → Update Address |
| **REMOVE** | Only delete operations | Delete Employee → Delete Address |
| **REFRESH** | Only refresh operations | Refresh Employee → Refresh Address |

---

## 🎤 **7. Interview Questions**

### Q1: What is the difference between Unidirectional and Bidirectional mapping?

**Answer:** 
```
Bhai, yeh bahut important question hai! 

Unidirectional:
- Sirf owner entity target entity ko jaanti hai
- Memory efficient  
- Simple implementation
- Example: Employee knows Address, but Address doesn't know Employee

Bidirectional:  
- Dono entities ek dusre ko jaante hain
- More memory usage
- Complex but provides two-way navigation
- Example: Employee ⟷ Address both know each other
```

### Q2: Why use @JoinColumn annotation?

**Answer with Code:**
```java
// Without @JoinColumn - JPA creates default names
@OneToOne
private Address address;
// Creates: employee_address_id (confusing!)

// With @JoinColumn - Clear naming
@OneToOne
@JoinColumn(name = "addrs_id", referencedColumnName = "id") 
private Address address;
// Creates: addrs_id (clear and meaningful!)
```

### Q3: What happens if we don't use Cascade?

**Answer:**
```java
// Without Cascade
@OneToOne
@JoinColumn(name = "addrs_id")
private Address address;

// Problem: You have to save Address separately!
Address addr = new Address();
addressRepository.save(addr);  // Manual save needed

Employee emp = new Employee();
emp.setAddress(addr);
employeeRepository.save(emp);

// With CascadeType.ALL
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "addrs_id")
private Address address;

// Solution: Address saves automatically!
Employee emp = new Employee();
emp.setAddress(new Address());
employeeRepository.save(emp);  // Address auto-saved! 🎉
```

### Tricky Scenario 🧩
**Q: What if we save Employee without setting Address?**

```java
Employee emp = new Employee();
emp.setName("Rahul");
// emp.setAddress(null); - Address is null

employeeRepository.save(emp); // What happens?

// Answer: Employee saves successfully with addrs_id = NULL
// No error because Address is optional by default!
```

---

## ❌ **8. Common Mistakes**

### Mistake 1: Wrong Cascade Usage 🚫
```java
// ❌ Wrong - Using wrong cascade
@OneToOne(cascade = CascadeType.REMOVE) 
// Only deletes Address, but not useful for saving

// ✅ Correct
@OneToOne(cascade = CascadeType.ALL)
// Handles all operations properly
```

### Mistake 2: Forgetting @JoinColumn 🚫
```java
// ❌ Wrong - JPA creates confusing column names
@OneToOne(cascade = CascadeType.ALL)
private Address address;
// Creates: address_id (generic name)

// ✅ Correct - Clear column naming
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "addrs_id", referencedColumnName = "id")
private Address address;
```

### Mistake 3: Making it Bidirectional by Mistake 🚫
```java
// ❌ Wrong - This breaks unidirectional nature
public class Address {
    @OneToOne(mappedBy = "address")
    private Employee employee; // Don't add this in unidirectional!
}

// ✅ Correct - Keep it unidirectional
public class Address {
    // No Employee reference - Perfect!
}
```

### Actual Error Messages 💥
```bash
# Error when wrong referencedColumnName
org.hibernate.MappingException: Unable to find column with logical name: wrong_id in table: address

# Error when circular reference in JSON
com.fasterxml.jackson.databind.JsonMappingException: Infinite recursion

# Solution for JSON issue:
@JsonIgnore or @JsonManagedReference/@JsonBackReference
```

---

## ⭐ **9. Best Practices**

### Industry Standards 🏭

1. **Naming Convention**
```java
// ✅ Good naming
@JoinColumn(name = "address_id")          // Clear purpose
@JoinColumn(name = "profile_id")          // Clear purpose  
@JoinColumn(name = "specification_id")    // Clear purpose

// ❌ Bad naming
@JoinColumn(name = "id1")                 // Confusing
@JoinColumn(name = "ref")                 // Too generic
```

2. **Repository Layer**
```java
// ✅ Best Practice - Use JpaRepository
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    
    // Custom query methods
    List<Employee> findByAddressCity(String city);
    Optional<Employee> findByEmailId(String email);
}
```

3. **Service Layer Pattern**
```java
@Service
@Transactional  // Important for data consistency
public class EmployeeServiceImpl implements EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    @Override
    public Employee saveEmployee(Employee employee) {
        return employeeRepository.save(employee);
    }
}
```

### Clean Code Principles 🧹

1. **Use DTOs for API**
```java
// ✅ Good - Separate DTO for API
@Data
public class EmployeeDTO {
    private String name;
    private String emailId;
    private AddressDTO address;
}

// ✅ Good - Entity for database
@Entity
@Data  
public class Employee {
    // Database specific annotations
}
```

2. **Validation**
```java
@Entity
@Data
public class Employee {
    
    @NotBlank(message = "Name cannot be blank")
    private String name;
    
    @Email(message = "Email should be valid")
    private String emailId;
    
    @Valid  // Validates nested object
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "addrs_id")
    private Address address;
}
```

### Documentation Tips 📝

```java
/**
 * Employee entity with unidirectional one-to-one mapping to Address
 * 
 * Table: EMPLOYEE
 * Foreign Key: addrs_id -> ADDRESS.id
 * 
 * Note: This is unidirectional mapping - Address entity doesn't 
 * know about Employee entity.
 */
@Entity
@Table(name = "EMPLOYEE")
@Data
public class Employee {
    // Implementation
}
```

---

## 📝 **10. Complete Working Controller Example**

```java
@RestController
@RequestMapping("/api/employees")
@Validated
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    /**
     * Save employee with address
     * POST /api/employees
     */
    @PostMapping
    public ResponseEntity<Map<String, Object>> saveEmployee(
            @Valid @RequestBody EmployeeDTO employeeDTO) {
        
        // Convert DTO to Entity
        Employee employee = new Employee();
        employee.setName(employeeDTO.getName());
        employee.setEmailId(employeeDTO.getEmailId());
        employee.setMobNo(employeeDTO.getMobNo());
        employee.setDesign(employeeDTO.getDesign());
        
        // Create and set address
        Address address = new Address();
        address.setStreet(employeeDTO.getStreet());
        address.setCity(employeeDTO.getCity());
        address.setState(employeeDTO.getState());
        
        employee.setAddress(address);
        
        // Save (cascade will save address too!)
        Employee savedEmployee = employeeService.saveEmployee(employee);
        
        Map<String, Object> response = new HashMap<>();
        response.put("status", "success");
        response.put("message", "Employee saved successfully!");
        response.put("employeeId", savedEmployee.getId());
        
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
    
    /**
     * Get all employees with their addresses  
     * GET /api/employees
     */
    @GetMapping
    public ResponseEntity<List<Employee>> getAllEmployees() {
        List<Employee> employees = employeeService.findAllEmployees();
        return ResponseEntity.ok(employees);
    }
    
    /**
     * Get employee by ID
     * GET /api/employees/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<Employee> getEmployeeById(@PathVariable Integer id) {
        Optional<Employee> employee = employeeService.findEmployeeById(id);
        
        if (employee.isPresent()) {
            return ResponseEntity.ok(employee.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }
}
```

---

## 🎯 **11. Summary/Quick Recap**

### Key Takeaways 🔑

1. **One-to-One Unidirectional** = Ek entity dusre ko jaanti hai, but reverse nahi
2. **@OneToOne + @JoinColumn** = Magic combination hai bhai!
3. **CascadeType.ALL** = Parent ke saath child bhi handle ho jata hai
4. **Unidirectional** = Memory efficient aur simple
5. **Foreign Key** owner entity mein hoti hai, target mein nahi

### Memory Tricks 🧠

- **"Employee has Address, Address doesn't care about Employee"** 👤🏠
- **"Owner knows target, target doesn't know owner"** 🎯
- **"One direction traffic - no U-turn allowed!"** 🚗➡️

### When to Use What 🤔

| Use Case | Mapping Type | Why? |
|----------|-------------|------|
| User → Profile | Unidirectional | Profile doesn't need to know user |
| Employee → Address | Unidirectional | Address is just data store |
| Order ↔ Customer | Bidirectional | Both need to navigate each other |

### Quick Configuration Checklist ✅

```java
// ✅ Perfect Unidirectional Setup
@Entity
public class Owner {
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "target_id", referencedColumnName = "id")
    private Target target;
}

@Entity  
public class Target {
    // No reference to Owner
}
```

---

## 🚀 **Bonus: Advanced Tips**

### Custom Repository Methods
```java
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    
    // Find employees by city
    @Query("SELECT e FROM Employee e WHERE e.address.city = :city")
    List<Employee> findEmployeesByCity(@Param("city") String city);
    
    // Find employees by state  
    List<Employee> findByAddressState(String state);
    
    // Count employees in a city
    @Query("SELECT COUNT(e) FROM Employee e WHERE e.address.city = :city")
    Long countEmployeesByCity(@Param("city") String city);
}
```

### Transaction Management
```java
@Service
@Transactional
public class EmployeeServiceImpl {
    
    @Transactional(rollbackFor = Exception.class)
    public Employee saveEmployeeWithValidation(Employee employee) {
        // Custom business logic
        if (employee.getAddress() == null) {
            throw new BusinessException("Address is required!");
        }
        return employeeRepository.save(employee);
    }
}
```

---

**Yaad rakhna bhai** 💭: 
- Practice makes perfect! 
- Start simple, then add complexity
- Test your mappings with actual data
- Always check generated SQL queries using `show-sql=true`

**Happy Coding! 🎉👨‍💻**

---

*Made with ❤️ for Java enthusiasts | Keep practicing, keep growing! 🌱*
