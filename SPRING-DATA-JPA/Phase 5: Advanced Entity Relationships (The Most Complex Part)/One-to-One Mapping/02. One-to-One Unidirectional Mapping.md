# ğŸ¯ Spring Boot JPA One-to-One Unidirectional Mapping 
## Complete Study Guide ğŸ“š

---

## ğŸ¤” **1. Introduction with Confusion Clearing**

### Simple Explanation First ğŸŒŸ
Bhai, **One-to-One Unidirectional Mapping** matlab ek entity ka sirf ek hi dusre entity se relationship hai, lekin yeh relationship **ek taraf** se hi hai! 

### Real-life Analogy ğŸ 
Socho tumhara ek **Aadhaar Card** hai:
- **Tumhare paas** ek Aadhaar card hai (Employee has Address)
- **Aadhaar card** ko pata nahi ki yeh kiski hai (Address doesn't know about Employee)
- **Ek Employee** = **Ek Address** (One-to-One)
- **Sirf Employee** ko pata hai ki uska address kya hai (Unidirectional)

### Technical Definition ğŸ“–
> **One-to-One Unidirectional Mapping**: Ek entity class ka instance dusre entity class ke sirf ek hi instance se associated hota hai, aur yeh association sirf ek direction mein hoti hai using foreign key.

---

## ğŸ”‘ **2. Key Terms/Concepts**

| Term | Technical Definition |
|------|---------------------|
| **@OneToOne** | JPA annotation for one-to-one relationship |
| **@JoinColumn** | Foreign key column definition |
| **Unidirectional** | Only owning entity knows about relationship |
| **Owning Entity** |  Entity that contains foreign key |
| **Target Entity** |  Referenced entity (doesn't know about owner) |
| **CascadeType.ALL** | All operations cascade to related entity |

### Visual Representation ğŸ“Š
```
Employee Table          Address Table
+----+------+--------+   +----+--------+------+-------+
| id | name |addrs_id|   | id | street | city | state |
+----+------+--------+   +----+--------+------+-------+
| 1  |Rahul | 101    |   |101 |CP      |Delhi |DL     |
| 2  |Priya | 102    |   |102 |Andheri |Mumbai|MH     |
+----+------+--------+   +----+--------+------+-------+
      â†“
  Foreign Key Reference (Unidirectional)
```

---

## ğŸ’¡ **3. Detailed Examples**

### Complete Working Code ğŸ”¥

#### Address Entity (Target Entity)
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data  // Lombok - Auto generates getters/setters
public class Address {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String street;
    private String city; 
    private String state;
    
    // No reference to Employee - That's why UNIDIRECTIONAL! ğŸ¯
}
```

#### Employee Entity (Owning Entity)
```java
package com.springjava.entity;

import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Employee {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    
    private String name;
    private String emailId;
    private String mobNo;
    private String design;
    
    // ğŸ”¥ This is where the magic happens!
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "addrs_id", referencedColumnName = "id")
    private Address address;
}
```

### Expected Outputs ğŸ“¤

#### Database Tables Generated:
```sql
-- EMPLOYEE Table
CREATE TABLE EMPLOYEE (
    ID INTEGER PRIMARY KEY,
    NAME VARCHAR(255),
    EMAIL_ID VARCHAR(255),
    MOB_NO VARCHAR(255),
    DESIGN VARCHAR(255),
    ADDRS_ID INTEGER,  -- Foreign Key
    FOREIGN KEY (ADDRS_ID) REFERENCES ADDRESS(ID)
);

-- ADDRESS Table  
CREATE TABLE ADDRESS (
    ID INTEGER PRIMARY KEY,
    STREET VARCHAR(255),
    CITY VARCHAR(255),
    STATE VARCHAR(255)
);
```

### Step-by-step Explanation ğŸªœ

1. **@Entity**: JPA ko batata hai ki yeh database table hai
2. **@Data**: Lombok automatically getters/setters banata hai
3. **@Id + @GeneratedValue**: Primary key auto-increment
4. **@OneToOne**: One-to-One relationship define karta hai
5. **@JoinColumn**: Foreign key column ka naam aur reference
6. **cascade = CascadeType.ALL**: Employee save/delete karo toh Address bhi ho jayega

---

## ğŸ“ **4. Rules/Guidelines**

### Rule 1: @OneToOne Annotation âœ…
```java
// âœ… Correct Way
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "addrs_id", referencedColumnName = "id")
private Address address;

// âŒ Wrong Way - No JoinColumn
@OneToOne(cascade = CascadeType.ALL)
private Address address;
```

### Rule 2: Proper Foreign Key Naming âœ…
```java
// âœ… Correct - Clear naming
@JoinColumn(name = "addrs_id", referencedColumnName = "id")

// âŒ Wrong - Confusing naming  
@JoinColumn(name = "xyz", referencedColumnName = "id")
```

### Rule 3: Cascade Operations âœ…
```java
// âœ… Correct - Use appropriate cascade
@OneToOne(cascade = CascadeType.ALL)  // For full control
@OneToOne(cascade = CascadeType.PERSIST) // Only for save operations

// âŒ Wrong - No cascade when needed
@OneToOne  // Address won't be saved automatically
```

### Rule 4: Unidirectional Nature âœ…
```java
// âœ… Correct - Target entity has no back reference
public class Address {
    // No Employee reference - Perfect! ğŸ¯
}

// âŒ Wrong - This makes it bidirectional
public class Address {
    @OneToOne(mappedBy = "address")
    private Employee employee; // This breaks unidirectional rule!
}
```

---

## ğŸŒ **5. Real-world Applications**

### Banking System Example ğŸ¦
```java
@Entity
public class Account {
    @Id
    private Long accountNumber;
    private String accountType;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "kyc_id")
    private KYCDetails kycDetails;
}

@Entity  
public class KYCDetails {
    @Id
    private Long id;
    private String panNumber;
    private String aadhaarNumber;
    // No Account reference - Unidirectional!
}
```

### E-commerce Product System ğŸ›’
```java
@Entity
public class Product {
    @Id
    private Long productId;
    private String name;
    private Double price;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "spec_id")
    private ProductSpecification specification;
}

@Entity
public class ProductSpecification {
    @Id
    private Long id;
    private String color;
    private String size;
    private String material;
    // No Product reference
}
```

### User Profile System ğŸ‘¤
```java
@Entity
public class User {
    @Id
    private Long userId;
    private String username;
    private String email;
    
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "profile_id")
    private UserProfile profile;
}
```

---

## âš–ï¸ **6. Comparison Tables**

### Unidirectional vs Bidirectional ğŸ”„

| Aspect | Unidirectional | Bidirectional |
|--------|---------------|---------------|
| **Navigation** | Only Owner â†’ Target | Owner âŸ· Target |
| **Memory Usage** | Lower | Higher |
| **Complexity** | Simple | Complex |
| **Performance** | Better | Slower |
| **Use Case** | Simple references | Two-way navigation needed |

### Cascade Types Comparison ğŸŒŠ

| CascadeType | When Used | Example |
|-------------|-----------|---------|
| **ALL** | Complete control over child | Employee controls Address completely |
| **PERSIST** | Only save operations | Save Employee â†’ Save Address |
| **MERGE** | Only update operations | Update Employee â†’ Update Address |
| **REMOVE** | Only delete operations | Delete Employee â†’ Delete Address |
| **REFRESH** | Only refresh operations | Refresh Employee â†’ Refresh Address |

---

## ğŸ¤ **7. Interview Questions**

### Q1: What is the difference between Unidirectional and Bidirectional mapping?

**Answer:** 
```
Bhai, yeh bahut important question hai! 

Unidirectional:
- Sirf owner entity target entity ko jaanti hai
- Memory efficient  
- Simple implementation
- Example: Employee knows Address, but Address doesn't know Employee

Bidirectional:  
- Dono entities ek dusre ko jaante hain
- More memory usage
- Complex but provides two-way navigation
- Example: Employee âŸ· Address both know each other
```

### Q2: Why use @JoinColumn annotation?

**Answer with Code:**
```java
// Without @JoinColumn - JPA creates default names
@OneToOne
private Address address;
// Creates: employee_address_id (confusing!)

// With @JoinColumn - Clear naming
@OneToOne
@JoinColumn(name = "addrs_id", referencedColumnName = "id") 
private Address address;
// Creates: addrs_id (clear and meaningful!)
```

### Q3: What happens if we don't use Cascade?

**Answer:**
```java
// Without Cascade
@OneToOne
@JoinColumn(name = "addrs_id")
private Address address;

// Problem: You have to save Address separately!
Address addr = new Address();
addressRepository.save(addr);  // Manual save needed

Employee emp = new Employee();
emp.setAddress(addr);
employeeRepository.save(emp);

// With CascadeType.ALL
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "addrs_id")
private Address address;

// Solution: Address saves automatically!
Employee emp = new Employee();
emp.setAddress(new Address());
employeeRepository.save(emp);  // Address auto-saved! ğŸ‰
```

### Tricky Scenario ğŸ§©
**Q: What if we save Employee without setting Address?**

```java
Employee emp = new Employee();
emp.setName("Rahul");
// emp.setAddress(null); - Address is null

employeeRepository.save(emp); // What happens?

// Answer: Employee saves successfully with addrs_id = NULL
// No error because Address is optional by default!
```

---

## âŒ **8. Common Mistakes**

### Mistake 1: Wrong Cascade Usage ğŸš«
```java
// âŒ Wrong - Using wrong cascade
@OneToOne(cascade = CascadeType.REMOVE) 
// Only deletes Address, but not useful for saving

// âœ… Correct
@OneToOne(cascade = CascadeType.ALL)
// Handles all operations properly
```

### Mistake 2: Forgetting @JoinColumn ğŸš«
```java
// âŒ Wrong - JPA creates confusing column names
@OneToOne(cascade = CascadeType.ALL)
private Address address;
// Creates: address_id (generic name)

// âœ… Correct - Clear column naming
@OneToOne(cascade = CascadeType.ALL)
@JoinColumn(name = "addrs_id", referencedColumnName = "id")
private Address address;
```

### Mistake 3: Making it Bidirectional by Mistake ğŸš«
```java
// âŒ Wrong - This breaks unidirectional nature
public class Address {
    @OneToOne(mappedBy = "address")
    private Employee employee; // Don't add this in unidirectional!
}

// âœ… Correct - Keep it unidirectional
public class Address {
    // No Employee reference - Perfect!
}
```

### Actual Error Messages ğŸ’¥
```bash
# Error when wrong referencedColumnName
org.hibernate.MappingException: Unable to find column with logical name: wrong_id in table: address

# Error when circular reference in JSON
com.fasterxml.jackson.databind.JsonMappingException: Infinite recursion

# Solution for JSON issue:
@JsonIgnore or @JsonManagedReference/@JsonBackReference
```

---

## â­ **9. Best Practices**

### Industry Standards ğŸ­

1. **Naming Convention**
```java
// âœ… Good naming
@JoinColumn(name = "address_id")          // Clear purpose
@JoinColumn(name = "profile_id")          // Clear purpose  
@JoinColumn(name = "specification_id")    // Clear purpose

// âŒ Bad naming
@JoinColumn(name = "id1")                 // Confusing
@JoinColumn(name = "ref")                 // Too generic
```

2. **Repository Layer**
```java
// âœ… Best Practice - Use JpaRepository
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    
    // Custom query methods
    List<Employee> findByAddressCity(String city);
    Optional<Employee> findByEmailId(String email);
}
```

3. **Service Layer Pattern**
```java
@Service
@Transactional  // Important for data consistency
public class EmployeeServiceImpl implements EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    @Override
    public Employee saveEmployee(Employee employee) {
        return employeeRepository.save(employee);
    }
}
```

### Clean Code Principles ğŸ§¹

1. **Use DTOs for API**
```java
// âœ… Good - Separate DTO for API
@Data
public class EmployeeDTO {
    private String name;
    private String emailId;
    private AddressDTO address;
}

// âœ… Good - Entity for database
@Entity
@Data  
public class Employee {
    // Database specific annotations
}
```

2. **Validation**
```java
@Entity
@Data
public class Employee {
    
    @NotBlank(message = "Name cannot be blank")
    private String name;
    
    @Email(message = "Email should be valid")
    private String emailId;
    
    @Valid  // Validates nested object
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "addrs_id")
    private Address address;
}
```

### Documentation Tips ğŸ“

```java
/**
 * Employee entity with unidirectional one-to-one mapping to Address
 * 
 * Table: EMPLOYEE
 * Foreign Key: addrs_id -> ADDRESS.id
 * 
 * Note: This is unidirectional mapping - Address entity doesn't 
 * know about Employee entity.
 */
@Entity
@Table(name = "EMPLOYEE")
@Data
public class Employee {
    // Implementation
}
```

---

## ğŸ“ **10. Complete Working Controller Example**

```java
@RestController
@RequestMapping("/api/employees")
@Validated
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    /**
     * Save employee with address
     * POST /api/employees
     */
    @PostMapping
    public ResponseEntity<Map<String, Object>> saveEmployee(
            @Valid @RequestBody EmployeeDTO employeeDTO) {
        
        // Convert DTO to Entity
        Employee employee = new Employee();
        employee.setName(employeeDTO.getName());
        employee.setEmailId(employeeDTO.getEmailId());
        employee.setMobNo(employeeDTO.getMobNo());
        employee.setDesign(employeeDTO.getDesign());
        
        // Create and set address
        Address address = new Address();
        address.setStreet(employeeDTO.getStreet());
        address.setCity(employeeDTO.getCity());
        address.setState(employeeDTO.getState());
        
        employee.setAddress(address);
        
        // Save (cascade will save address too!)
        Employee savedEmployee = employeeService.saveEmployee(employee);
        
        Map<String, Object> response = new HashMap<>();
        response.put("status", "success");
        response.put("message", "Employee saved successfully!");
        response.put("employeeId", savedEmployee.getId());
        
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }
    
    /**
     * Get all employees with their addresses  
     * GET /api/employees
     */
    @GetMapping
    public ResponseEntity<List<Employee>> getAllEmployees() {
        List<Employee> employees = employeeService.findAllEmployees();
        return ResponseEntity.ok(employees);
    }
    
    /**
     * Get employee by ID
     * GET /api/employees/{id}
     */
    @GetMapping("/{id}")
    public ResponseEntity<Employee> getEmployeeById(@PathVariable Integer id) {
        Optional<Employee> employee = employeeService.findEmployeeById(id);
        
        if (employee.isPresent()) {
            return ResponseEntity.ok(employee.get());
        } else {
            return ResponseEntity.notFound().build();
        }
    }
}
```

---

## ğŸ¯ **11. Summary/Quick Recap**

### Key Takeaways ğŸ”‘

1. **One-to-One Unidirectional** = Ek entity dusre ko jaanti hai, but reverse nahi
2. **@OneToOne + @JoinColumn** = Magic combination hai bhai!
3. **CascadeType.ALL** = Parent ke saath child bhi handle ho jata hai
4. **Unidirectional** = Memory efficient aur simple
5. **Foreign Key** owner entity mein hoti hai, target mein nahi

### Memory Tricks ğŸ§ 

- **"Employee has Address, Address doesn't care about Employee"** ğŸ‘¤ğŸ 
- **"Owner knows target, target doesn't know owner"** ğŸ¯
- **"One direction traffic - no U-turn allowed!"** ğŸš—â¡ï¸

### When to Use What ğŸ¤”

| Use Case | Mapping Type | Why? |
|----------|-------------|------|
| User â†’ Profile | Unidirectional | Profile doesn't need to know user |
| Employee â†’ Address | Unidirectional | Address is just data store |
| Order â†” Customer | Bidirectional | Both need to navigate each other |

### Quick Configuration Checklist âœ…

```java
// âœ… Perfect Unidirectional Setup
@Entity
public class Owner {
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "target_id", referencedColumnName = "id")
    private Target target;
}

@Entity  
public class Target {
    // No reference to Owner
}
```

---

## ğŸš€ **Bonus: Advanced Tips**

### Custom Repository Methods
```java
public interface EmployeeRepository extends JpaRepository<Employee, Integer> {
    
    // Find employees by city
    @Query("SELECT e FROM Employee e WHERE e.address.city = :city")
    List<Employee> findEmployeesByCity(@Param("city") String city);
    
    // Find employees by state  
    List<Employee> findByAddressState(String state);
    
    // Count employees in a city
    @Query("SELECT COUNT(e) FROM Employee e WHERE e.address.city = :city")
    Long countEmployeesByCity(@Param("city") String city);
}
```

### Transaction Management
```java
@Service
@Transactional
public class EmployeeServiceImpl {
    
    @Transactional(rollbackFor = Exception.class)
    public Employee saveEmployeeWithValidation(Employee employee) {
        // Custom business logic
        if (employee.getAddress() == null) {
            throw new BusinessException("Address is required!");
        }
        return employeeRepository.save(employee);
    }
}
```

---

**Yaad rakhna bhai** ğŸ’­: 
- Practice makes perfect! 
- Start simple, then add complexity
- Test your mappings with actual data
- Always check generated SQL queries using `show-sql=true`

**Happy Coding! ğŸ‰ğŸ‘¨â€ğŸ’»**

---

*Made with â¤ï¸ for Java enthusiasts | Keep practicing, keep growing! ğŸŒ±*
