# JPA Entity Mappings - Complete Study Notes 📚

## 🎯 Introduction with Confusion Clearing

### Simple Explanation First 💡
**Bhai, JPA Entity Mapping kya hai?** 🤔

Simple words mein - Jab tumhara Java application database se baat karta hai, tab tumhe batana padta hai ki ek table ka dusre table se kya relationship hai. JPA Entity Mapping yahi kaam karta hai!

### Real-life Analogy 🌟
**Socho ek family tree jaisi situation:**
- **OneToOne** = Ek husband, ek wife (Employee-Address)
- **OneToMany** = Ek papa, multiple bachhe (Post-Comments)
- **ManyToOne** = Multiple bachhe, ek papa (Comments-Post)
- **ManyToMany** = Multiple students, multiple subjects (Student-Subject)

### Technical Definition 📖
JPA (Java Persistence API) Entity Mappings define how Java objects relate to database tables and establish relationships between different entities using annotations.

---

## 🔑 Key Terms/Concepts

| Term | Hindi Meaning | Technical Definition |
|------|---------------|---------------------|
| **Entity** | डेटा की इकाई | Java class mapped to database table |
| **Mapping** | रिश्ता | Relationship between entities |
| **Annotation** | टैग | Special markers like @OneToOne |
| **Cascade** | झरना प्रभाव | Operations flow from parent to child |
| **JoinColumn** | जोड़ने वाला कॉलम | Foreign key column |
| **JoinTable** | जोड़ने वाली टेबल | Intermediate table for ManyToMany |

### Visual Representation 📊
```
OneToOne:     Employee ←→ Address
OneToMany:    Post ← Comments (1,2,3...)  
ManyToOne:    Comments (1,2,3...) → Post
ManyToMany:   Students ↔ Subjects
```

---

## 💻 Detailed Examples

### 1. OneToOne Mapping 👫

**Real-life scenario:** Employee ka sirf ek address hota hai!

```java
// Employee.java
import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String name;
    private String emailId;
    private String mobNo;
    private String designation;
    
    // ✅ OneToOne mapping with Address
    @OneToOne(cascade = CascadeType.ALL)
    @JoinColumn(name = "address_id", referencedColumnName = "id")
    private Address address;
}
```

```java
// Address.java
import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String street;
    private String city;
    private String state;
    private String pincode;
}
```

**Expected Output (Database Tables):**
```sql
-- employee table
id | name     | email_id      | mob_no    | designation | address_id
1  | Rajesh   | raj@mail.com  | 9876543210| Developer   | 1

-- address table  
id | street        | city      | state | pincode
1  | MG Road 123   | Mumbai    | MH    | 400001
```

**Step-by-step Explanation:**
1. `@OneToOne` - Batata hai ki ek employee ka ek hi address
2. `cascade = CascadeType.ALL` - Employee save karo to address bhi save ho jayega
3. `@JoinColumn` - Foreign key column specify karta hai

---

### 2. OneToMany Mapping 📝→💬💬💬

**Real-life scenario:** Ek blog post par multiple comments!

```java
// Post.java
import javax.persistence.*;
import java.util.List;
import lombok.Data;

@Entity
@Data
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String title;
    private String description;
    
    // ✅ OneToMany mapping with Comments
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private List<Comment> comments;
}
```

```java
// Comment.java
import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String message;
    private String commenterName;
}
```

**Expected Output (Database Tables):**
```sql
-- post table
id | title           | description
1  | Java Tutorial   | Learn Java OOP

-- comment table
id | message              | commenter_name | post_id
1  | Great tutorial!      | Amit          | 1
2  | Very helpful         | Priya         | 1  
3  | Thanks for sharing   | Rohan         | 1
```

---

### 3. ManyToOne Mapping 💬💬💬→📝

**Real-life scenario:** Multiple comments belong to one post!

```java
// Comment.java (Updated)
import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String message;
    private String commenterName;
    
    // ✅ ManyToOne mapping with Post
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "post_id")
    private Post post;
}
```

```java
// Post.java (Simple version)
import javax.persistence.*;
import lombok.Data;

@Entity
@Data
public class Post {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String title;
    private String description;
}
```

---

### 4. ManyToMany Mapping 👨‍🎓↔📚

**Real-life scenario:** Students choose multiple subjects, subjects have multiple students!

```java
// Student.java
import javax.persistence.*;
import java.util.List;
import lombok.Data;

@Entity
@Data
public class Student {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String name;
    private String email;
    private String rollNumber;
    
    // ✅ ManyToMany mapping with Subjects
    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(
        name = "student_subject_mapping",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "subject_id")
    )
    private List<Subject> subjects;
}
```

```java
// Subject.java
import javax.persistence.*;
import java.util.List;
import lombok.Data;

@Entity
@Data
public class Subject {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;
    private String name;
    private String code;
    private Integer credits;
    
    // Bidirectional mapping (Optional)
    @ManyToMany(mappedBy = "subjects")
    private List<Student> students;
}
```

**Expected Output (Database Tables):**
```sql
-- student table
id | name    | email           | roll_number
1  | Arjun   | arjun@mail.com  | CS2021001
2  | Sneha   | sneha@mail.com  | CS2021002

-- subject table
id | name        | code  | credits
1  | Java        | CS101 | 4
2  | Database    | CS102 | 3

-- student_subject_mapping table
student_id | subject_id
1          | 1
1          | 2  
2          | 1
```

---

## 📋 Rules/Guidelines

### Rule 1: Annotation Placement ✅
**✅ Correct:**
```java
@OneToOne
@JoinColumn(name = "address_id")
private Address address;
```

**❌ Wrong:**
```java
private Address address;
@OneToOne  // Galat jagah!
@JoinColumn(name = "address_id")
```

### Rule 2: Cascade Types 🌊
```java
// ✅ Different cascade types
CascadeType.ALL        // Sab operations cascade karenge
CascadeType.PERSIST    // Sirf save operation
CascadeType.MERGE      // Sirf update operation
CascadeType.REMOVE     // Sirf delete operation
```

### Rule 3: Fetch Types 🏃‍♂️
```java
// ✅ Lazy loading (Recommended for performance)
@OneToMany(fetch = FetchType.LAZY)
private List<Comment> comments;

// ❌ Eager loading (Use carefully)
@OneToMany(fetch = FetchType.EAGER)  // Immediately load karta hai
private List<Comment> comments;
```

### Rule 4: Join Column Naming 📝
```java
// ✅ Clear naming convention
@JoinColumn(name = "employee_id", referencedColumnName = "id")

// ❌ Confusing names
@JoinColumn(name = "xyz")  // Kya hai ye xyz?
```

### Common Error Examples with Messages:

**Error 1: Missing @Entity**
```java
// ❌ Wrong
public class Employee {  // @Entity missing!
    @Id
    private Integer id;
}
```
**Error Message:**
```
Exception: Not an entity: class com.example.Employee
```

**Error 2: Missing @Id**
```java
// ❌ Wrong  
@Entity
public class Employee {
    private Integer id;  // @Id missing!
}
```
**Error Message:**
```
Exception: No identifier specified for entity: Employee
```

---

## 🌍 Real-world Applications

### 1. Banking System 🏦
```java
@Entity
public class Account {
    @Id private String accountNumber;
    
    @ManyToOne
    @JoinColumn(name = "customer_id")
    private Customer customer;  // Multiple accounts, one customer
    
    @OneToMany(mappedBy = "account")
    private List<Transaction> transactions;  // One account, many transactions
}

@Entity  
public class Customer {
    @Id private Integer customerId;
    
    @OneToMany(mappedBy = "customer")
    private List<Account> accounts;  // One customer, multiple accounts
}
```

### 2. E-commerce System 🛒
```java
@Entity
public class Order {
    @Id private Integer orderId;
    
    @ManyToMany
    @JoinTable(name = "order_product")
    private List<Product> products;  // One order, multiple products
    
    @ManyToOne
    @JoinColumn(name = "customer_id") 
    private Customer customer;  // Multiple orders, one customer
}
```

### 3. Library Management 📚
```java
@Entity
public class Book {
    @Id private Integer bookId;
    
    @ManyToMany(mappedBy = "borrowedBooks")
    private List<Member> members;  // One book, multiple members can borrow
}

@Entity
public class Member {
    @Id private Integer memberId;
    
    @ManyToMany
    @JoinTable(name = "book_issue")
    private List<Book> borrowedBooks;  // One member, multiple books
}
```

---

## 📊 Comparison Table

| Mapping Type | Cardinality | Use Case | Example | Join Strategy |
|--------------|-------------|----------|---------|---------------|
| **@OneToOne** | 1:1 | Unique relationship | Employee-Address | Foreign Key |
| **@OneToMany** | 1:N | Parent-Child | Post-Comments | Foreign Key |
| **@ManyToOne** | N:1 | Child-Parent | Comments-Post | Foreign Key |
| **@ManyToMany** | N:N | Many-to-Many | Student-Subject | Join Table |

### Unidirectional vs Bidirectional

| Type | Navigation | Performance | Use When |
|------|------------|-------------|----------|
| **Unidirectional** | One direction only | Better | Simple relationships |
| **Bidirectional** | Both directions | Slower | Need reverse lookup |

---

## 🎤 Interview Questions

### Q1: OneToOne vs ManyToOne mein kya difference hai?
**Answer:** 
```java
// OneToOne - Ek employee ka ek address
@OneToOne
private Address address;

// ManyToOne - Multiple employees, same address possible  
@ManyToOne
private Address address;
```

### Q2: Cascade types explain karo?
**Answer:**
```java
// CascadeType.ALL - Parent save/update/delete hone par child bhi
@OneToMany(cascade = CascadeType.ALL)

// CascadeType.PERSIST - Sirf save operation
@OneToMany(cascade = CascadeType.PERSIST)
```

### Q3: @JoinTable kab use karte hain?
**Answer:** ManyToMany mapping mein intermediate table banane ke liye:
```java
@ManyToMany
@JoinTable(
    name = "student_course",
    joinColumns = @JoinColumn(name = "student_id"),
    inverseJoinColumns = @JoinColumn(name = "course_id")
)
```

### Q4: Lazy vs Eager loading kya hai?
**Answer:**
```java
// Lazy - Jab zarorat ho tab load karo (Default for @OneToMany, @ManyToMany)
@OneToMany(fetch = FetchType.LAZY)

// Eager - Immediately load karo (Default for @OneToOne, @ManyToOne)  
@OneToMany(fetch = FetchType.EAGER)
```

### Q5: Bidirectional mapping mein mappedBy ka role?
**Answer:**
```java
// Parent side
@OneToMany(mappedBy = "post")  // Child entity mein 'post' field
private List<Comment> comments;

// Child side  
@ManyToOne
private Post post;  // Yahi field name mappedBy mein use hota hai
```

---

## 🚫 Common Mistakes

### Mistake 1: Wrong Cascade Type
```java
// ❌ Wrong - Employee delete karne par address bhi delete ho jayega
@OneToOne(cascade = CascadeType.ALL)
private Address address;

// ✅ Correct - Sirf save/update cascade karo
@OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
private Address address;
```

### Mistake 2: Missing mappedBy in Bidirectional
```java
// ❌ Wrong - Infinite loop possible
@Entity
public class Post {
    @OneToMany
    @JoinColumn(name = "post_id")
    private List<Comment> comments;
}

@Entity  
public class Comment {
    @ManyToOne
    @JoinColumn(name = "post_id")
    private Post post;
}

// ✅ Correct - Use mappedBy
@Entity
public class Post {
    @OneToMany(mappedBy = "post")  // mappedBy use karo
    private List<Comment> comments;
}
```

### Mistake 3: Wrong Fetch Type Usage
```java
// ❌ Wrong - Performance issue
@OneToMany(fetch = FetchType.EAGER)  // Har baar sab comments load
private List<Comment> comments;

// ✅ Correct - Load when needed
@OneToMany(fetch = FetchType.LAZY)
private List<Comment> comments;
```

### Mistake 4: Missing @JoinColumn
```java
// ❌ Wrong - Hibernate apna naam dega column ko
@OneToOne
private Address address;  // Column name: address_id (auto-generated)

// ✅ Correct - Clear naming
@OneToOne
@JoinColumn(name = "emp_address_id")
private Address address;
```

---

## ✨ Best Practices

### 1. Naming Conventions 📝
```java
// ✅ Good naming
@JoinColumn(name = "employee_id")          // Clear
@JoinTable(name = "student_course_mapping") // Descriptive

// ❌ Bad naming  
@JoinColumn(name = "emp_id")               // Abbreviated
@JoinTable(name = "sc_map")                // Confusing
```

### 2. Performance Optimization 🚀
```java
// ✅ Use Lazy loading for collections
@OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
private List<Comment> comments;

// ✅ Use proper cascade types
@OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
private Address address;
```

### 3. Documentation Tips 📚
```java
/**
 * Employee entity with OneToOne relationship with Address
 * Each employee has exactly one address
 */
@Entity
public class Employee {
    
    /**
     * Employee's residential address
     * Cascade: PERSIST, MERGE (address saved/updated with employee)
     */
    @OneToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    @JoinColumn(name = "address_id", referencedColumnName = "id")
    private Address address;
}
```

### 4. Testing Best Practices 🧪
```java
@Test
public void testOneToOneMapping() {
    // Given
    Employee employee = new Employee();
    employee.setName("Rajesh");
    
    Address address = new Address();
    address.setCity("Mumbai");
    
    employee.setAddress(address);
    
    // When
    Employee savedEmployee = employeeRepository.save(employee);
    
    // Then
    assertNotNull(savedEmployee.getAddress());
    assertEquals("Mumbai", savedEmployee.getAddress().getCity());
}
```

---

## 📝 Summary/Quick Recap

### Key Takeaways 🎯
1. **OneToOne** = Unique relationship (Employee-Address)
2. **OneToMany** = Parent has multiple children (Post-Comments)  
3. **ManyToOne** = Multiple children, one parent (Comments-Post)
4. **ManyToMany** = Both sides can have multiple (Student-Subject)

### Memory Tricks 🧠
- **"One"** dekho to **unique** relationship
- **"Many"** dekho to **collection/List** use karo
- **JoinColumn** = Foreign Key
- **JoinTable** = Intermediate Table (ManyToMany mein)

### When to Use What? 🤔

| Scenario | Mapping Type | Example |
|----------|--------------|---------|
| Unique ownership | @OneToOne | Employee-Passport |
| Parent-Child | @OneToMany | Department-Employees |
| Child belongs to Parent | @ManyToOne | Employee-Department |
| Mutual relationship | @ManyToMany | Author-Books |

### Yaad Rakhne Ka Mantra 🕉️
```
"Relation dekho, Direction socho, Annotation lagao!"
```

---

## 🔧 Additional Configurations

### Advanced Annotations
```java
// Orphan removal - Parent se child remove ho to database se bhi delete
@OneToMany(orphanRemoval = true)
private List<Comment> comments;

// Optional - Relationship optional hai ya mandatory
@OneToOne(optional = false)  // Mandatory relationship
private Address address;

// TargetEntity - Explicit entity specify karna
@OneToMany(targetEntity = Comment.class)
private List comments;  // Generic type missing ke case mein
```

### Custom Column Definitions
```java
// Composite keys ke saath
@ManyToOne
@JoinColumns({
    @JoinColumn(name = "emp_id", referencedColumnName = "id"),
    @JoinColumn(name = "dept_id", referencedColumnName = "dept_id")
})
private Employee employee;
```

**Bhai, ye notes se tumhara JPA Entity Mapping concept clear ho jana chahiye! Practice karo aur interview mein confidence se answer do! 💪🔥**

---
*Happy Coding! 🚀✨*
