# Java Study Notes: @Data vs @Entity Annotations ğŸ“š

## ğŸ¤” Introduction with Confusion Clearing

### Simple Explanation First ğŸ¯
Bhai, ye dono annotations hai jo Spring Boot mein use karte hain, lekin **confusion alert!** ğŸš¨ 
- **@Data** = Code generator (Lombok ka kamaal)
- **@Entity** = Database table mapper (JPA ka jadoo)

### Real-life Analogy ğŸ 
Think of it like this yaar:
- **@Entity** is like your **house address** ğŸ¡ - tells everyone where you live (database table)
- **@Data** is like your **house helper** ğŸ‘¨â€ğŸ’¼ - automatically does all basic chores (getters, setters, etc.)

### Technical Definition ğŸ“–
- **@Entity**: JPA annotation jo class ko database table ke saath map karta hai
- **@Data**: Lombok annotation jo boilerplate code automatically generate karta hai

---

## ğŸ”‘ Key Terms/Concepts

| Term | Meaning | Example |
|------|---------|---------|
| **JPA** | Java Persistence API - database operations ke liye | `@Entity`, `@Id`, `@Table` |
| **Lombok** | Code generation library - boilerplate code reduce karta hai | `@Data`, `@Getter`, `@Setter` |
| **ORM** | Object-Relational Mapping - Java objects ko database tables se connect karta hai | Entity mapping |
| **DTO** | Data Transfer Object - sirf data carry karne ke liye use hota hai | API responses |
| **POJO** | Plain Old Java Object - simple Java class | Basic Java beans |

### Visual Representation ğŸ¨
```
@Entity Class (Database Entity)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    ğŸ“Š Database Table        â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”      â”‚
â”‚    â”‚ ID  â”‚Name â”‚Priceâ”‚      â”‚
â”‚    â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤      â”‚
â”‚    â”‚  1  â”‚Book â”‚ 500 â”‚      â”‚
â”‚    â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â¬†ï¸
@Entity annotation maps this

@Data Class (Code Generator)
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ”§ Auto-Generated Methods   â”‚
â”‚ â€¢ getId(), setId()          â”‚
â”‚ â€¢ getName(), setName()      â”‚
â”‚ â€¢ toString()                â”‚
â”‚ â€¢ equals(), hashCode()      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â¬†ï¸
@Data annotation generates this
```

---

## ğŸ’¡ Detailed Examples

### @Entity Example - Database Entity ğŸ—ƒï¸

```java
// Basic @Entity example
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;

@Entity
@Table(name = "products") // Optional: custom table name
public class Product {
    
    @Id  // Primary key - mandatory!
    private Long id;
    
    private String name;
    private double price;
    
    // Manual getters and setters (boilerplate code ğŸ˜µ)
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public double getPrice() {
        return price;
    }
    
    public void setPrice(double price) {
        this.price = price;
    }
    
    @Override
    public String toString() {
        return "Product{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", price=" + price +
                '}';
    }
}
```

**Expected Database Table:**
```sql
CREATE TABLE products (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255),
    price DOUBLE
);
```

### @Data Example - Code Generator âš¡

```java
// @Data example - Lombok magic!
import lombok.Data;

@Data
public class ProductDTO {
    private Long id;
    private String name;
    private double price;
    
    // Ye sab automatically generate ho jata hai:
    // âœ… getId(), setId()
    // âœ… getName(), setName() 
    // âœ… getPrice(), setPrice()
    // âœ… toString()
    // âœ… equals() and hashCode()
    // âœ… default constructor (if no other exists)
}
```

**Generated Code (Behind the scenes):**
```java
// Ye sab Lombok automatically kar deta hai
public class ProductDTO {
    private Long id;
    private String name;
    private double price;
    
    public ProductDTO() {}
    
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    // ... all other getters and setters
    
    @Override
    public String toString() {
        return "ProductDTO(id=" + id + ", name=" + name + ", price=" + price + ")";
    }
    
    @Override
    public boolean equals(Object o) { /* auto-generated */ }
    
    @Override
    public int hashCode() { /* auto-generated */ }
}
```

### Combined Example - Best of Both Worlds! ğŸŒŸ

```java
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import lombok.Data;

@Entity
@Data  // Combination - database mapping + code generation
public class Student {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    private int age;
    
    // No need to write getters, setters, toString, etc.
    // @Data handles it all! ğŸ‰
}
```

**Usage Example:**
```java
@RestController
public class StudentController {
    
    @Autowired
    private StudentRepository studentRepository;
    
    @PostMapping("/students")
    public Student createStudent(@RequestBody Student student) {
        // @Data generated setters work here
        student.setName(student.getName().trim());
        
        // @Entity enables database save
        return studentRepository.save(student);
    }
    
    @GetMapping("/students/{id}")
    public Student getStudent(@PathVariable Long id) {
        Student student = studentRepository.findById(id).orElse(null);
        
        // @Data generated toString() for logging
        System.out.println("Found student: " + student);
        
        return student;
    }
}
```

---

## âœ…âŒ Rules/Guidelines

### @Entity Rules ğŸ“‹

1. **âœ… Must have @Id annotation**
   ```java
   @Entity
   public class Book {
       @Id  // Mandatory!
       private Long id;
   }
   ```
   
   **âŒ Wrong:**
   ```java
   @Entity
   public class Book {
       private Long id;  // Error: No @Id found
   }
   ```
   **Error:** `org.hibernate.AnnotationException: No identifier specified for entity: Book`

2. **âœ… Default constructor required**
   ```java
   @Entity
   public class Book {
       @Id
       private Long id;
       
       public Book() {}  // JPA needs this
       
       public Book(String title) {
           this.title = title;
       }
   }
   ```

3. **âœ… Class must be public or protected**
   ```java
   @Entity
   public class Book {  // âœ… Correct
       // ...
   }
   ```
   
   **âŒ Wrong:**
   ```java
   @Entity
   private class Book {  // âŒ Error - can't be private
       // ...
   }
   ```

### @Data Rules ğŸ“‹

1. **âœ… Works with any class structure**
   ```java
   @Data
   public class PersonDTO {
       private String name;
       private int age;
       // All getters/setters auto-generated
   }
   ```

2. **âœ… Handles inheritance correctly**
   ```java
   @Data
   public class Employee extends Person {
       private String department;
       private double salary;
   }
   ```

3. **âŒ Be careful with circular references**
   ```java
   @Data
   public class Parent {
       private List<Child> children;
   }
   
   @Data
   public class Child {
       private Parent parent;  // Can cause StackOverflowError in toString()
   }
   ```
   
   **Better approach:**
   ```java
   @Data
   @ToString(exclude = "parent")  // Exclude from toString
   @EqualsAndHashCode(exclude = "parent")  // Exclude from equals/hashCode
   public class Child {
       private Parent parent;
   }
   ```

---

## ğŸŒ Real-world Applications

### Banking System Example ğŸ¦

```java
// Account Entity - Database table
@Entity
@Data
@Table(name = "bank_accounts")
public class Account {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long accountNumber;
    
    private String accountHolderName;
    private double balance;
    private String accountType;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
}

// Transfer DTO - API request/response
@Data
public class TransferRequestDTO {
    private Long fromAccount;
    private Long toAccount;
    private double amount;
    private String description;
    
    // No database mapping needed, just data transfer
}

// Service class usage
@Service
public class BankingService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    public TransferResponseDTO transferMoney(TransferRequestDTO request) {
        // @Entity enables database operations
        Account fromAcc = accountRepository.findById(request.getFromAccount())
                .orElseThrow(() -> new AccountNotFoundException("Account not found"));
        
        Account toAcc = accountRepository.findById(request.getToAccount())
                .orElseThrow(() -> new AccountNotFoundException("Account not found"));
        
        // @Data generated getters/setters in action
        if (fromAcc.getBalance() < request.getAmount()) {
            throw new InsufficientFundsException("Insufficient balance");
        }
        
        fromAcc.setBalance(fromAcc.getBalance() - request.getAmount());
        toAcc.setBalance(toAcc.getBalance() + request.getAmount());
        
        accountRepository.save(fromAcc);
        accountRepository.save(toAcc);
        
        return TransferResponseDTO.builder()
                .transactionId(generateTransactionId())
                .status("SUCCESS")
                .message("Transfer completed successfully")
                .build();
    }
}
```

### E-commerce System Example ğŸ›’

```java
// Product Entity
@Entity
@Data
@Table(name = "products")
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long productId;
    
    private String productName;
    private String description;
    private double price;
    private int stockQuantity;
    private String category;
    
    @OneToMany(mappedBy = "product", cascade = CascadeType.ALL)
    private List<Review> reviews;
}

// Product Response DTO
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProductResponseDTO {
    private Long productId;
    private String productName;
    private double price;
    private boolean inStock;
    private double averageRating;
    private int totalReviews;
    
    // Used in REST API responses
}

// Controller
@RestController
@RequestMapping("/api/products")
public class ProductController {
    
    @GetMapping
    public List<ProductResponseDTO> getAllProducts() {
        return productService.getAllProducts()
                .stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
    }
    
    private ProductResponseDTO convertToDTO(Product product) {
        // @Data generated getters in action
        return ProductResponseDTO.builder()
                .productId(product.getProductId())
                .productName(product.getProductName())
                .price(product.getPrice())
                .inStock(product.getStockQuantity() > 0)
                .averageRating(calculateAverageRating(product.getReviews()))
                .totalReviews(product.getReviews().size())
                .build();
    }
}
```

---

## ğŸ“Š Comparison Tables

### Feature Comparison

| Feature | @Entity | @Data | Combined (@Entity + @Data) |
|---------|---------|-------|---------------------------|
| **Purpose** | Database mapping | Code generation | Database mapping + Code generation |
| **Package** | `jakarta.persistence` | `lombok` | Both packages |
| **Database Operations** | âœ… Enables CRUD | âŒ No database interaction | âœ… Enables CRUD |
| **Code Generation** | âŒ No generation | âœ… Generates methods | âœ… Generates methods |
| **Performance** | Fast (no overhead) | Fast (compile-time) | Fast |
| **Memory Usage** | Low | Low | Low |
| **Maintenance** | High (manual code) | Low (auto-generated) | Low |

### Use Case Comparison

| Scenario | Recommended Approach | Why? |
|----------|---------------------|------|
| **Database Entity** | `@Entity` alone | Database mapping is primary concern |
| **Simple DTO** | `@Data` alone | No database, just data transfer |
| **API Response** | `@Data` + `@Builder` | Easy object creation, no database |
| **Complex Entity** | `@Entity` + `@Data` + exclusions | Database mapping + convenience |
| **Entity with Relationships** | `@Entity` + selective Lombok | Avoid circular references |

### Performance Comparison

| Aspect | @Entity Only | @Data Only | Combined |
|--------|-------------|-----------|----------|
| **Compile Time** | Fast âš¡ | Medium ğŸŸ¡ | Medium ğŸŸ¡ |
| **Runtime Performance** | Fast âš¡ | Fast âš¡ | Fast âš¡ |
| **Memory Footprint** | Small ğŸ“¦ | Small ğŸ“¦ | Small ğŸ“¦ |
| **Code Readability** | Poor ğŸ“–âŒ | Excellent ğŸ“–âœ… | Excellent ğŸ“–âœ… |

---

## ğŸ¤ Interview Questions

### Question 1: Basic Difference
**Q: @Data aur @Entity mein kya difference hai?**

**Answer:**
```java
// @Entity - JPA annotation for database mapping
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    // Manual getters/setters needed
}

// @Data - Lombok annotation for code generation  
@Data
public class UserDTO {
    private Long id;
    private String name;
    // Auto-generates getters/setters, toString, equals, hashCode
}
```

**Key Points:**
- @Entity maps class to database table
- @Data generates boilerplate code
- Different purposes, can be used together

### Question 2: Combined Usage Issues
**Q: @Entity ke saath @Data use karne mein kya problems aa sakti hain?**

**Answer:**
```java
// Problem: Lazy Loading issues
@Entity
@Data
public class User {
    @Id
    private Long id;
    private String name;
    
    @OneToMany(fetch = FetchType.LAZY)
    private List<Order> orders;  // Can cause LazyInitializationException
}

// Solution: Exclude problematic fields
@Entity
@Data
@ToString(exclude = "orders")
@EqualsAndHashCode(exclude = "orders")
public class User {
    @Id
    private Long id;
    private String name;
    
    @OneToMany(fetch = FetchType.LAZY)
    private List<Order> orders;
}
```

### Question 3: Best Practices
**Q: Production mein @Data ke saath @Entity use karte time kya best practices follow karni chahiye?**

**Answer:**
```java
@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString(exclude = {"createdAt", "updatedAt"})
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    private double price;
    
    @CreationTimestamp
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // Custom method when needed
    public void applyDiscount(double percentage) {
        this.price = this.price * (1 - percentage / 100);
    }
}
```

### Question 4: Tricky Scenario
**Q: Circular reference problem ko kaise handle karenge?**

**Answer:**
```java
// Problem scenario
@Entity
@Data
public class Department {
    @Id
    private Long id;
    private String name;
    
    @OneToMany(mappedBy = "department")
    private List<Employee> employees;  // Circular reference risk
}

@Entity
@Data
public class Employee {
    @Id
    private Long id;
    private String name;
    
    @ManyToOne
    private Department department;  // toString() mein infinite loop!
}

// Solution
@Entity
@Data
@ToString(exclude = "employees")  // Break the cycle
@EqualsAndHashCode(exclude = "employees")
public class Department {
    @Id
    private Long id;
    private String name;
    
    @OneToMany(mappedBy = "department")
    @JsonIgnore  // Also for JSON serialization
    private List<Employee> employees;
}

@Entity
@Data
@ToString(exclude = "department")
@EqualsAndHashCode(exclude = "department")
public class Employee {
    @Id
    private Long id;
    private String name;
    
    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
}
```

---

## ğŸš« Common Mistakes

### Mistake 1: @Id Annotation Missing
**âŒ Wrong:**
```java
@Entity
@Data
public class Product {
    private Long id;  // Missing @Id annotation
    private String name;
}
```

**Error Message:**
```
org.hibernate.AnnotationException: No identifier specified for entity: Product
```

**âœ… Correct:**
```java
@Entity
@Data
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;  // âœ… Proper @Id annotation
    private String name;
}
```

### Mistake 2: Using @Data with Complex Relationships
**âŒ Wrong:**
```java
@Entity
@Data  // This will cause issues!
public class User {
    @Id
    private Long id;
    
    @OneToMany(fetch = FetchType.LAZY)
    private List<Order> orders;  // LazyInitializationException possible
}
```

**Why it's wrong:**
- `toString()` method tries to access lazy collections
- Can cause performance issues
- Circular reference problems

**âœ… Correct:**
```java
@Entity
@Data
@ToString(exclude = {"orders"})  // Exclude lazy collections
@EqualsAndHashCode(exclude = {"orders"})
public class User {
    @Id
    private Long id;
    
    @OneToMany(fetch = FetchType.LAZY)
    private List<Order> orders;
}
```

### Mistake 3: Not Understanding Scope
**âŒ Wrong:**
```java
// Using @Entity for DTO classes
@Entity  // Wrong! DTO doesn't need database mapping
@Data
public class UserResponseDTO {
    private String name;
    private String email;
}

// Using @Data for utility classes with custom logic
@Data  // Wrong! Custom equals/hashCode needed
public class Point {
    private double x;
    private double y;
    
    // Custom distance calculation needed
    public double distanceFrom(Point other) {
        return Math.sqrt(Math.pow(x - other.x, 2) + Math.pow(y - other.y, 2));
    }
}
```

**âœ… Correct:**
```java
// DTO - only @Data needed
@Data
@Builder
public class UserResponseDTO {
    private String name;
    private String email;
}

// Utility class - manual implementation
public class Point {
    private final double x;
    private final double y;
    
    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
    
    // Custom getters
    public double getX() { return x; }
    public double getY() { return y; }
    
    // Custom equals and hashCode for mathematical precision
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof Point)) return false;
        Point point = (Point) obj;
        return Double.compare(point.x, x) == 0 && Double.compare(point.y, y) == 0;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }
}
```

### Mistake 4: Mixing Annotations Incorrectly
**âŒ Wrong:**
```java
@Entity
@Data
@Immutable  // Conflict! @Data generates setters, @Immutable means no setters
public class Configuration {
    @Id
    private String key;
    private String value;
}
```

**âœ… Correct:**
```java
@Entity
@Getter  // Only getters for immutable entity
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString
@Immutable
public class Configuration {
    @Id
    @EqualsAndHashCode.Include
    private String key;
    private String value;
}
```

---

## ğŸŒŸ Best Practices

### 1. Entity Classes Best Practices ğŸ—ï¸

```java
@Entity
@Table(name = "users", indexes = {
    @Index(name = "idx_email", columnList = "email", unique = true)
})
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
@ToString(exclude = {"password", "orders", "createdAt", "updatedAt"})
public class User {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @EqualsAndHashCode.Include  // Only include ID in equals/hashCode
    private Long id;
    
    @Column(nullable = false, unique = true)
    private String email;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false)
    @ToString.Exclude  // Exclude sensitive data from toString
    private String password;
    
    @Enumerated(EnumType.STRING)
    private UserRole role;
    
    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    @ToString.Exclude  // Avoid lazy loading in toString
    private List<Order> orders = new ArrayList<>();
    
    @CreationTimestamp
    @Column(updatable = false)
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    private LocalDateTime updatedAt;
    
    // Custom business methods
    public void addOrder(Order order) {
        orders.add(order);
        order.setUser(this);
    }
    
    public boolean isActive() {
        return role != UserRole.INACTIVE;
    }
}
```

### 2. DTO Classes Best Practices ğŸ“¦

```java
// Request DTO
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
@JsonIgnoreProperties(ignoreUnknown = true)
public class CreateUserRequestDTO {
    
    @NotBlank(message = "Name cannot be blank")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;
    
    @Email(message = "Invalid email format")
    @NotBlank(message = "Email cannot be blank")
    private String email;
    
    @Pattern(regexp = "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=])(?=\\S+$).{8,}$",
             message = "Password must contain at least 8 characters with uppercase, lowercase, digit and special character")
    private String password;
    
    @NotNull(message = "Role cannot be null")
    private UserRole role;
}

// Response DTO
@Data
@Builder
@JsonInclude(JsonInclude.Include.NON_NULL)
public class UserResponseDTO {
    private Long id;
    private String name;
    private String email;
    private UserRole role;
    private LocalDateTime createdAt;
    private int totalOrders;
    
    // Factory method for conversion
    public static UserResponseDTO from(User user) {
        return UserResponseDTO.builder()
                .id(user.getId())
                .name(user.getName())
                .email(user.getEmail())
                .role(user.getRole())
                .createdAt(user.getCreatedAt())
                .totalOrders(user.getOrders().size())
                .build();
    }
}
```

### 3. Service Layer Best Practices ğŸ”§

```java
@Service
@Transactional
@RequiredArgsConstructor
public class UserService {
    
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final UserMapper userMapper; // MapStruct mapper
    
    public UserResponseDTO createUser(CreateUserRequestDTO requestDTO) {
        // Validation
        if (userRepository.existsByEmail(requestDTO.getEmail())) {
            throw new DuplicateEmailException("Email already exists: " + requestDTO.getEmail());
        }
        
        // Convert DTO to Entity
        User user = User.builder()
                .name(requestDTO.getName())
                .email(requestDTO.getEmail())
                .password(passwordEncoder.encode(requestDTO.getPassword()))
                .role(requestDTO.getRole())
                .build();
        
        // Save entity
        User savedUser = userRepository.save(user);
        
        // Convert back to DTO
        return UserResponseDTO.from(savedUser);
    }
    
    @Transactional(readOnly = true)
    public UserResponseDTO getUserById(Long id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("User not found with id: " + id));
        
        return UserResponseDTO.from(user);
    }
}
```

### 4. Testing Best Practices ğŸ§ª

```java
@DataJpaTest
class UserEntityTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    @DisplayName("Should save and retrieve user entity")
    void shouldSaveAndRetrieveUser() {
        // Given
        User user = User.builder()
                .name("John Doe")
                .email("john@example.com")
                .password("encodedPassword")
                .role(UserRole.USER)
                .build();
        
        // When
        User savedUser = entityManager.persistAndFlush(user);
        
        // Then
        assertThat(savedUser.getId()).isNotNull();
        assertThat(savedUser.getCreatedAt()).isNotNull();
        assertThat(savedUser.getUpdatedAt()).isNotNull();
        
        // Verify @Data generated methods work
        assertThat(savedUser.toString()).contains("John Doe");
        assertThat(savedUser.getName()).isEqualTo("John Doe");
    }
    
    @Test
    @DisplayName("Should handle equals and hashCode correctly")
    void shouldHandleEqualsAndHashCode() {
        // Given
        User user1 = User.builder().id(1L).name("John").email("john@test.com").build();
        User user2 = User.builder().id(1L).name("Jane").email("jane@test.com").build();
        User user3 = User.builder().id(2L).name("John").email("john@test.com").build();
        
        // Then - same ID should be equal (due to @EqualsAndHashCode.Include on id)
        assertThat(user1).isEqualTo(user2);
        assertThat(user1.hashCode()).isEqualTo(user2.hashCode());
        
        // Different ID should not be equal
        assertThat(user1).isNotEqualTo(user3);
    }
}

@WebMvcTest(UserController.class)
class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Test
    @DisplayName("Should create user successfully")
    void shouldCreateUser() throws Exception {
        // Given
        CreateUserRequestDTO requestDTO = CreateUserRequestDTO.builder()
                .name("John Doe")
                .email("john@example.com")
                .password("Password123!")
                .role(UserRole.USER)
                .build();
        
        UserResponseDTO responseDTO = UserResponseDTO.builder()
                .id(1L)
                .name("John Doe")
                .email("john@example.com")
                .role(UserRole.USER)
                .createdAt(LocalDateTime.now())
                .totalOrders(0)
                .build();
        
        when(userService.createUser(any(CreateUserRequestDTO.class)))
                .thenReturn(responseDTO);
        
        // When & Then
        mockMvc.perform(post("/api/users")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(requestDTO)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value(1))
                .andExpect(jsonPath("$.name").value("John Doe"))
                .andExpect(jsonPath("$.email").value("john@example.com"));
    }
}
```

---

## ğŸ“ Summary/Quick Recap

### ğŸ¯ Key Takeaways

| Aspect | @Entity | @Data | Combined |
|--------|---------|-------|----------|
| **Main Purpose** | Database mapping ğŸ—ƒï¸ | Code generation âš¡ | Both benefits
