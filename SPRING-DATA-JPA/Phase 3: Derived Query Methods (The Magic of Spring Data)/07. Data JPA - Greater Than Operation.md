# ğŸ¯ Spring Data JPA - Greater Than Operations Complete Guide

*Bhai, aaj seekhte hain JPA Repository mein Greater Than kaise use karte hain! ğŸ’ª*

---

## ğŸ¤” Introduction - Confusion Clear Karte Hain

### Simple Explanation Pehle ğŸ“
**Yaar, simple words mein:** Greater Than matlab hum database se wahi records fetch karte hain jo specified value se **zyada** hain. Jaise agar hume 1000 rupaye se zyada ke orders chahiye, toh ye feature use karenge! 

### Real-life Analogy ğŸª
**Socho tumhare paas ek shop hai:**
- Customer bolte hain: "Bhai 500 rupaye se zyada wale products dikhao"
- Tum shop mein jaate ho aur 501, 600, 700... wale products nikaalte ho
- Exactly yahi kaam JPA Repository mein Greater Than operator karta hai! 

### Technical Definition ğŸ”¬
JPA Repository mein Greater Than operator use karke hum easily comparison operations perform kar sakte hain, where field value specified value se greater hona chahiye. **Teen tarike hain isko implement karne ke:**
1. **Query Method** with `GreaterThan` keyword
2. **JPQL** (Java Persistence Query Language) 
3. **Native SQL** queries

---

## ğŸ”‘ Key Terms/Concepts

| Term | Technical Explanation |
|------|----------------------|
| **JPA Repository**  | Database operations ke liye interface |
| **Greater Than** |  Comparison operator (>) |
| **JPQL** |  Object-oriented query language |
| **Native Query** | Direct SQL commands |
| **Query Method** | Method name se automatic query generation |

### Visual Representation ğŸ“Š
```
Database Records: [100, 200, 300, 400, 500, 600]
Greater Than 250: [300, 400, 500, 600] âœ…
Smaller/Equal:    [100, 200, 250] âŒ
```

---

## ğŸ’¡ Detailed Examples - Complete Working Code

### Method 1: Query Method with GreaterThan Keyword ğŸ¯

```java
// Repository Interface
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // âœ… Correct: findBy + FieldName + GreaterThan + Parameter
    List<OrderDetail> findByAmountGreaterThan(Double amount);
    
    // âœ… Multiple fields bhi kar sakte hain
    List<OrderDetail> findByAmountGreaterThanAndCustomerIdEquals(Double amount, Long customerId);
    
    // âœ… Order by bhi add kar sakte hain
    List<OrderDetail> findByAmountGreaterThanOrderByAmountDesc(Double amount);
}
```

**Expected Output:**
```sql
-- Hibernate generates ye query:
SELECT od.id, od.amount, od.customer_id 
FROM order_detail od 
WHERE od.amount > ?
```

### Method 2: JPQL Query ğŸ“

```java
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // âœ… JPQL with Greater Than
    @Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount")
    List<OrderDetail> findOrdersWithAmountGreaterThan(@Param("amount") Double amount);
    
    // âœ… Multiple conditions ke saath
    @Query("SELECT o FROM OrderDetail o WHERE o.amount > :minAmount AND o.customerId = :customerId")
    List<OrderDetail> findCustomerOrdersGreaterThan(@Param("minAmount") Double amount, 
                                                   @Param("customerId") Long customerId);
}
```

**Expected Output:**
```sql
-- Same SQL generates hota hai:
SELECT od.id, od.amount, od.customer_id 
FROM order_detail od 
WHERE od.amount > ?
```

### Method 3: Native SQL Query ğŸ’¾

```java
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // âœ… Native SQL Query
    @Query(value = "SELECT * FROM order_detail WHERE amount > :amount", nativeQuery = true)
    List<OrderDetail> findOrdersWithNativeQuery(@Param("amount") Double amount);
    
    // âœ… Complex native query
    @Query(value = "SELECT * FROM order_detail WHERE amount > :amount AND customer_id IN (:customerIds)", 
           nativeQuery = true)
    List<OrderDetail> findOrdersForCustomersGreaterThan(@Param("amount") Double amount, 
                                                       @Param("customerIds") List<Long> customerIds);
}
```

**Expected Output:**
```sql
-- Direct SQL execute hota hai:
SELECT * FROM order_detail WHERE amount > ?
```

---

## ğŸ“‹ Rules/Guidelines - Yaad Rakhne Ke Rules

### Rule 1: Method Naming Convention âœ…
```java
// âœ… Correct Pattern
findBy + FieldName + GreaterThan + (Parameter)

// âœ… Valid Examples
findByAmountGreaterThan(Double amount)
findBySalaryGreaterThan(BigDecimal salary) 
findByAgeGreaterThan(Integer age)

// âŒ Wrong Examples
findGreaterThanAmount(Double amount)        // Wrong order
findByAmountBiggerThan(Double amount)      // Wrong keyword
findAmountGreaterThan(Double amount)       // Missing "By"
```

### Rule 2: Parameter Type Matching âœ…
```java
// âœ… Correct - Types match
@Entity
public class OrderDetail {
    private Double amount;  // Database field type
}

List<OrderDetail> findByAmountGreaterThan(Double amount); // Same type parameter

// âŒ Wrong - Type mismatch
List<OrderDetail> findByAmountGreaterThan(String amount); // Wrong type!
```

**Error Example:**
```
ERROR: No property 'amount' of type 'java.lang.String' found in type 'OrderDetail'
```

### Rule 3: JPQL Entity Names âœ…
```java
// âœ… Correct - Use Entity name, not table name
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount")

// âŒ Wrong - Table name use mat karo
@Query("SELECT o FROM order_detail o WHERE o.amount > :amount") // âŒ
```

### Rule 4: Native Query Table Names âœ…
```java
// âœ… Correct - Use actual table name
@Query(value = "SELECT * FROM order_detail WHERE amount > :amount", nativeQuery = true)

// âŒ Wrong - Entity name mat use karo native query mein
@Query(value = "SELECT * FROM OrderDetail WHERE amount > :amount", nativeQuery = true) // âŒ
```

---

## ğŸŒ Real-world Applications

### 1. Banking Application ğŸ¦
```java
@Entity
public class Transaction {
    @Id
    private Long id;
    private BigDecimal amount;
    private LocalDateTime transactionDate;
    
    // getters and setters
}

@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    
    // High-value transactions (> 50,000)
    List<Transaction> findByAmountGreaterThan(BigDecimal amount);
    
    // Suspicious transactions in last 24 hours
    @Query("SELECT t FROM Transaction t WHERE t.amount > :amount AND t.transactionDate > :date")
    List<Transaction> findSuspiciousTransactions(@Param("amount") BigDecimal amount, 
                                                @Param("date") LocalDateTime date);
}

// Service layer usage
@Service
public class TransactionService {
    
    @Autowired
    private TransactionRepository repository;
    
    public List<Transaction> getHighValueTransactions() {
        return repository.findByAmountGreaterThan(new BigDecimal("50000"));
    }
}
```

### 2. E-commerce Application ğŸ›’
```java
@Entity 
public class Product {
    @Id
    private Long id;
    private String name;
    private Double price;
    private Integer stockQuantity;
    
    // getters and setters
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Premium products (> 10,000)
    List<Product> findByPriceGreaterThan(Double price);
    
    // Products with good stock
    List<Product> findByStockQuantityGreaterThan(Integer quantity);
    
    // Combined filter
    @Query("SELECT p FROM Product p WHERE p.price > :minPrice AND p.stockQuantity > :minStock")
    List<Product> findAvailablePremiumProducts(@Param("minPrice") Double price, 
                                              @Param("minStock") Integer stock);
}
```

### 3. Employee Management System ğŸ‘¨â€ğŸ’¼
```java
@Entity
public class Employee {
    @Id
    private Long id;
    private String name;
    private BigDecimal salary;
    private Integer experience;
    
    // getters and setters
}

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // Senior employees (> 5 years experience)
    List<Employee> findByExperienceGreaterThan(Integer years);
    
    // High salary employees
    List<Employee> findBySalaryGreaterThan(BigDecimal salary);
    
    // Performance bonus eligible
    @Query(value = "SELECT * FROM employee WHERE salary > :minSalary AND experience > :minExp", 
           nativeQuery = true)
    List<Employee> findBonusEligibleEmployees(@Param("minSalary") BigDecimal salary, 
                                            @Param("minExp") Integer experience);
}
```

---

## ğŸ†š Comparison Table - Konsa Method Kab Use Kare

| Feature | Query Method | JPQL | Native SQL |
|---------|--------------|------|------------|
| **Ease of Use** | â­â­â­â­â­ | â­â­â­ | â­â­ |
| **Performance** | â­â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| **Database Independence** | âœ… | âœ… | âŒ |
| **Complex Queries** | âŒ | âœ… | âœ… |
| **Auto-completion** | âœ… | âŒ | âŒ |
| **Compile-time Checking** | âœ… | âŒ | âŒ |

### When to Use What? ğŸ¤·â€â™‚ï¸

| Scenario | Best Choice | Reason |
|----------|-------------|---------|
| Simple field comparison | Query Method | Easiest, no SQL knowledge needed |
| Multiple conditions | JPQL | Object-oriented, database independent |
| Complex joins/subqueries | Native SQL | Full SQL power |
| Performance critical | Native SQL | Direct database optimization |
| Beginners | Query Method | Less prone to errors |

---

## ğŸ¤ Interview Questions - Ready Raho!

### Q1: Query Method mein GreaterThan aur GreaterThanEqual mein kya difference hai?

**Answer:**
```java
// GreaterThan - Strictly greater (>)
List<Order> findByAmountGreaterThan(Double amount);     // amount > 1000
// Input: 1000, Result: [1001, 1500, 2000] âœ…

// GreaterThanEqual - Greater than or equal (>=)  
List<Order> findByAmountGreaterThanEqual(Double amount); // amount >= 1000
// Input: 1000, Result: [1000, 1001, 1500, 2000] âœ…
```

### Q2: JPQL aur Native Query mein performance difference kya hai?

**Answer:**
```java
// JPQL - Gets converted to SQL by Hibernate
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount") // â­â­â­â­
// + Database independent
// - Extra conversion overhead

// Native SQL - Direct execution
@Query(value = "SELECT * FROM order_detail WHERE amount > :amount", nativeQuery = true) // â­â­â­â­â­  
// + Fastest execution
// - Database specific
```

### Q3: Multiple Greater Than conditions kaise likhenge?

**Answer:**
```java
// Method 1: Query Method
List<Order> findByAmountGreaterThanAndQuantityGreaterThan(Double amount, Integer quantity);

// Method 2: JPQL
@Query("SELECT o FROM Order o WHERE o.amount > :amount AND o.quantity > :quantity")
List<Order> findOrdersWithMultipleConditions(@Param("amount") Double amount, 
                                            @Param("quantity") Integer quantity);

// Method 3: Criteria API (Advanced)
Specification<Order> spec = Specification
    .where((root, query, cb) -> cb.greaterThan(root.get("amount"), amount))
    .and((root, query, cb) -> cb.greaterThan(root.get("quantity"), quantity));
```

### Q4: Null values ke saath Greater Than kaise handle kare?

**Answer:**
```java
// Problem: Null values comparison mein issues
List<Order> findByAmountGreaterThan(Double amount); // NullPointerException possible!

// Solution 1: Custom query with null check
@Query("SELECT o FROM Order o WHERE o.amount IS NOT NULL AND o.amount > :amount")
List<Order> findByAmountGreaterThanSafely(@Param("amount") Double amount);

// Solution 2: Optional wrapper
Optional<List<Order>> findByAmountGreaterThanAndAmountIsNotNull(Double amount);
```

---

## ğŸ˜± Common Mistakes - Inse Bacho Bhai!

### Mistake 1: Wrong Method Naming âŒ
```java
// âŒ Galat tarika
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    List<OrderDetail> findGreaterThanAmount(Double amount);        // Wrong!
    List<OrderDetail> findByAmountBigThan(Double amount);          // Wrong keyword!
    List<OrderDetail> findOrderByAmountGreaterThan(Double amount); // Extra word!
}

// âœ… Sahi tarika  
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    List<OrderDetail> findByAmountGreaterThan(Double amount);      // Perfect! âœ…
}
```

**Error Message:**
```
org.springframework.data.mapping.PropertyReferenceException: 
No property 'greaterThanAmount' found for type 'OrderDetail'
```

### Mistake 2: Parameter Type Mismatch âŒ
```java
@Entity
public class OrderDetail {
    private Double amount; // Database field is Double
}

// âŒ Wrong parameter type
List<OrderDetail> findByAmountGreaterThan(String amount); // String instead of Double!

// âœ… Correct parameter type
List<OrderDetail> findByAmountGreaterThan(Double amount); // Matches field type âœ…
```

### Mistake 3: JPQL mein Table Name Use Karna âŒ
```java
// âŒ Wrong - Table name use kiya
@Query("SELECT o FROM order_detail o WHERE o.amount > :amount") // Table name!

// âœ… Correct - Entity name use karo
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount")  // Entity name âœ…
```

### Mistake 4: Native Query mein Entity Name âŒ
```java
// âŒ Wrong - Entity name in native query
@Query(value = "SELECT * FROM OrderDetail WHERE amount > :amount", nativeQuery = true)

// âœ… Correct - Table name in native query  
@Query(value = "SELECT * FROM order_detail WHERE amount > :amount", nativeQuery = true) âœ…
```

### Mistake 5: Parameter Binding Issues âŒ
```java
// âŒ Wrong - Parameter name mismatch
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :minAmount")
List<OrderDetail> findByAmount(Double amount); // Parameter name different!

// âœ… Correct - Consistent parameter naming
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount")  
List<OrderDetail> findByAmount(@Param("amount") Double amount); âœ…

// âœ… Alternative - Positional parameter
@Query("SELECT o FROM OrderDetail o WHERE o.amount > ?1")
List<OrderDetail> findByAmount(Double amount); âœ…
```

---

## â­ Best Practices - Professional Bano!

### 1. Consistent Naming Convention ğŸ“
```java
// âœ… Good naming pattern
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Clear, descriptive method names
    List<Product> findByPriceGreaterThan(Double price);
    List<Product> findByStockQuantityGreaterThan(Integer quantity);
    
    // Complex conditions are clearly named
    List<Product> findByPriceGreaterThanAndStockQuantityGreaterThan(Double price, Integer stock);
    
    // Custom queries have descriptive names
    @Query("SELECT p FROM Product p WHERE p.price > :minPrice ORDER BY p.price ASC")
    List<Product> findPremiumProductsSortedByPrice(@Param("minPrice") Double minPrice);
}
```

### 2. Proper Exception Handling ğŸ›¡ï¸
```java
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    // âœ… Good - Exception handling with meaningful messages
    public List<OrderDetail> getHighValueOrders(Double minAmount) {
        try {
            if (minAmount == null || minAmount < 0) {
                throw new IllegalArgumentException("Amount must be positive and not null");
            }
            
            List<OrderDetail> orders = orderRepository.findByAmountGreaterThan(minAmount);
            
            if (orders.isEmpty()) {
                log.info("No orders found with amount greater than {}", minAmount);
            }
            
            return orders;
            
        } catch (Exception e) {
            log.error("Error fetching orders with amount > {}: {}", minAmount, e.getMessage());
            throw new ServiceException("Failed to fetch high value orders", e);
        }
    }
}
```

### 3. Query Optimization ğŸš€
```java
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // âœ… Good - Add sorting for consistent results
    List<OrderDetail> findByAmountGreaterThanOrderByAmountDesc(Double amount);
    
    // âœ… Good - Pagination for large datasets
    Page<OrderDetail> findByAmountGreaterThan(Double amount, Pageable pageable);
    
    // âœ… Good - Limit results when needed
    List<OrderDetail> findTop10ByAmountGreaterThanOrderByAmountDesc(Double amount);
    
    // âœ… Good - Use projections for specific fields
    @Query("SELECT o.id, o.amount FROM OrderDetail o WHERE o.amount > :amount")
    List<Object[]> findOrderIdsAndAmountsGreaterThan(@Param("amount") Double amount);
}
```

### 4. Documentation & Comments ğŸ“š
```java
/**
 * Repository for OrderDetail entity operations
 * 
 * @author Your Name
 * @since 1.0
 */
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    /**
     * Finds all orders with amount greater than specified value
     * 
     * @param amount minimum amount (exclusive)
     * @return list of orders with amount > specified value
     * @throws IllegalArgumentException if amount is null or negative
     */
    List<OrderDetail> findByAmountGreaterThan(Double amount);
    
    /**
     * Custom query to find high-value orders for premium customers
     * Uses JPQL for database independence
     * 
     * @param minAmount minimum order amount
     * @param customerTier customer tier (GOLD, PLATINUM, etc.)
     * @return sorted list of premium customer orders
     */
    @Query("SELECT o FROM OrderDetail o JOIN o.customer c " +
           "WHERE o.amount > :minAmount AND c.tier = :tier " +
           "ORDER BY o.amount DESC")
    List<OrderDetail> findPremiumCustomerHighValueOrders(
        @Param("minAmount") Double minAmount,
        @Param("tier") String customerTier
    );
}
```

### 5. Testing Best Practices ğŸ§ª
```java
@DataJpaTest
public class OrderRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired  
    private OrderRepository orderRepository;
    
    @Test
    public void testFindByAmountGreaterThan() {
        // Given - Test data setup
        OrderDetail order1 = new OrderDetail(1L, 500.0);
        OrderDetail order2 = new OrderDetail(2L, 1500.0);
        OrderDetail order3 = new OrderDetail(3L, 2500.0);
        
        entityManager.persistAndFlush(order1);
        entityManager.persistAndFlush(order2);  
        entityManager.persistAndFlush(order3);
        
        // When - Execute query
        List<OrderDetail> result = orderRepository.findByAmountGreaterThan(1000.0);
        
        // Then - Verify results
        assertThat(result).hasSize(2);
        assertThat(result).extracting(OrderDetail::getAmount)
                         .containsExactly(1500.0, 2500.0);
    }
    
    @Test
    public void testFindByAmountGreaterThan_NoResults() {
        // Given
        OrderDetail order = new OrderDetail(1L, 500.0);
        entityManager.persistAndFlush(order);
        
        // When
        List<OrderDetail> result = orderRepository.findByAmountGreaterThan(1000.0);
        
        // Then
        assertThat(result).isEmpty();
    }
}
```

---

## ğŸ“ Summary/Quick Recap - Yaad Rakhne Ka Mantra

### ğŸ¯ Key Takeaways

| Method | Syntax | Best For | Example |
|--------|--------|----------|---------|
| **Query Method** | `findBy[Field]GreaterThan()` | Simple conditions | `findByAmountGreaterThan(1000.0)` |
| **JPQL** | `@Query("SELECT ... WHERE field > :param")` | Complex logic | Multiple joins, calculations |
| **Native SQL** | `@Query(value="...", nativeQuery=true)` | Performance critical | Database-specific features |

### ğŸ§  Memory Tricks

**"Greater Than SAGA" - Step by Step:**
- **S** - **S**elect method type (Query/JPQL/Native)
- **A** - **A**dd proper syntax (`GreaterThan` keyword)
- **G** - **G**et parameter types right (Double with Double)
- **A** - **A**dd error handling and testing

### ğŸ“Š When to Use What - Decision Tree

```
Query Complexity?
â”œâ”€â”€ Simple (single field) â†’ Query Method âœ…
â”œâ”€â”€ Medium (multiple conditions) â†’ JPQL âœ…  
â””â”€â”€ Complex (joins, subqueries) â†’ Native SQL âœ…

Performance Critical?
â”œâ”€â”€ Yes â†’ Native SQL âœ…
â””â”€â”€ No â†’ Query Method/JPQL âœ…

Team Experience?
â”œâ”€â”€ Beginners â†’ Query Method âœ…
â”œâ”€â”€ Intermediate â†’ JPQL âœ…
â””â”€â”€ Advanced â†’ Native SQL âœ…
```

### ğŸš¨ Must Remember Points

1. **Method Naming:** `findBy + FieldName + GreaterThan + Parameter` âœ…
2. **Parameter Types:** Must match entity field types exactly âœ…
3. **JPQL:** Use Entity names, NOT table names âœ…  
4. **Native SQL:** Use table names, NOT entity names âœ…
5. **Null Safety:** Always handle null values in queries âœ…

### ğŸ‰ Final Boss Challenge

**Complete this repository interface:**
```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // 1. Find products with price > given amount
    List<Product> findBy_______________(Double price);
    
    // 2. JPQL query for products with stock > given quantity  
    @Query("SELECT p FROM ______ p WHERE p._____ > :stock")
    List<Product> findProductsWithHighStock(@Param("stock") Integer stock);
    
    // 3. Native query for products with rating > given value
    @Query(value = "SELECT * FROM _______ WHERE _____ > :rating", nativeQuery = true)
    List<Product> findHighRatedProducts(@Param("rating") Double rating);
}
```

**Answers:**
1. `findByPriceGreaterThan`
2. `Product`, `stockQuantity`  
3. `product`, `rating`

---

**Bas ho gaya bhai! ğŸŠ Ab tum JPA mein Greater Than operations ke master ho! Practice karo aur interview mein rock karo! ğŸ’ª**

**Happy Coding! ğŸš€âœ¨**
