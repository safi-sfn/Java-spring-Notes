# 🎯 Spring Data JPA - Greater Than Operations Complete Guide

*Bhai, aaj seekhte hain JPA Repository mein Greater Than kaise use karte hain! 💪*

---

## 🤔 Introduction - Confusion Clear Karte Hain

### Simple Explanation Pehle 📝
**Yaar, simple words mein:** Greater Than matlab hum database se wahi records fetch karte hain jo specified value se **zyada** hain. Jaise agar hume 1000 rupaye se zyada ke orders chahiye, toh ye feature use karenge! 

### Real-life Analogy 🏪
**Socho tumhare paas ek shop hai:**
- Customer bolte hain: "Bhai 500 rupaye se zyada wale products dikhao"
- Tum shop mein jaate ho aur 501, 600, 700... wale products nikaalte ho
- Exactly yahi kaam JPA Repository mein Greater Than operator karta hai! 

### Technical Definition 🔬
JPA Repository mein Greater Than operator use karke hum easily comparison operations perform kar sakte hain, where field value specified value se greater hona chahiye. **Teen tarike hain isko implement karne ke:**
1. **Query Method** with `GreaterThan` keyword
2. **JPQL** (Java Persistence Query Language) 
3. **Native SQL** queries

---

## 🔑 Key Terms/Concepts

| Term | Technical Explanation |
|------|----------------------|
| **JPA Repository**  | Database operations ke liye interface |
| **Greater Than** |  Comparison operator (>) |
| **JPQL** |  Object-oriented query language |
| **Native Query** | Direct SQL commands |
| **Query Method** | Method name se automatic query generation |

### Visual Representation 📊
```
Database Records: [100, 200, 300, 400, 500, 600]
Greater Than 250: [300, 400, 500, 600] ✅
Smaller/Equal:    [100, 200, 250] ❌
```

---

## 💡 Detailed Examples - Complete Working Code

### Method 1: Query Method with GreaterThan Keyword 🎯

```java
// Repository Interface
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // ✅ Correct: findBy + FieldName + GreaterThan + Parameter
    List<OrderDetail> findByAmountGreaterThan(Double amount);
    
    // ✅ Multiple fields bhi kar sakte hain
    List<OrderDetail> findByAmountGreaterThanAndCustomerIdEquals(Double amount, Long customerId);
    
    // ✅ Order by bhi add kar sakte hain
    List<OrderDetail> findByAmountGreaterThanOrderByAmountDesc(Double amount);
}
```

**Expected Output:**
```sql
-- Hibernate generates ye query:
SELECT od.id, od.amount, od.customer_id 
FROM order_detail od 
WHERE od.amount > ?
```

### Method 2: JPQL Query 📝

```java
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // ✅ JPQL with Greater Than
    @Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount")
    List<OrderDetail> findOrdersWithAmountGreaterThan(@Param("amount") Double amount);
    
    // ✅ Multiple conditions ke saath
    @Query("SELECT o FROM OrderDetail o WHERE o.amount > :minAmount AND o.customerId = :customerId")
    List<OrderDetail> findCustomerOrdersGreaterThan(@Param("minAmount") Double amount, 
                                                   @Param("customerId") Long customerId);
}
```

**Expected Output:**
```sql
-- Same SQL generates hota hai:
SELECT od.id, od.amount, od.customer_id 
FROM order_detail od 
WHERE od.amount > ?
```

### Method 3: Native SQL Query 💾

```java
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // ✅ Native SQL Query
    @Query(value = "SELECT * FROM order_detail WHERE amount > :amount", nativeQuery = true)
    List<OrderDetail> findOrdersWithNativeQuery(@Param("amount") Double amount);
    
    // ✅ Complex native query
    @Query(value = "SELECT * FROM order_detail WHERE amount > :amount AND customer_id IN (:customerIds)", 
           nativeQuery = true)
    List<OrderDetail> findOrdersForCustomersGreaterThan(@Param("amount") Double amount, 
                                                       @Param("customerIds") List<Long> customerIds);
}
```

**Expected Output:**
```sql
-- Direct SQL execute hota hai:
SELECT * FROM order_detail WHERE amount > ?
```

---

## 📋 Rules/Guidelines - Yaad Rakhne Ke Rules

### Rule 1: Method Naming Convention ✅
```java
// ✅ Correct Pattern
findBy + FieldName + GreaterThan + (Parameter)

// ✅ Valid Examples
findByAmountGreaterThan(Double amount)
findBySalaryGreaterThan(BigDecimal salary) 
findByAgeGreaterThan(Integer age)

// ❌ Wrong Examples
findGreaterThanAmount(Double amount)        // Wrong order
findByAmountBiggerThan(Double amount)      // Wrong keyword
findAmountGreaterThan(Double amount)       // Missing "By"
```

### Rule 2: Parameter Type Matching ✅
```java
// ✅ Correct - Types match
@Entity
public class OrderDetail {
    private Double amount;  // Database field type
}

List<OrderDetail> findByAmountGreaterThan(Double amount); // Same type parameter

// ❌ Wrong - Type mismatch
List<OrderDetail> findByAmountGreaterThan(String amount); // Wrong type!
```

**Error Example:**
```
ERROR: No property 'amount' of type 'java.lang.String' found in type 'OrderDetail'
```

### Rule 3: JPQL Entity Names ✅
```java
// ✅ Correct - Use Entity name, not table name
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount")

// ❌ Wrong - Table name use mat karo
@Query("SELECT o FROM order_detail o WHERE o.amount > :amount") // ❌
```

### Rule 4: Native Query Table Names ✅
```java
// ✅ Correct - Use actual table name
@Query(value = "SELECT * FROM order_detail WHERE amount > :amount", nativeQuery = true)

// ❌ Wrong - Entity name mat use karo native query mein
@Query(value = "SELECT * FROM OrderDetail WHERE amount > :amount", nativeQuery = true) // ❌
```

---

## 🌍 Real-world Applications

### 1. Banking Application 🏦
```java
@Entity
public class Transaction {
    @Id
    private Long id;
    private BigDecimal amount;
    private LocalDateTime transactionDate;
    
    // getters and setters
}

@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    
    // High-value transactions (> 50,000)
    List<Transaction> findByAmountGreaterThan(BigDecimal amount);
    
    // Suspicious transactions in last 24 hours
    @Query("SELECT t FROM Transaction t WHERE t.amount > :amount AND t.transactionDate > :date")
    List<Transaction> findSuspiciousTransactions(@Param("amount") BigDecimal amount, 
                                                @Param("date") LocalDateTime date);
}

// Service layer usage
@Service
public class TransactionService {
    
    @Autowired
    private TransactionRepository repository;
    
    public List<Transaction> getHighValueTransactions() {
        return repository.findByAmountGreaterThan(new BigDecimal("50000"));
    }
}
```

### 2. E-commerce Application 🛒
```java
@Entity 
public class Product {
    @Id
    private Long id;
    private String name;
    private Double price;
    private Integer stockQuantity;
    
    // getters and setters
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Premium products (> 10,000)
    List<Product> findByPriceGreaterThan(Double price);
    
    // Products with good stock
    List<Product> findByStockQuantityGreaterThan(Integer quantity);
    
    // Combined filter
    @Query("SELECT p FROM Product p WHERE p.price > :minPrice AND p.stockQuantity > :minStock")
    List<Product> findAvailablePremiumProducts(@Param("minPrice") Double price, 
                                              @Param("minStock") Integer stock);
}
```

### 3. Employee Management System 👨‍💼
```java
@Entity
public class Employee {
    @Id
    private Long id;
    private String name;
    private BigDecimal salary;
    private Integer experience;
    
    // getters and setters
}

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // Senior employees (> 5 years experience)
    List<Employee> findByExperienceGreaterThan(Integer years);
    
    // High salary employees
    List<Employee> findBySalaryGreaterThan(BigDecimal salary);
    
    // Performance bonus eligible
    @Query(value = "SELECT * FROM employee WHERE salary > :minSalary AND experience > :minExp", 
           nativeQuery = true)
    List<Employee> findBonusEligibleEmployees(@Param("minSalary") BigDecimal salary, 
                                            @Param("minExp") Integer experience);
}
```

---

## 🆚 Comparison Table - Konsa Method Kab Use Kare

| Feature | Query Method | JPQL | Native SQL |
|---------|--------------|------|------------|
| **Ease of Use** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ |
| **Performance** | ⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **Database Independence** | ✅ | ✅ | ❌ |
| **Complex Queries** | ❌ | ✅ | ✅ |
| **Auto-completion** | ✅ | ❌ | ❌ |
| **Compile-time Checking** | ✅ | ❌ | ❌ |

### When to Use What? 🤷‍♂️

| Scenario | Best Choice | Reason |
|----------|-------------|---------|
| Simple field comparison | Query Method | Easiest, no SQL knowledge needed |
| Multiple conditions | JPQL | Object-oriented, database independent |
| Complex joins/subqueries | Native SQL | Full SQL power |
| Performance critical | Native SQL | Direct database optimization |
| Beginners | Query Method | Less prone to errors |

---

## 🎤 Interview Questions - Ready Raho!

### Q1: Query Method mein GreaterThan aur GreaterThanEqual mein kya difference hai?

**Answer:**
```java
// GreaterThan - Strictly greater (>)
List<Order> findByAmountGreaterThan(Double amount);     // amount > 1000
// Input: 1000, Result: [1001, 1500, 2000] ✅

// GreaterThanEqual - Greater than or equal (>=)  
List<Order> findByAmountGreaterThanEqual(Double amount); // amount >= 1000
// Input: 1000, Result: [1000, 1001, 1500, 2000] ✅
```

### Q2: JPQL aur Native Query mein performance difference kya hai?

**Answer:**
```java
// JPQL - Gets converted to SQL by Hibernate
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount") // ⭐⭐⭐⭐
// + Database independent
// - Extra conversion overhead

// Native SQL - Direct execution
@Query(value = "SELECT * FROM order_detail WHERE amount > :amount", nativeQuery = true) // ⭐⭐⭐⭐⭐  
// + Fastest execution
// - Database specific
```

### Q3: Multiple Greater Than conditions kaise likhenge?

**Answer:**
```java
// Method 1: Query Method
List<Order> findByAmountGreaterThanAndQuantityGreaterThan(Double amount, Integer quantity);

// Method 2: JPQL
@Query("SELECT o FROM Order o WHERE o.amount > :amount AND o.quantity > :quantity")
List<Order> findOrdersWithMultipleConditions(@Param("amount") Double amount, 
                                            @Param("quantity") Integer quantity);

// Method 3: Criteria API (Advanced)
Specification<Order> spec = Specification
    .where((root, query, cb) -> cb.greaterThan(root.get("amount"), amount))
    .and((root, query, cb) -> cb.greaterThan(root.get("quantity"), quantity));
```

### Q4: Null values ke saath Greater Than kaise handle kare?

**Answer:**
```java
// Problem: Null values comparison mein issues
List<Order> findByAmountGreaterThan(Double amount); // NullPointerException possible!

// Solution 1: Custom query with null check
@Query("SELECT o FROM Order o WHERE o.amount IS NOT NULL AND o.amount > :amount")
List<Order> findByAmountGreaterThanSafely(@Param("amount") Double amount);

// Solution 2: Optional wrapper
Optional<List<Order>> findByAmountGreaterThanAndAmountIsNotNull(Double amount);
```

---

## 😱 Common Mistakes - Inse Bacho Bhai!

### Mistake 1: Wrong Method Naming ❌
```java
// ❌ Galat tarika
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    List<OrderDetail> findGreaterThanAmount(Double amount);        // Wrong!
    List<OrderDetail> findByAmountBigThan(Double amount);          // Wrong keyword!
    List<OrderDetail> findOrderByAmountGreaterThan(Double amount); // Extra word!
}

// ✅ Sahi tarika  
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    List<OrderDetail> findByAmountGreaterThan(Double amount);      // Perfect! ✅
}
```

**Error Message:**
```
org.springframework.data.mapping.PropertyReferenceException: 
No property 'greaterThanAmount' found for type 'OrderDetail'
```

### Mistake 2: Parameter Type Mismatch ❌
```java
@Entity
public class OrderDetail {
    private Double amount; // Database field is Double
}

// ❌ Wrong parameter type
List<OrderDetail> findByAmountGreaterThan(String amount); // String instead of Double!

// ✅ Correct parameter type
List<OrderDetail> findByAmountGreaterThan(Double amount); // Matches field type ✅
```

### Mistake 3: JPQL mein Table Name Use Karna ❌
```java
// ❌ Wrong - Table name use kiya
@Query("SELECT o FROM order_detail o WHERE o.amount > :amount") // Table name!

// ✅ Correct - Entity name use karo
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount")  // Entity name ✅
```

### Mistake 4: Native Query mein Entity Name ❌
```java
// ❌ Wrong - Entity name in native query
@Query(value = "SELECT * FROM OrderDetail WHERE amount > :amount", nativeQuery = true)

// ✅ Correct - Table name in native query  
@Query(value = "SELECT * FROM order_detail WHERE amount > :amount", nativeQuery = true) ✅
```

### Mistake 5: Parameter Binding Issues ❌
```java
// ❌ Wrong - Parameter name mismatch
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :minAmount")
List<OrderDetail> findByAmount(Double amount); // Parameter name different!

// ✅ Correct - Consistent parameter naming
@Query("SELECT o FROM OrderDetail o WHERE o.amount > :amount")  
List<OrderDetail> findByAmount(@Param("amount") Double amount); ✅

// ✅ Alternative - Positional parameter
@Query("SELECT o FROM OrderDetail o WHERE o.amount > ?1")
List<OrderDetail> findByAmount(Double amount); ✅
```

---

## ⭐ Best Practices - Professional Bano!

### 1. Consistent Naming Convention 📝
```java
// ✅ Good naming pattern
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Clear, descriptive method names
    List<Product> findByPriceGreaterThan(Double price);
    List<Product> findByStockQuantityGreaterThan(Integer quantity);
    
    // Complex conditions are clearly named
    List<Product> findByPriceGreaterThanAndStockQuantityGreaterThan(Double price, Integer stock);
    
    // Custom queries have descriptive names
    @Query("SELECT p FROM Product p WHERE p.price > :minPrice ORDER BY p.price ASC")
    List<Product> findPremiumProductsSortedByPrice(@Param("minPrice") Double minPrice);
}
```

### 2. Proper Exception Handling 🛡️
```java
@Service
public class OrderService {
    
    @Autowired
    private OrderRepository orderRepository;
    
    // ✅ Good - Exception handling with meaningful messages
    public List<OrderDetail> getHighValueOrders(Double minAmount) {
        try {
            if (minAmount == null || minAmount < 0) {
                throw new IllegalArgumentException("Amount must be positive and not null");
            }
            
            List<OrderDetail> orders = orderRepository.findByAmountGreaterThan(minAmount);
            
            if (orders.isEmpty()) {
                log.info("No orders found with amount greater than {}", minAmount);
            }
            
            return orders;
            
        } catch (Exception e) {
            log.error("Error fetching orders with amount > {}: {}", minAmount, e.getMessage());
            throw new ServiceException("Failed to fetch high value orders", e);
        }
    }
}
```

### 3. Query Optimization 🚀
```java
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // ✅ Good - Add sorting for consistent results
    List<OrderDetail> findByAmountGreaterThanOrderByAmountDesc(Double amount);
    
    // ✅ Good - Pagination for large datasets
    Page<OrderDetail> findByAmountGreaterThan(Double amount, Pageable pageable);
    
    // ✅ Good - Limit results when needed
    List<OrderDetail> findTop10ByAmountGreaterThanOrderByAmountDesc(Double amount);
    
    // ✅ Good - Use projections for specific fields
    @Query("SELECT o.id, o.amount FROM OrderDetail o WHERE o.amount > :amount")
    List<Object[]> findOrderIdsAndAmountsGreaterThan(@Param("amount") Double amount);
}
```

### 4. Documentation & Comments 📚
```java
/**
 * Repository for OrderDetail entity operations
 * 
 * @author Your Name
 * @since 1.0
 */
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    /**
     * Finds all orders with amount greater than specified value
     * 
     * @param amount minimum amount (exclusive)
     * @return list of orders with amount > specified value
     * @throws IllegalArgumentException if amount is null or negative
     */
    List<OrderDetail> findByAmountGreaterThan(Double amount);
    
    /**
     * Custom query to find high-value orders for premium customers
     * Uses JPQL for database independence
     * 
     * @param minAmount minimum order amount
     * @param customerTier customer tier (GOLD, PLATINUM, etc.)
     * @return sorted list of premium customer orders
     */
    @Query("SELECT o FROM OrderDetail o JOIN o.customer c " +
           "WHERE o.amount > :minAmount AND c.tier = :tier " +
           "ORDER BY o.amount DESC")
    List<OrderDetail> findPremiumCustomerHighValueOrders(
        @Param("minAmount") Double minAmount,
        @Param("tier") String customerTier
    );
}
```

### 5. Testing Best Practices 🧪
```java
@DataJpaTest
public class OrderRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired  
    private OrderRepository orderRepository;
    
    @Test
    public void testFindByAmountGreaterThan() {
        // Given - Test data setup
        OrderDetail order1 = new OrderDetail(1L, 500.0);
        OrderDetail order2 = new OrderDetail(2L, 1500.0);
        OrderDetail order3 = new OrderDetail(3L, 2500.0);
        
        entityManager.persistAndFlush(order1);
        entityManager.persistAndFlush(order2);  
        entityManager.persistAndFlush(order3);
        
        // When - Execute query
        List<OrderDetail> result = orderRepository.findByAmountGreaterThan(1000.0);
        
        // Then - Verify results
        assertThat(result).hasSize(2);
        assertThat(result).extracting(OrderDetail::getAmount)
                         .containsExactly(1500.0, 2500.0);
    }
    
    @Test
    public void testFindByAmountGreaterThan_NoResults() {
        // Given
        OrderDetail order = new OrderDetail(1L, 500.0);
        entityManager.persistAndFlush(order);
        
        // When
        List<OrderDetail> result = orderRepository.findByAmountGreaterThan(1000.0);
        
        // Then
        assertThat(result).isEmpty();
    }
}
```

---

## 📝 Summary/Quick Recap - Yaad Rakhne Ka Mantra

### 🎯 Key Takeaways

| Method | Syntax | Best For | Example |
|--------|--------|----------|---------|
| **Query Method** | `findBy[Field]GreaterThan()` | Simple conditions | `findByAmountGreaterThan(1000.0)` |
| **JPQL** | `@Query("SELECT ... WHERE field > :param")` | Complex logic | Multiple joins, calculations |
| **Native SQL** | `@Query(value="...", nativeQuery=true)` | Performance critical | Database-specific features |

### 🧠 Memory Tricks

**"Greater Than SAGA" - Step by Step:**
- **S** - **S**elect method type (Query/JPQL/Native)
- **A** - **A**dd proper syntax (`GreaterThan` keyword)
- **G** - **G**et parameter types right (Double with Double)
- **A** - **A**dd error handling and testing

### 📊 When to Use What - Decision Tree

```
Query Complexity?
├── Simple (single field) → Query Method ✅
├── Medium (multiple conditions) → JPQL ✅  
└── Complex (joins, subqueries) → Native SQL ✅

Performance Critical?
├── Yes → Native SQL ✅
└── No → Query Method/JPQL ✅

Team Experience?
├── Beginners → Query Method ✅
├── Intermediate → JPQL ✅
└── Advanced → Native SQL ✅
```

### 🚨 Must Remember Points

1. **Method Naming:** `findBy + FieldName + GreaterThan + Parameter` ✅
2. **Parameter Types:** Must match entity field types exactly ✅
3. **JPQL:** Use Entity names, NOT table names ✅  
4. **Native SQL:** Use table names, NOT entity names ✅
5. **Null Safety:** Always handle null values in queries ✅

### 🎉 Final Boss Challenge

**Complete this repository interface:**
```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // 1. Find products with price > given amount
    List<Product> findBy_______________(Double price);
    
    // 2. JPQL query for products with stock > given quantity  
    @Query("SELECT p FROM ______ p WHERE p._____ > :stock")
    List<Product> findProductsWithHighStock(@Param("stock") Integer stock);
    
    // 3. Native query for products with rating > given value
    @Query(value = "SELECT * FROM _______ WHERE _____ > :rating", nativeQuery = true)
    List<Product> findHighRatedProducts(@Param("rating") Double rating);
}
```

**Answers:**
1. `findByPriceGreaterThan`
2. `Product`, `stockQuantity`  
3. `product`, `rating`

---

**Bas ho gaya bhai! 🎊 Ab tum JPA mein Greater Than operations ke master ho! Practice karo aur interview mein rock karo! 💪**

**Happy Coding! 🚀✨**
