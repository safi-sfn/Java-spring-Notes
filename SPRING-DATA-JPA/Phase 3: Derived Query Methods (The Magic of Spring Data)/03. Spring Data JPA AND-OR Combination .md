# Spring Data JPA AND/OR Combination Complete Guide 🚀

## Table of Contents 📚
1. [Introduction with Confusion Clearing](#introduction)
2. [Key Terms/Concepts](#key-terms)
3. [Detailed Examples](#detailed-examples)
4. [Rules/Guidelines](#rules-guidelines)
5. [Real-world Applications](#real-world-applications)
6. [Comparison Tables](#comparison-tables)
7. [Interview Questions](#interview-questions)
8. [Common Mistakes](#common-mistakes)
9. [Best Practices](#best-practices)
10. [Summary/Quick Recap](#summary)

---

## 1. Introduction with Confusion Clearing 🤔

### Simple Explanation First 
Bhai, simple words mein samjho - jab tumhe database se data filter karna ho multiple conditions ke saath, tab AND/OR operators use karte hain. Jaise real life mein bolte hain "Mujhe IT department ka staff chahiye JO Alice hai YA jiska salary 70,000 se zyada hai" 💰

### Real-life Analogy 🎯
**Imagine karo tum ek HR manager ho:**
- Tum chahte ho: IT department ke employees (AND condition) 
- Plus: Jo ya toh Alice hain ya 70k+ salary wale hain (OR condition)
- Matlab: `IT Department AND (Alice OR Salary > 70k)`

### Technical Definition 📖
Spring Data JPA mein AND/OR combination ka matlab hai multiple filtering conditions ko combine karna ek hi query mein. Ye teen tarike se kar sakte hain: Custom Query Methods, JPQL queries, aur Native SQL queries.

---

## 2. Key Terms/Concepts 🎯

### 🔑 Important Terminology

| Term | Explanation |
|------|-------------|
| **Repository Interface** | Database operations ke liye interface |
| **JPA (Java Persistence API)** | Java objects ko database tables se map karta hai |
| **JPQL (Java Persistence Query Language)** | Object-oriented query language |
| **Native SQL** | Direct database SQL queries |
| **Query Methods** | Method names se automatic queries |

### 🎨 Visual Representation
```
Database Query Flow:
┌─────────────────┐    ┌──────────────┐    ┌─────────────┐
│ Controller      │────│ Service      │────│ Repository  │
│ (API Endpoint)  │    │ (Business    │    │ (Database   │
│                 │    │  Logic)      │    │  Access)    │
└─────────────────┘    └──────────────┘    └─────────────┘
                                                   │
                                           ┌───────▼──────┐
                                           │   Database   │
                                           │   (H2/MySQL) │
                                           └──────────────┘
```

---

## 3. Detailed Examples 💻

### 🏗️ Complete Working Project Structure

#### A. Maven Dependencies (pom.xml)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.springjava</groupId>
    <artifactId>demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>demo</name>
    <description>Demo project for Spring Boot</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Data JPA - Database operations ke liye -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <!-- Spring Boot Web - REST APIs ke liye -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- H2 Database - Testing ke liye lightweight database -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Lombok - Boilerplate code reduce karne ke liye -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>
```

#### B. Database Configuration (application.properties)
```properties
# H2 Database Configuration - Yaad rakho, ye testing ke liye hai
spring.datasource.url=jdbc:h2:mem:test
spring.datasource.username=sa
spring.datasource.password=

# JPA Settings - SQL queries console mein dikhane ke liye
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=update

# H2 Console enable karna - browser mein database dekhne ke liye
spring.h2.console.enabled=true
```

#### C. JPA Entity Class 📝
```java
package com.springjava.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.Data;

@Data  // Lombok - automatic getter/setter/toString
@Entity  // JPA annotation - ye class database table banayegi
public class Staff {
    
    @Id  // Primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // Auto-increment
    private Long id;
    
    private String name;        // Employee ka naam
    private String department;  // Department name (IT, Finance, etc.)
    private double salary;      // Monthly salary
    
    // Lombok @Data annotation se ye sab automatic generate hoga:
    // - Default constructor
    // - Parameterized constructor
    // - Getters and Setters
    // - toString(), equals(), hashCode()
}
```

**Expected Database Table Structure:**
```sql
CREATE TABLE staff (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    department VARCHAR(255),
    salary DOUBLE
);
```

#### D. Repository Interface - Teen Tarike 🎯

```java
package com.springjava.repository;

import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import com.springjava.entity.Staff;

public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    // 🔥 Method 1: Query Method Names (Spring Magic!)
    // Ye method name se automatic query banata hai
    List<Staff> findByDepartmentAndNameOrSalaryGreaterThan(
        String department, String name, double salary
    );
    // Generated SQL: WHERE department = ? AND name = ? OR salary > ?
    // ⚠️ Dhyan do: Default precedence hai, parentheses nahi!
    
    // 🔥 Method 2: JPQL Query (Object-Oriented SQL)
    @Query("SELECT s FROM Staff s WHERE s.department = :department " +
           "AND (s.name = :name OR s.salary > :salary)")
    List<Staff> findByDepartmentAndNameOrSalaryGreaterThanJPQL(
        String department, String name, double salary
    );
    // ✅ Proper parentheses use kiye hain for correct logic
    
    // 🔥 Method 3: Native SQL Query (Direct Database SQL)
    @Query(value = "SELECT * FROM staff WHERE department = :department " +
                  "AND (name = :name OR salary > :salary)", 
           nativeQuery = true)
    List<Staff> findByDepartmentAndNameOrSalaryGreaterThanNative(
        String department, String name, double salary
    );
    // ✅ Pure SQL - database specific features use kar sakte hain
}
```

#### E. Service Layer 🔧
```java
package com.springjava.service;

import java.util.List;
import com.springjava.entity.Staff;

// Service Interface - Business logic ke liye contract
public interface StaffService {
    void saveAll(List<Staff> staffList);
    
    List<Staff> getByDepartmentAndNameOrSalaryGreaterThan(
        String department, String name, double salary
    );
    
    List<Staff> getByDepartmentAndNameOrSalaryGreaterThanJPQL(
        String department, String name, double salary
    );
    
    List<Staff> getByDepartmentAndNameOrSalaryGreaterThanNative(
        String department, String name, double salary
    );
}
```

```java
package com.springjava.service;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.springjava.entity.Staff;
import com.springjava.repository.StaffRepository;

@Service  // Spring ka service component
public class StaffServiceImpl implements StaffService {
    
    @Autowired  // Dependency Injection - Repository inject kar rahe hain
    private StaffRepository staffRepo;
    
    @Override
    public void saveAll(List<Staff> staffList) {
        staffRepo.saveAll(staffList);  // Batch insert operation
    }
    
    @Override
    public List<Staff> getByDepartmentAndNameOrSalaryGreaterThan(
            String department, String name, double salary) {
        return staffRepo.findByDepartmentAndNameOrSalaryGreaterThan(
            department, name, salary
        );
    }
    
    @Override
    public List<Staff> getByDepartmentAndNameOrSalaryGreaterThanJPQL(
            String department, String name, double salary) {
        return staffRepo.findByDepartmentAndNameOrSalaryGreaterThanJPQL(
            department, name, salary
        );
    }
    
    @Override
    public List<Staff> getByDepartmentAndNameOrSalaryGreaterThanNative(
            String department, String name, double salary) {
        return staffRepo.findByDepartmentAndNameOrSalaryGreaterThanNative(
            department, name, salary
        );
    }
}
```

#### F. REST Controller 🌐
```java
package com.springjava.controller;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.springjava.entity.Staff;
import com.springjava.service.StaffService;

@RestController  // REST API endpoints ke liye
@RequestMapping("/api/staff")  // Base URL path
public class StaffController {
    
    @Autowired
    private StaffService staffService;
    
    // 📝 POST API - Multiple staff members save karne ke liye
    @PostMapping("/save-all")
    public ResponseEntity<?> save(@RequestBody List<Staff> staffList) {
        Map<String, Object> response = new LinkedHashMap<>();
        
        staffService.saveAll(staffList);
        response.put("status", 1);
        response.put("message", "Records saved successfully! 🎉");
        
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }
    
    // 🔍 GET API - Query Method approach
    @GetMapping("/and-or-with-query-method")
    public ResponseEntity<?> getByDepartmentAndNameOrSalaryGreaterThan(
            @RequestParam String department,
            @RequestParam String name,
            @RequestParam double salary) {
        
        Map<String, Object> response = new LinkedHashMap<>();
        List<Staff> staffList = staffService.getByDepartmentAndNameOrSalaryGreaterThan(
            department, name, salary
        );
        
        if (!staffList.isEmpty()) {
            response.put("status", 1);
            response.put("data", staffList);
            response.put("method", "Query Method Approach");
            return new ResponseEntity<>(response, HttpStatus.OK);
        } else {
            response.put("status", 0);
            response.put("message", "No data found! 😔");
            return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
        }
    }
    
    // 🔍 GET API - JPQL approach  
    @GetMapping("/and-or-with-jpql")
    public ResponseEntity<?> getByDepartmentAndNameOrSalaryGreaterThanJPQL(
            @RequestParam String department,
            @RequestParam String name,
            @RequestParam double salary) {
        
        Map<String, Object> response = new LinkedHashMap<>();
        List<Staff> staffList = staffService.getByDepartmentAndNameOrSalaryGreaterThanJPQL(
            department, name, salary
        );
        
        if (!staffList.isEmpty()) {
            response.put("status", 1);
            response.put("data", staffList);
            response.put("method", "JPQL Approach");
            return new ResponseEntity<>(response, HttpStatus.OK);
        } else {
            response.put("status", 0);
            response.put("message", "No data found! 😔");
            return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
        }
    }
    
    // 🔍 GET API - Native SQL approach
    @GetMapping("/and-or-with-native")
    public ResponseEntity<?> getByDepartmentAndNameOrSalaryGreaterThanNative(
            @RequestParam String department,
            @RequestParam String name,
            @RequestParam double salary) {
        
        Map<String, Object> response = new LinkedHashMap<>();
        List<Staff> staffList = staffService.getByDepartmentAndNameOrSalaryGreaterThanNative(
            department, name, salary
        );
        
        if (!staffList.isEmpty()) {
            response.put("status", 1);
            response.put("data", staffList);
            response.put("method", "Native SQL Approach");
            return new ResponseEntity<>(response, HttpStatus.OK);
        } else {
            response.put("status", 0);
            response.put("message", "No data found! 😔");
            return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
        }
    }
}
```

### 🧪 Testing Data
```json
[
    {
        "name": "John",
        "department": "Finance",
        "salary": 65000.00
    },
    {
        "name": "Alice", 
        "department": "IT",
        "salary": 80000.00
    },
    {
        "name": "Robert",
        "department": "IT", 
        "salary": 55000.00
    },
    {
        "name": "Sarah",
        "department": "HR",
        "salary": 75000.00
    }
]
```

### 📊 Expected Outputs

**Test Query:** `department=IT&name=Alice&salary=70000`

**Query Method Output:**
Generated SQL: `WHERE department = ? AND name = ? OR salary > ?`
- Result: Alice (IT + Alice), Sarah (salary > 70000)
- ⚠️ Wrong logic due to operator precedence!

**JPQL/Native Output:**
Generated SQL: `WHERE department = ? AND (name = ? OR salary > ?)`
- Result: Only Alice (IT department AND Alice name)
- ✅ Correct logic with proper parentheses!

---

## 4. Rules/Guidelines 📋

### ✅ DO's and ❌ DON'Ts

#### Rule 1: Operator Precedence Samjho 🎯
✅ **Correct:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND (s.name = :name OR s.salary > :salary)")
```
❌ **Wrong:**
```java
// Query method without understanding precedence
findByDepartmentAndNameOrSalaryGreaterThan() 
// Results in: (dept AND name) OR salary - Wrong logic!
```

#### Rule 2: Parameter Names Consistent Rakho 📝
✅ **Correct:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :department")
List<Staff> findByDept(@Param("department") String dept);
```
❌ **Wrong:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :department")
List<Staff> findByDept(String dept);  // Parameter name mismatch!
```

#### Rule 3: Method Naming Convention Follow Karo 🏷️
✅ **Correct:**
```java
findByDepartmentAndNameOrSalaryGreaterThan(String dept, String name, double salary)
//    ↑          ↑   ↑    ↑        ↑
//  Column    AND  Col  OR     Col+Operator
```
❌ **Wrong:**
```java
findByDeptAndNameOrSalGreater()  // Column names match nahi kar rahe!
```

#### Rule 4: JPQL vs Native SQL Usage 🔧
✅ **Use JPQL when:**
- Database independent code chahiye
- Object-oriented approach prefer karte ho
- Entity properties use karna hai

✅ **Use Native SQL when:**
- Database-specific functions use karne hain
- Complex joins ya performance optimization chahiye
- Raw SQL queries existing hain

#### Rule 5: Exception Handling Zaroori Hai ⚠️
✅ **Correct:**
```java
@Override
public List<Staff> getStaff(String dept, String name, double salary) {
    try {
        return staffRepo.findByDepartmentAndNameOrSalaryGreaterThan(dept, name, salary);
    } catch (Exception e) {
        log.error("Error fetching staff: {}", e.getMessage());
        return Collections.emptyList();
    }
}
```

---

## 5. Real-world Applications 🌍

### 🏦 Banking System Example
```java
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    // Find accounts: Active status AND (High balance OR VIP customer)
    @Query("SELECT a FROM Account a WHERE a.status = 'ACTIVE' " +
           "AND (a.balance > :minBalance OR a.customerType = 'VIP')")
    List<Account> findActiveHighValueOrVipAccounts(
        @Param("minBalance") double minBalance
    );
    
    // Find loan applicants: Good credit score AND (High income OR existing customer)
    List<LoanApplication> findByCreditScoreGreaterThanAndIncomeGreaterThanOrExistingCustomer(
        int creditScore, double income, boolean existingCustomer
    );
}
```

### 🛒 E-commerce System Example  
```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Find products: In stock AND (On sale OR Premium brand)
    @Query("SELECT p FROM Product p WHERE p.stockQuantity > 0 " +
           "AND (p.onSale = true OR p.brand IN :premiumBrands)")
    List<Product> findAvailableDealsOrPremium(
        @Param("premiumBrands") List<String> premiumBrands
    );
    
    // Customer search: Category filter AND (Price range OR Rating)
    List<Product> findByCategoryAndPriceBetweenOrRatingGreaterThan(
        String category, double minPrice, double maxPrice, double rating
    );
}
```

### 🏥 Hospital Management System
```java
public interface PatientRepository extends JpaRepository<Patient, Long> {
    
    // Find patients: Critical condition AND (Emergency contact available OR Family present)
    @Query("SELECT p FROM Patient p WHERE p.condition = 'CRITICAL' " +
           "AND (p.emergencyContact IS NOT NULL OR p.familyPresent = true)")
    List<Patient> findCriticalPatientsWithSupport();
    
    // Doctor availability: Department match AND (Shift time OR On-call status)
    List<Doctor> findByDepartmentAndShiftTimeOrOnCallStatus(
        String department, String shiftTime, boolean onCall
    );
}
```

### 📚 Student Management System
```java
public interface StudentRepository extends JpaRepository<Student, Long> {
    
    // Scholarship eligible: Good grades AND (Financial need OR Merit basis)
    @Query("SELECT s FROM Student s WHERE s.cgpa >= :minCgpa " +
           "AND (s.familyIncome < :maxIncome OR s.meritRank <= :topRank)")
    List<Student> findScholarshipEligible(
        @Param("minCgpa") double minCgpa,
        @Param("maxIncome") double maxIncome, 
        @Param("topRank") int topRank
    );
}
```

---

## 6. Comparison Tables 📊

### Method Comparison Table

| Aspect | Query Methods | JPQL | Native SQL |
|--------|---------------|------|------------|
| **Learning Curve** | 🟢 Easy | 🟡 Medium | 🔴 Hard |
| **Type Safety** | 🟢 Compile-time | 🟡 Runtime | 🔴 Runtime |
| **Database Independence** | 🟢 Yes | 🟢 Yes | 🔴 No |
| **Complex Queries** | 🔴 Limited | 🟡 Good | 🟢 Excellent |
| **Performance** | 🟡 Medium | 🟡 Medium | 🟢 Best |
| **Readability** | 🔴 Poor for complex | 🟢 Good | 🟡 OK |
| **Maintenance** | 🔴 Hard | 🟢 Easy | 🟡 Medium |

### Operator Precedence Table

| Query Type | Logic | Generated SQL | Result |
|------------|-------|---------------|--------|
| **Query Method** | `dept AND name OR salary` | `WHERE dept=? AND name=? OR salary>?` | ❌ Wrong grouping |
| **JPQL** | `dept AND (name OR salary)` | `WHERE dept=? AND (name=? OR salary>?)` | ✅ Correct grouping |
| **Native SQL** | `dept AND (name OR salary)` | `WHERE dept=? AND (name=? OR salary>?)` | ✅ Correct grouping |

### Performance Comparison

| Method | Query Compilation | Execution Time | Memory Usage | Best For |
|--------|------------------|----------------|--------------|----------|
| **Query Methods** | 🟢 Compile-time | 🟡 Medium | 🟢 Low | Simple queries |
| **JPQL** | 🟡 First execution | 🟡 Medium | 🟡 Medium | Business logic |
| **Native SQL** | 🔴 Every time | 🟢 Fast | 🟡 Medium | Performance critical |

---

## 7. Interview Questions 🎤

### Q1: Spring Data JPA mein AND/OR combination ke kitne tarike hain?
**Answer:** Teen main tarike hain bhai:

1. **Query Method Names:** Method name se automatic query generation
2. **JPQL Queries:** Object-oriented query language using @Query
3. **Native SQL Queries:** Direct database SQL with nativeQuery = true

**Code Example:**
```java
// Method 1: Query Method
List<Staff> findByDepartmentAndNameOrSalaryGreaterThan(String dept, String name, double salary);

// Method 2: JPQL  
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND (s.name = :name OR s.salary > :salary)")
List<Staff> findWithJPQL(@Param("dept") String dept, @Param("name") String name, @Param("salary") double salary);

// Method 3: Native SQL
@Query(value = "SELECT * FROM staff WHERE department = ? AND (name = ? OR salary > ?)", nativeQuery = true)
List<Staff> findWithNativeSQL(String dept, String name, double salary);
```

### Q2: Query Method Names mein operator precedence ka kya issue hai?
**Answer:** Bhai, ye bahut important question hai! Query method names mein conditions left-to-right evaluate hoti hain without proper parentheses, jisse wrong logic mil sakti hai.

**Tricky Example:**
```java
// Method name: findByDepartmentAndNameOrSalaryGreaterThan
// Expected: department = 'IT' AND (name = 'Alice' OR salary > 70000)  
// Actual SQL: WHERE department = ? AND name = ? OR salary > ?
// Actual Logic: (department = 'IT' AND name = 'Alice') OR salary > 70000

// Test case:
Staff staff1 = new Staff("Alice", "IT", 50000);      // ✅ Matches: IT AND Alice  
Staff staff2 = new Staff("Bob", "Finance", 80000);   // ✅ Matches: Salary > 70000 (Wrong!)
Staff staff3 = new Staff("John", "IT", 60000);       // ❌ No match (Correct)
```

**Solution:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND (s.name = :name OR s.salary > :salary)")
List<Staff> findCorrectly(@Param("dept") String dept, @Param("name") String name, @Param("salary") double salary);
```

### Q3: JPQL vs Native SQL kab use karna chahiye?
**Answer:** Ye scenario-based decision hai yaar:

**Use JPQL when:**
- Database portability chahiye (MySQL se PostgreSQL easily switch)
- Entity relationships use karne hain (joins with objects)
- Type safety important hai

**Use Native SQL when:**
- Database-specific functions chahiye (MySQL's JSON functions, PostgreSQL arrays)
- Performance critical queries hain
- Complex stored procedures call karne hain
- Raw SQL already exists aur optimize hai

**Example:**
```java
// JPQL - Database independent
@Query("SELECT s FROM Staff s JOIN s.department d WHERE d.name = :deptName")
List<Staff> findByDepartmentJPQL(@Param("deptName") String deptName);

// Native SQL - Database specific (MySQL example)
@Query(value = "SELECT * FROM staff WHERE JSON_EXTRACT(metadata, '$.skills') LIKE %:skill%", 
       nativeQuery = true)
List<Staff> findBySkillNative(@Param("skill") String skill);
```

### Q4: @Query annotation mein parameters kaise pass karte hain?
**Answer:** Do tarike hain bhai:

**1. Positional Parameters (? ka use):**
```java
@Query("SELECT s FROM Staff s WHERE s.department = ?1 AND s.salary > ?2")
List<Staff> findByDeptAndSalary(String department, double salary);
```

**2. Named Parameters (:name ka use) - Recommended!**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND s.salary > :sal")
List<Staff> findByDeptAndSalary(@Param("dept") String department, @Param("sal") double salary);
```

**Best Practice Example:**
```java
@Query("SELECT s FROM Staff s WHERE " +
       "(:department IS NULL OR s.department = :department) AND " +
       "(:minSalary IS NULL OR s.salary >= :minSalary) AND " +
       "(:maxSalary IS NULL OR s.salary <= :maxSalary)")
List<Staff> findWithOptionalFilters(
    @Param("department") String department,
    @Param("minSalary") Double minSalary, 
    @Param("maxSalary") Double maxSalary
);
```

### Q5: Complex AND/OR combinations kaise handle karte hain?
**Answer:** Complex queries ke liye proper grouping zaroori hai:

**Scenario:** Find employees who are:
- (Senior level OR Team lead) AND (IT department OR Finance department) AND (High salary OR Bonus eligible)

```java
@Query("SELECT s FROM Staff s WHERE " +
       "(s.level = 'SENIOR' OR s.position = 'TEAM_LEAD') AND " +
       "(s.department IN ('IT', 'FINANCE')) AND " +
       "(s.salary > :highSalary OR s.bonusEligible = true)")
List<Staff> findComplexCriteria(@Param("highSalary") double highSalary);

// Alternative: Using Criteria API for dynamic queries
public List<Staff> findComplexCriteriaApi(String level, List<String> departments, double salary) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Staff> cq = cb.createQuery(Staff.class);
    Root<Staff> staff = cq.from(Staff.class);
    
    Predicate seniorOrLead = cb.or(
        cb.equal(staff.get("level"), "SENIOR"),
        cb.equal(staff.get("position"), "TEAM_LEAD")
    );
    
    Predicate deptCondition = staff.get("department").in(departments);
    
    Predicate salaryOrBonus = cb.or(
        cb.gt(staff.get("salary"), salary),
        cb.equal(staff.get("bonusEligible"), true)
    );
    
    cq.where(cb.and(seniorOrLead, deptCondition, salaryOrBonus));
    return entityManager.createQuery(cq).getResultList();
}
```

---

## 8. Common Mistakes 🚫

### ❌ Mistake 1: Operator Precedence Ignore Karna
```java
// Wrong approach - Precedence samjhe bina
public interface StaffRepository extends JpaRepository<Staff, Long> {
    // Ye method galat logic dega!
    List<Staff> findByDepartmentAndNameOrSalaryGreaterThan(String dept, String name, double salary);
    // SQL: WHERE department = ? AND name = ? OR salary > ?
    // Logic: (department AND name) OR salary - WRONG! 😱
}
```

**Why it's wrong:** Default precedence ke wajah se grouping galat ho jati hai.

**✅ Correct Approach:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND (s.name = :name OR s.salary > :salary)")
List<Staff> findCorrectLogic(@Param("dept") String dept, @Param("name") String name, @Param("salary") double salary);
```

### ❌ Mistake 2: Parameter Mapping Galat Karna
```java
// Wrong - Parameter names match nahi kar rahe
@Query("SELECT s FROM Staff s WHERE s.department = :department AND s.salary > :salary")
List<Staff> findByDeptAndSal(String dept, double sal);  // ❌ Names different hain!

// Error message:
// org.hibernate.QueryException: Named parameter not bound: department
```

**✅ Correct Approach:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :department AND s.salary > :salary")
List<Staff> findByDeptAndSal(@Param("department") String dept, @Param("salary") double sal);
```

### ❌ Mistake 3: Null Values Handle Nahi Karna
```java
// Wrong - Null parameters ke liye provision nahi
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND s.name = :name")
List<Staff> findByDeptAndName(@Param("dept") String dept, @Param("name") String name);
// Agar name null pass kiya toh kya hoga? 🤔
```

**✅ Correct Approach:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :dept " +
       "AND (:name IS NULL OR s.name = :name)")
List<Staff> findByDeptAndOptionalName(@Param("dept") String dept, @Param("name") String name);
```

### ❌ Mistake 4: Method Names Too Long/Confusing
```java
// Wrong - Method name bahut lamba aur confusing
public interface StaffRepository extends JpaRepository<Staff, Long> {
    List<Staff> findByDepartmentAndNameOrSalaryGreaterThanAndJoiningDateBetweenOrDesignationContainingIgnoreCase(
        String dept, String name, double salary, Date startDate, Date endDate, String designation);
    // 😵‍💫 Samjh mein nahi aa raha kya kar raha hai!
}
```

**✅ Correct Approach:**
```java
// Better - JPQL with meaningful method name
@Query("SELECT s FROM Staff s WHERE s.department = :dept " +
       "AND (:name IS NULL OR s.name = :name) " +
       "AND (:minSalary IS NULL OR s.salary >= :minSalary) " +
       "AND (:startDate IS NULL OR s.joiningDate >= :startDate) " +
       "AND (:designation IS NULL OR UPPER(s.designation) LIKE UPPER(CONCAT('%', :designation, '%')))")
List<Staff> findStaffWithMultipleFilters(
    @Param("dept") String department,
    @Param("name") String name,
    @Param("minSalary") Double minSalary,
    @Param("startDate") Date startDate,
    @Param("designation") String designation
);
```

### ❌ Mistake 5: Exception Handling Missing
```java
// Wrong - Exception handling nahi hai
@GetMapping("/staff")
public ResponseEntity<List<Staff>> getStaff(
        @RequestParam String dept, 
        @RequestParam String name) {
    List<Staff> staff = staffService.findByDeptAndName(dept, name);
    return ResponseEntity.ok(staff);  // Agar error aaye toh app crash! 💥
}
```

**✅ Correct Approach:**
```java
@GetMapping("/staff")
public ResponseEntity<?> getStaff(
        @RequestParam String dept, 
        @RequestParam(required = false) String name) {
    try {
        List<Staff> staff = staffService.findByDeptAndName(dept, name);
        
        Map<String, Object> response = new HashMap<>();
        if (!staff.isEmpty()) {
            response.put("status", "success");
            response.put("data", staff);
            response.put("count", staff.size());
            return ResponseEntity.ok(response);
        } else {
            response.put("status", "no_data");
            response.put("message", "No staff found with given criteria");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
        }
    } catch (DataAccessException e) {
        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("status", "error");
        errorResponse.put("message", "Database error occurred");
        log.error("Database error: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
}
```

---

## 9. Best Practices 🏆

### 🌟 Practice 1: Meaningful Method Names
```java
// ✅ Good naming convention
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    // Clear what it does
    List<Staff> findActiveEmployeesByDeptAndSalaryRange(String dept, double minSal, double maxSal);
    
    // Use business domain terms
    @Query("SELECT s FROM Staff s WHERE s.status = 'ACTIVE' " +
           "AND s.department = :dept AND s.salary BETWEEN :min AND :max")
    List<Staff> findActiveEmployeesByDeptAndSalaryRange(
        @Param("dept") String department,
        @Param("min") double minSalary, 
        @Param("max") double maxSalary
    );
}
```

### 🌟 Practice 2: Use DTOs for API Responses
```java
// ✅ Create DTOs instead of exposing entities directly
@Data
@Builder
public class StaffResponseDTO {
    private Long id;
    private String name;
    private String department;
    private double salary;
    private String designation;
    private LocalDate joiningDate;
    
    // Sensitive information exclude karo
    // private String socialSecurityNumber; - Ye nahi bhejte API response mein
}

// Service layer mein mapping
@Service
public class StaffServiceImpl implements StaffService {
    
    public List<StaffResponseDTO> getStaffByFilters(String dept, String name, double minSalary) {
        List<Staff> staffList = staffRepo.findByDepartmentAndNameOrSalaryGreaterThan(dept, name, minSalary);
        
        return staffList.stream()
                       .map(this::convertToDTO)
                       .collect(Collectors.toList());
    }
    
    private StaffResponseDTO convertToDTO(Staff staff) {
        return StaffResponseDTO.builder()
                              .id(staff.getId())
                              .name(staff.getName())
                              .department(staff.getDepartment())
                              .salary(staff.getSalary())
                              .designation(staff.getDesignation())
                              .joiningDate(staff.getJoiningDate())
                              .build();
    }
}
```

### 🌟 Practice 3: Pagination and Sorting
```java
// ✅ Always use pagination for large datasets
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    @Query("SELECT s FROM Staff s WHERE s.department = :dept " +
           "AND (:name IS NULL OR s.name LIKE %:name%) " +
           "AND (:minSalary IS NULL OR s.salary >= :minSalary)")
    Page<Staff> findStaffWithFilters(
        @Param("dept") String department,
        @Param("name") String name,
        @Param("minSalary") Double minSalary,
        Pageable pageable
    );
}

// Controller mein use
@GetMapping("/staff")
public ResponseEntity<?> getStaff(
        @RequestParam String department,
        @RequestParam(required = false) String name,
        @RequestParam(required = false) Double minSalary,
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "10") int size,
        @RequestParam(defaultValue = "name") String sortBy,
        @RequestParam(defaultValue = "asc") String sortDirection) {
    
    Sort sort = sortDirection.equalsIgnoreCase("desc") 
        ? Sort.by(sortBy).descending() 
        : Sort.by(sortBy).ascending();
    
    Pageable pageable = PageRequest.of(page, size, sort);
    Page<Staff> staffPage = staffService.findStaffWithFilters(department, name, minSalary, pageable);
    
    Map<String, Object> response = new HashMap<>();
    response.put("staff", staffPage.getContent());
    response.put("totalElements", staffPage.getTotalElements());
    response.put("totalPages", staffPage.getTotalPages());
    response.put("currentPage", page);
    response.put("hasNext", staffPage.hasNext());
    response.put("hasPrevious", staffPage.hasPrevious());
    
    return ResponseEntity.ok(response);
}
```

### 🌟 Practice 4: Query Performance Optimization
```java
// ✅ Use indexes for frequently queried columns
@Entity
@Table(name = "staff", indexes = {
    @Index(name = "idx_department_salary", columnList = "department, salary"),
    @Index(name = "idx_name", columnList = "name"),
    @Index(name = "idx_joining_date", columnList = "joining_date")
})
public class Staff {
    // ... entity fields
}

// ✅ Use @Query with fetch joins to avoid N+1 problem
@Query("SELECT s FROM Staff s LEFT JOIN FETCH s.department d " +
       "WHERE s.status = 'ACTIVE' AND d.name = :deptName")
List<Staff> findActiveStaffWithDepartment(@Param("deptName") String departmentName);

// ✅ Use native queries for complex aggregations
@Query(value = "SELECT department, COUNT(*) as staff_count, AVG(salary) as avg_salary " +
              "FROM staff WHERE salary > :minSalary " +
              "GROUP BY department HAVING COUNT(*) > :minCount", 
       nativeQuery = true)
List<Object[]> getDepartmentStatistics(@Param("minSalary") double minSalary, 
                                      @Param("minCount") int minCount);
```

### 🌟 Practice 5: Comprehensive Testing
```java
// ✅ Write comprehensive tests
@DataJpaTest
class StaffRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired 
    private StaffRepository staffRepository;
    
    @BeforeEach
    void setUp() {
        // Test data setup
        Staff alice = new Staff("Alice", "IT", 80000);
        Staff bob = new Staff("Bob", "IT", 60000);
        Staff charlie = new Staff("Charlie", "Finance", 75000);
        
        entityManager.persist(alice);
        entityManager.persist(bob);
        entityManager.persist(charlie);
        entityManager.flush();
    }
    
    @Test
    @DisplayName("Should find IT department staff with Alice name OR salary > 70000")
    void testFindByDepartmentAndNameOrSalaryGreaterThan() {
        // Given
        String department = "IT";
        String name = "Alice";
        double salary = 70000;
        
        // When
        List<Staff> result = staffRepository.findByDepartmentAndNameOrSalaryGreaterThanJPQL(
            department, name, salary
        );
        
        // Then
        assertThat(result).hasSize(1);
        assertThat(result.get(0).getName()).isEqualTo("Alice");
        assertThat(result.get(0).getDepartment()).isEqualTo("IT");
    }
    
    @Test
    @DisplayName("Should handle null parameters gracefully")
    void testFindWithNullParameters() {
        // Given
        String department = "IT";
        String name = null;
        double salary = 70000;
        
        // When & Then - Should not throw exception
        assertDoesNotThrow(() -> {
            List<Staff> result = staffRepository.findByDepartmentAndNameOrSalaryGreaterThanJPQL(
                department, name, salary
            );
            assertThat(result).isNotNull();
        });
    }
}
```

---

## 10. Summary/Quick Recap 📝

### 🎯 Key Takeaways

| Point | Description | Memory Trick |
|-------|-------------|--------------|
| **3 Methods** | Query Methods, JPQL, Native SQL | **Q**uery **J**PQL **N**ative = **QJN** |
| **Precedence** | AND/OR operator precedence important | **P**arentheses **A**lways **R**equired = **PAR** |
| **Parameters** | Named parameters better than positional | **N**amed **P**arameters **B**etter = **NPB** |
| **Performance** | Use indexes and pagination | **P**erformance **I**ndexes **P**agination = **PIP** |

### 🧠 Memory Tricks Yaad Rakhne Ke Liye

1. **"JAR" Method:** **J**PQL **A**nd **R**ules
   - **J**PQL for business logic
   - **A**lways use parentheses for OR conditions
   - **R**emember to handle null parameters

2. **"SPIN" for Query Writing:**
   - **S**elect what you need
   - **P**arameters properly mapped
   - **I**ndexes on filtered columns
   - **N**ull handling included

3. **"PACE" for Best Practices:**
   - **P**agination for large datasets
   - **A**PI responses with DTOs
   - **C**aching for frequent queries
   - **E**xception handling everywhere

### ⚡ Quick Decision Tree

```
Need AND/OR Query?
├── Simple logic? 
│   ├── Yes → Use Query Methods ✅
│   └── No → Go to complex
├── Complex logic?
│   ├── Database independent? 
│   │   ├── Yes → Use JPQL ✅
│   │   └── No → Use Native SQL ✅
└── Performance critical?
    └── Yes → Use Native SQL with indexes ✅
```

### 🎪 Real Interview Scenario

**Interviewer:** "Ek query likhiye jo IT department ke employees ko find kare jo ya toh 'Senior' designation ke hain ya 80,000+ salary wale hain, aur active status mein hain."

**Your Answer:**
```java
@Query("SELECT s FROM Staff s WHERE s.status = 'ACTIVE' " +
       "AND s.department = 'IT' " + 
       "AND (s.designation = 'Senior' OR s.salary >= 80000)")
List<Staff> findActiveITSeniorOrHighSalary();
```

**Follow-up:** "Performance optimize kaise karenge?"

**Your Answer:**
```java
// 1. Add indexes
@Table(indexes = {
    @Index(name = "idx_dept_status", columnList = "department, status"),
    @Index(name = "idx_salary", columnList = "salary")
})

// 2. Use pagination
Page<Staff> findActiveITSeniorOrHighSalary(Pageable pageable);

// 3. Add caching if needed
@Cacheable("staff-cache")
List<Staff> findActiveITSeniorOrHighSalary();
```

### 🚀 Final Tips for Success

1. **Practice Daily:** Roz 15-20 minutes Spring Data JPA queries practice karo
2. **Read Documentation:** Spring Data JPA official docs padho
3. **Join Communities:** StackOverflow, Reddit pe participate karo
4. **Build Projects:** Real-world scenarios mein implement karo
5. **Debug Queries:** SQL console mein generated queries check karo

### 🎉 Congratulations! 

Ab tumhe Spring Data JPA AND/OR combinations ki complete knowledge hai! Go build amazing applications, yaar! 💪

**Remember:** "Code karo, fail karo, learn karo, repeat karo!" 🔁

---

**Happy Coding! 🎊**

*Made with ❤️ for Java developers by Java developers*
