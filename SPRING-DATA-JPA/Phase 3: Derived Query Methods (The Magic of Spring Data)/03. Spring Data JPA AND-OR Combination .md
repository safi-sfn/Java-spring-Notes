# Spring Data JPA AND/OR Combination Complete Guide 🚀

## Table of Contents 📚
1. [Introduction with Confusion Clearing](#introduction)
2. [Key Terms/Concepts](#key-terms)
3. [Detailed Examples](#detailed-examples)
4. [Rules/Guidelines](#rules-guidelines)
5. [Real-world Applications](#real-world-applications)
6. [Comparison Tables](#comparison-tables)
7. [Interview Questions](#interview-questions)
8. [Common Mistakes](#common-mistakes)
9. [Best Practices](#best-practices)
10. [Summary/Quick Recap](#summary)

---

## 1. Introduction with Confusion Clearing 🤔

### Simple Explanation First 
Bhai, simple words mein samjho - jab tumhe database se data filter karna ho multiple conditions ke saath, tab AND/OR operators use karte hain. Jaise real life mein bolte hain "Mujhe IT department ka staff chahiye JO Alice hai YA jiska salary 70,000 se zyada hai" 💰

### Real-life Analogy 🎯
**Imagine karo tum ek HR manager ho:**
- Tum chahte ho: IT department ke employees (AND condition) 
- Plus: Jo ya toh Alice hain ya 70k+ salary wale hain (OR condition)
- Matlab: `IT Department AND (Alice OR Salary > 70k)`

### Technical Definition 📖
Spring Data JPA mein AND/OR combination ka matlab hai multiple filtering conditions ko combine karna ek hi query mein. Ye teen tarike se kar sakte hain: Custom Query Methods, JPQL queries, aur Native SQL queries.

---

## 2. Key Terms/Concepts 🎯

### 🔑 Important Terminology

| Term | Explanation |
|------|-------------|
| **Repository Interface** | Database operations ke liye interface |
| **JPA (Java Persistence API)** | Java objects ko database tables se map karta hai |
| **JPQL (Java Persistence Query Language)** | Object-oriented query language |
| **Native SQL** | Direct database SQL queries |
| **Query Methods** | Method names se automatic queries |

### 🎨 Visual Representation
```
Database Query Flow:
┌─────────────────┐    ┌──────────────┐    ┌─────────────┐
│ Controller      │────│ Service      │────│ Repository  │
│ (API Endpoint)  │    │ (Business    │    │ (Database   │
│                 │    │  Logic)      │    │  Access)    │
└─────────────────┘    └──────────────┘    └─────────────┘
                                                   │
                                           ┌───────▼──────┐
                                           │   Database   │
                                           │   (H2/MySQL) │
                                           └──────────────┘
```

---

## 3. Detailed Examples 💻

### 🏗️ Complete Working Project Structure

#### A. Maven Dependencies (pom.xml)
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
         https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.0</version>
        <relativePath/>
    </parent>
    
    <groupId>com.springjava</groupId>
    <artifactId>demo</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>demo</name>
    <description>Demo project for Spring Boot</description>
    
    <properties>
        <java.version>17</java.version>
    </properties>
    
    <dependencies>
        <!-- Spring Boot Data JPA - Database operations ke liye -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        
        <!-- Spring Boot Web - REST APIs ke liye -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        
        <!-- H2 Database - Testing ke liye lightweight database -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>
        
        <!-- Lombok - Boilerplate code reduce karne ke liye -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>
    </dependencies>
</project>
```

#### B. Database Configuration (application.properties)
```properties
# H2 Database Configuration - Yaad rakho, ye testing ke liye hai
spring.datasource.url=jdbc:h2:mem:test
spring.datasource.username=sa
spring.datasource.password=

# JPA Settings - SQL queries console mein dikhane ke liye
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.H2Dialect
spring.jpa.hibernate.ddl-auto=update

# H2 Console enable karna - browser mein database dekhne ke liye
spring.h2.console.enabled=true
```

#### C. JPA Entity Class 📝
```java
package com.springjava.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.Data;

@Data  // Lombok - automatic getter/setter/toString
@Entity  // JPA annotation - ye class database table banayegi
public class Staff {
    
    @Id  // Primary key
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // Auto-increment
    private Long id;
    
    private String name;        // Employee ka naam
    private String department;  // Department name (IT, Finance, etc.)
    private double salary;      // Monthly salary
    
    // Lombok @Data annotation se ye sab automatic generate hoga:
    // - Default constructor
    // - Parameterized constructor
    // - Getters and Setters
    // - toString(), equals(), hashCode()
}
```

**Expected Database Table Structure:**
```sql
CREATE TABLE staff (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255),
    department VARCHAR(255),
    salary DOUBLE
);
```

#### D. Repository Interface - Teen Tarike 🎯

```java
package com.springjava.repository;

import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import com.springjava.entity.Staff;

public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    // 🔥 Method 1: Query Method Names (Spring Magic!)
    // Ye method name se automatic query banata hai
    List<Staff> findByDepartmentAndNameOrSalaryGreaterThan(
        String department, String name, double salary
    );
    // Generated SQL: WHERE department = ? AND name = ? OR salary > ?
    // ⚠️ Dhyan do: Default precedence hai, parentheses nahi!
    
    // 🔥 Method 2: JPQL Query (Object-Oriented SQL)
    @Query("SELECT s FROM Staff s WHERE s.department = :department " +
           "AND (s.name = :name OR s.salary > :salary)")
    List<Staff> findByDepartmentAndNameOrSalaryGreaterThanJPQL(
        String department, String name, double salary
    );
    // ✅ Proper parentheses use kiye hain for correct logic
    
    // 🔥 Method 3: Native SQL Query (Direct Database SQL)
    @Query(value = "SELECT * FROM staff WHERE department = :department " +
                  "AND (name = :name OR salary > :salary)", 
           nativeQuery = true)
    List<Staff> findByDepartmentAndNameOrSalaryGreaterThanNative(
        String department, String name, double salary
    );
    // ✅ Pure SQL - database specific features use kar sakte hain
}
```

#### E. Service Layer 🔧
```java
package com.springjava.service;

import java.util.List;
import com.springjava.entity.Staff;

// Service Interface - Business logic ke liye contract
public interface StaffService {
    void saveAll(List<Staff> staffList);
    
    List<Staff> getByDepartmentAndNameOrSalaryGreaterThan(
        String department, String name, double salary
    );
    
    List<Staff> getByDepartmentAndNameOrSalaryGreaterThanJPQL(
        String department, String name, double salary
    );
    
    List<Staff> getByDepartmentAndNameOrSalaryGreaterThanNative(
        String department, String name, double salary
    );
}
```

```java
package com.springjava.service;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.springjava.entity.Staff;
import com.springjava.repository.StaffRepository;

@Service  // Spring ka service component
public class StaffServiceImpl implements StaffService {
    
    @Autowired  // Dependency Injection - Repository inject kar rahe hain
    private StaffRepository staffRepo;
    
    @Override
    public void saveAll(List<Staff> staffList) {
        staffRepo.saveAll(staffList);  // Batch insert operation
    }
    
    @Override
    public List<Staff> getByDepartmentAndNameOrSalaryGreaterThan(
            String department, String name, double salary) {
        return staffRepo.findByDepartmentAndNameOrSalaryGreaterThan(
            department, name, salary
        );
    }
    
    @Override
    public List<Staff> getByDepartmentAndNameOrSalaryGreaterThanJPQL(
            String department, String name, double salary) {
        return staffRepo.findByDepartmentAndNameOrSalaryGreaterThanJPQL(
            department, name, salary
        );
    }
    
    @Override
    public List<Staff> getByDepartmentAndNameOrSalaryGreaterThanNative(
            String department, String name, double salary) {
        return staffRepo.findByDepartmentAndNameOrSalaryGreaterThanNative(
            department, name, salary
        );
    }
}
```

#### F. REST Controller 🌐
```java
package com.springjava.controller;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import com.springjava.entity.Staff;
import com.springjava.service.StaffService;

@RestController  // REST API endpoints ke liye
@RequestMapping("/api/staff")  // Base URL path
public class StaffController {
    
    @Autowired
    private StaffService staffService;
    
    // 📝 POST API - Multiple staff members save karne ke liye
    @PostMapping("/save-all")
    public ResponseEntity<?> save(@RequestBody List<Staff> staffList) {
        Map<String, Object> response = new LinkedHashMap<>();
        
        staffService.saveAll(staffList);
        response.put("status", 1);
        response.put("message", "Records saved successfully! 🎉");
        
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }
    
    // 🔍 GET API - Query Method approach
    @GetMapping("/and-or-with-query-method")
    public ResponseEntity<?> getByDepartmentAndNameOrSalaryGreaterThan(
            @RequestParam String department,
            @RequestParam String name,
            @RequestParam double salary) {
        
        Map<String, Object> response = new LinkedHashMap<>();
        List<Staff> staffList = staffService.getByDepartmentAndNameOrSalaryGreaterThan(
            department, name, salary
        );
        
        if (!staffList.isEmpty()) {
            response.put("status", 1);
            response.put("data", staffList);
            response.put("method", "Query Method Approach");
            return new ResponseEntity<>(response, HttpStatus.OK);
        } else {
            response.put("status", 0);
            response.put("message", "No data found! 😔");
            return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
        }
    }
    
    // 🔍 GET API - JPQL approach  
    @GetMapping("/and-or-with-jpql")
    public ResponseEntity<?> getByDepartmentAndNameOrSalaryGreaterThanJPQL(
            @RequestParam String department,
            @RequestParam String name,
            @RequestParam double salary) {
        
        Map<String, Object> response = new LinkedHashMap<>();
        List<Staff> staffList = staffService.getByDepartmentAndNameOrSalaryGreaterThanJPQL(
            department, name, salary
        );
        
        if (!staffList.isEmpty()) {
            response.put("status", 1);
            response.put("data", staffList);
            response.put("method", "JPQL Approach");
            return new ResponseEntity<>(response, HttpStatus.OK);
        } else {
            response.put("status", 0);
            response.put("message", "No data found! 😔");
            return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
        }
    }
    
    // 🔍 GET API - Native SQL approach
    @GetMapping("/and-or-with-native")
    public ResponseEntity<?> getByDepartmentAndNameOrSalaryGreaterThanNative(
            @RequestParam String department,
            @RequestParam String name,
            @RequestParam double salary) {
        
        Map<String, Object> response = new LinkedHashMap<>();
        List<Staff> staffList = staffService.getByDepartmentAndNameOrSalaryGreaterThanNative(
            department, name, salary
        );
        
        if (!staffList.isEmpty()) {
            response.put("status", 1);
            response.put("data", staffList);
            response.put("method", "Native SQL Approach");
            return new ResponseEntity<>(response, HttpStatus.OK);
        } else {
            response.put("status", 0);
            response.put("message", "No data found! 😔");
            return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
        }
    }
}
```

### 🧪 Testing Data
```json
[
    {
        "name": "John",
        "department": "Finance",
        "salary": 65000.00
    },
    {
        "name": "Alice", 
        "department": "IT",
        "salary": 80000.00
    },
    {
        "name": "Robert",
        "department": "IT", 
        "salary": 55000.00
    },
    {
        "name": "Sarah",
        "department": "HR",
        "salary": 75000.00
    }
]
```

### 📊 Expected Outputs

**Test Query:** `department=IT&name=Alice&salary=70000`

**Query Method Output:**
Generated SQL: `WHERE department = ? AND name = ? OR salary > ?`
- Result: Alice (IT + Alice), Sarah (salary > 70000)
- ⚠️ Wrong logic due to operator precedence!

**JPQL/Native Output:**
Generated SQL: `WHERE department = ? AND (name = ? OR salary > ?)`
- Result: Only Alice (IT department AND Alice name)
- ✅ Correct logic with proper parentheses!

---

## 4. Rules/Guidelines 📋

### ✅ DO's and ❌ DON'Ts

#### Rule 1: Operator Precedence Samjho 🎯
✅ **Correct:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND (s.name = :name OR s.salary > :salary)")
```
❌ **Wrong:**
```java
// Query method without understanding precedence
findByDepartmentAndNameOrSalaryGreaterThan() 
// Results in: (dept AND name) OR salary - Wrong logic!
```

#### Rule 2: Parameter Names Consistent Rakho 📝
✅ **Correct:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :department")
List<Staff> findByDept(@Param("department") String dept);
```
❌ **Wrong:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :department")
List<Staff> findByDept(String dept);  // Parameter name mismatch!
```

#### Rule 3: Method Naming Convention Follow Karo 🏷️
✅ **Correct:**
```java
findByDepartmentAndNameOrSalaryGreaterThan(String dept, String name, double salary)
//    ↑          ↑   ↑    ↑        ↑
//  Column    AND  Col  OR     Col+Operator
```
❌ **Wrong:**
```java
findByDeptAndNameOrSalGreater()  // Column names match nahi kar rahe!
```

#### Rule 4: JPQL vs Native SQL Usage 🔧
✅ **Use JPQL when:**
- Database independent code chahiye
- Object-oriented approach prefer karte ho
- Entity properties use karna hai

✅ **Use Native SQL when:**
- Database-specific functions use karne hain
- Complex joins ya performance optimization chahiye
- Raw SQL queries existing hain

#### Rule 5: Exception Handling Zaroori Hai ⚠️
✅ **Correct:**
```java
@Override
public List<Staff> getStaff(String dept, String name, double salary) {
    try {
        return staffRepo.findByDepartmentAndNameOrSalaryGreaterThan(dept, name, salary);
    } catch (Exception e) {
        log.error("Error fetching staff: {}", e.getMessage());
        return Collections.emptyList();
    }
}
```

---

## 5. Real-world Applications 🌍

### 🏦 Banking System Example
```java
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    // Find accounts: Active status AND (High balance OR VIP customer)
    @Query("SELECT a FROM Account a WHERE a.status = 'ACTIVE' " +
           "AND (a.balance > :minBalance OR a.customerType = 'VIP')")
    List<Account> findActiveHighValueOrVipAccounts(
        @Param("minBalance") double minBalance
    );
    
    // Find loan applicants: Good credit score AND (High income OR existing customer)
    List<LoanApplication> findByCreditScoreGreaterThanAndIncomeGreaterThanOrExistingCustomer(
        int creditScore, double income, boolean existingCustomer
    );
}
```

### 🛒 E-commerce System Example  
```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Find products: In stock AND (On sale OR Premium brand)
    @Query("SELECT p FROM Product p WHERE p.stockQuantity > 0 " +
           "AND (p.onSale = true OR p.brand IN :premiumBrands)")
    List<Product> findAvailableDealsOrPremium(
        @Param("premiumBrands") List<String> premiumBrands
    );
    
    // Customer search: Category filter AND (Price range OR Rating)
    List<Product> findByCategoryAndPriceBetweenOrRatingGreaterThan(
        String category, double minPrice, double maxPrice, double rating
    );
}
```

### 🏥 Hospital Management System
```java
public interface PatientRepository extends JpaRepository<Patient, Long> {
    
    // Find patients: Critical condition AND (Emergency contact available OR Family present)
    @Query("SELECT p FROM Patient p WHERE p.condition = 'CRITICAL' " +
           "AND (p.emergencyContact IS NOT NULL OR p.familyPresent = true)")
    List<Patient> findCriticalPatientsWithSupport();
    
    // Doctor availability: Department match AND (Shift time OR On-call status)
    List<Doctor> findByDepartmentAndShiftTimeOrOnCallStatus(
        String department, String shiftTime, boolean onCall
    );
}
```

### 📚 Student Management System
```java
public interface StudentRepository extends JpaRepository<Student, Long> {
    
    // Scholarship eligible: Good grades AND (Financial need OR Merit basis)
    @Query("SELECT s FROM Student s WHERE s.cgpa >= :minCgpa " +
           "AND (s.familyIncome < :maxIncome OR s.meritRank <= :topRank)")
    List<Student> findScholarshipEligible(
        @Param("minCgpa") double minCgpa,
        @Param("maxIncome") double maxIncome, 
        @Param("topRank") int topRank
    );
}
```

---

## 6. Comparison Tables 📊

### Method Comparison Table

| Aspect | Query Methods | JPQL | Native SQL |
|--------|---------------|------|------------|
| **Learning Curve** | 🟢 Easy | 🟡 Medium | 🔴 Hard |
| **Type Safety** | 🟢 Compile-time | 🟡 Runtime | 🔴 Runtime |
| **Database Independence** | 🟢 Yes | 🟢 Yes | 🔴 No |
| **Complex Queries** | 🔴 Limited | 🟡 Good | 🟢 Excellent |
| **Performance** | 🟡 Medium | 🟡 Medium | 🟢 Best |
| **Readability** | 🔴 Poor for complex | 🟢 Good | 🟡 OK |
| **Maintenance** | 🔴 Hard | 🟢 Easy | 🟡 Medium |

### Operator Precedence Table

| Query Type | Logic | Generated SQL | Result |
|------------|-------|---------------|--------|
| **Query Method** | `dept AND name OR salary` | `WHERE dept=? AND name=? OR salary>?` | ❌ Wrong grouping |
| **JPQL** | `dept AND (name OR salary)` | `WHERE dept=? AND (name=? OR salary>?)` | ✅ Correct grouping |
| **Native SQL** | `dept AND (name OR salary)` | `WHERE dept=? AND (name=? OR salary>?)` | ✅ Correct grouping |

### Performance Comparison

| Method | Query Compilation | Execution Time | Memory Usage | Best For |
|--------|------------------|----------------|--------------|----------|
| **Query Methods** | 🟢 Compile-time | 🟡 Medium | 🟢 Low | Simple queries |
| **JPQL** | 🟡 First execution | 🟡 Medium | 🟡 Medium | Business logic |
| **Native SQL** | 🔴 Every time | 🟢 Fast | 🟡 Medium | Performance critical |

---

## 7. Interview Questions 🎤

### Q1: Spring Data JPA mein AND/OR combination ke kitne tarike hain?
**Answer:** Teen main tarike hain bhai:

1. **Query Method Names:** Method name se automatic query generation
2. **JPQL Queries:** Object-oriented query language using @Query
3. **Native SQL Queries:** Direct database SQL with nativeQuery = true

**Code Example:**
```java
// Method 1: Query Method
List<Staff> findByDepartmentAndNameOrSalaryGreaterThan(String dept, String name, double salary);

// Method 2: JPQL  
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND (s.name = :name OR s.salary > :salary)")
List<Staff> findWithJPQL(@Param("dept") String dept, @Param("name") String name, @Param("salary") double salary);

// Method 3: Native SQL
@Query(value = "SELECT * FROM staff WHERE department = ? AND (name = ? OR salary > ?)", nativeQuery = true)
List<Staff> findWithNativeSQL(String dept, String name, double salary);
```

### Q2: Query Method Names mein operator precedence ka kya issue hai?
**Answer:** Bhai, ye bahut important question hai! Query method names mein conditions left-to-right evaluate hoti hain without proper parentheses, jisse wrong logic mil sakti hai.

**Tricky Example:**
```java
// Method name: findByDepartmentAndNameOrSalaryGreaterThan
// Expected: department = 'IT' AND (name = 'Alice' OR salary > 70000)  
// Actual SQL: WHERE department = ? AND name = ? OR salary > ?
// Actual Logic: (department = 'IT' AND name = 'Alice') OR salary > 70000

// Test case:
Staff staff1 = new Staff("Alice", "IT", 50000);      // ✅ Matches: IT AND Alice  
Staff staff2 = new Staff("Bob", "Finance", 80000);   // ✅ Matches: Salary > 70000 (Wrong!)
Staff staff3 = new Staff("John", "IT", 60000);       // ❌ No match (Correct)
```

**Solution:**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND (s.name = :name OR s.salary > :salary)")
List<Staff> findCorrectly(@Param("dept") String dept, @Param("name") String name, @Param("salary") double salary);
```

### Q3: JPQL vs Native SQL kab use karna chahiye?
**Answer:** Ye scenario-based decision hai yaar:

**Use JPQL when:**
- Database portability chahiye (MySQL se PostgreSQL easily switch)
- Entity relationships use karne hain (joins with objects)
- Type safety important hai

**Use Native SQL when:**
- Database-specific functions chahiye (MySQL's JSON functions, PostgreSQL arrays)
- Performance critical queries hain
- Complex stored procedures call karne hain
- Raw SQL already exists aur optimize hai

**Example:**
```java
// JPQL - Database independent
@Query("SELECT s FROM Staff s JOIN s.department d WHERE d.name = :deptName")
List<Staff> findByDepartmentJPQL(@Param("deptName") String deptName);

// Native SQL - Database specific (MySQL example)
@Query(value = "SELECT * FROM staff WHERE JSON_EXTRACT(metadata, '$.skills') LIKE %:skill%", 
       nativeQuery = true)
List<Staff> findBySkillNative(@Param("skill") String skill);
```

### Q4: @Query annotation mein parameters kaise pass karte hain?
**Answer:** Do tarike hain bhai:

**1. Positional Parameters (? ka use):**
```java
@Query("SELECT s FROM Staff s WHERE s.department = ?1 AND s.salary > ?2")
List<Staff> findByDeptAndSalary(String department, double salary);
```

**2. Named Parameters (:name ka use) - Recommended!**
```java
@Query("SELECT s FROM Staff s WHERE s.department = :dept AND s.salary > :sal")
List<Staff> findByDeptAndSalary(@Param("dept") String department, @Param("sal") double salary);
```

**Best Practice Example:**
```java
@Query("SELECT s FROM Staff s WHERE " +
       "(:department IS NULL OR s.department = :department) AND " +
       "(:minSalary IS NULL OR s.salary >= :minSalary) AND " +
       "(:maxSalary IS NULL OR s.salary <= :maxSalary)")
List<Staff> findWithOptionalFilters(
    @Param("department") String department,
    @Param("minSalary") Double minSalary, 
    @Param("maxSalary") Double maxSalary
);
```

### Q5: Complex AND/OR combinations kaise handle karte hain?
**Answer:** Complex queries ke liye proper grouping zaroori hai:

**Scenario:** Find employees who are:
- (Senior level OR Team lead) AND (IT department OR Finance department) AND (High salary OR Bonus eligible)

```java
@Query("SELECT s FROM Staff s WHERE " +
       "(s.level = 'SENIOR' OR s.position = 'TEAM_LEAD') AND " +
       "(s.department IN ('IT', 'FINANCE')) AND " +
       "(s.salary > :highSalary OR s.bonusEligible = true)")
List<Staff> findComplexCriteria(@Param("highSalary") double highSalary);

// Alternative: Using Criteria API for dynamic queries
public List<Staff> findComplexCriteriaApi(String level, List<String> departments, double salary) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Staff> cq = cb.createQuery(Staff.class);
    Root<Staff> staff = cq.from(Staff.class);
    
    Predicate seniorOrLead = cb.or(
        cb.equal(staff.get("level"), "SENIOR"),
        cb.equal(staff.get("position"), "TEAM_LEAD")
    );
    
    Predicate deptCondition = staff.get("department").in(departments);
    
    Predicate salaryOrBonus = cb.or(
        cb.gt(staff.get("salary"), salary),
        cb.equal(staff.get("bonusEligible"), true)
    );
    
    cq.where(cb.and(seniorOrLead, deptCondition, salaryOrBonus));
    return entityManager.createQuery(cq).getResultList();
}
```

---

## 8. Common Mistakes 🚫

### ❌ Mistake 1: Operator Precedence Ignore Karna
```java
// Wrong approach - Precedence samjhe bina
public interface StaffRepository extends JpaRepository<Staff, Long> {
    List
