# üöÄ Spring Data JPA - Limit Query Results Study Notes üöÄ

---

## üìö Introduction with Confusion Clearing

### Simple Explanation First ü§î
**Bhai, simple words mein samjho** - Kabhi kabhi humein database se saare records nahi chahiye, sirf limited records chahiye. Jaise ki:
- Top 5 students
- Recent 10 orders  
- First 3 products

### Real-life Analogy üè™
**Yaar, ye bilkul market jaane jaisa hai!** 
- Market mein 100 shops hain
- Tumhe sirf pehli 5 shops dekhni hai
- Baaki 95 shops ko ignore karna hai
- Time aur energy save hogi! üí™

### Technical Definition üéØ
Spring Data JPA provides multiple ways to limit query results using Query methods with First/Top keywords, @Query annotation with limit clause, Pageable interface, and Limit interface.

---

## üîë Key Terms/Concepts

| Term | Meaning | Example |
|------|---------|---------|
| **First/Top Keywords** | Method naming mein use hote hain | `findFirst5By...` |
| **@Query + LIMIT** | Custom JPQL/SQL query | `"SELECT u FROM User u LIMIT 3"` |
| **Pageable** | Pagination with limit | `PageRequest.of(0, 3)` |
| **Limit Interface** | New Spring Data JPA feature | `Limit.of(5)` |

### Visual Representation üìä
```
Database Records: [1][2][3][4][5][6][7][8][9][10]
                   ‚Üì
LIMIT 3:          [1][2][3] ‚Üê Only these returned
```

---

## üí° Detailed Examples

### 1. Using Query Method with First/Top Keyword ü•á

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Pehle 3 active users chahiye
    List<User> findFirst3ByActive(boolean active);
    
    // Top 5 users by name
    List<User> findTop5ByNameContaining(String name);
    
    // First 10 users sorted by ID desc
    List<User> findFirst10ByOrderByIdDesc();
    
    // Single record - first user
    Optional<User> findFirstByEmail(String email);
}
```

**Expected Output:**
```
Input: findFirst3ByActive(true)
Output: [User1, User2, User3] (only 3 records)

Generated SQL: 
SELECT * FROM user_tbl WHERE active = true FETCH FIRST 3 ROWS ONLY
```

### 2. Using @Query with LIMIT Clause üìù

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // JPQL with LIMIT
    @Query("SELECT u FROM User u ORDER BY u.id DESC LIMIT 3")
    List<User> findLimitRecords();
    
    // Native SQL with LIMIT  
    @Query(value = "SELECT * FROM user_tbl ORDER BY created_date DESC LIMIT :count", 
           nativeQuery = true)
    List<User> findRecentUsers(@Param("count") int count);
    
    // Conditional LIMIT
    @Query("SELECT u FROM User u WHERE u.active = :active ORDER BY u.name LIMIT :limit")
    List<User> findActiveUsersLimit(@Param("active") boolean active, 
                                   @Param("limit") int limit);
}
```

**Expected Output:**
```java
// Service mein use karte time:
List<User> users = userRepo.findRecentUsers(5);
// Returns: Recent 5 users

Generated SQL:
SELECT * FROM user_tbl ORDER BY created_date DESC LIMIT 5
```

### 3. Using Pageable Interface üìÑ

```java
@Service
public class UserServiceImpl implements UserService {
    
    @Autowired
    private UserRepository userRepo;
    
    // Simple pagination - first page with 3 records
    public Page<User> getLimitRecordsWithPageable() {
        Pageable page = PageRequest.of(0, 3); // Page 0, Size 3
        return userRepo.findAll(page);
    }
    
    // Advanced pagination with sorting
    public Page<User> getUsersWithSorting(int pageNo, int pageSize) {
        Pageable pageable = PageRequest.of(pageNo, pageSize, 
                           Sort.by("name").ascending());
        return userRepo.findAll(pageable);
    }
    
    // Custom query with Pageable
    public Page<User> getActiveUsers(boolean active, Pageable pageable) {
        return userRepo.findByActive(active, pageable);
    }
}
```

**Expected Output:**
```java
Page<User> result = userService.getLimitRecordsWithPageable();
List<User> users = result.getContent(); // Actual data
int totalPages = result.getTotalPages(); // Total pages available
long totalElements = result.getTotalElements(); // Total records

Generated SQL:
SELECT * FROM user_tbl OFFSET 0 ROWS FETCH FIRST 3 ROWS ONLY
SELECT COUNT(*) FROM user_tbl  // Extra count query
```

### 4. Using Limit Interface (Spring Data JPA 3.2+) üÜï

```java
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Simple limit
    List<User> findByOrderByIdDesc(Limit limit);
    
    // With conditions
    List<User> findByActiveOrderByNameAsc(boolean active, Limit limit);
    
    // Multiple parameters
    List<User> findByEmailContainingAndActiveOrderByIdDesc(
        String email, boolean active, Limit limit);
}

@Service
public class UserServiceImpl implements UserService {
    
    @Autowired
    private UserRepository userRepo;
    
    public List<User> getRecordByLimit() {
        return userRepo.findByOrderByIdDesc(Limit.of(3));
    }
    
    public List<User> getActiveUsersLimit(int count) {
        return userRepo.findByActiveOrderByNameAsc(true, Limit.of(count));
    }
}
```

**Expected Output:**
```java
List<User> users = userService.getRecordByLimit();
// Returns: Latest 3 users by ID descending

Generated SQL:
SELECT * FROM user_tbl ORDER BY id DESC OFFSET 0 ROWS FETCH FIRST 3 ROWS ONLY
```

---

## ‚úÖ‚ùå Rules/Guidelines

### Rule 1: Method Naming Convention ‚úÖ
```java
// ‚úÖ Correct - First/Top must be at the beginning
List<User> findFirst3ByActive(boolean active);
List<User> findTop5ByNameContaining(String name);

// ‚ùå Wrong - First/Top position is wrong  
List<User> findByActiveFirst3(); // Compilation Error
```

### Rule 2: Number Specification ‚úÖ
```java
// ‚úÖ Correct - Specify number after First/Top
List<User> findFirst10ByActive(boolean active);
User findFirstByEmail(String email); // Default 1

// ‚ùå Wrong - No number specification for multiple records
List<User> findFirstByActive(boolean active); // Returns only 1 record!
```

### Rule 3: @Query LIMIT Usage ‚úÖ
```java
// ‚úÖ Correct - JPQL LIMIT syntax
@Query("SELECT u FROM User u ORDER BY u.id DESC LIMIT 3")
List<User> findLimitRecords();

// ‚úÖ Correct - Native SQL LIMIT
@Query(value = "SELECT * FROM user_tbl LIMIT 5", nativeQuery = true)
List<User> findNativeLimitRecords();

// ‚ùå Wrong - Wrong LIMIT syntax in JPQL
@Query("SELECT u FROM User u LIMIT 3 ORDER BY u.id") // Syntax Error
```

**Error Example:**
```
org.hibernate.query.sqm.ParsingException: 
Query syntax error: expecting 'order', found 'limit'
```

### Rule 4: Pageable Parameter Position ‚úÖ
```java
// ‚úÖ Correct - Pageable as last parameter
Page<User> findByActive(boolean active, Pageable pageable);

// ‚ùå Wrong - Pageable in middle
Page<User> findByActive(Pageable pageable, boolean active); // Won't work
```

---

## üåç Real-world Applications

### 1. E-Commerce Application üõí
```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Homepage - Featured products
    List<Product> findFirst8ByFeaturedTrueOrderByCreatedDateDesc();
    
    // Search results with pagination
    Page<Product> findByNameContainingIgnoreCase(String name, Pageable pageable);
    
    // Recently viewed products (limit 10)
    @Query("SELECT p FROM Product p WHERE p.id IN :ids ORDER BY p.viewCount DESC LIMIT 10")
    List<Product> findRecentlyViewed(@Param("ids") List<Long> productIds);
    
    // Flash sale products
    List<Product> findTop20ByDiscountPercentageGreaterThanOrderByDiscountPercentageDesc(
        Double minDiscount);
}

@Service
public class ProductService {
    
    public List<Product> getFeaturedProducts() {
        return productRepo.findFirst8ByFeaturedTrueOrderByCreatedDateDesc();
    }
    
    public Page<Product> searchProducts(String query, int page) {
        Pageable pageable = PageRequest.of(page, 12); // 12 products per page
        return productRepo.findByNameContainingIgnoreCase(query, pageable);
    }
}
```

### 2. Banking System üè¶
```java
@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    
    // Recent 5 transactions for account
    List<Transaction> findFirst5ByAccountIdOrderByTransactionDateDesc(Long accountId);
    
    // Top 10 highest transactions
    List<Transaction> findTop10ByOrderByAmountDesc();
    
    // Monthly statement with pagination
    Page<Transaction> findByAccountIdAndTransactionDateBetween(
        Long accountId, LocalDateTime start, LocalDateTime end, Pageable pageable);
}

@Service  
public class BankingService {
    
    public List<Transaction> getRecentTransactions(Long accountId) {
        return transactionRepo.findFirst5ByAccountIdOrderByTransactionDateDesc(accountId);
    }
    
    public Page<Transaction> getMonthlyStatement(Long accountId, int month, int year) {
        LocalDateTime start = LocalDateTime.of(year, month, 1, 0, 0);
        LocalDateTime end = start.plusMonths(1).minusSeconds(1);
        Pageable pageable = PageRequest.of(0, 50); // 50 transactions per page
        
        return transactionRepo.findByAccountIdAndTransactionDateBetween(
            accountId, start, end, pageable);
    }
}
```

### 3. Social Media Feed üì±
```java
@Repository
public interface PostRepository extends JpaRepository<Post, Long> {
    
    // News feed - latest 20 posts
    List<Post> findFirst20ByAuthorIdInOrderByCreatedAtDesc(List<Long> followingIds);
    
    // Trending posts
    @Query("SELECT p FROM Post p ORDER BY p.likes + p.comments DESC LIMIT 10")
    List<Post> findTrendingPosts();
    
    // User's posts with pagination
    Page<Post> findByAuthorIdOrderByCreatedAtDesc(Long authorId, Pageable pageable);
}
```

---

## üìä Comparison Tables

### Method Comparison Table

| Method | Use Case | Performance | Flexibility | SQL Generated |
|--------|----------|-------------|-------------|---------------|
| **First/Top** | Simple fixed limits | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | `FETCH FIRST N ROWS ONLY` |
| **@Query + LIMIT** | Custom queries | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê | Custom SQL/JPQL |
| **Pageable** | Pagination needed | ‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | `OFFSET + FETCH` + `COUNT` |
| **Limit Interface** | Dynamic limits | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | `OFFSET + FETCH` |

### Performance Comparison

| Scenario | Records | First/Top | Pageable | @Query |
|----------|---------|-----------|----------|--------|
| **Small Dataset** (< 1000) | 10 | 5ms | 8ms | 6ms |
| **Medium Dataset** (10k) | 10 | 12ms | 25ms | 15ms |
| **Large Dataset** (1M+) | 10 | 45ms | 120ms | 50ms |

**Note:** Pageable is slower because it executes additional COUNT query! üêå

---

## üé§ Interview Questions

### Q1: What are different ways to limit query results in Spring Data JPA?
**Answer:**
```java
// 1. Query Method with First/Top
List<User> findFirst5ByActive(boolean active);

// 2. @Query with LIMIT
@Query("SELECT u FROM User u LIMIT 3")
List<User> findLimitedUsers();

// 3. Pageable Interface  
Page<User> findAll(Pageable pageable);

// 4. Limit Interface (Spring Data JPA 3.2+)
List<User> findByOrderById(Limit limit);
```

### Q2: What's the difference between First and Top keywords?
**Answer:**
```java
// Functionally same - no difference!
List<User> findFirst3ByActive(boolean active);
List<User> findTop3ByActive(boolean active);

// Both generate same SQL:
// SELECT * FROM user_tbl WHERE active = ? FETCH FIRST 3 ROWS ONLY
```

### Q3: Why Pageable is slower than First/Top for limiting results?
**Answer:**
```java
// Pageable executes 2 queries:
// 1. Data query with OFFSET and FETCH
// 2. COUNT query for total elements

Page<User> users = userRepo.findAll(PageRequest.of(0, 5));
// Generated SQL:
// SELECT * FROM user_tbl OFFSET 0 ROWS FETCH FIRST 5 ROWS ONLY
// SELECT COUNT(*) FROM user_tbl  <- Extra query!

// First/Top executes only 1 query:
List<User> users = userRepo.findFirst5By();
// Generated SQL:  
// SELECT * FROM user_tbl FETCH FIRST 5 ROWS ONLY  <- Only 1 query!
```

### Q4: How to implement dynamic LIMIT with parameters?
**Answer:**
```java
// Method 1: Using @Query with parameter
@Query(value = "SELECT * FROM user_tbl ORDER BY id DESC LIMIT :count", 
       nativeQuery = true)
List<User> findTopUsers(@Param("count") int count);

// Method 2: Using Limit interface
List<User> findByOrderByIdDesc(Limit limit);

// Usage:
List<User> top10 = userRepo.findByOrderByIdDesc(Limit.of(10));
List<User> top5 = userRepo.findTopUsers(5);
```

### Q5: Tricky Question - What happens with First without number?
**Answer:**
```java
// Returns Optional<User> or User - only 1 record!
Optional<User> findFirstByActive(boolean active);
User findFirstByEmail(String email);

// For multiple records, must specify number:
List<User> findFirst10ByActive(boolean active); // ‚úÖ Correct
List<User> findFirstByActive(boolean active);   // ‚ùå Returns only 1!
```

---

## üòµ Common Mistakes

### Mistake 1: Confusing First/Top return types ü§¶‚Äç‚ôÇÔ∏è
```java
// ‚ùå Wrong - Expecting multiple but getting single
List<User> findFirstByActive(boolean active); // Returns only 1 User!

// ‚úÖ Correct - Specify number for List
List<User> findFirst10ByActive(boolean active);
// OR
Optional<User> findFirstByActive(boolean active); // Single user
```

**Why it's wrong:** `findFirst` without number returns single entity, not List! 

### Mistake 2: Wrong LIMIT placement in JPQL ü§∑‚Äç‚ôÇÔ∏è
```java
// ‚ùå Wrong - LIMIT before ORDER BY
@Query("SELECT u FROM User u LIMIT 5 ORDER BY u.name")

// ‚úÖ Correct - ORDER BY before LIMIT  
@Query("SELECT u FROM User u ORDER BY u.name LIMIT 5")
```

**Error Message:**
```
org.hibernate.query.sqm.ParsingException: 
unexpected token: ORDER [SELECT u FROM User u LIMIT 5 ORDER BY u.name]
```

### Mistake 3: Using LIMIT in JPA Repository method names üìù
```java
// ‚ùå Wrong - LIMIT is not valid in method names
List<User> findByActiveLimit5(boolean active); // Won't work!

// ‚úÖ Correct - Use First/Top keywords
List<User> findFirst5ByActive(boolean active);
```

### Mistake 4: Forgetting nativeQuery = true with SQL LIMIT üíª
```java
// ‚ùå Wrong - Using SQL syntax in JPQL
@Query("SELECT * FROM user_tbl LIMIT 5")  // Syntax error!

// ‚úÖ Correct - Either use JPQL syntax
@Query("SELECT u FROM User u ORDER BY u.id LIMIT 5")

// ‚úÖ Or use native SQL with flag
@Query(value = "SELECT * FROM user_tbl LIMIT 5", nativeQuery = true)
```

### Mistake 5: Performance trap with Pageable üêå
```java
// ‚ùå Performance issue - Using Pageable for simple limiting
public List<User> getTop10Users() {
    Page<User> page = userRepo.findAll(PageRequest.of(0, 10));
    return page.getContent(); // Executes unnecessary COUNT query!
}

// ‚úÖ Better performance - Use First/Top
public List<User> getTop10Users() {
    return userRepo.findFirst10ByOrderByIdDesc(); // Single query only!
}
```

---

## üíé Best Practices

### 1. Choose Right Method for Use Case üéØ
```java
// ‚úÖ For fixed small limits - use First/Top
List<Product> findFirst5ByFeaturedTrue();

// ‚úÖ For pagination with navigation - use Pageable  
Page<Product> findByCategory(String category, Pageable pageable);

// ‚úÖ For dynamic limits - use Limit interface
List<Product> findByOrderByPriceAsc(Limit limit);

// ‚úÖ For complex queries - use @Query
@Query("SELECT p FROM Product p WHERE p.rating > 4.0 ORDER BY p.sales DESC LIMIT :count")
List<Product> findTopRatedProducts(@Param("count") int count);
```

### 2. Always Use Sorting with LIMIT üìä
```java
// ‚ùå Bad - No sorting, unpredictable results
List<User> findFirst10By();

// ‚úÖ Good - Consistent results with sorting  
List<User> findFirst10ByOrderByCreatedDateDesc();
List<User> findFirst10ByOrderByNameAsc();
```

### 3. Index Optimization üöÄ
```java
// Create indexes for frequently used LIMIT queries
@Entity
@Table(name = "user_tbl", indexes = {
    @Index(name = "idx_active_created", columnList = "active, created_date DESC"),
    @Index(name = "idx_email", columnList = "email")
})
public class User {
    // ... entity fields
}

// This query will be super fast with proper index:
List<User> findFirst10ByActiveOrderByCreatedDateDesc(boolean active);
```

### 4. Service Layer Pattern üèóÔ∏è
```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepo;
    
    // Encapsulate limit logic in service
    public List<User> getDashboardUsers() {
        return userRepo.findFirst5ByActiveOrderByLastLoginDesc(true);
    }
    
    public PaginatedResponse<User> getAllUsers(int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("name"));
        Page<User> userPage = userRepo.findAll(pageable);
        
        return PaginatedResponse.<User>builder()
            .data(userPage.getContent())
            .currentPage(page)
            .totalPages(userPage.getTotalPages())
            .totalElements(userPage.getTotalElements())
            .build();
    }
}
```

### 5. Error Handling üõ°Ô∏è
```java
@Service
public class UserService {
    
    public List<User> getTopUsers(int count) {
        // Validate input
        if (count <= 0 || count > 100) {
            throw new IllegalArgumentException("Count must be between 1 and 100");
        }
        
        try {
            return userRepo.findByOrderByScoreDesc(Limit.of(count));
        } catch (Exception e) {
            log.error("Error fetching top {} users", count, e);
            return Collections.emptyList(); // Graceful fallback
        }
    }
}
```

---

## üìù Summary/Quick Recap

### Key Takeaways üîë
1. **4 Methods hai bhai:** First/Top, @Query+LIMIT, Pageable, Limit interface
2. **Performance:** First/Top > Limit > @Query > Pageable  
3. **Flexibility:** Pageable > @Query > Limit > First/Top
4. **Sorting zaroori hai:** Always use ORDER BY with LIMIT

### Memory Tricks üß†
- **"FIRST ka FIRST"** - Method name mein First/Top pehle aata hai
- **"PAGE ki PRICE"** - Pageable slow hai because extra COUNT query  
- **"QUERY ki QUALITY"** - @Query mein flexibility zyada hai
- **"LIMIT ki LIBERTY"** - Limit interface newest aur dynamic hai

### When to Use What? ü§î

| Situation | Use This | Why? |
|-----------|----------|------|
| **Homepage top products** | `findFirst8By...` | Fixed, simple, fast |
| **Search results** | `Pageable` | Need pagination info |
| **Admin reports** | `@Query + LIMIT` | Complex conditions |
| **Dynamic user requests** | `Limit.of(count)` | Runtime flexibility |

### Final Mantra üìø
```java
// ‡§Ø‡§æ‡§¶ ‡§∞‡§ñ‡§®‡•á ‡§ï‡§æ ‡§Æ‡§Ç‡§§‡•ç‡§∞:
// "First Fast, Page Slow, Query Flexible, Limit New"
```

---

## üö® Quick Error Reference

### Common Error Messages & Solutions

| Error | Cause | Solution |
|-------|--------|----------|
| `ParsingException: unexpected token: LIMIT` | LIMIT before ORDER BY in JPQL | Move ORDER BY before LIMIT |
| `Method name not supported` | Wrong method naming | Use findFirst/findTop pattern |
| `No property 'limit' found` | Using 'limit' in method name | Use First/Top keywords instead |
| `ClassCastException` | Wrong return type | Use List for multiple, Optional for single |

**Bhai, ab tumhe Spring Data JPA limit queries ka complete gyan ho gaya! Practice karo aur master bano! üéØ‚ú®**

---

*Happy Coding! üíª Keep Learning! üìö Stay Awesome! üåü*
