# 🔥 Spring Data JPA AND Operator - Complete Guide 🚀

Bhai log, aaj hum sikhenge **Spring Data JPA mein AND Operator** ka use kaise karte hain! 💻✨

---

## 📚 Introduction - Confusion Clear Karte Hain! 

### Simple Explanation First 🤔
Yaar, imagine karo tum ek library mein books dhundh rahe ho. Tumhe ek specific **author** ki **programming** category ki books chahiye. Toh tum librarian se kahoge - "Bhai mujhe John ki programming books do!" 📚

Yahi kaam AND operator karta hai - **multiple conditions** ko combine karke exact results deta hai!

### Real-life Analogy 🏪
```
Restaurant mein order:
❌ Sirf "Pizza" bola → Sab pizza mil jayenge
✅ "Veg Pizza AND Medium Size" bola → Perfect match! 🍕
```

### Technical Definition 🎯
> **AND Operator** Spring Data JPA mein multiple conditions ko combine karta hai taaki hum database se exact filtered data retrieve kar sakein.

---

## 🔑 Key Terms/Concepts

| Term | Description |
|------|-------------|
| **Query Method| Repository mein custom method banane ka tarika |
| **JPQL** | Object-oriented query language |
| **Native Query** | Raw SQL queries |
| **@Query** |  Custom queries define karne ke liye |
| **findBy** |  Query method naming convention |

### Visual Representation 📊
```
Database Query Flow:
Client Request → Repository Method → AND Operator → Database → Filtered Results
     ↓              ↓                    ↓            ↓           ↓
   "Give me"    findByNameAnd...    WHERE a=? AND    MySQL      Exact Match
```

---

## 💡 Detailed Examples - Code Dekho Samjho!

### 1. Query Method with AND Keyword ⚡

```java
// Repository Interface - Sabse Simple Approach!
public interface StaffRepository extends JpaRepository<Staff, Long> {
    // ✅ Ye automatically SQL generate karta hai
    List<Staff> findByNameAndDepartment(String name, String department);
    
    // ✅ Multiple conditions - Easy peasy!
    List<Staff> findByNameAndDepartmentAndSalary(String name, String department, Double salary);
    
    // ✅ Different data types bhi use kar sakte hain
    List<Staff> findByIdAndActiveStatus(Long id, Boolean active);
}
```

**Expected Output SQL:**
```sql
SELECT * FROM staff WHERE name = ? AND department = ?
```

**Step-by-step Explanation:**
1. `findBy` - Query method start karta hai
2. `Name` - First field condition
3. `And` - Operator keyword
4. `Department` - Second field condition
5. Parameters automatically map ho jate hain! 🎯

### 2. JPQL with AND Operator 📝

```java
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    // ✅ Custom JPQL Query
    @Query("SELECT s FROM Staff s WHERE s.name = :name AND s.department = :department")
    List<Staff> findByNameAndDepartmentJPQL(String name, String department);
    
    // ✅ Complex conditions with JPQL
    @Query("SELECT s FROM Staff s WHERE s.salary > :minSalary AND s.department = :dept AND s.active = true")
    List<Staff> findHighSalaryStaffInDept(Double minSalary, String dept);
    
    // ✅ Case insensitive search
    @Query("SELECT s FROM Staff s WHERE LOWER(s.name) = LOWER(:name) AND s.department = :dept")
    List<Staff> findByNameIgnoreCaseAndDept(String name, String dept);
}
```

### 3. Native SQL Query with AND 🛠️

```java
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    // ✅ Raw SQL Query
    @Query(value = "SELECT * FROM staff WHERE name = :name AND department = :department", 
           nativeQuery = true)
    List<Staff> findByNameAndDepartmentNative(String name, String department);
    
    // ✅ Complex JOIN with AND
    @Query(value = "SELECT s.*, d.dept_name FROM staff s JOIN departments d ON s.dept_id = d.id WHERE s.active = :active AND d.location = :location", 
           nativeQuery = true)
    List<Object[]> findActiveStaffInLocation(Boolean active, String location);
}
```

---

## 📋 Rules/Guidelines - Yaad Rakhne Wale Points!

### Rule 1: Query Method Naming Convention ✅
```java
// ✅ CORRECT - CamelCase follow karo
List<Staff> findByFirstNameAndLastName(String firstName, String lastName);

// ❌ WRONG - Underscore mat use karo
List<Staff> findBy_first_name_And_last_name(String firstName, String lastName);
// Error: Invalid method name!
```

### Rule 2: Parameter Order Matter Karta Hai ✅
```java
// ✅ CORRECT - Method name aur parameters same order mein
List<Staff> findByNameAndDepartment(String name, String department);

// ❌ WRONG - Order mismatch
List<Staff> findByNameAndDepartment(String department, String name);
// Result: Galat data filter hoga!
```

### Rule 3: Data Types Match Hona Chahiye ✅
```java
// ✅ CORRECT
List<Staff> findByIdAndSalary(Long id, Double salary);

// ❌ WRONG
List<Staff> findByIdAndSalary(String id, Integer salary);
// Error: org.springframework.dao.InvalidDataAccessApiUsageException
```

### Rule 4: Null Values Handle Karo ✅
```java
// ✅ CORRECT - Null check add karo
@Query("SELECT s FROM Staff s WHERE (:name IS NULL OR s.name = :name) AND s.department = :dept")
List<Staff> findStaffWithOptionalName(String name, String dept);

// ❌ WRONG - Direct null pass kiya
List<Staff> result = staffRepo.findByNameAndDepartment(null, "IT");
// Result: Empty list ya unexpected behavior
```

---

## 🌍 Real-world Applications

### 1. Banking System 🏦
```java
@Entity
public class BankAccount {
    private String accountNumber;
    private String accountType;
    private String branchCode;
    private Boolean isActive;
    private Double balance;
}

// Repository Methods
public interface BankAccountRepository extends JpaRepository<BankAccount, Long> {
    
    // Active accounts in specific branch
    List<BankAccount> findByIsActiveAndBranchCode(Boolean active, String branchCode);
    
    // High balance savings accounts
    @Query("SELECT ba FROM BankAccount ba WHERE ba.accountType = :type AND ba.balance >= :minBalance AND ba.isActive = true")
    List<BankAccount> findHighBalanceSavingsAccounts(String type, Double minBalance);
}
```

### 2. E-commerce Product Search 🛒
```java
@Entity
public class Product {
    private String name;
    private String category;
    private String brand;
    private Double price;
    private Integer stock;
    private Boolean available;
}

public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Available products in price range
    List<Product> findByAvailableAndPriceBetween(Boolean available, Double minPrice, Double maxPrice);
    
    // Brand specific products in category
    List<Product> findByBrandAndCategoryAndStockGreaterThan(String brand, String category, Integer minStock);
}
```

### 3. Student Management System 🎓
```java
@Entity
public class Student {
    private String name;
    private String course;
    private Integer semester;
    private String section;
    private Boolean isActive;
}

public interface StudentRepository extends JpaRepository<Student, Long> {
    
    // Active students in specific course and semester
    List<Student> findByIsActiveAndCourseAndSemester(Boolean active, String course, Integer semester);
    
    // Section-wise active students
    @Query("SELECT s FROM Student s WHERE s.course = :course AND s.section = :section AND s.isActive = true")
    List<Student> findActiveByCourseAndSection(String course, String section);
}
```

---

## 📊 Comparison Tables

### Query Methods vs JPQL vs Native SQL

| Feature | Query Method | JPQL | Native SQL |
|---------|-------------|------|------------|
| **Simplicity** | 🟢 Very Easy | 🟡 Medium | 🔴 Complex |
| **Type Safety** | ✅ Yes | ✅ Yes | ❌ No |
| **Performance** | 🟡 Good | 🟢 Better | 🟢 Best |
| **Database Independence** | ✅ Yes | ✅ Yes | ❌ No |
| **Complex Queries** | ❌ Limited | 🟡 Good | ✅ Excellent |
| **Learning Curve** | 🟢 Easy | 🟡 Medium | 🔴 Hard |

### When to Use What? 🤔

| Scenario | Recommended Approach | Reason |
|----------|---------------------|---------|
| Simple 2-3 field filtering | Query Method | Easy to read and maintain |
| Complex business logic | JPQL | Object-oriented approach |
| Performance critical | Native SQL | Direct database optimization |
| Join operations | JPQL/Native SQL | Better control over joins |
| Database specific features | Native SQL | Access to DB-specific functions |

---

## ❓ Interview Questions - Taiyari Karo Bhai!

### Q1: Query Method mein AND operator kaise use karte hain?
**Answer:** 
```java
// Simple approach - method name mein 'And' keyword add karo
List<User> findByUsernameAndEmail(String username, String email);

// Multiple conditions
List<Product> findByNameAndCategoryAndPriceGreaterThan(String name, String category, Double price);
```

### Q2: JPQL aur Native Query mein difference kya hai?
**Answer:**
```java
// JPQL - Object oriented, database independent
@Query("SELECT u FROM User u WHERE u.name = :name AND u.active = :active")
List<User> findByJPQL(String name, Boolean active);

// Native SQL - Database specific, more control
@Query(value = "SELECT * FROM users WHERE name = :name AND active = :active", nativeQuery = true)  
List<User> findByNative(String name, Boolean active);
```

### Q3: Multiple AND conditions ke saath performance optimize kaise kare?
**Answer:**
```java
// ✅ Index-based columns use karo
List<User> findByIdAndEmail(Long id, String email);  // Both indexed

// ✅ @Query mein specific fields select karo  
@Query("SELECT u.id, u.name FROM User u WHERE u.department = :dept AND u.active = true")
List<Object[]> findSpecificFields(String dept);

// ✅ Pagination use karo large datasets ke liye
Page<User> findByDepartmentAndActive(String dept, Boolean active, Pageable pageable);
```

---

## 🚫 Common Mistakes - Galti Se Bacho!

### Mistake 1: Wrong Parameter Mapping ❌
```java
// ❌ WRONG
@Query("SELECT s FROM Staff s WHERE s.name = :empName AND s.dept = :department")
List<Staff> findStaff(String name, String dept);  // Parameter names don't match!

// ✅ CORRECT  
@Query("SELECT s FROM Staff s WHERE s.name = :name AND s.dept = :dept")
List<Staff> findStaff(String name, String dept);
```

### Mistake 2: Case Sensitivity Issues ❌
```java
// ❌ WRONG - Case sensitive search
List<User> findByNameAndEmail(String name, String email);

// ✅ CORRECT - Case insensitive search
@Query("SELECT u FROM User u WHERE LOWER(u.name) = LOWER(:name) AND LOWER(u.email) = LOWER(:email)")
List<User> findByNameAndEmailIgnoreCase(String name, String email);
```

### Mistake 3: Null Parameter Handling ❌
```java
// ❌ WRONG - Null values cause issues
public List<Staff> searchStaff(String name, String dept) {
    return staffRepo.findByNameAndDepartment(name, dept);  // If name is null, no results!
}

// ✅ CORRECT - Handle null values
public List<Staff> searchStaff(String name, String dept) {
    if(name == null && dept == null) {
        return staffRepo.findAll();
    } else if(name == null) {
        return staffRepo.findByDepartment(dept);
    } else if(dept == null) {
        return staffRepo.findByName(name);
    }
    return staffRepo.findByNameAndDepartment(name, dept);
}
```

### Mistake 4: Over-fetching Data ❌
```java
// ❌ WRONG - Sab data fetch kar rahe ho
@Query("SELECT u FROM User u WHERE u.active = :active AND u.department = :dept")
List<User> findUsers(Boolean active, String dept);

// ✅ CORRECT - Sirf required fields lo
@Query("SELECT new com.example.UserDTO(u.id, u.name, u.email) FROM User u WHERE u.active = :active AND u.department = :dept")
List<UserDTO> findUsersDTOs(Boolean active, String dept);
```

---

## 🌟 Best Practices - Industry Standards

### 1. Method Naming Convention 📝
```java
// ✅ GOOD - Clear and descriptive
List<Order> findByStatusAndCustomerIdAndOrderDateBetween(String status, Long customerId, Date startDate, Date endDate);

// ❌ AVOID - Too long method names
List<Order> findByStatusAndCustomerIdAndOrderDateBetweenAndAmountGreaterThanAndShippingAddressContaining(...);
```

### 2. Use DTOs for Complex Queries 🎯
```java
// ✅ RECOMMENDED
@Query("SELECT new com.example.StaffSummaryDTO(s.name, s.department, s.salary) FROM Staff s WHERE s.active = :active AND s.department = :dept")
List<StaffSummaryDTO> findStaffSummary(Boolean active, String dept);

// DTO Class
public class StaffSummaryDTO {
    private String name;
    private String department; 
    private Double salary;
    
    // Constructor, getters, setters
}
```

### 3. Add Proper Indexing 🚀
```java
@Entity
@Table(name = "staff", indexes = {
    @Index(name = "idx_name_dept", columnList = "name, department"),
    @Index(name = "idx_active_salary", columnList = "active, salary")
})
public class Staff {
    // Entity fields
}
```

### 4. Exception Handling 🛡️
```java
@Service
public class StaffService {
    
    public List<Staff> findStaffByCriteria(String name, String dept) {
        try {
            if (name == null || name.trim().isEmpty()) {
                throw new IllegalArgumentException("Name cannot be null or empty");
            }
            return staffRepository.findByNameAndDepartment(name, dept);
        } catch (DataAccessException e) {
            log.error("Database error while fetching staff: {}", e.getMessage());
            throw new ServiceException("Error retrieving staff data", e);
        }
    }
}
```

### 5. Pagination for Large Datasets 📄
```java
// ✅ Use Pageable for large results
@Repository
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    Page<Staff> findByDepartmentAndActive(String department, Boolean active, Pageable pageable);
    
    // Custom query with pagination
    @Query("SELECT s FROM Staff s WHERE s.salary >= :minSalary AND s.department = :dept")
    Page<Staff> findHighSalaryStaff(Double minSalary, String dept, Pageable pageable);
}

// Service layer
@Service
public class StaffService {
    
    public Page<Staff> getStaffByDepartment(String dept, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("name"));
        return staffRepository.findByDepartmentAndActive(dept, true, pageable);
    }
}
```

---

## 📝 Summary/Quick Recap

### Key Takeaways 🎯
1. **3 Ways hai AND operator use karne ke**: Query Method, JPQL, Native SQL
2. **Query Method** - Sabse simple, `findByField1AndField2` pattern
3. **JPQL** - Object-oriented queries, `@Query` annotation ke saath
4. **Native SQL** - Raw SQL power, `nativeQuery = true` ke saath
5. **Performance** ke liye proper indexing aur pagination use karo

### Memory Tricks 🧠
```
🎭 Query Method: "findBy + Field + And + Field" - Drama ki script ki tarah!
🎯 JPQL: "SELECT entity FROM Entity WHERE field1 = :param1 AND field2 = :param2"
🛠️ Native: "SELECT * FROM table WHERE column1 = :param1 AND column2 = :param2"
```

### When to Use What? ⭐
| Situation | Use This | Reason |
|-----------|----------|--------|
| Simple filtering (2-3 fields) | **Query Method** | Readable aur easy |
| Complex business logic | **JPQL** | Object-oriented approach |
| Performance critical | **Native SQL** | Maximum control |
| Joins required | **JPQL/Native** | Better join support |

### Yaad Rakhne Ka Mantra 🔮
```
📚 "Simple se complex ki taraf jao"
🎯 "Performance matters, indexing karo"  
🛡️ "Null values handle karo hamesha"
📄 "Large data? Pagination use karo"
✅ "Test karo, exception handle karo"
```

---

## 🎉 Final Code Template - Copy Paste Ready!

```java
// Complete Working Example
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String department;
    private Double salary;
    private Boolean active;
    
    // Constructors, getters, setters
}

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // 1. Query Method - Simple AND
    List<Employee> findByDepartmentAndActive(String department, Boolean active);
    
    // 2. JPQL - Custom logic
    @Query("SELECT e FROM Employee e WHERE e.salary >= :minSalary AND e.department = :dept")
    List<Employee> findHighSalaryInDepartment(@Param("minSalary") Double minSalary, 
                                            @Param("dept") String department);
    
    // 3. Native SQL - Performance optimized  
    @Query(value = "SELECT * FROM employees WHERE active = :active AND salary BETWEEN :minSal AND :maxSal", 
           nativeQuery = true)
    List<Employee> findBySalaryRange(@Param("active") Boolean active, 
                                   @Param("minSal") Double minSalary, 
                                   @Param("maxSal") Double maxSalary);
}
```

Bas bhai! Ab tum Spring Data JPA mein AND operator ke expert ho gaye! 🎊 Practice karo aur interview mein rock karo! 🚀

**Happy Coding! 💻✨**
