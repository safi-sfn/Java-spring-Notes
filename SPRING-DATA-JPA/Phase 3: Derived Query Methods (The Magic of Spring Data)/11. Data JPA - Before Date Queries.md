# Spring Data JPA - Before Date Queries 📅✨

**Bhai, Date ke saath queries karna sikho!** 🚀

---

## 🎯 Introduction - Confusion Clear Karte Hain!

### Simple Explanation Pehle 🤔
**Yaar**, kabhi socha hai ki database mein specific date se pehle ke records kaise nikaalte hain? Jaise tumhe chahiye saare orders jo 1st October se pehle place hue the. Bas yehi seekhenge aaj!

### Real-life Analogy 🏪
**Imagine karo** - Tum ek shop owner ho aur tumhe chahiye saari sales jo Diwali se pehle hui thi. Tum apni diary mein date check karke saari entries nikaaloge jo target date se pehle ki hain. JPA mein bhi same concept hai!

### Technical Definition 📚
Spring Data JPA mein **"Before Date"** queries ka matlab hai - database se un records ko fetch karna jo specified date se pehle create/insert hui hain. Yeh 3 tarike se kar sakte hain:
- Query Methods (`findBy...Before()`)
- JPQL with `<` operator  
- Native SQL with `<` operator

---

## 🔑 Key Terms/Concepts

| Term | Hinglish Explanation | Technical Definition |
|------|---------------------|---------------------|
| **JPA Repository** 📦 | Database ke saath baat-cheet karne ka interface | Java Persistence API repository interface |
| **Query Methods** 🔍 | Method name se query banane ka tarika | Spring Data JPA's method name-based query creation |
| **JPQL** 💻 | Java objects ke liye SQL jaisa language | Java Persistence Query Language |
| **Native SQL** 🗄️ | Pure database SQL commands | Direct SQL queries on database |
| **LocalDate** 📅 | Java mein date represent karne ka modern way | Java 8+ date-time API class |
| **Before Operator** ⬅️ | "Se pehle" wala condition | Less than (<) comparison for dates |

---

## 🛠️ Detailed Examples - Code Dekho Aur Samjho!

### Method 1: Query Methods (`findBy...Before()`) ✅

```java
// Repository Interface
import java.time.LocalDate;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;

public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    // 🎯 Magic method - Spring automatically banayega query!
    List<OrderDetail> findByOrderDateBefore(LocalDate date);
}

// Service mein use karna
@Service
public class OrderServiceImpl implements OrderService {
    
    @Autowired
    private OrderRepository orderRepo;
    
    public List<OrderDetail> getOrdersBeforeDate(LocalDate date) {
        // Yeh method return karega saare orders jo given date se pehle ke hain
        return orderRepo.findByOrderDateBefore(date);
    }
}
```

**Expected Output:** 📊
```sql
-- Spring automatically generate karega yeh SQL:
SELECT od.id, od.amount, od.customer_id, od.order_date 
FROM order_detail od 
WHERE od.order_date < ?
```

### Method 2: JPQL Query (`@Query` annotation) 💡

```java
import org.springframework.data.jpa.repository.Query;

public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // 🔥 Custom JPQL query - Java objects ka naam use karo!
    @Query("SELECT od FROM OrderDetail od WHERE od.orderDate < ?1")
    List<OrderDetail> findOrderBeforeDate(LocalDate date);
}
```

**Step-by-step Explanation:** 🤓
1. `SELECT od FROM OrderDetail od` - OrderDetail entity se data select kar rahe
2. `WHERE od.orderDate < ?1` - orderDate field jo pehla parameter se kam hai
3. `?1` - Method ka first parameter (date) yahan use hoga

### Method 3: Native SQL Query 🗄️

```java
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // 🚀 Pure SQL query - database table names use karo!
    @Query(value = "SELECT * FROM order_detail WHERE order_date < ?1", 
           nativeQuery = true)
    List<OrderDetail> findOrderBeforeDateNative(LocalDate date);
}
```

**Important Note:** 📝
- JPQL mein **Entity class name** use karte hain (`OrderDetail`)
- Native SQL mein **Table name** use karte hain (`order_detail`)

---

## ⚖️ Rules/Guidelines - Yaad Rakhne Ke Mantras!

### Rule 1: Method Naming Convention ✅
```java
// ✅ Correct - CamelCase aur proper structure
List<OrderDetail> findByOrderDateBefore(LocalDate date);

// ❌ Wrong - galat naming
List<OrderDetail> getOrdersBeforeDate(LocalDate date);  // 'find' missing
List<OrderDetail> findbyorderdatebefore(LocalDate date); // case sensitivity
```

### Rule 2: Parameter Binding ✅
```java
// ✅ Correct - parameter indexing
@Query("SELECT od FROM OrderDetail od WHERE od.orderDate < ?1")
List<OrderDetail> findOrderBeforeDate(LocalDate date);

// ❌ Wrong - galat parameter reference  
@Query("SELECT od FROM OrderDetail od WHERE od.orderDate < ?2") // Only 1 parameter hai!
```

### Rule 3: Date Type Consistency ✅
```java
// ✅ Correct - LocalDate use karo modern apps mein
private LocalDate orderDate;

// ❌ Wrong - avoid legacy Date class
private java.util.Date orderDate; // Deprecated approach
```

---

## 🌍 Real-world Applications

### Banking System Example 🏦

```java
@Entity
public class Transaction {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String accountNumber;
    private Double amount;
    private LocalDate transactionDate;
    
    // Getters and setters...
}

// Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    
    // Monthly report ke liye - specific month se pehle ke transactions
    List<Transaction> findByTransactionDateBefore(LocalDate endDate);
    
    // Account-specific queries
    List<Transaction> findByAccountNumberAndTransactionDateBefore(
        String accountNumber, LocalDate endDate);
}

// Service implementation
@Service
public class TransactionService {
    
    @Autowired
    private TransactionRepository transactionRepo;
    
    // Month-end report generation
    public List<Transaction> getMonthlyReport(String month, int year) {
        LocalDate endDate = LocalDate.of(year, Month.valueOf(month.toUpperCase()), 1);
        return transactionRepo.findByTransactionDateBefore(endDate);
    }
}
```

### E-commerce Order Management 🛒

```java
@Entity
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)  
    private Long orderId;
    
    private String customerEmail;
    private Double totalAmount;
    private String status; // PENDING, SHIPPED, DELIVERED
    private LocalDate orderDate;
    
    // Constructors, getters, setters...
}

// Advanced queries with multiple conditions
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // Pending orders jo specific date se pehle ki hain
    @Query("SELECT o FROM Order o WHERE o.orderDate < ?1 AND o.status = 'PENDING'")
    List<Order> findPendingOrdersBeforeDate(LocalDate date);
    
    // Customer-wise analysis
    List<Order> findByCustomerEmailAndOrderDateBefore(String email, LocalDate date);
}
```

---

## 📊 Comparison Table - Sab Methods Ka Comparison

| Feature | Query Method | JPQL | Native SQL |
|---------|-------------|------|------------|
| **Ease of Use** 😊 | Very Easy | Medium | Hard |
| **Performance** ⚡ | Good | Good | Best |
| **Database Independent** 🌐 | Yes | Yes | No |
| **Complex Queries** 🤯 | Limited | Good | Excellent |
| **Learning Curve** 📈 | Low | Medium | High |
| **Type Safety** 🛡️ | High | Medium | Low |

### When to Use What? 🤷‍♂️

```java
// 🟢 Simple queries - Query Methods use karo
List<Order> findByOrderDateBefore(LocalDate date);

// 🟡 Medium complexity - JPQL perfect hai  
@Query("SELECT o FROM Order o WHERE o.orderDate < ?1 AND o.status = ?2")
List<Order> findOrdersBeforeDateWithStatus(LocalDate date, String status);

// 🔴 Complex queries with joins - Native SQL
@Query(value = "SELECT o.* FROM orders o JOIN customers c ON o.customer_id = c.id " +
               "WHERE o.order_date < ?1 AND c.premium = true", nativeQuery = true)
List<Order> findPremiumCustomerOrdersBeforeDate(LocalDate date);
```

---

## 🎤 Interview Questions - Ready Ho Jaao!

### Q1: Spring Data JPA mein before date queries ke kitne tarike hain? 🤔
**Answer:** Teen main tarike hain bhai:

```java
// 1. Query Methods
List<Order> findByOrderDateBefore(LocalDate date);

// 2. JPQL with @Query
@Query("SELECT o FROM Order o WHERE o.orderDate < ?1")
List<Order> getOrdersBeforeDate(LocalDate date);

// 3. Native SQL
@Query(value = "SELECT * FROM orders WHERE order_date < ?1", nativeQuery = true)
List<Order> findOrdersBeforeDateNative(LocalDate date);
```

### Q2: JPQL aur Native SQL mein kya difference hai? 🧐
**Answer:**

| JPQL | Native SQL |
|------|------------|
| Entity names use karte hain | Table names use karte hain |
| Database independent | Database specific |
| Type safe | Not type safe |
| `OrderDetail` | `order_detail` |

```java
// JPQL - Entity name
@Query("SELECT od FROM OrderDetail od WHERE od.orderDate < ?1")

// Native SQL - Table name  
@Query(value = "SELECT * FROM order_detail WHERE order_date < ?1", nativeQuery = true)
```

### Q3: Performance wise kaun sa approach best hai? ⚡

**Answer:** Native SQL > JPQL > Query Methods

**Explanation:**
```java
// Query Methods - Spring converts to JPQL internally
// Extra overhead of method name parsing
List<Order> findByOrderDateBefore(LocalDate date);

// JPQL - Hibernate optimizes the query
// Good balance between performance and readability  
@Query("SELECT o FROM Order o WHERE o.orderDate < ?1")

// Native SQL - Direct database execution
// No extra layers, best performance
@Query(value = "SELECT * FROM orders WHERE order_date < ?1", nativeQuery = true)
```

---

## ❌ Common Mistakes - Inse Bacho!

### Mistake 1: Wrong Parameter Binding 🚫
```java
// ❌ Wrong - parameter count mismatch
@Query("SELECT o FROM Order o WHERE o.orderDate < ?1 AND o.status = ?2")
List<Order> findOrders(LocalDate date); // Only 1 parameter, query expects 2!

// ✅ Correct
@Query("SELECT o FROM Order o WHERE o.orderDate < ?1 AND o.status = ?2") 
List<Order> findOrders(LocalDate date, String status);
```

**Error Message:** 
```
org.springframework.dao.InvalidDataAccessApiUsageException: 
Parameter with that position [2] did not exist
```

### Mistake 2: Entity vs Table Name Confusion 🤦‍♂️
```java
// ❌ Wrong - table name in JPQL
@Query("SELECT od FROM order_detail od WHERE od.order_date < ?1") // TABLE NAME!

// ✅ Correct - entity name in JPQL  
@Query("SELECT od FROM OrderDetail od WHERE od.orderDate < ?1") // ENTITY NAME!
```

### Mistake 3: Date Format Issues 📅
```java
// ❌ Wrong - String date comparison
@Query("SELECT o FROM Order o WHERE o.orderDate < '2024-10-01'") // Hard-coded string!

// ✅ Correct - parameter binding
@Query("SELECT o FROM Order o WHERE o.orderDate < ?1")
List<Order> findOrders(LocalDate date);
```

---

## ✨ Best Practices - Industry Standards

### 1. Method Naming Convention 📝
```java
// ✅ Follow Spring Data JPA naming rules
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // Good naming - clear and descriptive
    List<Order> findByOrderDateBefore(LocalDate date);
    List<Order> findByOrderDateBeforeAndStatus(LocalDate date, String status);
    
    // Custom method names with @Query
    @Query("SELECT o FROM Order o WHERE o.orderDate < ?1")
    List<Order> findOrdersCreatedBefore(LocalDate date);
}
```

### 2. Parameter Validation 🛡️
```java
@Service
public class OrderService {
    
    public List<Order> getOrdersBeforeDate(LocalDate date) {
        // ✅ Always validate parameters
        if (date == null) {
            throw new IllegalArgumentException("Date cannot be null");
        }
        
        // ✅ Future date validation
        if (date.isAfter(LocalDate.now())) {
            throw new IllegalArgumentException("Date cannot be in future");
        }
        
        return orderRepository.findByOrderDateBefore(date);
    }
}
```

### 3. Exception Handling 🚨
```java
@RestController
public class OrderController {
    
    @GetMapping("/orders/before/{date}")
    public ResponseEntity<?> getOrdersBeforeDate(@PathVariable String date) {
        try {
            LocalDate parsedDate = LocalDate.parse(date);
            List<Order> orders = orderService.getOrdersBeforeDate(parsedDate);
            
            if (orders.isEmpty()) {
                return ResponseEntity.noContent().build();
            }
            
            return ResponseEntity.ok(orders);
            
        } catch (DateTimeParseException e) {
            return ResponseEntity.badRequest()
                .body("Invalid date format. Use YYYY-MM-DD");
        }
    }
}
```

---

## 📱 Complete Working Example - Postman Testing Ready!

### Entity Class 📋
```java
@Entity
@Data // Lombok for getters/setters
public class OrderDetail {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private Long customerId;
    private Double amount;
    private LocalDate orderDate;
}
```

### Repository Interface 🗄️
```java
@Repository
public interface OrderRepository extends JpaRepository<OrderDetail, Long> {
    
    // Method 1: Query Method
    List<OrderDetail> findByOrderDateBefore(LocalDate date);
    
    // Method 2: JPQL
    @Query("SELECT od FROM OrderDetail od WHERE od.orderDate < ?1")
    List<OrderDetail> findOrderBeforeDate(LocalDate date);
    
    // Method 3: Native SQL
    @Query(value = "SELECT * FROM order_detail WHERE order_date < ?1", 
           nativeQuery = true)
    List<OrderDetail> findOrderBeforeDateNative(LocalDate date);
}
```

### Rest Controller 🎮
```java
@RestController
@RequestMapping("/api/orders")
public class OrderController {
    
    @Autowired
    private OrderRepository orderRepo;
    
    // Test all three methods
    @GetMapping("/before/{date}")
    public Map<String, Object> getOrdersBeforeDate(@PathVariable String date) {
        LocalDate parsedDate = LocalDate.parse(date);
        
        Map<String, Object> response = new HashMap<>();
        
        // Method 1 results
        List<OrderDetail> queryMethod = orderRepo.findByOrderDateBefore(parsedDate);
        response.put("queryMethod", queryMethod);
        
        // Method 2 results  
        List<OrderDetail> jpqlMethod = orderRepo.findOrderBeforeDate(parsedDate);
        response.put("jpqlMethod", jpqlMethod);
        
        // Method 3 results
        List<OrderDetail> nativeMethod = orderRepo.findOrderBeforeDateNative(parsedDate);
        response.put("nativeMethod", nativeMethod);
        
        return response;
    }
}
```

### Postman Testing 🧪
```bash
# API Call
GET http://localhost:8080/api/orders/before/2024-10-01

# Sample Response
{
    "queryMethod": [
        {
            "id": 1,
            "customerId": 1,
            "amount": 700.0,
            "orderDate": "2024-09-30"
        }
    ],
    "jpqlMethod": [...], // Same data
    "nativeMethod": [...] // Same data
}
```

---

## 🎯 Summary/Quick Recap

### Key Takeaways 🔑
1. **3 Methods Hain:** Query Methods, JPQL, Native SQL
2. **LocalDate Use Karo** - Modern aur clean approach
3. **Parameter Validation** - Hamesha check karo null values
4. **Method Naming** - Spring conventions follow karo

### Memory Tricks 🧠
- **Query Methods** = Aasaan (Easy) 😊
- **JPQL** = Entity names, database independent 🌐  
- **Native SQL** = Table names, database specific ⚡
- **Before** = Less than (`<`) operator 📉

### When to Use What? 🤷‍♂️
```java
// Simple queries - Query Methods
findByOrderDateBefore(date)

// Medium complexity - JPQL
@Query("SELECT ... WHERE date < ?1")

// Complex with joins - Native SQL  
@Query(value = "SELECT ... JOIN ...", nativeQuery = true)
```

---

## 🔗 Related Topics to Explore

1. **After Date Queries** - `findByDateAfter()` 📈
2. **Between Date Queries** - `findByDateBetween()` 📊
3. **Custom Date Formatting** - `DateTimeFormatter` 📅
4. **Pagination with Date Queries** - `Pageable` interface 📄
5. **Complex Joins with Dates** - `@JoinColumn` 🔗

---

**Bhai, ab tum expert ho gaye! Database mein date queries lagana ab piece of cake hai! 🎂✨**

*Happy Coding! 💻🚀*
