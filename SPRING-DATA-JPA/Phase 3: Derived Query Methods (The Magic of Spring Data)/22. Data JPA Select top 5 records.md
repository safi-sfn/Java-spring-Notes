# Spring Data JPA - Top 5 Records Select Karne Ka Complete Guide üöÄ

## üéØ Introduction with Confusion Clearing

### Simple Explanation First üìö
Bhai, kabhi socha hai ke database mein hazaaron records hain aur tumhe sirf top 5 chahiye? Jaise cricket mein top 5 batsmen ya YouTube mein top 5 trending videos! Spring Data JPA mein ye kaam **4 different ways** mein kar sakte hain.

### Real-life Analogy üèè
**Cricket Leaderboard ki tarah samjho:**
- Tournament mein 100 players hain
- Tumhe sirf **top 5 scorers** chahiye
- Runs ke hisab se sorting karke top 5 nikaalna hai
- Database mein bhi same concept hai!

### Technical Definition üí°
Spring Data JPA provides **4 main approaches** to fetch limited records from database:
1. **Query Methods with Top keyword** - findTop5By...
2. **@Query annotation with LIMIT** - Custom JPQL/SQL
3. **Pageable interface** - PageRequest for pagination
4. **Limit interface** - Modern approach with Limit.of()

---

## üîë Key Terms/Concepts

| Term | Technical Definition |
|------|---------------------|
| **Top Keyword**  | Query method mein `findTopNBy` use karte hain |
| **Limit Clause** | SQL mein records ki ‡§∏‡§Ç‡§ñ‡•ç‡§Ø‡§æ control ‡§ï‡§∞‡§§‡§æ ‡§π‡•à |
| **Pageable** | Data ‡§ï‡•ã pages mein divide ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è |
| **JPQL** |  Object-oriented query language |
| **Order By** | Records ‡§ï‡•ã sort ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è |

---

## üìù 4 Methods to Select Top Records - Detail Examples

### Method 1: Query Method with Top Keyword ü•á

**Simple words mein:** Method ka naam hi query ban jata hai!

```java
public interface UserRepository extends JpaRepository<User, Long> {
    // Top 5 active users
    List<User> findTop5ByActive(boolean active);
    
    // Top 5 users ordered by ID descending
    List<User> findTop5ByOrderByIdDesc();
    
    // Top 3 users by name starting with specific letter
    List<User> findTop3ByNameStartingWith(String prefix);
}
```

**Generated SQL:**
```sql
-- For findTop5ByActive(true)
SELECT u.id, u.name, u.email, u.active 
FROM user_tbl u 
WHERE u.active = true 
FETCH FIRST 5 ROWS ONLY;
```

**Expected Output:**
```json
[
    {"id": 1, "name": "Test", "email": "test@gmail.com", "active": true},
    {"id": 2, "name": "ABC", "email": "abc@gmail.com", "active": true},
    {"id": 3, "name": "DEF", "email": "def@gmail.com", "active": true},
    {"id": 4, "name": "XYZ", "email": "xyz@gmail.com", "active": true},
    {"id": 5, "name": "PQR", "email": "pqr@gmail.com", "active": true}
]
```

### Method 2: @Query Annotation with LIMIT ü•à

**Real life example:** Manual query likhna, jaise SQL mein karte the!

```java
public interface UserRepository extends JpaRepository<User, Long> {
    // JPQL with LIMIT
    @Query("SELECT u FROM User u ORDER BY u.id DESC LIMIT 5")
    List<User> findTop5Records();
    
    // Native SQL query
    @Query(value = "SELECT * FROM user_tbl ORDER BY id DESC LIMIT 5", 
           nativeQuery = true)
    List<User> findTop5RecordsNative();
    
    // Dynamic limit with parameter
    @Query("SELECT u FROM User u WHERE u.active = :active ORDER BY u.id DESC LIMIT :limit")
    List<User> findTopRecordsByActive(@Param("active") boolean active, 
                                     @Param("limit") int limit);
}
```

### Method 3: Pageable Interface ü•â

**Yaad rakhne ka mantra:** Page-0, Size-5 = Top 5 records!

```java
public interface UserRepository extends JpaRepository<User, Long> {
    // Inherited method se use karenge
}

@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserRepository userRepo;
    
    public Page<User> getTop5Users() {
        // Page 0 (first page), Size 5 (5 records per page)
        Pageable topFive = PageRequest.of(0, 5);
        return userRepo.findAll(topFive);
    }
    
    public Page<User> getTop5UsersSorted() {
        // Sorting ke saath
        Pageable topFive = PageRequest.of(0, 5, 
            Sort.by(Sort.Direction.DESC, "id"));
        return userRepo.findAll(topFive);
    }
}
```

**Expected Output (Page Object):**
```json
{
    "content": [
        {"id": 7, "name": "MNO", "email": "mno@gmail.com", "active": false},
        {"id": 6, "name": "JKL", "email": "jkl@gmail.com", "active": true}
    ],
    "totalElements": 7,
    "totalPages": 2,
    "size": 5,
    "number": 0
}
```

### Method 4: Limit Interface (Modern Approach) üèÜ

**Latest feature hai yaar:** Spring Boot 3.0+ mein available!

```java
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByOrderByIdDesc(Limit limit);
    
    List<User> findByActiveOrderByNameAsc(boolean active, Limit limit);
}

@Service
public class UserServiceImpl {
    @Autowired
    private UserRepository userRepo;
    
    public List<User> getTop5UsersWithLimit() {
        return userRepo.findByOrderByIdDesc(Limit.of(5));
    }
    
    public List<User> getTop3ActiveUsers() {
        return userRepo.findByActiveOrderByNameAsc(true, Limit.of(3));
    }
}
```

---

## ‚úÖ‚ùå Rules/Guidelines

### Rule 1: Method Naming Convention ‚úÖ
```java
// ‚úÖ Correct
findTop5ByActive(boolean active)
findFirst10ByNameOrderByIdDesc(String name)

// ‚ùå Wrong
findTopByActive() // No number specified
findTop5Active() // Missing 'By' keyword
```

### Rule 2: Top vs First Keywords ‚úÖ
```java
// ‚úÖ Both are same
findTop5ByActive(boolean active)
findFirst5ByActive(boolean active)

// ‚úÖ Can use any number
findTop1ByEmail(String email)  // Single record
findTop100ByActive(boolean active)  // 100 records
```

### Rule 3: Combining with OrderBy ‚úÖ
```java
// ‚úÖ Correct ordering
findTop5ByActiveOrderByIdDesc(boolean active)
findTop10ByOrderByNameAscIdDesc()

// ‚ùå Wrong - OrderBy should come at end
findOrderByIdTop5ByActive(boolean active)
```

### Rule 4: Return Types ‚úÖ
```java
// ‚úÖ Correct return types
List<User> findTop5ByActive(boolean active)
Page<User> findAll(Pageable pageable)
Optional<User> findFirstByEmail(String email)

// ‚ùå Wrong return types
User findTop5ByActive(boolean active)  // Can't return single object for multiple
```

**Common Error Example:**
```java
// ‚ùå This will give compilation error
User findTop5ByActive(boolean active);
```
**Error Message:**
```
org.springframework.dao.IncorrectResultSizeDataAccessException: 
query did not return a unique result: 5
```

---

## üåç Real-world Applications

### 1. E-commerce Application üõí
```java
@Entity
public class Product {
    private Long id;
    private String name;
    private Double price;
    private Integer rating;
    private LocalDateTime createdDate;
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    // Top 5 highest rated products
    List<Product> findTop5ByOrderByRatingDesc();
    
    // Top 10 latest products
    List<Product> findTop10ByOrderByCreatedDateDesc();
    
    // Top 5 cheapest products in category
    @Query("SELECT p FROM Product p WHERE p.category = :category ORDER BY p.price ASC LIMIT 5")
    List<Product> findTop5CheapestInCategory(@Param("category") String category);
}
```

### 2. Social Media Analytics üì±
```java
@Entity
public class Post {
    private Long id;
    private String content;
    private Integer likes;
    private Integer shares;
    private LocalDateTime publishDate;
}

@Repository
public interface PostRepository extends JpaRepository<Post, Long> {
    // Viral posts (most liked)
    List<Post> findTop10ByOrderByLikesDesc();
    
    // Recent trending posts
    @Query("SELECT p FROM Post p WHERE p.publishDate >= :date ORDER BY (p.likes + p.shares) DESC LIMIT 5")
    List<Post> findTrendingPosts(@Param("date") LocalDateTime date);
}
```

### 3. Student Management System üéì
```java
@Entity
public class Student {
    private Long id;
    private String name;
    private Double marks;
    private String grade;
}

@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {
    // Top 5 performers
    List<Student> findTop5ByOrderByMarksDesc();
    
    // Top students in specific grade
    List<Student> findTop3ByGradeOrderByMarksDesc(String grade);
}

@Service
public class StudentService {
    public Page<Student> getToppersList() {
        Pageable topTen = PageRequest.of(0, 10, 
            Sort.by(Sort.Direction.DESC, "marks"));
        return studentRepo.findAll(topTen);
    }
}
```

---

## üìä Comparison Table

| Method | Pros üëç | Cons üëé | Use Case |
|--------|---------|---------|----------|
| **Query Method** | ‚Ä¢ No SQL writing needed<br/>‚Ä¢ Type-safe<br/>‚Ä¢ Auto-completion | ‚Ä¢ Limited flexibility<br/>‚Ä¢ Long method names | Simple queries |
| **@Query** | ‚Ä¢ Full SQL control<br/>‚Ä¢ Complex queries possible | ‚Ä¢ Manual SQL writing<br/>‚Ä¢ No type safety | Complex filtering |
| **Pageable** | ‚Ä¢ Built-in pagination<br/>‚Ä¢ Sorting included<br/>‚Ä¢ Metadata available | ‚Ä¢ Returns Page object<br/>‚Ä¢ More complex | Pagination needs |
| **Limit** | ‚Ä¢ Modern approach<br/>‚Ä¢ Clean syntax<br/>‚Ä¢ Type-safe | ‚Ä¢ Spring Boot 3.0+ only<br/>‚Ä¢ Limited adoption | Latest projects |

---

## üé§ Interview Questions

### Q1: Spring Data JPA mein top records select karne ke kitne ways hain?
**Answer:** 4 main ways hain bhai:

```java
// 1. Query Method with Top keyword
List<User> findTop5ByActive(boolean active);

// 2. @Query annotation with LIMIT
@Query("SELECT u FROM User u ORDER BY u.id DESC LIMIT 5")
List<User> findTop5Records();

// 3. Pageable interface
Page<User> findAll(PageRequest.of(0, 5));

// 4. Limit interface (Spring Boot 3.0+)
List<User> findByOrderByIdDesc(Limit.of(5));
```

### Q2: findTop5 aur findFirst5 mein kya difference hai?
**Answer:** **Koi difference nahi hai yaar!** Dono bilkul same work karte hain.

```java
// Both are exactly same
List<User> findTop5ByActive(boolean active);
List<User> findFirst5ByActive(boolean active);
```

### Q3: Pageable vs Query Method - kab kya use karein?
**Answer:**

| Scenario | Use This | Why? |
|----------|----------|------|
| Simple top N records | Query Method | `findTop5ByActive()` |
| Need pagination metadata | Pageable | Total pages, elements count |
| Complex filtering | @Query | Full SQL control |
| Modern projects | Limit interface | Latest Spring Boot feature |

### Q4: Performance mein kya difference hai?
**Answer:**
```java
// Fastest - Direct SQL generation
List<User> findTop5ByOrderByIdDesc();

// Good - But creates Page object overhead
Page<User> findAll(PageRequest.of(0, 5));

// Depends on query complexity
@Query("SELECT u FROM User u ORDER BY u.id DESC LIMIT 5")
List<User> findTop5Records();
```

---

## üö´ Common Mistakes

### Mistake 1: Wrong Return Type
```java
// ‚ùå Wrong
User findTop5ByActive(boolean active);  // Can't return single User for multiple records

// ‚úÖ Correct
List<User> findTop5ByActive(boolean active);
```

### Mistake 2: Missing Number in Top
```java
// ‚ùå Wrong
List<User> findTopByActive(boolean active);  // How many records?

// ‚úÖ Correct
List<User> findTop5ByActive(boolean active);
```

### Mistake 3: Wrong OrderBy Position
```java
// ‚ùå Wrong
List<User> findOrderByIdTop5ByActive(boolean active);

// ‚úÖ Correct
List<User> findTop5ByActiveOrderByIdDesc(boolean active);
```

### Mistake 4: Pageable Page Number Confusion
```java
// ‚ùå Wrong - Page numbers start from 0, not 1
PageRequest.of(1, 5);  // This gives records 6-10, not 1-5!

// ‚úÖ Correct - For first 5 records
PageRequest.of(0, 5);  // This gives records 1-5
```

### Mistake 5: LIMIT in Native Query
```java
// ‚ùå Wrong - LIMIT syntax varies by database
@Query(value = "SELECT * FROM users ORDER BY id DESC LIMIT 5", nativeQuery = true)

// ‚úÖ Better - Use JPQL (database independent)
@Query("SELECT u FROM User u ORDER BY u.id DESC LIMIT 5")
```

---

## üèÜ Best Practices

### 1. Choose Right Approach üìã
```java
// ‚úÖ For simple cases - Use Query Methods
List<User> findTop10ByOrderByCreatedDateDesc();

// ‚úÖ For pagination - Use Pageable
public Page<User> getUsers(int page, int size) {
    return userRepo.findAll(PageRequest.of(page, size));
}

// ‚úÖ For complex queries - Use @Query
@Query("SELECT u FROM User u WHERE u.active = true AND u.lastLogin >= :date ORDER BY u.points DESC LIMIT 5")
List<User> findTopActiveUsers(@Param("date") LocalDateTime date);
```

### 2. Performance Optimization ‚ö°
```java
// ‚úÖ Add database indexes for ORDER BY columns
@Entity
@Table(indexes = {
    @Index(name = "idx_user_active", columnList = "active"),
    @Index(name = "idx_user_created_date", columnList = "createdDate")
})
public class User {
    // ...
}

// ‚úÖ Use specific column selection for large tables
@Query("SELECT new com.example.UserDto(u.id, u.name, u.email) FROM User u ORDER BY u.id DESC LIMIT 5")
List<UserDto> findTop5UserDtos();
```

### 3. Error Handling üõ°Ô∏è
```java
@Service
public class UserService {
    public List<User> getTopUsers(int count) {
        try {
            if (count <= 0) {
                throw new IllegalArgumentException("Count must be positive");
            }
            
            // Dynamic query method call
            return userRepo.findByOrderByIdDesc(Limit.of(count));
        } catch (Exception e) {
            log.error("Error fetching top users: ", e);
            return Collections.emptyList();
        }
    }
}
```

### 4. Testing Top Records üß™
```java
@DataJpaTest
class UserRepositoryTest {
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldReturnTop5Users() {
        // Given
        createTestUsers(10);  // Create 10 test users
        
        // When
        List<User> top5Users = userRepository.findTop5ByOrderByIdDesc();
        
        // Then
        assertThat(top5Users).hasSize(5);
        assertThat(top5Users.get(0).getId()).isEqualTo(10L);  // Highest ID first
        assertThat(top5Users.get(4).getId()).isEqualTo(6L);   // 5th highest ID
    }
    
    @Test
    void shouldReturnTop5WithPageable() {
        // Given
        createTestUsers(10);
        
        // When
        Page<User> result = userRepository.findAll(PageRequest.of(0, 5));
        
        // Then
        assertThat(result.getContent()).hasSize(5);
        assertThat(result.getTotalElements()).isEqualTo(10);
        assertThat(result.getTotalPages()).isEqualTo(2);
    }
}
```

---

## üì¶ Complete Working Example

### Entity Class
```java
@Data
@Entity
@Table(name = "user_tbl")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    private boolean active;
    private Double rating;
    
    @CreationTimestamp
    private LocalDateTime createdDate;
}
```

### Repository Interface
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    // Method 1: Query Method
    List<User> findTop5ByActive(boolean active);
    List<User> findTop5ByOrderByRatingDesc();
    
    // Method 2: @Query
    @Query("SELECT u FROM User u ORDER BY u.createdDate DESC LIMIT 5")
    List<User> findRecentTop5Users();
    
    // Method 4: Limit interface
    List<User> findByOrderByRatingDesc(Limit limit);
}
```

### Service Layer
```java
@Service
@Transactional(readOnly = true)
public class UserService {
    
    @Autowired
    private UserRepository userRepo;
    
    // All 4 methods implemented
    public List<User> getTop5ActiveUsers() {
        return userRepo.findTop5ByActive(true);
    }
    
    public List<User> getTop5RecentUsers() {
        return userRepo.findRecentTop5Users();
    }
    
    public Page<User> getTop5UsersWithPagination() {
        Pageable topFive = PageRequest.of(0, 5, 
            Sort.by(Sort.Direction.DESC, "rating"));
        return userRepo.findAll(topFive);
    }
    
    public List<User> getTopRatedUsers(int count) {
        return userRepo.findByOrderByRatingDesc(Limit.of(count));
    }
}
```

### Controller Layer
```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    @GetMapping("/top5/active")
    public ResponseEntity<List<User>> getTop5Active() {
        List<User> users = userService.getTop5ActiveUsers();
        return ResponseEntity.ok(users);
    }
    
    @GetMapping("/top5/recent")
    public ResponseEntity<List<User>> getTop5Recent() {
        List<User> users = userService.getTop5RecentUsers();
        return ResponseEntity.ok(users);
    }
    
    @GetMapping("/top5/pageable")
    public ResponseEntity<Page<User>> getTop5WithPagination() {
        Page<User> users = userService.getTop5UsersWithPagination();
        return ResponseEntity.ok(users);
    }
    
    @GetMapping("/top/{count}/rated")
    public ResponseEntity<List<User>> getTopRated(@PathVariable int count) {
        List<User> users = userService.getTopRatedUsers(count);
        return ResponseEntity.ok(users);
    }
}
```

---

## üéØ Summary/Quick Recap

### Key Takeaways üß†
1. **4 Ways to Get Top Records:**
   - Query Methods (`findTop5By...`)
   - @Query annotation with LIMIT
   - Pageable interface
   - Limit interface (modern)

2. **When to Use What:**
   - Simple queries ‚Üí Query Methods
   - Complex filtering ‚Üí @Query
   - Pagination needed ‚Üí Pageable
   - Latest projects ‚Üí Limit interface

3. **Memory Tricks üß†:**
   - **Top** = **T**ake **O**nly **P**articular records
   - **Pageable** = **P**age number starts from **0**
   - **Limit.of(5)** = **L**imit **of** 5 records

### Performance Tips ‚ö°
- Add indexes on ORDER BY columns
- Use DTOs for large result sets
- Consider pagination for UI
- Test with realistic data volumes

### Interview Ready Points üìö
- Explain all 4 approaches with examples
- Know when to use which method
- Understand Page vs List return types
- Performance implications of each approach

**Yaad rakhne ka golden rule:** Simple queries ke liye Query Methods, complex ke liye @Query, pagination ke liye Pageable! üåü

---

> **Pro Tip:** Real projects mein sabse zyada Pageable use hota hai kyunki UI mein pagination chahiye hota hai. But interviews mein sabka knowledge hona important hai! üí™
