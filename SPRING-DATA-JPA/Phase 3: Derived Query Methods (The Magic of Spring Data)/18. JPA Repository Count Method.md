# Spring Data JPA - Count Methods Complete Guide üìä

> Bhai, Spring Data JPA mein count methods ka use karna sikho! Database mein records count karna hai? Easy peasy! üéØ

---

## 1. Introduction - Confusion Clearing! ü§î

### Simple Explanation First üë∂
Yaar, **count methods** ka matlab simple hai - database table mein kitne records hain, ye pata karna! Just like ghar mein aam kitne hain count karna, but database version! 

### Real-Life Analogy üè†
```
Instagram stories dekhte ho? Waha "View count" dikhta hai na?
- Total views: 145 (ye hai count() method)
- Friends views: 32 (ye hai countByFriends() method) 
- Family views: 13 (ye hai countByFamily() method)

Same way, database mein bhi count karte hain!
```

### Technical Definition üìö
JPA Repository ‡§Æ‡•á‡§Ç count method ‡§è‡§ï query method ‡§π‡•à ‡§ú‡•ã total number of entities return ‡§ï‡§∞‡§§‡•Ä ‡§π‡•à database table ‡§∏‡•á. Ye method pagination, data validation, aur existence checking ‡§ï‡•á ‡§≤‡§ø‡§è use ‡§π‡•ã‡§§‡•Ä ‡§π‡•à.

---

## 2. Key Terms/Concepts üîë

### Important Terminology üìñ

| Term | Hindi Meaning | Technical Definition |
|------|-------------|-------------------|
| **JpaRepository** | Database Repository | Spring interface jo CRUD operations provide ‡§ï‡§∞‡§§‡•Ä ‡§π‡•à |
| **count()** | ‡§ï‡•Å‡§≤ ‡§ó‡§ø‡§®‡§§‡•Ä | ‡§∏‡§≠‡•Ä records ‡§ï‡•Ä ‡§ó‡§ø‡§®‡§§‡•Ä ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡§æ method |
| **countBy...()** | ‡§∂‡§∞‡•ç‡§§ ‡§ï‡•á ‡§∏‡§æ‡§• ‡§ó‡§ø‡§®‡§§‡•Ä | Specific criteria ‡§ï‡•á ‡§∏‡§æ‡§• count ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡§æ method |
| **Entity** | ‡§°‡•á‡§ü‡§æ ‡§Æ‡•â‡§°‡§≤ | Database table ‡§ï‡§æ Java representation |
| **Criteria** | ‡§∂‡§∞‡•ç‡§§/‡§Æ‡§æ‡§™‡§¶‡§Ç‡§° | Filtering conditions for counting |

### Visual Representation üé®
```
üìä Count Methods Family Tree
‚îú‚îÄ‚îÄ count()                    ‚ûú ‡§∏‡§≠‡•Ä records count ‡§ï‡§∞‡•ã
‚îú‚îÄ‚îÄ countByProperty()          ‚ûú Property ‡§ï‡•á basis ‡§™‡§∞ count ‡§ï‡§∞‡•ã  
‚îú‚îÄ‚îÄ countByPropertyAndOther()  ‚ûú Multiple conditions ‡§ï‡•á ‡§∏‡§æ‡§•
‚îî‚îÄ‚îÄ @Query with COUNT(...)     ‚ûú Custom count queries
```

---

## 3. Detailed Examples üíª

### Basic Setup First üèóÔ∏è

```java
// Entity Class - User.java
@Entity
@Data  // Lombok annotation for getters/setters
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    private String email;
    private String status;    // Active, Inactive, Blocked
    private Integer age;
    private String city;
}
```

### Repository Interface üè™

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Basic count methods
    // count() already available from JpaRepository
    
    // Custom count methods
    long countByStatus(String status);
    long countByAge(Integer age);
    long countByCity(String city);
    
    // Multiple conditions
    long countByStatusAndAge(String status, Integer age);
    long countByStatusOrAge(String status, Integer age);
    
    // Range-based counting
    long countByAgeBetween(Integer startAge, Integer endAge);
    long countByAgeGreaterThan(Integer age);
    long countByAgeLessThan(Integer age);
    
    // String operations
    long countByNameContaining(String name);
    long countByEmailEndingWith(String domain);
    
    // Null checks
    long countByEmailIsNull();
    long countByEmailIsNotNull();
    
    // Custom query with @Query
    @Query("SELECT COUNT(u) FROM User u WHERE u.status = :status")
    long countUsersByStatus(@Param("status") String status);
    
    // Native query example
    @Query(value = "SELECT COUNT(*) FROM user WHERE city = ?1", nativeQuery = true)
    long countByCityNative(String city);
}
```

### Service Class Implementation üõ†Ô∏è

```java
@Service
public class UserService {
    
    @Autowired
    private UserRepository userRepository;
    
    // Basic count - ‡§∏‡§≠‡•Ä users
    public long getAllUsersCount() {
        return userRepository.count();
    }
    
    // Status-wise count
    public long getActiveUsersCount() {
        return userRepository.countByStatus("Active");
    }
    
    // Age-wise statistics
    public UserStatsDTO getUserStats() {
        UserStatsDTO stats = new UserStatsDTO();
        
        stats.setTotalUsers(userRepository.count());
        stats.setActiveUsers(userRepository.countByStatus("Active"));
        stats.setInactiveUsers(userRepository.countByStatus("Inactive"));
        stats.setAdults(userRepository.countByAgeGreaterThan(18));
        stats.setMinors(userRepository.countByAgeLessThan(18));
        
        return stats;
    }
    
    // City-wise distribution
    public Map<String, Long> getCityWiseCount() {
        // Ye approach thoda inefficient hai large data ke liye
        // Better approach: use native query with GROUP BY
        
        List<String> cities = Arrays.asList("Delhi", "Mumbai", "Bangalore", "Chennai");
        Map<String, Long> cityStats = new HashMap<>();
        
        for (String city : cities) {
            cityStats.put(city, userRepository.countByCity(city));
        }
        
        return cityStats;
    }
}
```

### Controller Implementation üéÆ

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    @Autowired
    private UserService userService;
    
    // Get total count
    @GetMapping("/count")
    public ResponseEntity<Long> getTotalCount() {
        long count = userService.getAllUsersCount();
        return ResponseEntity.ok(count);
    }
    
    // Get count by status
    @GetMapping("/count/status/{status}")
    public ResponseEntity<Long> getCountByStatus(@PathVariable String status) {
        long count = userService.getActiveUsersCount();
        return ResponseEntity.ok(count);
    }
    
    // Get detailed stats
    @GetMapping("/stats")
    public ResponseEntity<UserStatsDTO> getUserStats() {
        UserStatsDTO stats = userService.getUserStats();
        return ResponseEntity.ok(stats);
    }
}
```

### Expected Output üì§

```bash
# API Calls ‡§î‡§∞ Results:

GET /api/users/count
Response: 150

GET /api/users/count/status/Active  
Response: 89

GET /api/users/stats
Response: {
    "totalUsers": 150,
    "activeUsers": 89,
    "inactiveUsers": 45,
    "blockedUsers": 16,
    "adults": 134,
    "minors": 16
}

# Console SQL Logs:
Hibernate: select count(*) as col_0_0_ from user user0_
Hibernate: select count(user0_.id) as col_0_0_ from user user0_ where user0_.status=?
```

---

## 4. Rules/Guidelines üìã

### Rule 1: Method Naming Convention ‚úÖ
```java
// ‚úÖ Correct - Follow Spring Data JPA naming
long countByStatus(String status);
long countByStatusAndAge(String status, Integer age);
long countByAgeBetween(Integer start, Integer end);

// ‚ùå Wrong - Invalid naming
long getCountOfStatus(String status);  // Won't work
long statusCount(String status);       // Won't work
```

### Rule 2: Return Type Should Be Numeric ‚úÖ
```java
// ‚úÖ Correct return types
long countByStatus(String status);      // Recommended
int countByStatus(String status);       // Also works
Long countByStatus(String status);      // Wrapper class
Integer countByStatus(String status);   // Wrapper class

// ‚ùå Wrong return types  
String countByStatus(String status);    // Won't compile
List<User> countByStatus(String status); // Wrong purpose
```

### Rule 3: Parameter Types Must Match Entity Fields ‚úÖ
```java
// Entity field: private String status;
// ‚úÖ Correct parameter type
long countByStatus(String status);

// Entity field: private Integer age;
// ‚úÖ Correct parameter type  
long countByAge(Integer age);

// ‚ùå Wrong parameter type
long countByAge(String age);  // Type mismatch error
```

### Rule 4: Case Sensitivity Matters ‚úÖ
```java
// Entity field: private String firstName;
// ‚úÖ Correct case
long countByFirstName(String firstName);

// ‚ùå Wrong case
long countByFirstname(String firstName);  // Field not found error
long countByfirstName(String firstName);  // Invalid method name
```

### Rule 5: Use @Query for Complex Counts ‚úÖ
```java
// ‚úÖ Complex counting with custom query
@Query("SELECT COUNT(u) FROM User u WHERE u.age > :minAge AND u.status = :status")
long countByAgeGreaterThanAndStatus(@Param("minAge") Integer minAge, 
                                   @Param("status") String status);

// ‚úÖ Native query for database-specific functions
@Query(value = "SELECT COUNT(DISTINCT city) FROM user WHERE status = ?1", 
       nativeQuery = true)
long countDistinctCitiesByStatus(String status);
```

---

## 5. Real-World Applications üåç

### Banking System Example üè¶
```java
@Entity
public class Account {
    @Id
    private String accountNumber;
    private String accountType;  // Savings, Current, FD
    private String status;       // Active, Dormant, Closed
    private BigDecimal balance;
    private String branch;
}

@Repository
public interface AccountRepository extends JpaRepository<Account, String> {
    // Branch-wise account statistics
    long countByBranch(String branch);
    
    // Account type distribution
    long countByAccountType(String accountType);
    
    // Active accounts only
    long countByStatus(String status);
    
    // High-value accounts (balance > 1 lakh)
    @Query("SELECT COUNT(a) FROM Account a WHERE a.balance > :amount")
    long countHighValueAccounts(@Param("amount") BigDecimal amount);
    
    // Zero balance accounts
    @Query("SELECT COUNT(a) FROM Account a WHERE a.balance = 0")
    long countZeroBalanceAccounts();
}

@Service
public class BankingService {
    
    @Autowired
    private AccountRepository accountRepository;
    
    public BankingReportDTO generateReport() {
        BankingReportDTO report = new BankingReportDTO();
        
        // Total accounts
        report.setTotalAccounts(accountRepository.count());
        
        // By type
        report.setSavingsAccounts(accountRepository.countByAccountType("Savings"));
        report.setCurrentAccounts(accountRepository.countByAccountType("Current"));
        report.setFixedDeposits(accountRepository.countByAccountType("FD"));
        
        // By status
        report.setActiveAccounts(accountRepository.countByStatus("Active"));
        report.setDormantAccounts(accountRepository.countByStatus("Dormant"));
        
        // Special categories
        report.setHighValueAccounts(
            accountRepository.countHighValueAccounts(new BigDecimal("100000"))
        );
        report.setZeroBalanceAccounts(accountRepository.countZeroBalanceAccounts());
        
        return report;
    }
}
```

### E-commerce System Example üõí
```java
@Entity
public class Product {
    @Id
    private Long id;
    private String name;
    private String category;     // Electronics, Clothing, Books
    private String brand;
    private BigDecimal price;
    private Integer stock;
    private Boolean active;
    private LocalDateTime createdDate;
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    // Category-wise count
    long countByCategory(String category);
    
    // Brand-wise count
    long countByBrand(String brand);
    
    // Active products only
    long countByActiveTrue();
    
    // Out of stock products
    long countByStock(Integer stock);  // stock = 0
    
    // Price range counting
    long countByPriceBetween(BigDecimal minPrice, BigDecimal maxPrice);
    
    // Recent products (last 30 days)
    @Query("SELECT COUNT(p) FROM Product p WHERE p.createdDate > :date")
    long countRecentProducts(@Param("date") LocalDateTime date);
    
    // Low stock alert (stock < 10)
    @Query("SELECT COUNT(p) FROM Product p WHERE p.stock < :threshold AND p.active = true")
    long countLowStockProducts(@Param("threshold") Integer threshold);
}
```

### Student Management System Example üéì
```java
@Entity
public class Student {
    @Id
    private Long id;
    private String name;
    private String course;       // B.Tech, MBA, M.Tech
    private String department;   // CSE, ECE, Mechanical
    private Integer semester;
    private String status;       // Active, Graduated, Dropped
    private Integer age;
    private String city;
}

@Repository
public interface StudentRepository extends JpaRepository<Student, Long> {
    // Department-wise strength
    long countByDepartment(String department);
    
    // Course-wise distribution  
    long countByCourse(String course);
    
    // Semester-wise count
    long countBySemester(Integer semester);
    
    // Active students
    long countByStatus(String status);
    
    // Age group analysis
    long countByAgeBetween(Integer minAge, Integer maxAge);
    
    // City-wise students
    long countByCity(String city);
    
    // Course and department combination
    long countByCourseAndDepartment(String course, String department);
}
```

---

## 6. Comparison Tables üìä

### Count Methods Comparison

| Method Type | Use Case | Performance | Complexity | Example |
|------------|----------|-------------|------------|---------|
| `count()` | Total records | Fast ‚ö° | Simple üòä | `userRepo.count()` |
| `countBy...()` | Single condition | Fast ‚ö° | Simple üòä | `countByStatus("Active")` |
| `countBy...And...()` | Multiple AND conditions | Medium üö∂ | Medium üòê | `countByStatusAndAge("Active", 25)` |
| `countBy...Or...()` | Multiple OR conditions | Medium üö∂ | Medium üòê | `countByStatusOrAge("Active", 25)` |
| `@Query COUNT()` | Complex conditions | Fast-Medium üö∂ | High üòÖ | Custom SQL with joins |
| `Native Query` | Database-specific | Fastest ‚ö°‚ö° | High üòÖ | `COUNT(DISTINCT ...)` |

### When to Use What? ü§î

| Scenario | Best Method | Reason |
|----------|-------------|--------|
| Dashboard total users | `count()` | Simple, cached by database |
| Active users count | `countByStatus()` | Single indexed column |
| Complex business logic | `@Query` | Full control over SQL |
| Performance critical | Native query | Direct SQL execution |
| Multiple tables | `@Query` with JOIN | Repository can't handle joins |

---

## 7. Interview Questions üé§

### Question 1: Basic Count Methods
**Q: What's the difference between `count()` and `countBy...()`?**

**Answer:** 
```java
// count() - JpaRepository se inherited method, total records count karta hai
long totalUsers = userRepository.count();

// countBy...() - Custom method, specific criteria ke saath count karta hai  
long activeUsers = userRepository.countByStatus("Active");

// SQL generated:
// count(): SELECT COUNT(*) FROM user
// countByStatus(): SELECT COUNT(*) FROM user WHERE status = ?
```

### Question 2: Performance Considerations
**Q: Which is more efficient for counting - `findAll().size()` or `count()`?**

**Answer:**
```java
// ‚ùå WRONG - Memory intensive, loads all data
List<User> users = userRepository.findAll();
int count = users.size();  // Loads everything in memory!

// ‚úÖ CORRECT - Database level counting, efficient
long count = userRepository.count();  // Only returns count number

// Why count() is better:
// 1. No data transfer from DB to application
// 2. Database engines optimize COUNT queries
// 3. No memory overhead
// 4. Much faster for large datasets
```

### Question 3: Complex Counting Scenarios
**Q: How to count distinct values using JPA?**

**Answer:**
```java
// Method 1: Using @Query with JPQL
@Query("SELECT COUNT(DISTINCT u.city) FROM User u")
long countDistinctCities();

// Method 2: Using native query  
@Query(value = "SELECT COUNT(DISTINCT city) FROM user", nativeQuery = true)
long countDistinctCitiesNative();

// Method 3: For more complex scenarios
@Query("SELECT COUNT(DISTINCT u.department) FROM User u WHERE u.status = :status")
long countDistinctDepartmentsByStatus(@Param("status") String status);
```

### Question 4: Tricky Scenario
**Q: What happens if countBy method parameter is null?**

**Answer:**
```java
// ‡§Ø‡§π method call:
long count = userRepository.countByStatus(null);

// Generate ‡§ï‡§∞‡•á‡§ó‡§æ:
// SELECT COUNT(*) FROM user WHERE status IS NULL

// ‡§Ö‡§ó‡§∞ ‡§Ü‡§™ null values ‡§ï‡•ã handle ‡§ï‡§∞‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç:
@Query("SELECT COUNT(u) FROM User u WHERE (:status IS NULL OR u.status = :status)")
long countByStatusSafely(@Param("status") String status);
```

---

## 8. Common Mistakes ‚ö†Ô∏è

### Mistake 1: Loading All Data for Counting ‚ùå
```java
// ‚ùå ‡§¨‡§π‡•Å‡§§ ‡§ó‡§≤‡§§ approach - Memory wastage!
@Service
public class BadUserService {
    public long getUserCount() {
        List<User> allUsers = userRepository.findAll();
        return allUsers.size();  // üò± Sab data memory mein load kiya!
    }
}

// ‚úÖ ‡§∏‡§π‡•Ä approach
@Service  
public class GoodUserService {
    public long getUserCount() {
        return userRepository.count();  // üëç Sirf count return kiya!
    }
}
```

### Mistake 2: Wrong Method Naming ‚ùå
```java
// ‚ùå Ye methods kaam ‡§®‡§π‡•Ä‡§Ç ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á
public interface UserRepository extends JpaRepository<User, Long> {
    long getCountByStatus(String status);    // get prefix wrong ‡§π‡•à
    long totalByStatus(String status);       // total prefix wrong ‡§π‡•à  
    long statusCount(String status);         // count suffix missing
}

// ‚úÖ ‡§∏‡§π‡•Ä naming convention
public interface UserRepository extends JpaRepository<User, Long> {
    long countByStatus(String status);           // Perfect! ‚ú®
    long countByStatusAndAge(String status, Integer age);
    long countByAgeBetween(Integer min, Integer max);
}
```

### Mistake 3: Ignoring Case Sensitivity ‚ùå
```java
// Entity field name: firstName
@Entity
public class User {
    private String firstName;  // Camel case
}

// ‚ùå Wrong method names
long countByFirstname(String name);    // 'name' should be 'Name'  
long countByfirstName(String name);    // 'f' should be 'F'

// ‚úÖ Correct method name
long countByFirstName(String name);    // Perfect match! ‚ú®
```

### Mistake 4: Using Wrong Return Types ‚ùå
```java
// ‚ùå Wrong return types
String countByStatus(String status);        // String return type!
List<User> countByStatus(String status);    // List return type!
void countByStatus(String status);          // Void return type!

// ‚úÖ Correct return types
long countByStatus(String status);          // Recommended
int countByStatus(String status);           // Also okay
Long countByStatus(String status);          // Wrapper class
```

---

## 9. Best Practices üåü

### Practice 1: Use Appropriate Return Types üìù
```java
// ‚úÖ Use 'long' for large datasets (recommended)
long countByStatus(String status);

// ‚úÖ Use 'int' only if you're sure count won't exceed Integer.MAX_VALUE
int countBySmallDataset(String value);

// ‚úÖ Use wrapper classes if null handling needed
Long countByOptionalStatus(String status);
```

### Practice 2: Add Database Indexes üöÄ
```java
@Entity
@Table(indexes = {
    @Index(name = "idx_user_status", columnList = "status"),      // For countByStatus
    @Index(name = "idx_user_age", columnList = "age"),            // For countByAge  
    @Index(name = "idx_user_city", columnList = "city")           // For countByCity
})
public class User {
    private String status;
    private Integer age;
    private String city;
}

// Performance improvement with indexes:
// Without index: 2000ms for 1M records
// With index: 50ms for 1M records üöÄ
```

### Practice 3: Use @Query for Complex Scenarios üí°
```java
// ‚úÖ Complex counting with business logic
@Query("SELECT COUNT(u) FROM User u WHERE u.age BETWEEN :minAge AND :maxAge " +
       "AND u.status = 'Active' AND u.lastLoginDate > :cutoffDate")
long countActiveRecentUsers(@Param("minAge") Integer minAge,
                           @Param("maxAge") Integer maxAge, 
                           @Param("cutoffDate") LocalDateTime cutoffDate);

// ‚úÖ Counting with joins
@Query("SELECT COUNT(u) FROM User u JOIN u.orders o WHERE o.status = 'COMPLETED'")
long countUsersWithCompletedOrders();
```

### Practice 4: Error Handling üõ°Ô∏è
```java
@Service
public class UserService {
    
    public long getCountSafely(String status) {
        try {
            return userRepository.countByStatus(status);
        } catch (DataAccessException e) {
            log.error("Error counting users by status: {}", status, e);
            return 0L;  // Return default value or throw custom exception
        }
    }
    
    // Validation ‡§ï‡•á ‡§∏‡§æ‡§•
    public long getValidatedCount(String status) {
        if (status == null || status.trim().isEmpty()) {
            throw new IllegalArgumentException("Status cannot be null or empty");
        }
        
        return userRepository.countByStatus(status);
    }
}
```

### Practice 5: Caching for Frequent Counts üèÉ‚Äç‚ôÇÔ∏è
```java
@Service
public class UserService {
    
    // Redis/Spring cache ‡§ï‡§æ use ‡§ï‡§∞‡•á‡§Ç frequently accessed counts ‡§ï‡•á ‡§≤‡§ø‡§è
    @Cacheable(value = "userCounts", key = "#status")
    public long getCachedCountByStatus(String status) {
        return userRepository.countByStatus(status);
    }
    
    // Cache eviction when data changes
    @CacheEvict(value = "userCounts", allEntries = true)
    public void updateUserStatus(Long userId, String newStatus) {
        // Update logic
        userRepository.updateStatus(userId, newStatus);
    }
}
```

---

## 10. Summary/Quick Recap üìù

### Key Takeaways üéØ

**Yaad rakhne ka mantra - "COUNT ‡§ï‡§æ FUNDA":**
- **C**ount() = **C**omplete records
- **O**ptimize with indexes
- **U**se proper return types (long/int)
- **N**aming convention follow karo
- **T**est performance with large data

### Memory Tricks üß†

**"BASIC COUNT RULES":**
- **B**asic syntax: `countByPropertyName`
- **A**nd/Or for multiple conditions
- **S**QL optimization important hai  
- **I**ndex lagao performance ke liye
- **C**aching use karo frequent counts ke liye

### When to Use What? ü§∑‚Äç‚ôÇÔ∏è

```java
// üî• Quick Decision Tree:

// Simple counting ‚Üí count()
userRepository.count();

// Single condition ‚Üí countBy...()  
userRepository.countByStatus("Active");

// Multiple conditions ‚Üí countBy...And...()
userRepository.countByStatusAndAge("Active", 25);

// Complex logic ‚Üí @Query
@Query("SELECT COUNT(u) FROM User u WHERE ...")
```

### Final Pro Tips üí°

1. **Performance First**: Database-level counting > Application-level counting
2. **Index Your Columns**: Count queries ko fast banane ke liye
3. **Use Long Return Type**: Large datasets ‡§ï‡•á ‡§≤‡§ø‡§è safe
4. **Cache Frequently Used Counts**: Redis/Spring Cache use karo
5. **Handle Null Values**: Proper validation aur null checks

---

## Bonus: Advanced Count Patterns üöÄ

### Pattern 1: Conditional Counting
```java
// Dynamic counting based on conditions
@Query("SELECT COUNT(u) FROM User u WHERE " +
       "(:status IS NULL OR u.status = :status) AND " +
       "(:minAge IS NULL OR u.age >= :minAge)")
long countWithOptionalFilters(@Param("status") String status,
                             @Param("minAge") Integer minAge);
```

### Pattern 2: Grouped Counting
```java
// Count grouped by property - returns Map
@Query("SELECT u.status, COUNT(u) FROM User u GROUP BY u.status")
List<Object[]> countGroupedByStatus();

// Convert to Map for easy access
public Map<String, Long> getStatusCounts() {
    return userRepository.countGroupedByStatus()
        .stream()
        .collect(Collectors.toMap(
            row -> (String) row[0],    // status
            row -> (Long) row[1]       // count
        ));
}
```

### Pattern 3: Percentage Calculations
```java
public class UserStatsService {
    
    public UserStatsDTO getDetailedStats() {
        long total = userRepository.count();
        long active = userRepository.countByStatus("Active");
        
        UserStatsDTO stats = new UserStatsDTO();
        stats.setTotal(total);
        stats.setActive(active);
        stats.setActivePercentage((active * 100.0) / total);  // Percentage
        
        return stats;
    }
}
```

---

**Happy Coding, Bhai! üöÄ Ab jaake Spring Data JPA mein count methods ka master bano!** 

*Remember: Practice makes perfect! Ye sab concepts ko code karke try karo!* üí™
