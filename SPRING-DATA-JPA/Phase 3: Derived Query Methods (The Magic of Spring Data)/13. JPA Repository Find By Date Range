# ğŸ“… JPA Repository Find By Date Range - Complete Hinglish Guide

## ğŸ¤” Introduction - Confusion Clear Karte Hain

### Simple Explanation Pehle (Bhai Style) ğŸ˜
Yaar, kabhi socha hai ki **Amazon** ya **Flipkart** mein jab tum "Last 30 days orders" dekhte ho, to wo kaise karta hai? Ya phir bank statement mein "1st Jan se 31st March tak" ke transactions? 

**Simple words mein:** JPA Repository Find By Date Range matlab hai - database se specific dates ke beech ke records nikalna! ğŸ¯

### Real-life Analogy ğŸŒŸ
Imagine karo tumhare paas ek **diary** hai jismein har din ka entry hai:
- ğŸ“ 1st January - School gaya
- ğŸ“ 15th February - Movie dekhi  
- ğŸ“ 20th March - Birthday party

Ab agar tumhe **January se February** tak ke entries chahiye, to tum pages flip karoge na? Database mein bhi same concept hai - Spring Data JPA automatically SQL query banata hai jo specific date range ke records fetch karta hai!

### Technical Definition ğŸ”§
> **JPA Repository Find By Date Range** is a Spring Data JPA feature that allows you to query entities based on date/time fields using the `Between` keyword in repository method names. It generates SQL queries with `WHERE date_column BETWEEN startDate AND endDate` clause.

---

## ğŸ“š Key Terms/Concepts

### Important Terminology ğŸ¯

| Term | Technical Definition |
|------|---------------------|
| **Between Keyword** | Used in method names to create range queries |
| **LocalDate** | Java 8+ date class (time zone independent) |
| **LocalDateTime** | Java 8+ date-time class with time |
| **Repository Method** | Auto-generated database queries |
| **Query Derivation** | Spring's automatic SQL generation |

### Visual Representation ğŸ“Š
```
ğŸ—„ï¸ Database Table
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ EMPLOYEE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ID      â”‚ NAME        â”‚ HIRE_DATE   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1       â”‚ Rahul       â”‚ 2023-01-15  â”‚
â”‚ 2       â”‚ Priya       â”‚ 2023-03-20  â”‚
â”‚ 3       â”‚ Arjun       â”‚ 2023-05-10  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ” Query: findByHireDateBetween(2023-01-01, 2023-03-31)
ğŸ“Š Result: Returns Rahul and Priya
```

---

## ğŸ’» Detailed Examples

### Complete Working Code Examples

#### 1ï¸âƒ£ Basic Entity Setup
```java
package com.springjava.entity;

import java.time.LocalDate;
import javax.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "first_name")
    private String firstName;
    
    @Column(name = "last_name") 
    private String lastName;
    
    private String department;
    
    @Column(name = "hire_date")
    private LocalDate hireDate;
    
    @Column(name = "salary")
    private Double salary;
    
    // Constructors
    public Employee() {}
    
    public Employee(String firstName, String lastName, 
                   String department, LocalDate hireDate, Double salary) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.department = department;
        this.hireDate = hireDate;
        this.salary = salary;
    }
}
```

#### 2ï¸âƒ£ Repository Interface
```java
package com.springjava.repository;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import com.springjava.entity.Employee;

@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // âœ… Basic Date Range Query
    List<Employee> findByHireDateBetween(LocalDate startDate, LocalDate endDate);
    
    // âœ… Date Range with Additional Conditions
    List<Employee> findByHireDateBetweenAndDepartment(
        LocalDate startDate, LocalDate endDate, String department);
    
    // âœ… Date Range with Salary Filter
    List<Employee> findByHireDateBetweenAndSalaryGreaterThan(
        LocalDate startDate, LocalDate endDate, Double salary);
    
    // âœ… Custom JPQL Query
    @Query("SELECT e FROM Employee e WHERE e.hireDate BETWEEN :startDate AND :endDate")
    List<Employee> findEmployeesByDateRange(
        @Param("startDate") LocalDate startDate, 
        @Param("endDate") LocalDate endDate);
    
    // âœ… Native SQL Query
    @Query(value = "SELECT * FROM employees WHERE hire_date BETWEEN ?1 AND ?2", 
           nativeQuery = true)
    List<Employee> findByDateRangeNative(LocalDate startDate, LocalDate endDate);
    
    // âœ… Count Employees in Date Range
    Long countByHireDateBetween(LocalDate startDate, LocalDate endDate);
    
    // âœ… Check if Exists in Date Range
    boolean existsByHireDateBetween(LocalDate startDate, LocalDate endDate);
}
```

#### 3ï¸âƒ£ Service Layer Implementation
```java
package com.springjava.service;

import java.time.LocalDate;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.springjava.entity.Employee;
import com.springjava.repository.EmployeeRepository;

@Service
public class EmployeeService {
    
    @Autowired
    private EmployeeRepository employeeRepository;
    
    // Save employee
    public Employee saveEmployee(Employee employee) {
        return employeeRepository.save(employee);
    }
    
    // Get employees by date range
    public List<Employee> getEmployeesByDateRange(LocalDate startDate, LocalDate endDate) {
        return employeeRepository.findByHireDateBetween(startDate, endDate);
    }
    
    // Get employees hired in current month
    public List<Employee> getEmployeesHiredThisMonth() {
        LocalDate startOfMonth = LocalDate.now().withDayOfMonth(1);
        LocalDate endOfMonth = LocalDate.now().withDayOfMonth(
            LocalDate.now().lengthOfMonth());
        
        return employeeRepository.findByHireDateBetween(startOfMonth, endOfMonth);
    }
    
    // Get employees hired in last N days
    public List<Employee> getEmployeesHiredInLastNDays(int days) {
        LocalDate endDate = LocalDate.now();
        LocalDate startDate = endDate.minusDays(days);
        
        return employeeRepository.findByHireDateBetween(startDate, endDate);
    }
    
    // Get department wise employees by date range
    public List<Employee> getEmployeesByDateRangeAndDepartment(
            LocalDate startDate, LocalDate endDate, String department) {
        return employeeRepository.findByHireDateBetweenAndDepartment(
            startDate, endDate, department);
    }
}
```

#### 4ï¸âƒ£ REST Controller
```java
package com.springjava.controller;

import java.time.LocalDate;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.springjava.entity.Employee;
import com.springjava.service.EmployeeService;

@RestController
@RequestMapping("/api/employees")
@CrossOrigin("*")
public class EmployeeController {
    
    @Autowired
    private EmployeeService employeeService;
    
    // Save employee
    @PostMapping("/save")
    public ResponseEntity<?> saveEmployee(@RequestBody Employee employee) {
        Map<String, Object> response = new HashMap<>();
        try {
            Employee savedEmployee = employeeService.saveEmployee(employee);
            response.put("status", 1);
            response.put("message", "Employee saved successfully! ğŸ‰");
            response.put("data", savedEmployee);
            return ResponseEntity.status(HttpStatus.CREATED).body(response);
        } catch (Exception e) {
            response.put("status", 0);
            response.put("message", "Error saving employee: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    // Get employees by date range
    @GetMapping("/date-range")
    public ResponseEntity<?> getEmployeesByDateRange(
            @RequestParam("startDate") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate startDate,
            @RequestParam("endDate") @DateTimeFormat(iso = DateTimeFormat.ISO.DATE) LocalDate endDate) {
        
        Map<String, Object> response = new HashMap<>();
        try {
            List<Employee> employees = employeeService.getEmployeesByDateRange(startDate, endDate);
            
            if (!employees.isEmpty()) {
                response.put("status", 1);
                response.put("message", "Data found successfully! ğŸ“Š");
                response.put("count", employees.size());
                response.put("data", employees);
                return ResponseEntity.ok(response);
            } else {
                response.put("status", 0);
                response.put("message", "No employees found in given date range ğŸ˜”");
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
            }
        } catch (Exception e) {
            response.put("status", 0);
            response.put("message", "Error: " + e.getMessage());
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
    }
    
    // Get employees hired this month
    @GetMapping("/current-month")
    public ResponseEntity<?> getEmployeesHiredThisMonth() {
        Map<String, Object> response = new HashMap<>();
        List<Employee> employees = employeeService.getEmployeesHiredThisMonth();
        
        response.put("status", 1);
        response.put("message", "Current month hires ğŸ“…");
        response.put("count", employees.size());
        response.put("data", employees);
        
        return ResponseEntity.ok(response);
    }
    
    // Get employees hired in last N days
    @GetMapping("/last-n-days/{days}")
    public ResponseEntity<?> getEmployeesHiredInLastNDays(@PathVariable int days) {
        Map<String, Object> response = new HashMap<>();
        List<Employee> employees = employeeService.getEmployeesHiredInLastNDays(days);
        
        response.put("status", 1);
        response.put("message", "Last " + days + " days hires ğŸ•");
        response.put("count", employees.size());
        response.put("data", employees);
        
        return ResponseEntity.ok(response);
    }
}
```

### Expected Outputs ğŸ“¤

#### API Response Example:
```json
{
    "status": 1,
    "message": "Data found successfully! ğŸ“Š",
    "count": 2,
    "data": [
        {
            "id": 1,
            "firstName": "Rahul",
            "lastName": "Sharma",
            "department": "IT",
            "hireDate": "2023-01-15",
            "salary": 50000.0
        },
        {
            "id": 2,
            "firstName": "Priya",
            "lastName": "Singh",
            "department": "HR",
            "hireDate": "2023-02-20",
            "salary": 45000.0
        }
    ]
}
```

#### Generated SQL Query:
```sql
Hibernate: 
    select
        employee0_.id as id1_0_,
        employee0_.department as departme2_0_,
        employee0_.first_name as first_na3_0_,
        employee0_.hire_date as hire_dat4_0_,
        employee0_.last_name as last_nam5_0_,
        employee0_.salary as salary6_0_ 
    from
        employees employee0_ 
    where
        employee0_.hire_date between ? and ?
```

---

## ğŸ“‹ Rules/Guidelines

### 1ï¸âƒ£ Method Naming Convention Rules
âœ… **Correct Examples:**
```java
// Rule 1: Always start with findBy/countBy/existsBy
findByHireDateBetween(LocalDate start, LocalDate end)
countByHireDateBetween(LocalDate start, LocalDate end)
existsByHireDateBetween(LocalDate start, LocalDate end)

// Rule 2: Use exact property name from Entity
findByHireDateBetween() // âœ… If property name is hireDate
findByCreatedDateBetween() // âœ… If property name is createdDate
```

âŒ **Incorrect Examples:**
```java
// âŒ Wrong: Missing 'findBy' prefix
hireDateBetween(LocalDate start, LocalDate end)

// âŒ Wrong: Property name mismatch
findByHireDatesBetween() // Property is hireDate, not hireDates

// âŒ Wrong: Typo in Between
findByHireDateBetwen(LocalDate start, LocalDate end)
```

**Error Message:**
```
org.springframework.data.mapping.PropertyReferenceException: 
No property hireDates found for type Employee!
```

### 2ï¸âƒ£ Parameter Order Rules
âœ… **Correct:**
```java
// Rule: Start date first, end date second
List<Employee> findByHireDateBetween(LocalDate startDate, LocalDate endDate);

// Rule: Additional parameters come after date parameters
List<Employee> findByHireDateBetweenAndDepartment(
    LocalDate startDate, LocalDate endDate, String department);
```

âŒ **Incorrect:**
```java
// âŒ Wrong: End date before start date (logically wrong)
List<Employee> findByHireDateBetween(LocalDate endDate, LocalDate startDate);
```

### 3ï¸âƒ£ Date Type Compatibility Rules
âœ… **Compatible Types:**
```java
// LocalDate - for date only
List<Employee> findByHireDateBetween(LocalDate start, LocalDate end);

// LocalDateTime - for date and time
List<Employee> findByCreatedTimeBetween(LocalDateTime start, LocalDateTime end);

// Date - legacy support
List<Employee> findByHireDateBetween(Date start, Date end);
```

âŒ **Incompatible:**
```java
// âŒ Wrong: Mixed types
List<Employee> findByHireDateBetween(LocalDate start, LocalDateTime end);

// âŒ Wrong: String dates (won't compile)
List<Employee> findByHireDateBetween(String start, String end);
```

### 4ï¸âƒ£ Null Handling Rules
âœ… **Safe Approach:**
```java
@Service
public class EmployeeService {
    
    public List<Employee> getEmployeesByDateRange(LocalDate start, LocalDate end) {
        // Rule: Always validate parameters
        if (start == null || end == null) {
            throw new IllegalArgumentException("Start and end dates cannot be null");
        }
        
        if (start.isAfter(end)) {
            throw new IllegalArgumentException("Start date cannot be after end date");
        }
        
        return employeeRepository.findByHireDateBetween(start, end);
    }
}
```

---

## ğŸŒ Real-world Applications

### 1ï¸âƒ£ Banking System ğŸ¦
```java
@Entity
public class Transaction {
    @Id
    private Long id;
    private String accountNumber;
    private Double amount;
    private LocalDateTime transactionDate;
    private String transactionType;
}

@Repository
public interface TransactionRepository extends JpaRepository<Transaction, Long> {
    
    // Get monthly statements
    List<Transaction> findByAccountNumberAndTransactionDateBetween(
        String accountNumber, LocalDateTime start, LocalDateTime end);
    
    // Get transactions for tax calculation
    List<Transaction> findByTransactionDateBetweenAndAmountGreaterThan(
        LocalDateTime start, LocalDateTime end, Double amount);
}

@RestController
public class BankingController {
    
    @GetMapping("/statements/{accountNumber}")
    public List<Transaction> getMonthlyStatement(
            @PathVariable String accountNumber,
            @RequestParam int year,
            @RequestParam int month) {
        
        LocalDateTime startDate = LocalDateTime.of(year, month, 1, 0, 0);
        LocalDateTime endDate = startDate.plusMonths(1).minusSeconds(1);
        
        return transactionRepository.findByAccountNumberAndTransactionDateBetween(
            accountNumber, startDate, endDate);
    }
}
```

### 2ï¸âƒ£ E-commerce Order System ğŸ›’
```java
@Entity
public class Order {
    @Id
    private Long orderId;
    private String customerId;
    private Double totalAmount;
    private LocalDate orderDate;
    private String status;
}

@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    
    // Sales report queries
    List<Order> findByOrderDateBetween(LocalDate start, LocalDate end);
    
    // Customer specific orders
    List<Order> findByCustomerIdAndOrderDateBetween(
        String customerId, LocalDate start, LocalDate end);
    
    // Revenue calculation
    @Query("SELECT SUM(o.totalAmount) FROM Order o WHERE o.orderDate BETWEEN :start AND :end")
    Double getTotalRevenueByDateRange(@Param("start") LocalDate start, @Param("end") LocalDate end);
}

@Service
public class SalesReportService {
    
    public Map<String, Object> generateMonthlySalesReport(int year, int month) {
        LocalDate startDate = LocalDate.of(year, month, 1);
        LocalDate endDate = startDate.plusMonths(1).minusDays(1);
        
        List<Order> orders = orderRepository.findByOrderDateBetween(startDate, endDate);
        Double totalRevenue = orderRepository.getTotalRevenueByDateRange(startDate, endDate);
        
        Map<String, Object> report = new HashMap<>();
        report.put("month", month + "/" + year);
        report.put("totalOrders", orders.size());
        report.put("totalRevenue", totalRevenue);
        report.put("orders", orders);
        
        return report;
    }
}
```

### 3ï¸âƒ£ Attendance Management System ğŸ“Š
```java
@Entity
public class Attendance {
    @Id
    private Long id;
    private String employeeId;
    private LocalDate attendanceDate;
    private LocalTime checkInTime;
    private LocalTime checkOutTime;
    private String status; // PRESENT, ABSENT, LATE
}

@Repository
public interface AttendanceRepository extends JpaRepository<Attendance, Long> {
    
    // Monthly attendance
    List<Attendance> findByEmployeeIdAndAttendanceDateBetween(
        String employeeId, LocalDate start, LocalDate end);
    
    // Department wise attendance
    @Query("SELECT a FROM Attendance a JOIN Employee e ON a.employeeId = e.id " +
           "WHERE e.department = :dept AND a.attendanceDate BETWEEN :start AND :end")
    List<Attendance> findDepartmentAttendanceByDateRange(
        @Param("dept") String department, 
        @Param("start") LocalDate start, 
        @Param("end") LocalDate end);
}
```

---

## ğŸ†š Comparison Tables

### Query Method vs Custom Query vs Native Query

| Feature | Query Method | Custom JPQL | Native SQL |
|---------|-------------|-------------|------------|
| **Ease of Use** | ğŸŸ¢ Easiest | ğŸŸ¡ Moderate | ğŸ”´ Complex |
| **Type Safety** | ğŸŸ¢ Full | ğŸŸ¡ Partial | ğŸ”´ None |
| **Performance** | ğŸŸ¡ Good | ğŸŸ¢ Better | ğŸŸ¢ Best |
| **Database Independence** | ğŸŸ¢ Yes | ğŸŸ¢ Yes | ğŸ”´ No |
| **Complex Queries** | ğŸ”´ Limited | ğŸŸ¢ Good | ğŸŸ¢ Excellent |

### Example Comparison:
```java
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // 1. Query Method (Easiest)
    List<Employee> findByHireDateBetweenAndDepartment(
        LocalDate start, LocalDate end, String dept);
    
    // 2. JPQL Query (More control)
    @Query("SELECT e FROM Employee e WHERE e.hireDate BETWEEN :start AND :end " +
           "AND e.department = :dept ORDER BY e.hireDate DESC")
    List<Employee> findEmployeesWithJPQL(@Param("start") LocalDate start, 
                                        @Param("end") LocalDate end,
                                        @Param("dept") String dept);
    
    // 3. Native SQL (Maximum control)
    @Query(value = "SELECT * FROM employees WHERE hire_date BETWEEN ?1 AND ?2 " +
                   "AND department = ?3 ORDER BY hire_date DESC", 
           nativeQuery = true)
    List<Employee> findEmployeesWithNativeSQL(LocalDate start, LocalDate end, String dept);
}
```

### Date Types Comparison

| Type | Use Case | Time Zone | Precision | Example |
|------|----------|-----------|-----------|---------|
| **LocalDate** | Date only | âŒ No | Day | 2023-12-25 |
| **LocalDateTime** | Date + Time | âŒ No | Nanosecond | 2023-12-25T10:30:00 |
| **ZonedDateTime** | Date + Time + Zone | âœ… Yes | Nanosecond | 2023-12-25T10:30:00+05:30[Asia/Kolkata] |
| **Date** | Legacy | âœ… Yes | Millisecond | Mon Dec 25 10:30:00 IST 2023 |

---

## ğŸ¯ Interview Questions

### Q1: How does Spring Data JPA generate SQL for Between queries?
**Answer:**
```java
// Repository method
List<Employee> findByHireDateBetween(LocalDate start, LocalDate end);

// Generated SQL by Spring Data JPA
/*
SELECT e.* FROM employee e 
WHERE e.hire_date BETWEEN ? AND ?
*/

// Hibernate logs
Hibernate: 
    select
        employee0_.id as id1_0_,
        employee0_.hire_date as hire_dat2_0_,
        employee0_.first_name as first_na3_0_ 
    from
        employee employee0_ 
    where
        employee0_.hire_date between ? and ?
```

**Key Points:**
- Spring uses **query derivation** mechanism
- Method name parsing creates SQL
- Parameters are **automatically bound**
- **BETWEEN** clause includes both boundaries (inclusive)

### Q2: What's the difference between findBy...Between and custom @Query?
**Answer:**
```java
// Method 1: Query Derivation (Limited flexibility)
List<Employee> findByHireDateBetween(LocalDate start, LocalDate end);

// Method 2: Custom JPQL (More control)
@Query("SELECT e FROM Employee e WHERE e.hireDate BETWEEN :start AND :end ORDER BY e.salary DESC")
List<Employee> customDateRangeQuery(@Param("start") LocalDate start, @Param("end") LocalDate end);

// Method 3: Native SQL (Maximum control)
@Query(value = "SELECT * FROM employees WHERE hire_date BETWEEN ?1 AND ?2 AND salary > 50000", 
       nativeQuery = true)
List<Employee> nativeDateRangeQuery(LocalDate start, LocalDate end);
```

**When to use what:**
- **Query Method**: Simple queries, rapid development
- **JPQL**: Complex business logic, joins
- **Native SQL**: Database-specific features, performance optimization

### Q3: How to handle date range validation?
**Answer:**
```java
@Service
public class EmployeeService {
    
    public List<Employee> getEmployeesByDateRange(LocalDate startDate, LocalDate endDate) {
        // Validation 1: Null check
        if (startDate == null || endDate == null) {
            throw new IllegalArgumentException("Dates cannot be null");
        }
        
        // Validation 2: Logical check
        if (startDate.isAfter(endDate)) {
            throw new IllegalArgumentException("Start date cannot be after end date");
        }
        
        // Validation 3: Range check
        long daysBetween = ChronoUnit.DAYS.between(startDate, endDate);
        if (daysBetween > 365) {
            throw new IllegalArgumentException("Date range cannot exceed 1 year");
        }
        
        return employeeRepository.findByHireDateBetween(startDate, endDate);
    }
}

// Exception Handler
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<?> handleValidationError(IllegalArgumentException ex) {
        Map<String, Object> error = new HashMap<>();
        error.put("status", 0);
        error.put("message", "Validation Error: " + ex.getMessage());
        return ResponseEntity.badRequest().body(error);
    }
}
```

### Q4: Performance optimization for date range queries?
**Answer:**
```java
@Entity
@Table(name = "employees", 
       indexes = {
           @Index(name = "idx_hire_date", columnList = "hire_date"),
           @Index(name = "idx_hire_date_dept", columnList = "hire_date, department")
       })
public class Employee {
    // ... fields
}

// Repository with pagination
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    // Pagination for large datasets
    Page<Employee> findByHireDateBetween(LocalDate start, LocalDate end, Pageable pageable);
    
    // Projection for memory optimization
    @Query("SELECT new com.example.dto.EmployeeProjection(e.id, e.firstName, e.hireDate) " +
           "FROM Employee e WHERE e.hireDate BETWEEN :start AND :end")
    List<EmployeeProjection> findEmployeeProjectionsByDateRange(
        @Param("start") LocalDate start, @Param("end") LocalDate end);
}

// Usage with pagination
@Service
public class EmployeeService {
    
    public Page<Employee> getEmployeesByDateRangeWithPagination(
            LocalDate start, LocalDate end, int page, int size) {
        
        Pageable pageable = PageRequest.of(page, size, Sort.by("hireDate").descending());
        return employeeRepository.findByHireDateBetween(start, end, pageable);
    }
}
```

---

## ğŸš« Common Mistakes

### Mistake 1: Wrong Parameter Order
âŒ **Galat tarika:**
```java
// Wrong: end date pehle, start date baad mein
List<Employee> employees = employeeService.getEmployeesByDateRange(endDate, startDate);
```

âœ… **Sahi tarika:**
```java
// Correct: start date pehle, end date baad mein
List<Employee> employees = employeeService.getEmployeesByDateRange(startDate, endDate);
```

**Why it's wrong:** Logically incorrect range, empty results

### Mistake 2: Missing Date Validation
âŒ **Galat tarika:**
```java
@RestController
public class EmployeeController {
    
    @GetMapping("/date-range")
    public List<Employee> getByDateRange(
            @RequestParam LocalDate start,
            @RequestParam LocalDate end) {
        
        // Directly call without validation
        return employeeService.getEmployeesByDateRange(start, end);
    }
}
```

âœ… **Sahi tarika:**
```java
@RestController 
public class EmployeeController {
    
    @GetMapping("/date-range")
    public ResponseEntity<?> getByDateRange(
            @RequestParam LocalDate start,
            @RequestParam LocalDate end) {
        
        // Validation before processing
        if (start.isAfter(end)) {
            Map<String, String> error = new HashMap<>();
            error.put("error", "Start date cannot be after end date");
            return ResponseEntity.badRequest().body(error);
        }
        
        List<Employee> employees = employeeService.getEmployeesByDateRange(start, end);
        return ResponseEntity.ok(employees);
    }
}
```

### Mistake 3: Incorrect Property Name
âŒ **Galat tarika:**
```java
// Entity field name is 'hireDate' but using different name in method
List<Employee> findByJoinDateBetween(LocalDate start, LocalDate end);
```

**Error Message:**
```
org.springframework.data.mapping.PropertyReferenceException: 
No property joinDate found for type Employee!
```

âœ… **Sahi tarika:**
```java
// Use exact property name from entity
List<Employee> findByHireDateBetween(LocalDate start, LocalDate end);
```

### Mistake 4: Time Zone Issues
âŒ **Galat tarika:**
```java
// Using different time zones without consideration
LocalDate startDate = LocalDate.now(ZoneId.of("UTC"));
LocalDate endDate = LocalDate.now(ZoneId.of("Asia/Kolkata"));
```

âœ… **Sahi tarika:**
```java
// Consistent time zone usage
ZoneId appTimeZone = ZoneId.of("Asia/Kolkata");
LocalDate startDate = LocalDate.now(appTimeZone);
LocalDate endDate = LocalDate.now(appTimeZone);
```

---

## â­ Best
