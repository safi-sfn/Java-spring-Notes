# Spring Data JPA - OR Condition Complete Guide 🚀

*Bhai, database se data fetch karna hai multiple conditions ke saath? Ye notes tumhare kaam aayenge!* 📚✨

---

## 1. Introduction with Confusion Clearing 🤔

### Simple Explanation First 
**Yaar, OR condition ka matlab simple hai** - Agar tumhe database se data chahiye jahan **koi bhi ek condition match** ho jaye, toh tum OR use karte ho!

### Real-life Analogy 🏠
**Imagine karo** - Tum apne dost ko dhundh rahe ho college mein:
- "Bhai, agar **canteen mein** hai **YA** **library mein** hai, toh mujhe bata!"
- Dono jagah check karne ki zarurat nahi, **koi ek** jagah mil gaya toh bas! 

### Technical Definition 📖
```java
// OR condition means: Condition A OR Condition B
// Agar A true hai ya B true hai ya dono true hai - data milega!
SELECT * FROM staff WHERE name = 'John' OR department = 'IT';
```

---

## 2. Key Terms/Concepts 🎯

| **Term** | **Hindi/English** | **Example** |
|----------|-------------------|-------------|
| **OR Operator** | Ya/Athva | `name = 'John' OR dept = 'IT'` |
| **Query Method** | Method naam se query banana | `findByNameOrDepartment()` |
| **JPQL** | Java Persistence Query Language | HQL jaisa but Java entities ke liye |
| **Native SQL** | Pure SQL query | Database-specific SQL commands |
| **Repository** | Data access layer | Interface jo database se baat karta hai |

### Visual Representation 📊
```
OR Condition Logic:
┌─────────────┬─────────────┬─────────────┐
│ Condition A │ Condition B │   Result    │
├─────────────┼─────────────┼─────────────┤
│    TRUE     │    TRUE     │    TRUE ✅   │
│    TRUE     │   FALSE     │    TRUE ✅   │
│   FALSE     │    TRUE     │    TRUE ✅   │
│   FALSE     │   FALSE     │   FALSE ❌   │
└─────────────┴─────────────┴─────────────┘
```

---

## 3. Three Ways to Use OR in JPA 🛠️

### Method 1: Query Method with Or Keyword 🔍

**Sabse easy method hai yaar!** Just method name mein `Or` keyword use karo!

```java
public interface StaffRepository extends JpaRepository<Staff, Long> {
    // Method naming convention: findBy + Field1 + Or + Field2
    List<Staff> findByNameOrDepartment(String name, String department);
    
    // Multiple OR conditions bhi kar sakte ho
    List<Staff> findByNameOrDepartmentOrSalary(String name, String dept, Double salary);
}
```

**Expected Output:**
```sql
-- Spring automatically generates:
SELECT s.id, s.name, s.department, s.salary 
FROM staff s 
WHERE s.name = ? OR s.department = ?
```

### Method 2: JPQL with OR Operator 📝

**Jab complex queries chahiye toh JPQL use karo!**

```java
public interface StaffRepository extends JpaRepository<Staff, Long> {
    @Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :department")
    List<Staff> findByNameOrDepartmentJPQL(@Param("name") String name, 
                                           @Param("department") String department);
    
    // Complex condition example
    @Query("SELECT s FROM Staff s WHERE (s.name = :name OR s.department = :dept) AND s.salary > :minSalary")
    List<Staff> findComplexCondition(@Param("name") String name, 
                                   @Param("dept") String dept, 
                                   @Param("minSalary") Double minSalary);
}
```

### Method 3: Native SQL Query 💻

**Database-specific features chahiye? Native SQL use karo!**

```java
public interface StaffRepository extends JpaRepository<Staff, Long> {
    @Query(value = "SELECT * FROM staff WHERE name = :name OR department = :department", 
           nativeQuery = true)
    List<Staff> findByNameOrDepartmentNative(@Param("name") String name, 
                                           @Param("department") String department);
}
```

---

## 4. Complete Working Example 🏗️

### Entity Class
```java
package com.springjava.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name = "staff")
public class Staff {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false) 
    private String department;
    
    private Double salary;
    
    // Constructors
    public Staff() {}
    
    public Staff(String name, String department, Double salary) {
        this.name = name;
        this.department = department;
        this.salary = salary;
    }
}
```

### Repository Interface
```java
package com.springjava.repository;

import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    // Method 1: Query Method
    List<Staff> findByNameOrDepartment(String name, String department);
    
    // Method 2: JPQL
    @Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :department")
    List<Staff> findByNameOrDepartmentJPQL(@Param("name") String name, 
                                           @Param("department") String department);
    
    // Method 3: Native SQL
    @Query(value = "SELECT * FROM staff WHERE name = :name OR department = :department", 
           nativeQuery = true)
    List<Staff> findByNameOrDepartmentNative(@Param("name") String name, 
                                           @Param("department") String department);
}
```

### Service Layer
```java
package com.springjava.service;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class StaffService {
    
    @Autowired
    private StaffRepository staffRepository;
    
    public List<Staff> findStaffByQueryMethod(String name, String department) {
        return staffRepository.findByNameOrDepartment(name, department);
    }
    
    public List<Staff> findStaffByJPQL(String name, String department) {
        return staffRepository.findByNameOrDepartmentJPQL(name, department);
    }
    
    public List<Staff> findStaffByNativeSQL(String name, String department) {
        return staffRepository.findByNameOrDepartmentNative(name, department);
    }
}
```

### Controller
```java
package com.springjava.controller;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/staff")
public class StaffController {
    
    @Autowired
    private StaffService staffService;
    
    @GetMapping("/search/query-method")
    public ResponseEntity<List<Staff>> searchByQueryMethod(
            @RequestParam String name, 
            @RequestParam String department) {
        
        List<Staff> staff = staffService.findStaffByQueryMethod(name, department);
        return ResponseEntity.ok(staff);
    }
    
    @GetMapping("/search/jpql")
    public ResponseEntity<List<Staff>> searchByJPQL(
            @RequestParam String name, 
            @RequestParam String department) {
        
        List<Staff> staff = staffService.findStaffByJPQL(name, department);
        return ResponseEntity.ok(staff);
    }
    
    @GetMapping("/search/native")
    public ResponseEntity<List<Staff>> searchByNative(
            @RequestParam String name, 
            @RequestParam String department) {
        
        List<Staff> staff = staffService.findStaffByNativeSQL(name, department);
        return ResponseEntity.ok(staff);
    }
}
```

---

## 5. Rules/Guidelines 📋

### ✅ **DO's (Ye karo bhai!)**

**Rule 1:** Method naming mein proper convention follow karo
```java
// ✅ Correct
List<Staff> findByNameOrDepartment(String name, String department);

// ❌ Wrong  
List<Staff> findByNameOrDept(String name, String department); // Parameter mismatch
```

**Rule 2:** Parameters ka order method name ke saath match karna chahiye
```java
// ✅ Correct - name first, department second
findByNameOrDepartment(String name, String department)

// ❌ Wrong - order mismatch
findByNameOrDepartment(String department, String name) // Confusing!
```

**Rule 3:** JPQL mein entity name use karo, table name nahi
```java
// ✅ Correct - 'Staff' is entity name
@Query("SELECT s FROM Staff s WHERE s.name = :name")

// ❌ Wrong - 'staff' is table name
@Query("SELECT s FROM staff s WHERE s.name = :name")
```

**Rule 4:** Native queries mein nativeQuery = true karna must hai
```java
// ✅ Correct
@Query(value = "SELECT * FROM staff WHERE name = ?1", nativeQuery = true)

// ❌ Wrong - nativeQuery missing
@Query(value = "SELECT * FROM staff WHERE name = ?1") // Error aayega!
```

**Rule 5:** Parameter binding properly karo
```java
// ✅ Method 1 - Named parameters (Recommended)
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.dept = :dept")
List<Staff> findStaff(@Param("name") String name, @Param("dept") String dept);

// ✅ Method 2 - Positional parameters  
@Query("SELECT s FROM Staff s WHERE s.name = ?1 OR s.dept = ?2")
List<Staff> findStaff(String name, String dept);
```

### ❌ **DON'Ts (Ye mat karo!)**

**Rule 6:** Query methods mein spelling mistakes mat karo
```java
// ❌ Wrong
List<Staff> findByNameOrDeparment(String name, String department);
//                    ^^^^^^^^^ - 't' missing in Department

// Error message:
// "No property 'deparment' found for type 'Staff'"
```

**Rule 7:** Mixed approaches mat use karo
```java
// ❌ Wrong - Don't mix query method with @Query
@Query("SELECT s FROM Staff s WHERE s.name = :name")
List<Staff> findByNameOrDepartment(String name, String department);
```

---

## 6. Real-world Applications 🌍

### Banking System Example 🏦
```java
@Entity
public class Account {
    @Id
    private Long accountNumber;
    private String accountType; // SAVINGS, CURRENT, etc.
    private String status;      // ACTIVE, INACTIVE, BLOCKED
    private Double balance;
    private String branchCode;
}

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    // Find accounts by type or status
    List<Account> findByAccountTypeOrStatus(String type, String status);
    
    // Find accounts with high balance or specific branch
    @Query("SELECT a FROM Account a WHERE a.balance > :amount OR a.branchCode = :branch")
    List<Account> findHighBalanceOrBranch(@Param("amount") Double amount, 
                                        @Param("branch") String branchCode);
}

// Usage in service
@Service
public class AccountService {
    
    public List<Account> findSavingsOrActiveAccounts() {
        return accountRepository.findByAccountTypeOrStatus("SAVINGS", "ACTIVE");
    }
}
```

### E-commerce Product Search 🛒
```java
@Entity
public class Product {
    @Id
    private Long id;
    private String name;
    private String category;
    private Double price;
    private String brand;
    private Boolean inStock;
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Search by name or category
    List<Product> findByNameContainingOrCategoryContaining(String name, String category);
    
    // Find products by brand or within price range
    @Query("SELECT p FROM Product p WHERE p.brand = :brand OR p.price BETWEEN :minPrice AND :maxPrice")
    List<Product> findByBrandOrPriceRange(@Param("brand") String brand,
                                        @Param("minPrice") Double minPrice,
                                        @Param("maxPrice") Double maxPrice);
}
```

---

## 7. Comparison Table 📊

| **Aspect** | **Query Method** | **JPQL** | **Native SQL** |
|------------|------------------|----------|----------------|
| **Ease of Use** 😊 | ⭐⭐⭐⭐⭐ Very Easy | ⭐⭐⭐⭐ Easy | ⭐⭐⭐ Moderate |
| **Type Safety** 🔒 | ✅ Compile-time | ✅ Compile-time | ❌ Runtime |
| **Database Independence** 🔄 | ✅ Full | ✅ Full | ❌ Database specific |
| **Complex Queries** 🤯 | ❌ Limited | ✅ Good | ✅ Excellent |
| **Performance** ⚡ | ⭐⭐⭐⭐ Good | ⭐⭐⭐⭐ Good | ⭐⭐⭐⭐⭐ Best |
| **Readability** 👀 | ⭐⭐⭐⭐⭐ Best | ⭐⭐⭐⭐ Good | ⭐⭐⭐ OK |
| **Debugging** 🐛 | Easy | Moderate | Hard |

### **When to Use What? 🤷‍♂️**

```java
// ✅ Use Query Methods for: Simple conditions
List<Staff> findByNameOrDepartment(String name, String dept);

// ✅ Use JPQL for: Medium complexity with business logic
@Query("SELECT s FROM Staff s WHERE (s.name = :name OR s.dept = :dept) AND s.salary > 50000")

// ✅ Use Native SQL for: Database-specific features, complex joins, performance critical
@Query(value = "SELECT * FROM staff s WHERE s.name = ?1 OR s.dept = ?2 ORDER BY s.created_date DESC LIMIT 10", 
       nativeQuery = true)
```

---

## 8. Interview Questions 🎯

### **Q1: What's the difference between OR and AND in JPA?**

**Answer:**
```java
// OR - Koi bhi ek condition true ho toh result milega
List<Staff> findByNameOrDepartment(String name, String dept);
// SQL: WHERE name = 'John' OR department = 'IT'

// AND - Dono conditions true honi chahiye
List<Staff> findByNameAndDepartment(String name, String dept); 
// SQL: WHERE name = 'John' AND department = 'IT'
```

**Real Example:**
```java
// OR example - Either name is 'John' OR department is 'IT'
// Results: John from Finance + Alice from IT + Bob from IT
staffRepository.findByNameOrDepartment("John", "IT");

// AND example - Name is 'John' AND department is 'IT'  
// Results: Only if someone named John works in IT
staffRepository.findByNameAndDepartment("John", "IT");
```

### **Q2: Can you use multiple OR conditions in a single query method?**

**Answer:** Haan bilkul! Multiple OR conditions use kar sakte ho:

```java
// Multiple OR conditions
List<Staff> findByNameOrDepartmentOrSalary(String name, String dept, Double salary);

// JPQL mein bhi multiple OR
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.dept = :dept OR s.salary > :salary OR s.city = :city")
List<Staff> findByMultipleOrConditions(@Param("name") String name,
                                     @Param("dept") String dept,
                                     @Param("salary") Double salary,
                                     @Param("city") String city);
```

### **Q3: What happens if both parameters are null in OR condition?**

**Answer:**
```java
// Agar dono null hai toh query kya karega?
staffRepository.findByNameOrDepartment(null, null);

// Generated SQL:
// WHERE name IS NULL OR department IS NULL

// Result: Records jinke name ya department null hai, wo milenge
```

**Safe approach:**
```java
@Query("SELECT s FROM Staff s WHERE (:name IS NULL OR s.name = :name) OR (:dept IS NULL OR s.dept = :dept)")
List<Staff> findSafely(@Param("name") String name, @Param("dept") String dept);
```

### **Q4: Performance difference between Query Method vs JPQL vs Native SQL?**

**Answer:**

| **Method** | **Performance** | **Why?** |
|------------|-----------------|----------|
| Query Method | ⭐⭐⭐⭐ | Spring generates optimized SQL |
| JPQL | ⭐⭐⭐⭐ | Hibernate optimizes, portable |
| Native SQL | ⭐⭐⭐⭐⭐ | Direct database access, no translation |

```java
// Performance test example
@RestController
public class PerformanceTest {
    
    @GetMapping("/performance-test")
    public ResponseEntity<Map<String, Long>> testPerformance() {
        long start, end;
        Map<String, Long> results = new HashMap<>();
        
        // Query Method
        start = System.currentTimeMillis();
        staffRepository.findByNameOrDepartment("John", "IT");
        end = System.currentTimeMillis();
        results.put("QueryMethod", end - start);
        
        // JPQL
        start = System.currentTimeMillis();
        staffRepository.findByNameOrDepartmentJPQL("John", "IT");
        end = System.currentTimeMillis();
        results.put("JPQL", end - start);
        
        // Native SQL
        start = System.currentTimeMillis();
        staffRepository.findByNameOrDepartmentNative("John", "IT");
        end = System.currentTimeMillis();
        results.put("NativeSQL", end - start);
        
        return ResponseEntity.ok(results);
    }
}
```

---

## 9. Common Mistakes 🚫

### **Mistake 1: Wrong Method Naming**
```java
// ❌ Wrong
List<Staff> findByName_Or_Department(String name, String dept); // Underscores nahi!

// ❌ Wrong  
List<Staff> findByNameORDepartment(String name, String dept); // Case sensitive!

// ✅ Correct
List<Staff> findByNameOrDepartment(String name, String dept);
```

**Error Message:**
```
No property 'name_Or_Department' found for type 'Staff'!
```

### **Mistake 2: Parameter Order Mismatch**
```java
// ❌ Wrong - Method expects name first, dept second
public List<Staff> searchStaff(String department, String name) {
    return staffRepository.findByNameOrDepartment(name, department); // Confusing!
}

// ✅ Correct - Parameter order matches method name
public List<Staff> searchStaff(String name, String department) {
    return staffRepository.findByNameOrDepartment(name, department);
}
```

### **Mistake 3: Mixing Entity and Table Names**
```java
// ❌ Wrong - staff is table name, Staff is entity name
@Query("SELECT s FROM staff s WHERE s.name = :name OR s.department = :dept")

// ✅ Correct - Use entity name in JPQL
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :dept")
```

### **Mistake 4: Forgetting nativeQuery = true**
```java
// ❌ Wrong - SQL syntax but no nativeQuery flag
@Query("SELECT * FROM staff WHERE name = ?1 OR department = ?2")
List<Staff> findStaff(String name, String dept);

// Error: "SELECT * FROM staff" is not valid JPQL syntax

// ✅ Correct
@Query(value = "SELECT * FROM staff WHERE name = ?1 OR department = ?2", 
       nativeQuery = true)
List<Staff> findStaff(String name, String dept);
```

### **Mistake 5: Not Handling Null Values**
```java
// ❌ Wrong - Null values can cause unexpected results
public List<Staff> searchStaff(String name, String dept) {
    // Agar name null hai toh kya hoga?
    return staffRepository.findByNameOrDepartment(name, dept);
}

// ✅ Correct - Handle null values
public List<Staff> searchStaff(String name, String dept) {
    if (name == null && dept == null) {
        return staffRepository.findAll(); // All records
    }
    return staffRepository.findByNameOrDepartment(name, dept);
}
```

---

## 10. Best Practices 🏆

### **1. Use Optional for Better Null Handling**
```java
// ✅ Best Practice
public Optional<List<Staff>> searchStaff(String name, String department) {
    List<Staff> results = staffRepository.findByNameOrDepartment(name, department);
    return results.isEmpty() ? Optional.empty() : Optional.of(results);
}

// Usage
Optional<List<Staff>> staffList = staffService.searchStaff("John", "IT");
if (staffList.isPresent()) {
    // Process results
    staffList.get().forEach(System.out::println);
} else {
    System.out.println("No staff found!");
}
```

### **2. Add Proper Validation**
```java
// ✅ Best Practice with validation
@Service
public class StaffService {
    
    public List<Staff> searchStaff(@Valid @NotBlank String name, 
                                  @Valid @NotBlank String department) {
        
        // Input validation
        if (StringUtils.isBlank(name) && StringUtils.isBlank(department)) {
            throw new IllegalArgumentException("At least one search parameter is required");
        }
        
        return staffRepository.findByNameOrDepartment(name.trim(), department.trim());
    }
}
```

### **3. Use Specifications for Dynamic Queries**
```java
// ✅ Advanced: Dynamic OR conditions using Specifications
@Repository
public interface StaffRepository extends JpaRepository<Staff, Long>, JpaSpecificationExecutor<Staff> {
}

@Service
public class StaffService {
    
    public List<Staff> searchStaffDynamic(String name, String department, Double minSalary) {
        
        Specification<Staff> spec = Specification.where(null);
        
        if (StringUtils.isNotBlank(name)) {
            spec = spec.or((root, query, cb) -> 
                cb.like(cb.lower(root.get("name")), "%" + name.toLowerCase() + "%"));
        }
        
        if (StringUtils.isNotBlank(department)) {
            spec = spec.or((root, query, cb) -> 
                cb.equal(root.get("department"), department));
        }
        
        if (minSalary != null) {
            spec = spec.or((root, query, cb) -> 
                cb.greaterThanOrEqualTo(root.get("salary"), minSalary));
        }
        
        return staffRepository.findAll(spec);
    }
}
```

### **4. Add Logging for Debugging**
```java
// ✅ Best Practice with logging
@Service
@Slf4j
public class StaffService {
    
    public List<Staff> searchStaff(String name, String department) {
        
        log.info("Searching staff with name: {} OR department: {}", name, department);
        
        List<Staff> results = staffRepository.findByNameOrDepartment(name, department);
        
        log.info("Found {} staff members matching criteria", results.size());
        
        return results;
    }
}
```

### **5. Use Caching for Frequent Queries**
```java
// ✅ Best Practice with caching
@Service
public class StaffService {
    
    @Cacheable(value = "staffSearch", key = "#name + '_' + #department")
    public List<Staff> searchStaffCached(String name, String department) {
        log.info("Cache miss - executing database query");
        return staffRepository.findByNameOrDepartment(name, department);
    }
    
    @CacheEvict(value = "staffSearch", allEntries = true)
    public void clearCache() {
        log.info("Clearing staff search cache");
    }
}
```

---

## 11. Testing Your OR Conditions 🧪

### **Unit Test Example**
```java
@DataJpaTest
class StaffRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private StaffRepository staffRepository;
    
    @BeforeEach
    void setUp() {
        // Test data
        Staff john = new Staff("John", "Finance", 65000.0);
        Staff alice = new Staff("Alice", "IT", 80000.0);
        Staff bob = new Staff("Bob", "HR", 55000.0);
        
        entityManager.persistAndFlush(john);
        entityManager.persistAndFlush(alice);
        entityManager.persistAndFlush(bob);
    }
    
    @Test
    void testFindByNameOrDepartment_BothMatch() {
        // Test: Both conditions match different records
        List<Staff> result = staffRepository.findByNameOrDepartment("John", "IT");
        
        assertThat(result).hasSize(2); // John + Alice
        assertThat(result).extracting(Staff::getName)
                         .containsExactlyInAnyOrder("John", "Alice");
    }
    
    @Test
    void testFindByNameOrDepartment_OnlyNameMatches() {
        // Test: Only name matches
        List<Staff> result = staffRepository.findByNameOrDepartment("John", "Marketing");
        
        assertThat(result).hasSize(1);
        assertThat(result.get(0).getName()).isEqualTo("John");
    }
    
    @Test
    void testFindByNameOrDepartment_NoMatch() {
        // Test: No matches
        List<Staff> result = staffRepository.findByNameOrDepartment("Unknown", "Unknown");
        
        assertThat(result).isEmpty();
    }
}
```

### **Integration Test Example**
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestMethodOrder(OrderAnnotation.class)
class StaffControllerIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    @Order(1)
    void testSearchByQueryMethod() {
        // Test API endpoint
        String url = "/api/staff/search/query-method?name=John&department=IT";
        
        ResponseEntity<List> response = restTemplate.getForEntity(url, List.class);
        
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
    }
}
```

---

## 12. Performance Tips 🚀

### **1. Index Your OR Columns**
```sql
-- Database mein proper indexes banao
CREATE INDEX idx_staff_name ON staff(name);
CREATE INDEX idx_staff_department ON staff(department);

-- Composite index for better OR performance
CREATE INDEX idx_staff_name_dept ON staff(name, department);
```

### **2. Use UNION for Better Performance (Advanced)**
```java
// Sometimes UNION is faster than OR for large datasets
@Query(value = "SELECT * FROM staff WHERE name = :name " +
               "UNION " +
               "SELECT * FROM staff WHERE department = :dept", 
       nativeQuery = true)
List<Staff> findByNameOrDepartmentUnion(@Param("name") String name, 
                                      @Param("dept") String dept);
```

### **3. Pagination for Large Results**
```java
// Large datasets ke liye pagination use karo
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    Page<Staff> findByNameOrDepartment(String name, String department, Pageable pageable);
}

// Usage
@Service
public class StaffService {
    
    public Page<Staff> searchStaffPaginated(String name, String dept, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("name"));
        return staffRepository.findByNameOrDepartment(name, dept, pageable);
    }
}
```

---

## 13. Summary/Quick Recap 📝

### **Key Takeaways 🎯**

1. **OR Condition** = At least one condition should be true
2. **Three Ways**: Query Methods, JPQL, Native SQL
3. **Query Method**: Easiest for simple conditions
4. **JPQL**: Best for medium complexity
5. **Native SQL**: Best for performance & database-specific features

### **Memory Tricks 🧠**

| **Trick** | **Remember** |
|-----------|--------------|
| **OR = "Ya"** | "John **YA** IT department wale chahiye" |
| **Method Naming** | findBy + Field1 + **Or** + Field2 |
| **JPQL Entity** | Staff (not staff) - Capital letter! |
| **Native Flag** | nativeQuery = **true** always! |

### **When to Use What? 🤔**

```java
// 🟢 Simple search? → Query Method
List<Staff> findByNameOrDepartment(String name, String dept);

// 🟡 Medium complexity? → JPQL  
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.dept = :dept AND s.salary > 50000")

// 🔴 Complex/Performance critical? → Native SQL
@Query(value = "SELECT * FROM staff WHERE name = ?1 OR dept = ?2 ORDER BY created_date", 
       nativeQuery = true)
```

### **Quick Reference Card 📋**

```java
// 1. Basic OR
findByField1OrField2(param1, param2)

// 2. JPQL OR
@Query("SELECT e FROM Entity e WHERE e.field1 = :param1 OR e.field2 = :param2")

// 3. Native OR
@Query(value = "SELECT * FROM table WHERE field1 = :param1 OR field2 = :param2", 
       nativeQuery = true)

// 4. Multiple OR
findByField1OrField2OrField3(param1, param2, param3)

// 5. Complex OR with AND
@Query("SELECT e FROM Entity e WHERE (e.field1 = :p1 OR e.field2 = :p2) AND e.field3 > :p3")
```

---

## 14. Advanced OR Scenarios 🎓

### **Scenario 1: OR with LIKE Operations**
```java
// Case-insensitive search with OR
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    @Query("SELECT s FROM Staff s WHERE " +
           "LOWER(s.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(s.department) LIKE LOWER(CONCAT('%', :searchTerm, '%'))")
    List<Staff> searchByNameOrDepartmentContaining(@Param("searchTerm") String searchTerm);
}

// Usage: Search for "jo" will find "John", "IT" will find IT department
List<Staff> results = staffRepository.searchByNameOrDepartmentContaining("jo");
```

### **Scenario 2: OR with Date Ranges**
```java
@Entity
public class Staff {
    // ... other fields
    
    @Column(name = "hire_date")
    private LocalDate hireDate;
    
    @Column(name = "birth_date") 
    private LocalDate birthDate;
}

// Find staff hired after 2020 OR born before 1990
@Query("SELECT s FROM Staff s WHERE s.hireDate > :hireDate OR s.birthDate < :birthDate")
List<Staff> findByHireDateOrBirthDate(@Param("hireDate") LocalDate hireDate,
                                    @Param("birthDate") LocalDate birthDate);

// Usage
LocalDate hireAfter = LocalDate.of(2020, 1, 1);
LocalDate bornBefore = LocalDate.of(1990, 1, 1);
List<Staff> experienced = staffRepository.findByHireDateOrBirthDate(hireAfter, bornBefore);
```

### **Scenario 3: OR with Null Checks**
```java
// Find staff where email is null OR phone is null (incomplete profiles)
@Query("SELECT s FROM Staff s WHERE s.email IS NULL OR s.phone IS NULL")
List<Staff> findIncompleteProfiles();

// Find staff with specific name OR null department (unassigned)
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department IS NULL")
List<Staff> findByNameOrUnassigned(@Param("name") String name);
```

### **Scenario 4: OR with Subqueries**
```java
// Find staff from IT department OR staff with salary > average salary
@Query("SELECT s FROM Staff s WHERE s.department = 'IT' OR " +
       "s.salary > (SELECT AVG(st.salary) FROM Staff st)")
List<Staff> findITStaffOrAboveAverageSalary();
```

### **Scenario 5: Dynamic OR with Criteria API**
```java
@Service
public class StaffSearchService {
    
    @Autowired
    private EntityManager entityManager;
    
    public List<Staff> dynamicOrSearch(StaffSearchCriteria criteria) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<Staff> query = cb.createQuery(Staff.class);
        Root<Staff> staff = query.from(Staff.class);
        
        List<Predicate> orPredicates = new ArrayList<>();
        
        // Add OR conditions dynamically
        if (criteria.getName() != null) {
            orPredicates.add(cb.like(cb.lower(staff.get("name")), 
                            "%" + criteria.getName().toLowerCase() + "%"));
        }
        
        if (criteria.getDepartment() != null) {
            orPredicates.add(cb.equal(staff.get("department"), criteria.getDepartment()));
        }
        
        if (criteria.getMinSalary() != null) {
            orPredicates.add(cb.greaterThanOrEqualTo(staff.get("salary"), 
                            criteria.getMinSalary()));
        }
        
        if (!orPredicates.isEmpty()) {
            query.where(cb.or(orPredicates.toArray(new Predicate[0])));
        }
        
        return entityManager.createQuery(query).getResultList();
    }
}

// Search criteria class
@Data
public class StaffSearchCriteria {
    private String name;
    private String department;
    private Double minSalary;
    private String city;
}
```

---

## 15. Error Handling & Debugging 🐛

### **Common Errors and Solutions**

#### **Error 1: PropertyReferenceException**
```java
// ❌ Error Code
List<Staff> findByNameOrDeparment(String name, String dept);  // Typo!

// 📋 Error Message:
// "No property 'deparment' found for type 'Staff'! Did you mean 'department'?"

// ✅ Solution
List<Staff> findByNameOrDepartment(String name, String dept);
```

#### **Error 2: QuerySyntaxException**
```java
// ❌ Error Code
@Query("SELECT s FROM staff s WHERE s.name = :name OR s.dept = :dept")  // Wrong entity name

// 📋 Error Message:
// "staff is not mapped [SELECT s FROM staff s WHERE...]"

// ✅ Solution  
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :dept")
```

#### **Error 3: InvalidJpaQueryException**
```java
// ❌ Error Code
@Query("SELECT * FROM staff WHERE name = :name OR dept = :dept")  // Missing nativeQuery

// 📋 Error Message:
// "SELECT * is not valid JPQL syntax"

// ✅ Solution
@Query(value = "SELECT * FROM staff WHERE name = :name OR department = :dept", 
       nativeQuery = true)
```

### **Debugging Tips 🔍**

#### **1. Enable SQL Logging**
```properties
# application.properties
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

#### **2. Test Queries in H2 Console**
```java
// Access H2 console: http://localhost:8080/h2-console
// Test your queries directly:

-- Test your OR condition
SELECT * FROM staff WHERE name = 'John' OR department = 'IT';

-- Check what data exists
SELECT DISTINCT name, department FROM staff;
```

#### **3. Add Debug Logging in Service**
```java
@Service
@Slf4j
public class StaffService {
    
    public List<Staff> searchStaff(String name, String department) {
        log.debug("Searching with parameters: name={}, department={}", name, department);
        
        List<Staff> results = staffRepository.findByNameOrDepartment(name, department);
        
        log.debug("Query returned {} results", results.size());
        
        if (log.isTraceEnabled()) {
            results.forEach(staff -> log.trace("Found staff: {}", staff));
        }
        
        return results;
    }
}
```

---

## 16. Security Considerations 🔒

### **SQL Injection Prevention**
```java
// ✅ Safe - Parameterized queries
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :dept")
List<Staff> safeFindStaff(@Param("name") String name, @Param("dept") String dept);

// ✅ Safe - Native query with parameters
@Query(value = "SELECT * FROM staff WHERE name = ?1 OR department = ?2", 
       nativeQuery = true)
List<Staff> safeNativeFindStaff(String name, String dept);

// ❌ Dangerous - String concatenation (NEVER DO THIS!)
@Query(value = "SELECT * FROM staff WHERE name = '" + name + "' OR department = '" + dept + "'", 
       nativeQuery = true)  // SQL Injection risk!
```

### **Input Validation**
```java
@Service
public class StaffService {
    
    public List<Staff> searchStaff(@Valid @NotNull String name, 
                                  @Valid @NotNull String department) {
        
        // Sanitize inputs
        name = StringUtils.trimToEmpty(name);
        department = StringUtils.trimToEmpty(department);
        
        // Validate length
        if (name.length() > 100 || department.length() > 50) {
            throw new IllegalArgumentException("Search parameters too long");
        }
        
        // Validate characters (prevent injection attempts)
        if (containsSqlKeywords(name) || containsSqlKeywords(department)) {
            throw new IllegalArgumentException("Invalid characters in search");
        }
        
        return staffRepository.findByNameOrDepartment(name, department);
    }
    
    private boolean containsSqlKeywords(String input) {
        String[] sqlKeywords = {"DROP", "DELETE", "UPDATE", "INSERT", "SELECT", "--", ";"};
        String upperInput = input.toUpperCase();
        return Arrays.stream(sqlKeywords).anyMatch(upperInput::contains);
    }
}
```

---

## 17. Real Production Example 🏭

### **Complete E-commerce Search Feature**
```java
// 🛍️ Product Entity
@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false)
    private String category;
    
    private String brand;
    private Double price;
    private Boolean inStock;
    private Double rating;
    private LocalDateTime createdDate;
    
    @Column(length = 1000)
    private String description;
}

// 🔍 Advanced Search Repository
@Repository
public interface ProductRepository extends JpaRepository<Product, Long>, JpaSpecificationExecutor<Product> {
    
    // Basic OR search
    @Query("SELECT p FROM Product p WHERE " +
           "LOWER(p.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(p.category) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(p.brand) LIKE LOWER(CONCAT('%', :searchTerm, '%'))")
    Page<Product> searchProducts(@Param("searchTerm") String searchTerm, Pageable pageable);
    
    // OR with price range and availability
    @Query("SELECT p FROM Product p WHERE " +
           "(p.name = :name OR p.category = :category) AND " +
           "p.price BETWEEN :minPrice AND :maxPrice AND " +
           "p.inStock = true")
    List<Product> findAvailableProducts(@Param("name") String name,
                                      @Param("category") String category,
                                      @Param("minPrice") Double minPrice,
                                      @Param("maxPrice") Double maxPrice);
    
    // Complex search with multiple OR conditions
    @Query("SELECT p FROM Product p WHERE " +
           "(p.rating >= :minRating OR p.brand = :premiumBrand) AND " +
           "(p.category = :category OR p.price <= :maxPrice) AND " +
           "p.inStock = true " +
           "ORDER BY p.rating DESC, p.price ASC")
    List<Product> findRecommendedProducts(@Param("minRating") Double minRating,
                                        @Param("premiumBrand") String premiumBrand,
                                        @Param("category") String category,
                                        @Param("maxPrice") Double maxPrice);
}

// 🎯 Search Service with Caching
@Service
@Transactional(readOnly = true)
@Slf4j
public class ProductSearchService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Cacheable(value = "productSearch", key = "#searchTerm + '_' + #page + '_' + #size")
    public Page<Product> searchProducts(String searchTerm, int page, int size) {
        
        if (StringUtils.isBlank(searchTerm)) {
            return Page.empty();
        }
        
        // Input validation
        if (searchTerm.length() > 100) {
            throw new IllegalArgumentException("Search term too long");
        }
        
        Pageable pageable = PageRequest.of(page, size, 
                           Sort.by("rating").descending()
                               .and(Sort.by("createdDate").descending()));
        
        log.info("Searching products with term: '{}', page: {}, size: {}", 
                searchTerm, page, size);
        
        Page<Product> results = productRepository.searchProducts(searchTerm, pageable);
        
        log.info("Found {} products matching '{}'", results.getTotalElements(), searchTerm);
        
        return results;
    }
    
    public List<Product> getRecommendedProducts(String category, String userBudget) {
        Double maxPrice = parsePrice(userBudget);
        String premiumBrand = "Apple"; // Business logic
        Double minRating = 4.0;
        
        return productRepository.findRecommendedProducts(minRating, premiumBrand, 
                                                       category, maxPrice);
    }
    
    private Double parsePrice(String budget) {
        try {
            return Double.parseDouble(budget);
        } catch (NumberFormatException e) {
            return 1000.0; // Default budget
        }
    }
}

// 🌐 REST Controller
@RestController
@RequestMapping("/api/products")
@Validated
public class ProductController {
    
    @Autowired
    private ProductSearchService searchService;
    
    @GetMapping("/search")
    public ResponseEntity<Page<Product>> searchProducts(
            @RequestParam @NotBlank @Size(min = 2, max = 100) String q,
            @RequestParam(defaultValue = "0") @Min(0) Integer page,
            @RequestParam(defaultValue = "10") @Min(1) @Max(50) Integer size) {
        
        try {
            Page<Product> results = searchService.searchProducts(q, page, size);
            return ResponseEntity.ok(results);
            
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        }
    }
    
    @GetMapping("/recommendations")
    public ResponseEntity<List<Product>> getRecommendations(
            @RequestParam String category,
            @RequestParam(required = false) String budget) {
        
        List<Product> recommendations = searchService.getRecommendedProducts(category, budget);
        return ResponseEntity.ok(recommendations);
    }
}
```

### **Testing the Production Code**
```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Sql(scripts = "/test-data.sql")
class ProductSearchServiceIntegrationTest {
    
    @Autowired
    private ProductSearchService searchService;
    
    @Test
    void testSearchProducts_WithValidTerm_ReturnsResults() {
        // Given
        String searchTerm = "laptop";
        
        // When
        Page<Product> results = searchService.searchProducts(searchTerm, 0, 10);
        
        // Then
        assertThat(results).isNotNull();
        assertThat(results.getContent()).isNotEmpty();
        assertThat(results.getContent()).allMatch(product -> 
            product.getName().toLowerCase().contains("laptop") ||
            product.getCategory().toLowerCase().contains("laptop") ||
            product.getBrand().toLowerCase().contains("laptop")
        );
    }
    
    @Test
    void testSearchProducts_WithEmptyTerm_ReturnsEmptyPage() {
        // When
        Page<Product> results = searchService.searchProducts("", 0, 10);
        
        // Then
        assertThat(results.isEmpty()).isTrue();
    }
}
```

---

## 18. Final Pro Tips 🚀

### **1. Monitor Query Performance**
```java
// Add performance monitoring
@Component
@Aspect
@Slf4j
public class QueryPerformanceMonitor {
    
    @Around("execution(* com.example.repository.*.*(..))")
    public Object monitorQuery(ProceedingJoinPoint joinPoint) throws Throwable {
        
        long startTime = System.currentTimeMillis();
        String methodName = joinPoint.getSignature().getName();
        
        try {
            Object result = joinPoint.proceed();
            
            long executionTime = System.currentTimeMillis() - startTime;
            
            if (executionTime > 1000) { // Log slow queries
                log.warn("Slow query detected: {} took {}ms", methodName, executionTime);
            } else {
                log.debug("Query {} executed in {}ms", methodName, executionTime);
            }
            
            return result;
            
        } catch (Exception e) {
            log.error("Query {} failed: {}", methodName, e.getMessage());
            throw e;
        }
    }
}
```

### **2. Use Database Views for Complex OR Queries**
```sql
-- Create a view for complex OR searches
CREATE VIEW staff_search_view AS
SELECT 
    id, name, department, salary,
    CONCAT(LOWER(name), ' ', LOWER(department), ' ', LOWER(COALESCE(city, ''))) as search_text
FROM staff;

-- Use view in repository
@Query(value = "SELECT * FROM staff_search_view WHERE search_text LIKE %:term%", 
       nativeQuery = true)
List<Staff> searchInView(@Param("term") String term);
```

### **3. Implement Search Analytics**
```java
@Entity
public class SearchLog {
    @Id
    @GeneratedValue
    private Long id;
    
    private String searchTerm;
    private Integer resultCount;
    private Long executionTime;
    private LocalDateTime searchDate;
    
    // getters, setters
}

@Service
public class SearchAnalyticsService {
    
    @Autowired
    private SearchLogRepository searchLogRepository;
    
    @Async
    public void logSearch(String searchTerm, int resultCount, long executionTime) {
        SearchLog log = new SearchLog();
        log.setSearchTerm(searchTerm);
        log.setResultCount(resultCount);
        log.setExecutionTime(executionTime);
        log.setSearchDate(LocalDateTime.now());
        
        searchLogRepository.save(log);
    }
    
    public List<String> getPopularSearchTerms() {
        return searchLogRepository.findTop10ByOrderBySearchCountDesc();
    }
}
```

---

## 🎉 Congratulations! You're Now a JPA OR Expert! 

**Bhai, ab tumhe pata hai:**
- ✅ OR condition kaise use karte hain
- ✅ 3 different methods (Query Method, JPQL, Native SQL)
- ✅ Performance optimization techniques
- ✅ Common mistakes se kaise bacha jaye
- ✅ Production-ready code kaise likhe
- ✅ Testing aur debugging tips

### **Remember the Golden Rules:** 🏆
1. **Simple queries** → Query Methods use karo
2. **Medium complexity** → JPQL prefer karo  
3. **High performance needed** → Native SQL choose karo
4. **Always validate inputs** aur SQL injection se bacho
5. **Monitor performance** aur cache frequently used queries

**Ab jaao aur amazing search features banao! Happy coding! 🚀💻**

---

### **Quick Help Commands** 📞
```bash
# Check generated SQL
spring.jpa.show-sql=true

# H2 Console access
http://localhost:8080/h2-console

# Test API
curl "http://localhost:8080/api/staff/search?name=John&department=IT"
```

**Koi doubt ho toh GitHub issues mein puchna, main help karunga! 👨‍💻**
