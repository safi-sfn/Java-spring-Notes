# Spring Data JPA - OR Condition Complete Guide üöÄ

*Bhai, database se data fetch karna hai multiple conditions ke saath? Ye notes tumhare kaam aayenge!* üìö‚ú®

---

## 1. Introduction with Confusion Clearing ü§î

### Simple Explanation First 
**Yaar, OR condition ka matlab simple hai** - Agar tumhe database se data chahiye jahan **koi bhi ek condition match** ho jaye, toh tum OR use karte ho!

### Real-life Analogy üè†
**Imagine karo** - Tum apne dost ko dhundh rahe ho college mein:
- "Bhai, agar **canteen mein** hai **YA** **library mein** hai, toh mujhe bata!"
- Dono jagah check karne ki zarurat nahi, **koi ek** jagah mil gaya toh bas! 

### Technical Definition üìñ
```java
// OR condition means: Condition A OR Condition B
// Agar A true hai ya B true hai ya dono true hai - data milega!
SELECT * FROM staff WHERE name = 'John' OR department = 'IT';
```

---

## 2. Key Terms/Concepts üéØ

| **Term** | **Hindi/English** | **Example** |
|----------|-------------------|-------------|
| **OR Operator** | Ya/Athva | `name = 'John' OR dept = 'IT'` |
| **Query Method** | Method naam se query banana | `findByNameOrDepartment()` |
| **JPQL** | Java Persistence Query Language | HQL jaisa but Java entities ke liye |
| **Native SQL** | Pure SQL query | Database-specific SQL commands |
| **Repository** | Data access layer | Interface jo database se baat karta hai |

### Visual Representation üìä
```
OR Condition Logic:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Condition A ‚îÇ Condition B ‚îÇ   Result    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ    TRUE     ‚îÇ    TRUE     ‚îÇ    TRUE ‚úÖ   ‚îÇ
‚îÇ    TRUE     ‚îÇ   FALSE     ‚îÇ    TRUE ‚úÖ   ‚îÇ
‚îÇ   FALSE     ‚îÇ    TRUE     ‚îÇ    TRUE ‚úÖ   ‚îÇ
‚îÇ   FALSE     ‚îÇ   FALSE     ‚îÇ   FALSE ‚ùå   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## 3. Three Ways to Use OR in JPA üõ†Ô∏è

### Method 1: Query Method with Or Keyword üîç

**Sabse easy method hai yaar!** Just method name mein `Or` keyword use karo!

```java
public interface StaffRepository extends JpaRepository<Staff, Long> {
    // Method naming convention: findBy + Field1 + Or + Field2
    List<Staff> findByNameOrDepartment(String name, String department);
    
    // Multiple OR conditions bhi kar sakte ho
    List<Staff> findByNameOrDepartmentOrSalary(String name, String dept, Double salary);
}
```

**Expected Output:**
```sql
-- Spring automatically generates:
SELECT s.id, s.name, s.department, s.salary 
FROM staff s 
WHERE s.name = ? OR s.department = ?
```

### Method 2: JPQL with OR Operator üìù

**Jab complex queries chahiye toh JPQL use karo!**

```java
public interface StaffRepository extends JpaRepository<Staff, Long> {
    @Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :department")
    List<Staff> findByNameOrDepartmentJPQL(@Param("name") String name, 
                                           @Param("department") String department);
    
    // Complex condition example
    @Query("SELECT s FROM Staff s WHERE (s.name = :name OR s.department = :dept) AND s.salary > :minSalary")
    List<Staff> findComplexCondition(@Param("name") String name, 
                                   @Param("dept") String dept, 
                                   @Param("minSalary") Double minSalary);
}
```

### Method 3: Native SQL Query üíª

**Database-specific features chahiye? Native SQL use karo!**

```java
public interface StaffRepository extends JpaRepository<Staff, Long> {
    @Query(value = "SELECT * FROM staff WHERE name = :name OR department = :department", 
           nativeQuery = true)
    List<Staff> findByNameOrDepartmentNative(@Param("name") String name, 
                                           @Param("department") String department);
}
```

---

## 4. Complete Working Example üèóÔ∏è

### Entity Class
```java
package com.springjava.entity;

import jakarta.persistence.*;
import lombok.Data;

@Data
@Entity
@Table(name = "staff")
public class Staff {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false) 
    private String department;
    
    private Double salary;
    
    // Constructors
    public Staff() {}
    
    public Staff(String name, String department, Double salary) {
        this.name = name;
        this.department = department;
        this.salary = salary;
    }
}
```

### Repository Interface
```java
package com.springjava.repository;

import java.util.List;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    // Method 1: Query Method
    List<Staff> findByNameOrDepartment(String name, String department);
    
    // Method 2: JPQL
    @Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :department")
    List<Staff> findByNameOrDepartmentJPQL(@Param("name") String name, 
                                           @Param("department") String department);
    
    // Method 3: Native SQL
    @Query(value = "SELECT * FROM staff WHERE name = :name OR department = :department", 
           nativeQuery = true)
    List<Staff> findByNameOrDepartmentNative(@Param("name") String name, 
                                           @Param("department") String department);
}
```

### Service Layer
```java
package com.springjava.service;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class StaffService {
    
    @Autowired
    private StaffRepository staffRepository;
    
    public List<Staff> findStaffByQueryMethod(String name, String department) {
        return staffRepository.findByNameOrDepartment(name, department);
    }
    
    public List<Staff> findStaffByJPQL(String name, String department) {
        return staffRepository.findByNameOrDepartmentJPQL(name, department);
    }
    
    public List<Staff> findStaffByNativeSQL(String name, String department) {
        return staffRepository.findByNameOrDepartmentNative(name, department);
    }
}
```

### Controller
```java
package com.springjava.controller;

import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/staff")
public class StaffController {
    
    @Autowired
    private StaffService staffService;
    
    @GetMapping("/search/query-method")
    public ResponseEntity<List<Staff>> searchByQueryMethod(
            @RequestParam String name, 
            @RequestParam String department) {
        
        List<Staff> staff = staffService.findStaffByQueryMethod(name, department);
        return ResponseEntity.ok(staff);
    }
    
    @GetMapping("/search/jpql")
    public ResponseEntity<List<Staff>> searchByJPQL(
            @RequestParam String name, 
            @RequestParam String department) {
        
        List<Staff> staff = staffService.findStaffByJPQL(name, department);
        return ResponseEntity.ok(staff);
    }
    
    @GetMapping("/search/native")
    public ResponseEntity<List<Staff>> searchByNative(
            @RequestParam String name, 
            @RequestParam String department) {
        
        List<Staff> staff = staffService.findStaffByNativeSQL(name, department);
        return ResponseEntity.ok(staff);
    }
}
```

---

## 5. Rules/Guidelines üìã

### ‚úÖ **DO's (Ye karo bhai!)**

**Rule 1:** Method naming mein proper convention follow karo
```java
// ‚úÖ Correct
List<Staff> findByNameOrDepartment(String name, String department);

// ‚ùå Wrong  
List<Staff> findByNameOrDept(String name, String department); // Parameter mismatch
```

**Rule 2:** Parameters ka order method name ke saath match karna chahiye
```java
// ‚úÖ Correct - name first, department second
findByNameOrDepartment(String name, String department)

// ‚ùå Wrong - order mismatch
findByNameOrDepartment(String department, String name) // Confusing!
```

**Rule 3:** JPQL mein entity name use karo, table name nahi
```java
// ‚úÖ Correct - 'Staff' is entity name
@Query("SELECT s FROM Staff s WHERE s.name = :name")

// ‚ùå Wrong - 'staff' is table name
@Query("SELECT s FROM staff s WHERE s.name = :name")
```

**Rule 4:** Native queries mein nativeQuery = true karna must hai
```java
// ‚úÖ Correct
@Query(value = "SELECT * FROM staff WHERE name = ?1", nativeQuery = true)

// ‚ùå Wrong - nativeQuery missing
@Query(value = "SELECT * FROM staff WHERE name = ?1") // Error aayega!
```

**Rule 5:** Parameter binding properly karo
```java
// ‚úÖ Method 1 - Named parameters (Recommended)
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.dept = :dept")
List<Staff> findStaff(@Param("name") String name, @Param("dept") String dept);

// ‚úÖ Method 2 - Positional parameters  
@Query("SELECT s FROM Staff s WHERE s.name = ?1 OR s.dept = ?2")
List<Staff> findStaff(String name, String dept);
```

### ‚ùå **DON'Ts (Ye mat karo!)**

**Rule 6:** Query methods mein spelling mistakes mat karo
```java
// ‚ùå Wrong
List<Staff> findByNameOrDeparment(String name, String department);
//                    ^^^^^^^^^ - 't' missing in Department

// Error message:
// "No property 'deparment' found for type 'Staff'"
```

**Rule 7:** Mixed approaches mat use karo
```java
// ‚ùå Wrong - Don't mix query method with @Query
@Query("SELECT s FROM Staff s WHERE s.name = :name")
List<Staff> findByNameOrDepartment(String name, String department);
```

---

## 6. Real-world Applications üåç

### Banking System Example üè¶
```java
@Entity
public class Account {
    @Id
    private Long accountNumber;
    private String accountType; // SAVINGS, CURRENT, etc.
    private String status;      // ACTIVE, INACTIVE, BLOCKED
    private Double balance;
    private String branchCode;
}

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
    
    // Find accounts by type or status
    List<Account> findByAccountTypeOrStatus(String type, String status);
    
    // Find accounts with high balance or specific branch
    @Query("SELECT a FROM Account a WHERE a.balance > :amount OR a.branchCode = :branch")
    List<Account> findHighBalanceOrBranch(@Param("amount") Double amount, 
                                        @Param("branch") String branchCode);
}

// Usage in service
@Service
public class AccountService {
    
    public List<Account> findSavingsOrActiveAccounts() {
        return accountRepository.findByAccountTypeOrStatus("SAVINGS", "ACTIVE");
    }
}
```

### E-commerce Product Search üõí
```java
@Entity
public class Product {
    @Id
    private Long id;
    private String name;
    private String category;
    private Double price;
    private String brand;
    private Boolean inStock;
}

@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    
    // Search by name or category
    List<Product> findByNameContainingOrCategoryContaining(String name, String category);
    
    // Find products by brand or within price range
    @Query("SELECT p FROM Product p WHERE p.brand = :brand OR p.price BETWEEN :minPrice AND :maxPrice")
    List<Product> findByBrandOrPriceRange(@Param("brand") String brand,
                                        @Param("minPrice") Double minPrice,
                                        @Param("maxPrice") Double maxPrice);
}
```

---

## 7. Comparison Table üìä

| **Aspect** | **Query Method** | **JPQL** | **Native SQL** |
|------------|------------------|----------|----------------|
| **Ease of Use** üòä | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Very Easy | ‚≠ê‚≠ê‚≠ê‚≠ê Easy | ‚≠ê‚≠ê‚≠ê Moderate |
| **Type Safety** üîí | ‚úÖ Compile-time | ‚úÖ Compile-time | ‚ùå Runtime |
| **Database Independence** üîÑ | ‚úÖ Full | ‚úÖ Full | ‚ùå Database specific |
| **Complex Queries** ü§Ø | ‚ùå Limited | ‚úÖ Good | ‚úÖ Excellent |
| **Performance** ‚ö° | ‚≠ê‚≠ê‚≠ê‚≠ê Good | ‚≠ê‚≠ê‚≠ê‚≠ê Good | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Best |
| **Readability** üëÄ | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Best | ‚≠ê‚≠ê‚≠ê‚≠ê Good | ‚≠ê‚≠ê‚≠ê OK |
| **Debugging** üêõ | Easy | Moderate | Hard |

### **When to Use What? ü§∑‚Äç‚ôÇÔ∏è**

```java
// ‚úÖ Use Query Methods for: Simple conditions
List<Staff> findByNameOrDepartment(String name, String dept);

// ‚úÖ Use JPQL for: Medium complexity with business logic
@Query("SELECT s FROM Staff s WHERE (s.name = :name OR s.dept = :dept) AND s.salary > 50000")

// ‚úÖ Use Native SQL for: Database-specific features, complex joins, performance critical
@Query(value = "SELECT * FROM staff s WHERE s.name = ?1 OR s.dept = ?2 ORDER BY s.created_date DESC LIMIT 10", 
       nativeQuery = true)
```

---

## 8. Interview Questions üéØ

### **Q1: What's the difference between OR and AND in JPA?**

**Answer:**
```java
// OR - Koi bhi ek condition true ho toh result milega
List<Staff> findByNameOrDepartment(String name, String dept);
// SQL: WHERE name = 'John' OR department = 'IT'

// AND - Dono conditions true honi chahiye
List<Staff> findByNameAndDepartment(String name, String dept); 
// SQL: WHERE name = 'John' AND department = 'IT'
```

**Real Example:**
```java
// OR example - Either name is 'John' OR department is 'IT'
// Results: John from Finance + Alice from IT + Bob from IT
staffRepository.findByNameOrDepartment("John", "IT");

// AND example - Name is 'John' AND department is 'IT'  
// Results: Only if someone named John works in IT
staffRepository.findByNameAndDepartment("John", "IT");
```

### **Q2: Can you use multiple OR conditions in a single query method?**

**Answer:** Haan bilkul! Multiple OR conditions use kar sakte ho:

```java
// Multiple OR conditions
List<Staff> findByNameOrDepartmentOrSalary(String name, String dept, Double salary);

// JPQL mein bhi multiple OR
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.dept = :dept OR s.salary > :salary OR s.city = :city")
List<Staff> findByMultipleOrConditions(@Param("name") String name,
                                     @Param("dept") String dept,
                                     @Param("salary") Double salary,
                                     @Param("city") String city);
```

### **Q3: What happens if both parameters are null in OR condition?**

**Answer:**
```java
// Agar dono null hai toh query kya karega?
staffRepository.findByNameOrDepartment(null, null);

// Generated SQL:
// WHERE name IS NULL OR department IS NULL

// Result: Records jinke name ya department null hai, wo milenge
```

**Safe approach:**
```java
@Query("SELECT s FROM Staff s WHERE (:name IS NULL OR s.name = :name) OR (:dept IS NULL OR s.dept = :dept)")
List<Staff> findSafely(@Param("name") String name, @Param("dept") String dept);
```

### **Q4: Performance difference between Query Method vs JPQL vs Native SQL?**

**Answer:**

| **Method** | **Performance** | **Why?** |
|------------|-----------------|----------|
| Query Method | ‚≠ê‚≠ê‚≠ê‚≠ê | Spring generates optimized SQL |
| JPQL | ‚≠ê‚≠ê‚≠ê‚≠ê | Hibernate optimizes, portable |
| Native SQL | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Direct database access, no translation |

```java
// Performance test example
@RestController
public class PerformanceTest {
    
    @GetMapping("/performance-test")
    public ResponseEntity<Map<String, Long>> testPerformance() {
        long start, end;
        Map<String, Long> results = new HashMap<>();
        
        // Query Method
        start = System.currentTimeMillis();
        staffRepository.findByNameOrDepartment("John", "IT");
        end = System.currentTimeMillis();
        results.put("QueryMethod", end - start);
        
        // JPQL
        start = System.currentTimeMillis();
        staffRepository.findByNameOrDepartmentJPQL("John", "IT");
        end = System.currentTimeMillis();
        results.put("JPQL", end - start);
        
        // Native SQL
        start = System.currentTimeMillis();
        staffRepository.findByNameOrDepartmentNative("John", "IT");
        end = System.currentTimeMillis();
        results.put("NativeSQL", end - start);
        
        return ResponseEntity.ok(results);
    }
}
```

---

## 9. Common Mistakes üö´

### **Mistake 1: Wrong Method Naming**
```java
// ‚ùå Wrong
List<Staff> findByName_Or_Department(String name, String dept); // Underscores nahi!

// ‚ùå Wrong  
List<Staff> findByNameORDepartment(String name, String dept); // Case sensitive!

// ‚úÖ Correct
List<Staff> findByNameOrDepartment(String name, String dept);
```

**Error Message:**
```
No property 'name_Or_Department' found for type 'Staff'!
```

### **Mistake 2: Parameter Order Mismatch**
```java
// ‚ùå Wrong - Method expects name first, dept second
public List<Staff> searchStaff(String department, String name) {
    return staffRepository.findByNameOrDepartment(name, department); // Confusing!
}

// ‚úÖ Correct - Parameter order matches method name
public List<Staff> searchStaff(String name, String department) {
    return staffRepository.findByNameOrDepartment(name, department);
}
```

### **Mistake 3: Mixing Entity and Table Names**
```java
// ‚ùå Wrong - staff is table name, Staff is entity name
@Query("SELECT s FROM staff s WHERE s.name = :name OR s.department = :dept")

// ‚úÖ Correct - Use entity name in JPQL
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :dept")
```

### **Mistake 4: Forgetting nativeQuery = true**
```java
// ‚ùå Wrong - SQL syntax but no nativeQuery flag
@Query("SELECT * FROM staff WHERE name = ?1 OR department = ?2")
List<Staff> findStaff(String name, String dept);

// Error: "SELECT * FROM staff" is not valid JPQL syntax

// ‚úÖ Correct
@Query(value = "SELECT * FROM staff WHERE name = ?1 OR department = ?2", 
       nativeQuery = true)
List<Staff> findStaff(String name, String dept);
```

### **Mistake 5: Not Handling Null Values**
```java
// ‚ùå Wrong - Null values can cause unexpected results
public List<Staff> searchStaff(String name, String dept) {
    // Agar name null hai toh kya hoga?
    return staffRepository.findByNameOrDepartment(name, dept);
}

// ‚úÖ Correct - Handle null values
public List<Staff> searchStaff(String name, String dept) {
    if (name == null && dept == null) {
        return staffRepository.findAll(); // All records
    }
    return staffRepository.findByNameOrDepartment(name, dept);
}
```

---

## 10. Best Practices üèÜ

### **1. Use Optional for Better Null Handling**
```java
// ‚úÖ Best Practice
public Optional<List<Staff>> searchStaff(String name, String department) {
    List<Staff> results = staffRepository.findByNameOrDepartment(name, department);
    return results.isEmpty() ? Optional.empty() : Optional.of(results);
}

// Usage
Optional<List<Staff>> staffList = staffService.searchStaff("John", "IT");
if (staffList.isPresent()) {
    // Process results
    staffList.get().forEach(System.out::println);
} else {
    System.out.println("No staff found!");
}
```

### **2. Add Proper Validation**
```java
// ‚úÖ Best Practice with validation
@Service
public class StaffService {
    
    public List<Staff> searchStaff(@Valid @NotBlank String name, 
                                  @Valid @NotBlank String department) {
        
        // Input validation
        if (StringUtils.isBlank(name) && StringUtils.isBlank(department)) {
            throw new IllegalArgumentException("At least one search parameter is required");
        }
        
        return staffRepository.findByNameOrDepartment(name.trim(), department.trim());
    }
}
```

### **3. Use Specifications for Dynamic Queries**
```java
// ‚úÖ Advanced: Dynamic OR conditions using Specifications
@Repository
public interface StaffRepository extends JpaRepository<Staff, Long>, JpaSpecificationExecutor<Staff> {
}

@Service
public class StaffService {
    
    public List<Staff> searchStaffDynamic(String name, String department, Double minSalary) {
        
        Specification<Staff> spec = Specification.where(null);
        
        if (StringUtils.isNotBlank(name)) {
            spec = spec.or((root, query, cb) -> 
                cb.like(cb.lower(root.get("name")), "%" + name.toLowerCase() + "%"));
        }
        
        if (StringUtils.isNotBlank(department)) {
            spec = spec.or((root, query, cb) -> 
                cb.equal(root.get("department"), department));
        }
        
        if (minSalary != null) {
            spec = spec.or((root, query, cb) -> 
                cb.greaterThanOrEqualTo(root.get("salary"), minSalary));
        }
        
        return staffRepository.findAll(spec);
    }
}
```

### **4. Add Logging for Debugging**
```java
// ‚úÖ Best Practice with logging
@Service
@Slf4j
public class StaffService {
    
    public List<Staff> searchStaff(String name, String department) {
        
        log.info("Searching staff with name: {} OR department: {}", name, department);
        
        List<Staff> results = staffRepository.findByNameOrDepartment(name, department);
        
        log.info("Found {} staff members matching criteria", results.size());
        
        return results;
    }
}
```

### **5. Use Caching for Frequent Queries**
```java
// ‚úÖ Best Practice with caching
@Service
public class StaffService {
    
    @Cacheable(value = "staffSearch", key = "#name + '_' + #department")
    public List<Staff> searchStaffCached(String name, String department) {
        log.info("Cache miss - executing database query");
        return staffRepository.findByNameOrDepartment(name, department);
    }
    
    @CacheEvict(value = "staffSearch", allEntries = true)
    public void clearCache() {
        log.info("Clearing staff search cache");
    }
}
```

---

## 11. Testing Your OR Conditions üß™

### **Unit Test Example**
```java
@DataJpaTest
class StaffRepositoryTest {
    
    @Autowired
    private TestEntityManager entityManager;
    
    @Autowired
    private StaffRepository staffRepository;
    
    @BeforeEach
    void setUp() {
        // Test data
        Staff john = new Staff("John", "Finance", 65000.0);
        Staff alice = new Staff("Alice", "IT", 80000.0);
        Staff bob = new Staff("Bob", "HR", 55000.0);
        
        entityManager.persistAndFlush(john);
        entityManager.persistAndFlush(alice);
        entityManager.persistAndFlush(bob);
    }
    
    @Test
    void testFindByNameOrDepartment_BothMatch() {
        // Test: Both conditions match different records
        List<Staff> result = staffRepository.findByNameOrDepartment("John", "IT");
        
        assertThat(result).hasSize(2); // John + Alice
        assertThat(result).extracting(Staff::getName)
                         .containsExactlyInAnyOrder("John", "Alice");
    }
    
    @Test
    void testFindByNameOrDepartment_OnlyNameMatches() {
        // Test: Only name matches
        List<Staff> result = staffRepository.findByNameOrDepartment("John", "Marketing");
        
        assertThat(result).hasSize(1);
        assertThat(result.get(0).getName()).isEqualTo("John");
    }
    
    @Test
    void testFindByNameOrDepartment_NoMatch() {
        // Test: No matches
        List<Staff> result = staffRepository.findByNameOrDepartment("Unknown", "Unknown");
        
        assertThat(result).isEmpty();
    }
}
```

### **Integration Test Example**
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestMethodOrder(OrderAnnotation.class)
class StaffControllerIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Test
    @Order(1)
    void testSearchByQueryMethod() {
        // Test API endpoint
        String url = "/api/staff/search/query-method?name=John&department=IT";
        
        ResponseEntity<List> response = restTemplate.getForEntity(url, List.class);
        
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();
    }
}
```

---

## 12. Performance Tips üöÄ

### **1. Index Your OR Columns**
```sql
-- Database mein proper indexes banao
CREATE INDEX idx_staff_name ON staff(name);
CREATE INDEX idx_staff_department ON staff(department);

-- Composite index for better OR performance
CREATE INDEX idx_staff_name_dept ON staff(name, department);
```

### **2. Use UNION for Better Performance (Advanced)**
```java
// Sometimes UNION is faster than OR for large datasets
@Query(value = "SELECT * FROM staff WHERE name = :name " +
               "UNION " +
               "SELECT * FROM staff WHERE department = :dept", 
       nativeQuery = true)
List<Staff> findByNameOrDepartmentUnion(@Param("name") String name, 
                                      @Param("dept") String dept);
```

### **3. Pagination for Large Results**
```java
// Large datasets ke liye pagination use karo
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    Page<Staff> findByNameOrDepartment(String name, String department, Pageable pageable);
}

// Usage
@Service
public class StaffService {
    
    public Page<Staff> searchStaffPaginated(String name, String dept, int page, int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by("name"));
        return staffRepository.findByNameOrDepartment(name, dept, pageable);
    }
}
```

---

## 13. Summary/Quick Recap üìù

### **Key Takeaways üéØ**

1. **OR Condition** = At least one condition should be true
2. **Three Ways**: Query Methods, JPQL, Native SQL
3. **Query Method**: Easiest for simple conditions
4. **JPQL**: Best for medium complexity
5. **Native SQL**: Best for performance & database-specific features

### **Memory Tricks üß†**

| **Trick** | **Remember** |
|-----------|--------------|
| **OR = "Ya"** | "John **YA** IT department wale chahiye" |
| **Method Naming** | findBy + Field1 + **Or** + Field2 |
| **JPQL Entity** | Staff (not staff) - Capital letter! |
| **Native Flag** | nativeQuery = **true** always! |

### **When to Use What? ü§î**

```java
// üü¢ Simple search? ‚Üí Query Method
List<Staff> findByNameOrDepartment(String name, String dept);

// üü° Medium complexity? ‚Üí JPQL  
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.dept = :dept AND s.salary > 50000")

// üî¥ Complex/Performance critical? ‚Üí Native SQL
@Query(value = "SELECT * FROM staff WHERE name = ?1 OR dept = ?2 ORDER BY created_date", 
       nativeQuery = true)
```

### **Quick Reference Card üìã**

```java
// 1. Basic OR
findByField1OrField2(param1, param2)

// 2. JPQL OR
@Query("SELECT e FROM Entity e WHERE e.field1 = :param1 OR e.field2 = :param2")

// 3. Native OR
@Query(value = "SELECT * FROM table WHERE field1 = :param1 OR field2 = :param2", 
       nativeQuery = true)

// 4. Multiple OR
findByField1OrField2OrField3(param1, param2, param3)

// 5. Complex OR with AND
@Query("SELECT e FROM Entity e WHERE (e.field1 = :p1 OR e.field2 = :p2) AND e.field3 > :p3")
```

---

## 14. Advanced OR Scenarios üéì

### **Scenario 1: OR with LIKE Operations**
```java
// Case-insensitive search with OR
public interface StaffRepository extends JpaRepository<Staff, Long> {
    
    @Query("SELECT s FROM Staff s WHERE " +
           "LOWER(s.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(s.department) LIKE LOWER(CONCAT('%', :searchTerm, '%'))")
    List<Staff> searchByNameOrDepartmentContaining(@Param("searchTerm") String searchTerm);
}

// Usage: Search for "jo" will find "John", "IT" will find IT department
List<Staff> results = staffRepository.searchByNameOrDepartmentContaining("jo");
```

### **Scenario 2: OR with Date Ranges**
```java
@Entity
public class Staff {
    // ... other fields
    
    @Column(name = "hire_date")
    private LocalDate hireDate;
    
    @Column(name = "birth_date") 
    private LocalDate birthDate;
}

// Find staff hired after 2020 OR born before 1990
@Query("SELECT s FROM Staff s WHERE s.hireDate > :hireDate OR s.birthDate < :birthDate")
List<Staff> findByHireDateOrBirthDate(@Param("hireDate") LocalDate hireDate,
                                    @Param("birthDate") LocalDate birthDate);

// Usage
LocalDate hireAfter = LocalDate.of(2020, 1, 1);
LocalDate bornBefore = LocalDate.of(1990, 1, 1);
List<Staff> experienced = staffRepository.findByHireDateOrBirthDate(hireAfter, bornBefore);
```

### **Scenario 3: OR with Null Checks**
```java
// Find staff where email is null OR phone is null (incomplete profiles)
@Query("SELECT s FROM Staff s WHERE s.email IS NULL OR s.phone IS NULL")
List<Staff> findIncompleteProfiles();

// Find staff with specific name OR null department (unassigned)
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department IS NULL")
List<Staff> findByNameOrUnassigned(@Param("name") String name);
```

### **Scenario 4: OR with Subqueries**
```java
// Find staff from IT department OR staff with salary > average salary
@Query("SELECT s FROM Staff s WHERE s.department = 'IT' OR " +
       "s.salary > (SELECT AVG(st.salary) FROM Staff st)")
List<Staff> findITStaffOrAboveAverageSalary();
```

### **Scenario 5: Dynamic OR with Criteria API**
```java
@Service
public class StaffSearchService {
    
    @Autowired
    private EntityManager entityManager;
    
    public List<Staff> dynamicOrSearch(StaffSearchCriteria criteria) {
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();
        CriteriaQuery<Staff> query = cb.createQuery(Staff.class);
        Root<Staff> staff = query.from(Staff.class);
        
        List<Predicate> orPredicates = new ArrayList<>();
        
        // Add OR conditions dynamically
        if (criteria.getName() != null) {
            orPredicates.add(cb.like(cb.lower(staff.get("name")), 
                            "%" + criteria.getName().toLowerCase() + "%"));
        }
        
        if (criteria.getDepartment() != null) {
            orPredicates.add(cb.equal(staff.get("department"), criteria.getDepartment()));
        }
        
        if (criteria.getMinSalary() != null) {
            orPredicates.add(cb.greaterThanOrEqualTo(staff.get("salary"), 
                            criteria.getMinSalary()));
        }
        
        if (!orPredicates.isEmpty()) {
            query.where(cb.or(orPredicates.toArray(new Predicate[0])));
        }
        
        return entityManager.createQuery(query).getResultList();
    }
}

// Search criteria class
@Data
public class StaffSearchCriteria {
    private String name;
    private String department;
    private Double minSalary;
    private String city;
}
```

---

## 15. Error Handling & Debugging üêõ

### **Common Errors and Solutions**

#### **Error 1: PropertyReferenceException**
```java
// ‚ùå Error Code
List<Staff> findByNameOrDeparment(String name, String dept);  // Typo!

// üìã Error Message:
// "No property 'deparment' found for type 'Staff'! Did you mean 'department'?"

// ‚úÖ Solution
List<Staff> findByNameOrDepartment(String name, String dept);
```

#### **Error 2: QuerySyntaxException**
```java
// ‚ùå Error Code
@Query("SELECT s FROM staff s WHERE s.name = :name OR s.dept = :dept")  // Wrong entity name

// üìã Error Message:
// "staff is not mapped [SELECT s FROM staff s WHERE...]"

// ‚úÖ Solution  
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :dept")
```

#### **Error 3: InvalidJpaQueryException**
```java
// ‚ùå Error Code
@Query("SELECT * FROM staff WHERE name = :name OR dept = :dept")  // Missing nativeQuery

// üìã Error Message:
// "SELECT * is not valid JPQL syntax"

// ‚úÖ Solution
@Query(value = "SELECT * FROM staff WHERE name = :name OR department = :dept", 
       nativeQuery = true)
```

### **Debugging Tips üîç**

#### **1. Enable SQL Logging**
```properties
# application.properties
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

#### **2. Test Queries in H2 Console**
```java
// Access H2 console: http://localhost:8080/h2-console
// Test your queries directly:

-- Test your OR condition
SELECT * FROM staff WHERE name = 'John' OR department = 'IT';

-- Check what data exists
SELECT DISTINCT name, department FROM staff;
```

#### **3. Add Debug Logging in Service**
```java
@Service
@Slf4j
public class StaffService {
    
    public List<Staff> searchStaff(String name, String department) {
        log.debug("Searching with parameters: name={}, department={}", name, department);
        
        List<Staff> results = staffRepository.findByNameOrDepartment(name, department);
        
        log.debug("Query returned {} results", results.size());
        
        if (log.isTraceEnabled()) {
            results.forEach(staff -> log.trace("Found staff: {}", staff));
        }
        
        return results;
    }
}
```

---

## 16. Security Considerations üîí

### **SQL Injection Prevention**
```java
// ‚úÖ Safe - Parameterized queries
@Query("SELECT s FROM Staff s WHERE s.name = :name OR s.department = :dept")
List<Staff> safeFindStaff(@Param("name") String name, @Param("dept") String dept);

// ‚úÖ Safe - Native query with parameters
@Query(value = "SELECT * FROM staff WHERE name = ?1 OR department = ?2", 
       nativeQuery = true)
List<Staff> safeNativeFindStaff(String name, String dept);

// ‚ùå Dangerous - String concatenation (NEVER DO THIS!)
@Query(value = "SELECT * FROM staff WHERE name = '" + name + "' OR department = '" + dept + "'", 
       nativeQuery = true)  // SQL Injection risk!
```

### **Input Validation**
```java
@Service
public class StaffService {
    
    public List<Staff> searchStaff(@Valid @NotNull String name, 
                                  @Valid @NotNull String department) {
        
        // Sanitize inputs
        name = StringUtils.trimToEmpty(name);
        department = StringUtils.trimToEmpty(department);
        
        // Validate length
        if (name.length() > 100 || department.length() > 50) {
            throw new IllegalArgumentException("Search parameters too long");
        }
        
        // Validate characters (prevent injection attempts)
        if (containsSqlKeywords(name) || containsSqlKeywords(department)) {
            throw new IllegalArgumentException("Invalid characters in search");
        }
        
        return staffRepository.findByNameOrDepartment(name, department);
    }
    
    private boolean containsSqlKeywords(String input) {
        String[] sqlKeywords = {"DROP", "DELETE", "UPDATE", "INSERT", "SELECT", "--", ";"};
        String upperInput = input.toUpperCase();
        return Arrays.stream(sqlKeywords).anyMatch(upperInput::contains);
    }
}
```

---

## 17. Real Production Example üè≠

### **Complete E-commerce Search Feature**
```java
// üõçÔ∏è Product Entity
@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String name;
    
    @Column(nullable = false)
    private String category;
    
    private String brand;
    private Double price;
    private Boolean inStock;
    private Double rating;
    private LocalDateTime createdDate;
    
    @Column(length = 1000)
    private String description;
}

// üîç Advanced Search Repository
@Repository
public interface ProductRepository extends JpaRepository<Product, Long>, JpaSpecificationExecutor<Product> {
    
    // Basic OR search
    @Query("SELECT p FROM Product p WHERE " +
           "LOWER(p.name) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(p.category) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(p.brand) LIKE LOWER(CONCAT('%', :searchTerm, '%'))")
    Page<Product> searchProducts(@Param("searchTerm") String searchTerm, Pageable pageable);
    
    // OR with price range and availability
    @Query("SELECT p FROM Product p WHERE " +
           "(p.name = :name OR p.category = :category) AND " +
           "p.price BETWEEN :minPrice AND :maxPrice AND " +
           "p.inStock = true")
    List<Product> findAvailableProducts(@Param("name") String name,
                                      @Param("category") String category,
                                      @Param("minPrice") Double minPrice,
                                      @Param("maxPrice") Double maxPrice);
    
    // Complex search with multiple OR conditions
    @Query("SELECT p FROM Product p WHERE " +
           "(p.rating >= :minRating OR p.brand = :premiumBrand) AND " +
           "(p.category = :category OR p.price <= :maxPrice) AND " +
           "p.inStock = true " +
           "ORDER BY p.rating DESC, p.price ASC")
    List<Product> findRecommendedProducts(@Param("minRating") Double minRating,
                                        @Param("premiumBrand") String premiumBrand,
                                        @Param("category") String category,
                                        @Param("maxPrice") Double maxPrice);
}

// üéØ Search Service with Caching
@Service
@Transactional(readOnly = true)
@Slf4j
public class ProductSearchService {
    
    @Autowired
    private ProductRepository productRepository;
    
    @Cacheable(value = "productSearch", key = "#searchTerm + '_' + #page + '_' + #size")
    public Page<Product> searchProducts(String searchTerm, int page, int size) {
        
        if (StringUtils.isBlank(searchTerm)) {
            return Page.empty();
        }
        
        // Input validation
        if (searchTerm.length() > 100) {
            throw new IllegalArgumentException("Search term too long");
        }
        
        Pageable pageable = PageRequest.of(page, size, 
                           Sort.by("rating").descending()
                               .and(Sort.by("createdDate").descending()));
        
        log.info("Searching products with term: '{}', page: {}, size: {}", 
                searchTerm, page, size);
        
        Page<Product> results = productRepository.searchProducts(searchTerm, pageable);
        
        log.info("Found {} products matching '{}'", results.getTotalElements(), searchTerm);
        
        return results;
    }
    
    public List<Product> getRecommendedProducts(String category, String userBudget) {
        Double maxPrice = parsePrice(userBudget);
        String premiumBrand = "Apple"; // Business logic
        Double minRating = 4.0;
        
        return productRepository.findRecommendedProducts(minRating, premiumBrand, 
                                                       category, maxPrice);
    }
    
    private Double parsePrice(String budget) {
        try {
            return Double.parseDouble(budget);
        } catch (NumberFormatException e) {
            return 1000.0; // Default budget
        }
    }
}

// üåê REST Controller
@RestController
@RequestMapping("/api/products")
@Validated
public class ProductController {
    
    @Autowired
    private ProductSearchService searchService;
    
    @GetMapping("/search")
    public ResponseEntity<Page<Product>> searchProducts(
            @RequestParam @NotBlank @Size(min = 2, max = 100) String q,
            @RequestParam(defaultValue = "0") @Min(0) Integer page,
            @RequestParam(defaultValue = "10") @Min(1) @Max(50) Integer size) {
        
        try {
            Page<Product> results = searchService.searchProducts(q, page, size);
            return ResponseEntity.ok(results);
            
        } catch (IllegalArgumentException e) {
            return ResponseEntity.badRequest().build();
        }
    }
    
    @GetMapping("/recommendations")
    public ResponseEntity<List<Product>> getRecommendations(
            @RequestParam String category,
            @RequestParam(required = false) String budget) {
        
        List<Product> recommendations = searchService.getRecommendedProducts(category, budget);
        return ResponseEntity.ok(recommendations);
    }
}
```

### **Testing the Production Code**
```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@Sql(scripts = "/test-data.sql")
class ProductSearchServiceIntegrationTest {
    
    @Autowired
    private ProductSearchService searchService;
    
    @Test
    void testSearchProducts_WithValidTerm_ReturnsResults() {
        // Given
        String searchTerm = "laptop";
        
        // When
        Page<Product> results = searchService.searchProducts(searchTerm, 0, 10);
        
        // Then
        assertThat(results).isNotNull();
        assertThat(results.getContent()).isNotEmpty();
        assertThat(results.getContent()).allMatch(product -> 
            product.getName().toLowerCase().contains("laptop") ||
            product.getCategory().toLowerCase().contains("laptop") ||
            product.getBrand().toLowerCase().contains("laptop")
        );
    }
    
    @Test
    void testSearchProducts_WithEmptyTerm_ReturnsEmptyPage() {
        // When
        Page<Product> results = searchService.searchProducts("", 0, 10);
        
        // Then
        assertThat(results.isEmpty()).isTrue();
    }
}
```

---

## 18. Final Pro Tips üöÄ

### **1. Monitor Query Performance**
```java
// Add performance monitoring
@Component
@Aspect
@Slf4j
public class QueryPerformanceMonitor {
    
    @Around("execution(* com.example.repository.*.*(..))")
    public Object monitorQuery(ProceedingJoinPoint joinPoint) throws Throwable {
        
        long startTime = System.currentTimeMillis();
        String methodName = joinPoint.getSignature().getName();
        
        try {
            Object result = joinPoint.proceed();
            
            long executionTime = System.currentTimeMillis() - startTime;
            
            if (executionTime > 1000) { // Log slow queries
                log.warn("Slow query detected: {} took {}ms", methodName, executionTime);
            } else {
                log.debug("Query {} executed in {}ms", methodName, executionTime);
            }
            
            return result;
            
        } catch (Exception e) {
            log.error("Query {} failed: {}", methodName, e.getMessage());
            throw e;
        }
    }
}
```

### **2. Use Database Views for Complex OR Queries**
```sql
-- Create a view for complex OR searches
CREATE VIEW staff_search_view AS
SELECT 
    id, name, department, salary,
    CONCAT(LOWER(name), ' ', LOWER(department), ' ', LOWER(COALESCE(city, ''))) as search_text
FROM staff;

-- Use view in repository
@Query(value = "SELECT * FROM staff_search_view WHERE search_text LIKE %:term%", 
       nativeQuery = true)
List<Staff> searchInView(@Param("term") String term);
```

### **3. Implement Search Analytics**
```java
@Entity
public class SearchLog {
    @Id
    @GeneratedValue
    private Long id;
    
    private String searchTerm;
    private Integer resultCount;
    private Long executionTime;
    private LocalDateTime searchDate;
    
    // getters, setters
}

@Service
public class SearchAnalyticsService {
    
    @Autowired
    private SearchLogRepository searchLogRepository;
    
    @Async
    public void logSearch(String searchTerm, int resultCount, long executionTime) {
        SearchLog log = new SearchLog();
        log.setSearchTerm(searchTerm);
        log.setResultCount(resultCount);
        log.setExecutionTime(executionTime);
        log.setSearchDate(LocalDateTime.now());
        
        searchLogRepository.save(log);
    }
    
    public List<String> getPopularSearchTerms() {
        return searchLogRepository.findTop10ByOrderBySearchCountDesc();
    }
}
```

---

## üéâ Congratulations! You're Now a JPA OR Expert! 

**Bhai, ab tumhe pata hai:**
- ‚úÖ OR condition kaise use karte hain
- ‚úÖ 3 different methods (Query Method, JPQL, Native SQL)
- ‚úÖ Performance optimization techniques
- ‚úÖ Common mistakes se kaise bacha jaye
- ‚úÖ Production-ready code kaise likhe
- ‚úÖ Testing aur debugging tips

### **Remember the Golden Rules:** üèÜ
1. **Simple queries** ‚Üí Query Methods use karo
2. **Medium complexity** ‚Üí JPQL prefer karo  
3. **High performance needed** ‚Üí Native SQL choose karo
4. **Always validate inputs** aur SQL injection se bacho
5. **Monitor performance** aur cache frequently used queries

**Ab jaao aur amazing search features banao! Happy coding! üöÄüíª**

---

### **Quick Help Commands** üìû
```bash
# Check generated SQL
spring.jpa.show-sql=true

# H2 Console access
http://localhost:8080/h2-console

# Test API
curl "http://localhost:8080/api/staff/search?name=John&department=IT"
```

**Koi doubt ho toh GitHub issues mein puchna, main help karunga! üë®‚Äçüíª**
